<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">

    <!-- ğŸ”¥ åŠ é€™æ®µ Service Worker -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').then(() => {
                console.log('âœ… Service Worker å·²è¨»å†Š');
            }).catch(err => {
                console.error('âŒ Service Worker è¨»å†Šå¤±æ•—:', err);
            });
        }
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­åœ‹è±¡æ£‹</title>

    <!-- ğŸ”¥ åŠ é€™äº› PWA è¨­å®š -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#f5f5dc">

    <!-- PWA æ”¯æ´ -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- iOS æ”¯æ´ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="è±¡æ£‹">
    <link rel="apple-touch-icon" href="./icons/icon-180.png">

    <!-- âœ… ä¿ç•™ ONNX -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>

    <!-- ğŸ”¥ æ­¥é©Ÿ 1: è¼‰å…¥ pikafish.js -->
    <script src="./pikafish.js"></script>

    <!-- ğŸ”¥ æ­¥é©Ÿ 2: ä¿®å¾©ç‰ˆåˆå§‹åŒ–ï¼ˆè§£æ±º NNUE å•é¡Œï¼‰ -->
    <script>
        console.log('ğŸ“¦ åˆå§‹åŒ– Pikafish WASMï¼ˆNNUE ä¿®å¾©ç‰ˆï¼‰...');

        if (typeof Pikafish === 'undefined') {
            console.error('âŒ Pikafish å‡½æ•¸æœªå®šç¾©');
        } else {
            window.pikafishMessageBuffer = [];

            // ğŸ”¥ é—œéµä¿®å¾©ï¼šä½¿ç”¨ dataFileDownloads é è¼‰å…¥ NNUE
            Pikafish({
                locateFile: function(path) {
                    console.log('ğŸ” locateFile:', path);

                    if (path.endsWith('.wasm')) {
                        return './pikafish.wasm';
                    }
                    if (path.endsWith('.nnue')) {
                        return 'https://github.com/dffge552/xiangqi-pwa/releases/download/v1.0.0/pikafish.nnue';
                    }
                    if (path.endsWith('.data')) {
                        return './pikafish.data';
                    }

                    return path;
                },

                onReceiveStdout: function(text) {
                    console.log('ğŸ“¤ Pikafish:', text);

                    // æš«å­˜è¨Šæ¯
                    if (!window.pikafishMessageBuffer) {
                        window.pikafishMessageBuffer = [];
                    }
                    window.pikafishMessageBuffer.push(text);

                    // å‚³éçµ¦ AI
                    if (window.xiangqiAI && window.xiangqiAI.wasmReady) {
                        setTimeout(() => {
                            if (window.xiangqiAI.handleEngineMessage) {
                                window.xiangqiAI.handleEngineMessage(text);
                            }
                        }, 0);
                    }
                },

                onReceiveStderr: function(text) {
                    console.error('âŒ Pikafish éŒ¯èª¤:', text);
                },

                print: function(text) {
                    console.log('ğŸ“¤ WASM print:', text);
                },

                printErr: function(text) {
                    console.error('âŒ WASM error:', text);
                },

                INITIAL_MEMORY: 128 * 1024 * 1024,
                ALLOW_MEMORY_GROWTH: true,

                // ğŸ”¥ é—œéµï¼šä½¿ç”¨ arguments å‚³é NNUE è·¯å¾‘
                arguments: ['--evalfile=https://github.com/dffge552/xiangqi-pwa/releases/download/v1.0.0/pikafish.nnue']

            }).then(function(module) {
                console.log('ğŸ‰ Pikafish WASM è¼‰å…¥å®Œæˆï¼');
                window.aiMonitor.markCheckpoint('wasmReady');  // åŠ é€™è¡Œ

                window.Module = module;
                window.pikafishReady = true;

                // ğŸ”¥ é¡å¤–è¨­å®šï¼šç¢ºä¿ NNUE è·¯å¾‘
                setTimeout(() => {
                    console.log('âš™ï¸ è¨­å®š NNUE è·¯å¾‘...');

                    if (window.xiangqiAI && window.xiangqiAI.wasmReady) {
                        // å˜—è©¦å¤šå€‹è·¯å¾‘
                        const nnuePaths = [
                            'https://github.com/dffge552/xiangqi-pwa/releases/download/v1.0.0/pikafish.nnue'
                        ];

                        nnuePaths.forEach(path => {
                            window.xiangqiAI.sendCommand(`setoption name EvalFile value ${path}`);
                        });
                    }

                    window.dispatchEvent(new CustomEvent('pikafish-ready', {
                        detail: { module: module }
                    }));

                    console.log('âœ… Pikafish å®Œå…¨å°±ç·’ï¼');
                }, 500);

            }).catch(function(error) {
                console.error('âŒ Pikafish è¼‰å…¥å¤±æ•—:', error);
            });
        }
    </script>

    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f5f5dc;
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #chess-board {
            display: grid;
            grid-template-columns: repeat(9, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 2px solid #000;
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
        }

        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            position: relative;
            border: none;
        }

        .chess-piece {
            width: 50px;
            height: 50px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            user-select: none;
        }

        .river-tile {
            background-color: rgba(170, 212, 229, 0.3);
            font-size: 24px;
            flex-direction: column;
        }

        .palace {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .red {
            color: red;
            font-weight: bold;
        }

        .black {
            color: black;
            font-weight: bold;
        }

        .selected {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }

        .possible-move {
            background-color: rgba(0, 0, 255, 0.2) !important;
        }

        .possible-move::after {
            content: "";
            display: block;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 255, 0.5);
            border-radius: 50%;
        }

        #turn-indicator {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }

        .red-turn {
            color: red;
        }

        .black-turn {
            color: black;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #45a049;
        }

        .coordinates-display {
            font-size: 18px;
            font-weight: bold;
            user-select: none;
            margin: 8px 0;
            text-align: center;
            font-family: Arial, "Microsoft YaHei", "å¾®è»Ÿæ­£é»‘é«”", sans-serif;  /* â† åŠ é€™è¡Œ */
        }

        .coordinates-display span {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #black-coordinates {
            color: black;
            margin-bottom: 0px;  /* â† æ”¹é€™è£¡ï¼ŒåŸæœ¬æ˜¯ 5px */
        }

        #red-coordinates {
            color: red;
            margin-top: 0px;      /* â† æ”¹é€™è£¡ï¼ŒåŸæœ¬æ˜¯ 5px */
            margin-bottom: 15px;
        }

        #move-history {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 400px;
            height: 70vh;
            max-height: 500px;
            overflow-y: auto;
            border: 2px solid #333;
            padding: 15px;
            padding-top: 50px; /* â† åŠ é€™è¡Œ */
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 9999;
        }

        #move-history.show {
            display: block;
        }

        /* é®ç½©å±¤ */
        #history-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        #history-overlay.show {
            display: block;
        }

        #move-history h3 {
            text-align: center;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #333;
            position: sticky;
            top: -15px;
            background: white;
            margin: -15px -15px 10px -15px;
            padding: 15px;
        }

        /* é—œé–‰æŒ‰éˆ• */
        #close-history {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #close-history:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        #close-history:active {
            transform: scale(0.95);
        }

        #move-list {
            font-family: monospace;
        }

        .move-item {
            margin-bottom: 5px;
            padding: 3px;
            border-radius: 3px;
        }

        .move-item:nth-child(odd) {
            background-color: #f5f5f5;
        }

        .move-number {
            display: inline-block;
            width: 25px;
            font-weight: bold;
        }


        .red-move {
            color: red;
        }

        .black-move {
            color: black;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* ========================================
           ğŸ“± æ‰‹æ©Ÿç‰ˆéŸ¿æ‡‰å¼è¨­è¨ˆ
           ======================================== */
        @media (max-width: 768px) {
            * {
                box-sizing: border-box;
            }

            body {
                height: 100vh;
                padding: 0;
                margin: 0;
                overflow: hidden;
                background-color: #f5f5dc;
                display: flex;
                flex-direction: column;
            }

            .game-container {
                flex-direction: column;
                align-items: center;
                gap: 0;
                width: 100vw;
                height: 100vh;
                padding: 5px;
                overflow-y: auto;
                overflow-x: hidden;
            }

            .game-info {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            #turn-indicator {
                font-size: 16px !important;
                margin: 5px 0 !important;
                padding: 5px;
            }

            @media (max-width: 768px) {
                #black-coordinates {
                    width: calc(100vw - 60px) !important;
                    max-width: 350px !important;
                    grid-template-columns: repeat(9, 1fr) !important;
                    margin: 0 auto 0px auto !important;  /* â† æ”¹é€™è£¡ï¼ŒæŠŠ 2px æ”¹æˆ 0px */
                    font-size: 13px !important;
                    padding: 0;
                }

                #red-coordinates {
                    width: calc(100vw - 60px) !important;
                    max-width: 350px !important;
                    grid-template-columns: repeat(9, 1fr) !important;
                    margin: 0px auto 8px auto !important;  /* â† æ”¹é€™è£¡ï¼ŒæŠŠ 2px æ”¹æˆ 0px */
                    font-size: 13px !important;
                    padding: 0;
                }
            }



            #chess-board {
                width: calc(100vw - 65px) !important;
                max-width: 350px !important;
                height: auto !important;
                aspect-ratio: 9 / 10;
                grid-template-columns: repeat(9, 1fr) !important;
                grid-template-rows: repeat(10, 1fr) !important;
                border: 2px solid #000;
                margin: 0;
                flex-shrink: 0;
            }

            .tile {
                width: 100% !important;
                height: 100% !important;
                font-size: 15px !important;
                padding: 0;
            }

            .chess-piece {
                width: 70% !important;
                height: 70% !important;
                max-width: 38px;
                max-height: 38px;
            }



            .controls {
                width: 100% !important;
                max-width: 350px !important;
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 8px !important;
                padding: 10px 5px !important;
                margin: 8px 0 !important;
            }

            .controls button {
                width: 100% !important;
                padding: 12px 8px !important;
                font-size: 14px !important;
                margin: 0 !important;
                white-space: nowrap;
            }

            #loadFile {
                display: none !important;
            }

            #move-history {
                width: 95% !important;
                height: 80vh !important;
                max-height: 600px !important;
            }

            .possible-move::after {
                width: 10px !important;
                height: 10px !important;
            }

            .river-tile {
                font-size: 13px !important;
                padding: 0 !important;
            }

            .selected {
                background-color: rgba(0, 255, 0, 0.4) !important;
            }
        }

        @media (max-width: 360px) {
            #chess-board {
                max-width: 300px !important;
                width: calc(100vw - 55px) !important;
            }

            #black-coordinates,
            #red-coordinates {
                max-width: 300px !important;
                font-size: 11px !important;
            }

            .controls {
                max-width: 300px !important;
            }

            .controls button {
                font-size: 12px !important;
                padding: 10px 5px !important;
            }

            .tile {
                font-size: 13px !important;
            }

            .captured-piece {
                width: 20px !important;
                height: 20px !important;
            }
        }

        @media (min-width: 480px) and (max-width: 768px) {
            #chess-board {
                max-width: 420px !important;
            }

            #black-coordinates,
            #red-coordinates {
                max-width: 420px !important;
                font-size: 15px !important;
            }

            .controls {
                max-width: 420px !important;
            }

            .tile {
                font-size: 17px !important;
            }

            .chess-piece {
                max-width: 45px;
                max-height: 45px;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            body {
                overflow: auto;
                height: auto;
            }

            .game-container {
                flex-direction: row !important;
                height: auto !important;
                padding: 10px !important;
                align-items: flex-start !important;
            }

            .game-info {
                flex: 0 0 auto;
            }

            #chess-board {
                height: 85vh !important;
                width: auto !important;
                max-height: 500px;
                max-width: none !important;
            }

            #black-coordinates,
            #red-coordinates {
                width: auto !important;
            }

            .controls {
                grid-template-columns: repeat(4, 1fr) !important;
                max-width: none !important;
            }

            #move-history {
                display: block !important;
                width: 220px !important;
                height: 85vh !important;
                max-height: 500px !important;
                margin: 0 !important;
            }
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="game-info">
        <div id="turn-indicator" class="red-turn">ç´…æ–¹å›åˆ</div>

        <!-- é»‘æ–¹åº§æ¨™ -->
        <div id="black-coordinates" class="coordinates-display" style="display: grid; grid-template-columns: repeat(9, 60px); width: 540px;">
            <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span>
        </div>

        <!-- æ£‹ç›¤ -->
        <div id="chess-board"></div>

        <div id="red-coordinates" class="coordinates-display" style="display: grid; grid-template-columns: repeat(9, 60px); width: 540px;">
            <span>ä¹</span><span>å…«</span><span>ä¸ƒ</span><span>å…­</span><span>äº”</span><span>å››</span><span>ä¸‰</span><span>äºŒ</span><span>ä¸€</span>
        </div>

        <div class="controls">
            <button id="undoBtn">æ‚”æ£‹</button>
            <button id="saveBtn">å„²å­˜ç•¶å‰å±€é¢</button>
            <input type="file" id="loadFile" accept=".json" style="display: none;">
            <button id="loadBtn">è¼‰å…¥å±€é¢æª”æ¡ˆ</button>
            <button id="newGameBtn">é‡æ–°é–‹å§‹</button>
            <button id="showHistoryBtn">æ£‹è­œè¨˜éŒ„</button>
        </div>
    </div>

    <!-- é®ç½©å±¤ -->
    <div id="history-overlay"></div>

    <!-- æ£‹è­œè¨˜éŒ„å½ˆçª— -->
    <div id="move-history">
        <button id="close-history">Ã—</button>
        <h3>æ£‹è­œè¨˜éŒ„</h3>
        <div id="move-list"></div>
    </div>
</div>

<script>
    const gameState = {
        currentTurn: 'red',
        boardSize: { rows: 10, cols: 9 },
        selectedPiece: null,
        possibleMoves: [],
        board: [],
        history: [],
        historyIndex: -1,
        gameRecord: [],
        gameOver: false,
        checkStatus: null,
        noCaptureCount: 0,
        totalMoves: 0,
        isFlipped: false,
        initialBoard: null,
        initialTurn: null,
        capturedPieces: {
            red: [],
            black: []
        }
    };

    // ==================== 3. åº§æ¨™è½‰æ›æ ¸å¿ƒå‡½æ•¸ ====================

    // ğŸ”¥ æ–°å¢å…¨åŸŸåº§æ¨™è½‰æ›å‡½æ•¸ï¼ˆæ”¾åœ¨ gameState å®šç¾©é™„è¿‘ï¼‰

    /**
     * å°‡é‚è¼¯è¡Œåº§æ¨™è½‰æ›ç‚ºè¦–è¦ºè¡Œåº§æ¨™
     * @param {number} logicalRow - é‚è¼¯åº§æ¨™ (0-9ï¼Œ0=é»‘æ–¹åº•ç·šï¼Œ9=ç´…æ–¹åº•ç·š)
     * @returns {number} è¦–è¦ºåº§æ¨™ (0-9)
     */
    function getVisualRow(logicalRow) {
        // å¦‚æœ gameState å°šæœªå®šç¾©ï¼Œå…ˆæª¢æŸ¥
        if (typeof gameState === 'undefined') {
            console.warn('gameState å°šæœªå®šç¾©ï¼Œé è¨­ä¸ç¿»è½‰');
            return logicalRow;
        }
        return gameState.isFlipped ? (9 - logicalRow) : logicalRow;
    }

    /**
     * å°‡è¦–è¦ºè¡Œåº§æ¨™è½‰æ›ç‚ºé‚è¼¯è¡Œåº§æ¨™
     * @param {number} visualRow - è¦–è¦ºåº§æ¨™ (0-9)
     * @returns {number} é‚è¼¯åº§æ¨™ (0-9ï¼Œ0=é»‘æ–¹åº•ç·šï¼Œ9=ç´…æ–¹åº•ç·š)
     */
    function getLogicalRow(visualRow) {
        if (typeof gameState === 'undefined') {
            console.warn('gameState å°šæœªå®šç¾©ï¼Œé è¨­ä¸ç¿»è½‰');
            return visualRow;
        }
        return gameState.isFlipped ? (9 - visualRow) : visualRow;
    }

    /**
     * åˆ—åº§æ¨™ä¸éœ€è¦è½‰æ›ï¼ˆå› ç‚ºå·¦å³å°ç¨±ï¼‰
     */
    function getVisualCol(logicalCol) {
        return logicalCol;
    }

    function getLogicalCol(visualCol) {
        return visualCol;
    }


    function deepCopyPiece(piece) {
        if (!piece) return null;
        return {
            type: piece.type,
            color: piece.color,
            moved: piece.moved || false
        };
    }



    function deepCopyBoard(board) {
        return board.map(row =>
            row.map(cell =>
                cell ? deepCopyPiece(cell) : null
            )
        );
    }

    // DOMå…ƒç´ 
    const chessBoard = document.getElementById('chess-board');
    const turnIndicator = document.getElementById('turn-indicator');
    const moveList = document.getElementById('move-list');



    // åˆå§‹åŒ–æ£‹ç›¤ (10è¡Œæ¨™æº–è±¡æ£‹æ£‹ç›¤)
    function initializeBoard() {
        chessBoard.innerHTML = '';

        // å‰µå»ºæ‰€æœ‰æ ¼å­ (ç¢ºä¿ gameState.boardSize.rows = 10)
        for (let row = 0; row < gameState.boardSize.rows; row++) {
            for (let col = 0; col < gameState.boardSize.cols; col++) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.row = row;
                tile.dataset.col = col;




                tile.addEventListener('click', () => handleTileClick(row, col));
                chessBoard.appendChild(tile);
            }
        }
    }

    // åˆå§‹åŒ–æ£‹å­
    function initializePieces() {
        const board = Array(gameState.boardSize.rows).fill().map(() => Array(gameState.boardSize.cols).fill(null));

        // ç´…æ–¹æ£‹å­ï¼ˆ5-9è¡Œï¼‰
        board[9][0] = { type: 'ä¿¥', color: 'red' };
        board[9][1] = { type: 'å‚Œ', color: 'red' };
        board[9][2] = { type: 'ç›¸', color: 'red' };
        board[9][3] = { type: 'ä»•', color: 'red' };
        board[9][4] = { type: 'å¸¥', color: 'red' };
        board[9][5] = { type: 'ä»•', color: 'red' };
        board[9][6] = { type: 'ç›¸', color: 'red' };
        board[9][7] = { type: 'å‚Œ', color: 'red' };
        board[9][8] = { type: 'ä¿¥', color: 'red' };
        board[7][1] = { type: 'ç‚®', color: 'red' };
        board[7][7] = { type: 'ç‚®', color: 'red' };
        board[6][0] = { type: 'å…µ', color: 'red' };
        board[6][2] = { type: 'å…µ', color: 'red' };
        board[6][4] = { type: 'å…µ', color: 'red' };
        board[6][6] = { type: 'å…µ', color: 'red' };
        board[6][8] = { type: 'å…µ', color: 'red' };

        // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
        board[0][0] = { type: 'è»Š', color: 'black' };
        board[0][1] = { type: 'é¦¬', color: 'black' };
        board[0][2] = { type: 'è±¡', color: 'black' };
        board[0][3] = { type: 'å£«', color: 'black' };
        board[0][4] = { type: 'å°‡', color: 'black' };
        board[0][5] = { type: 'å£«', color: 'black' };
        board[0][6] = { type: 'è±¡', color: 'black' };
        board[0][7] = { type: 'é¦¬', color: 'black' };
        board[0][8] = { type: 'è»Š', color: 'black' };
        board[2][1] = { type: 'åŒ…', color: 'black' };
        board[2][7] = { type: 'åŒ…', color: 'black' };
        board[3][0] = { type: 'å’', color: 'black' };
        board[3][2] = { type: 'å’', color: 'black' };
        board[3][4] = { type: 'å’', color: 'black' };
        board[3][6] = { type: 'å’', color: 'black' };
        board[3][8] = { type: 'å’', color: 'black' };

        return board;
    }



    // ğŸ”¥ åœ¨ç¾æœ‰çš„ renderBoard() å‡½æ•¸ä¸­ä¿®æ”¹
    function renderBoard() {
        const tiles = document.querySelectorAll('.tile');

        // ç²å–ç•¶å‰æ£‹å­é¢¨æ ¼å‰ç¶´
        const prefix = window.chessSettings ? window.chessSettings.getCurrentPrefix() : 'Minimalist White';

        // æ£‹å­é¡å‹åˆ°è‹±æ–‡åç¨±çš„æ˜ å°„
        const pieceNameMap = {
            // é»‘æ–¹æ£‹å­
            'å°‡': `${prefix} Black Jiang`,
            'å£«': `${prefix} Black Shi`,
            'è±¡': `${prefix} Black Xiang`,
            'é¦¬': `${prefix} Black Ma`,
            'è»Š': `${prefix} Black Ju`,
            'åŒ…': `${prefix} Black Pao`,
            'å’': `${prefix} Black Zu`,

            // ç´…æ–¹æ£‹å­
            'å¸¥': `${prefix} Red Shuai`,
            'ä»•': `${prefix} Red Shi`,
            'ç›¸': `${prefix} Red Xiang`,
            'å‚Œ': `${prefix} Red Ma`,
            'ä¿¥': `${prefix} Red Ju`,
            'ç‚®': `${prefix} Red Pao`,
            'å…µ': `${prefix} Red Bing`
        };

        tiles.forEach(tile => {
            // ä¿ç•™åæ¨™å’Œæ²³ç•Œæ–‡å­—
            const keepElements = Array.from(tile.children).filter(child =>
                child.classList.contains('x-coordinate') ||
                child.classList.contains('y-coordinate') ||
                child.textContent.includes('æ¥šæ²³') ||
                child.textContent.includes('æ¼¢ç•Œ')
            );

            // æ¸…é™¤å…¶ä»–å…§å®¹
            tile.innerHTML = '';
            keepElements.forEach(el => tile.appendChild(el));

            // ğŸ”¥ é—œéµä¿®æ”¹ï¼šå¾ DOM ç²å–è¦–è¦ºåº§æ¨™ï¼Œè½‰æ›ç‚ºé‚è¼¯åº§æ¨™
            const visualRow = parseInt(tile.dataset.row);
            const visualCol = parseInt(tile.dataset.col);

            const logicalRow = getLogicalRow(visualRow);
            const logicalCol = getLogicalCol(visualCol);

            // ğŸ”¥ ä½¿ç”¨é‚è¼¯åº§æ¨™è®€å–æ£‹å­
            const piece = gameState.board[logicalRow][logicalCol];

            if (piece) {
                const pieceElement = document.createElement('img');
                const imageName = pieceNameMap[piece.type];

                pieceElement.src = encodeURI(`chess pieces/${imageName}.png`);
                pieceElement.alt = piece.type;
                pieceElement.classList.add('chess-piece');
                pieceElement.style.width = '50px';
                pieceElement.style.height = '50px';
                pieceElement.draggable = false;

                pieceElement.onerror = function() {
                    console.error('âŒ åœ–ç‰‡è¼‰å…¥å¤±æ•—:', this.src);
                    const fallback = document.createElement('div');
                    fallback.textContent = piece.type;
                    fallback.classList.add(piece.color);
                    fallback.style.fontSize = '24px';
                    fallback.style.lineHeight = '50px';
                    fallback.style.textAlign = 'center';
                    this.replaceWith(fallback);
                };

                tile.appendChild(pieceElement);
            }
        });

        updateSelection();
        updateTurnIndicator();


    }



    // ğŸ”¥ åœ¨ç¾æœ‰çš„ handleTileClick() å‡½æ•¸é–‹é ­åŠ å…¥åº§æ¨™è½‰æ›
    function handleTileClick(visualRow, visualCol) {
        // ğŸ”¥ ç¬¬ä¸€æ­¥ï¼šç«‹å³è½‰æ›ç‚ºé‚è¼¯åº§æ¨™
        const row = getLogicalRow(visualRow);
        const col = getLogicalCol(visualCol);

        // ğŸ”¥ å¾ŒçºŒæ‰€æœ‰é‚è¼¯éƒ½ä½¿ç”¨ row, colï¼ˆé‚è¼¯åº§æ¨™ï¼‰
        console.log(`é»æ“Š: è¦–è¦º(${visualRow},${visualCol}) â†’ é‚è¼¯(${row},${col}), ä¾†æº: ${isAIClickSource ? 'AI' : isReplayClickSource ? 'è¦†ç›¤' : 'ç©å®¶'}`);

        if (gameState.gameOver) return;

        const isAIBattleMode = gameState.isAIBattle === true;
        const aiColor = gameState.aiColor;
        const currentColor = gameState.currentTurn;
        const opponentColor = currentColor === 'red' ? 'black' : 'red';
        const isAITurn = currentColor === aiColor;

        // ã€å„ªå…ˆæª¢æŸ¥1ã€‘AIå›åˆæ™‚ç¦æ­¢ç©å®¶æ“ä½œ
        if (isAIBattleMode && !isAIClickSource && isAITurn) {
            console.warn(`ğŸš« AIå›åˆä¸­ï¼Œç©å®¶æ“ä½œè¢«ç¦æ­¢ï¼`);
            showAIProtectionWarning(aiColor, true);
            return;
        }

        // ã€å„ªå…ˆæª¢æŸ¥2ã€‘è¦†ç›¤åˆ†æä¸­ç¦æ­¢ç©å®¶æ“ä½œ
        if (gameState.isAnalyzing && !isReplayClickSource) {
            console.warn(`ğŸš« è¦†ç›¤åˆ†æä¸­ï¼Œç©å®¶æ“ä½œè¢«ç¦æ­¢ï¼`);
            showReplayProtectionWarning();
            return;
        }

        if (isAIClickSource) {
            console.log(`âœ… AIæ¨™è¨˜å­˜åœ¨ï¼Œå…è¨±æ“ä½œ`);
        }

        if (isReplayClickSource) {
            console.log(`âœ… è¦†ç›¤æ¨™è¨˜å­˜åœ¨ï¼Œå…è¨±æ“ä½œ`);
        }

        const clickedPiece = gameState.board[row][col];

        // æª¢æŸ¥ç©å®¶æ˜¯å¦è©¦åœ–é¸æ“‡AIçš„æ£‹å­ï¼ˆåœ¨ç©å®¶å›åˆï¼‰
        const isPlayerTryingToSelectAIPiece =
            isAIBattleMode &&
            !isAIClickSource &&
            !isAITurn &&
            clickedPiece &&
            clickedPiece.color === aiColor;

        // æƒ…æ³1: å·²ç¶“æœ‰é¸ä¸­çš„æ£‹å­
        if (gameState.selectedPiece) {
            const isValidMove = gameState.possibleMoves.some(
                move => move.row === row && move.col === col
            );

            if (isValidMove) {
                console.log(`åŸ·è¡Œç§»å‹•: (${gameState.selectedPiece.row},${gameState.selectedPiece.col}) -> (${row},${col})`);

                saveToHistory();

                const simulatedBoard = simulateMove(
                    gameState.selectedPiece.row,
                    gameState.selectedPiece.col,
                    row,
                    col
                );

                if (gameState.checkStatus === currentColor) {
                    if (isCheck(currentColor, simulatedBoard)) {
                        showNoValidCheckResponseMessage(currentColor);
                        return;
                    }
                }

                movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                recordMove(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);

                gameState.currentTurn = opponentColor;

                console.log('\nğŸ” æª¢æŸ¥é›™æ–¹ç„¡å¯éæ²³æ£‹å­æ¢ä»¶...');

                let materialResult;
                try {
                    const detector = new NotationCycleDetector();
                    materialResult = detector.analyzeInsufficientMatingMaterial(gameState.board, gameState);
                    console.log('âœ… ææ–™æª¢æ¸¬å®Œæˆ:', materialResult);
                } catch (error) {
                    console.error('âŒ ææ–™æª¢æ¸¬å¤±æ•—:', error);
                    materialResult = null;
                }

                if (materialResult && materialResult.isDraw) {
                    console.log('ğŸ³ï¸ æª¢æ¸¬åˆ°é›™æ–¹ç„¡å¯éæ²³æ£‹å­ï¼Œå®£å¸ƒå’Œæ£‹ï¼');
                    clearSelection();
                    updateSelection();
                    renderBoard();
                    gameState.gameOver = true;
                    gameState.drawResult = materialResult;

                    setTimeout(() => {
                        showInsufficientMaterialDrawMessage(materialResult);
                    }, 300);

                    return;
                }

                clearSelection();
                updateSelection();
                renderBoard();
                checkSpecialConditions();

                setTimeout(() => {
                    if (isCheck(opponentColor)) {
                        gameState.checkStatus = opponentColor;
                        if (isCheckmate(opponentColor)) {
                            gameState.gameOver = true;
                            showCheckmateMessage(opponentColor);
                            return;
                        }
                    } else {
                        gameState.checkStatus = null;
                    }

                    if (!gameState.gameOver && !isCheck(opponentColor)) {
                        if (isStalemate(opponentColor)) {
                            gameState.gameOver = true;
                            showStalemateMessage(opponentColor);
                            return;
                        }
                    }
                }, 100);

                return;
            }

            // é‡æ–°é¸æ“‡æ£‹å­
            if (isPlayerTryingToSelectAIPiece) {
                console.warn(`âŒ ç¦æ­¢: ä¸èƒ½é¸æ“‡ ${aiColor} æ–¹(AI)çš„æ£‹å­!`);
                showAIProtectionWarning(aiColor, false);
                clearSelection();
            } else if (clickedPiece && clickedPiece.color === currentColor) {
                selectNewPiece(row, col, clickedPiece);
            } else {
                clearSelection();
            }
        }
        // æƒ…æ³2: é¸æ“‡æ–°æ£‹å­
        else if (clickedPiece && clickedPiece.color === currentColor) {
            if (isPlayerTryingToSelectAIPiece) {
                console.warn(`âŒ ç¦æ­¢: ä¸èƒ½é¸æ“‡ ${aiColor} æ–¹(AI)çš„æ£‹å­!`);
                showAIProtectionWarning(aiColor, false);
                clearSelection();
                updateSelection();
                renderBoard();
                return;
            }
            selectNewPiece(row, col, clickedPiece);
        }
        // æƒ…æ³3: é»æ“Šç„¡æ•ˆä½ç½®
        else {
            clearSelection();
        }

        updateSelection();
        renderBoard();
    }

    // å›°æ–ƒæª¢æŸ¥å‡½æ•¸
    function isStalemate(playerColor) {
        // 1. å¦‚æœè¢«å°‡è»ï¼Œä¸ç®—å›°æ–ƒ
        if (isCheck(playerColor)) return false;

        // 2. æª¢æŸ¥æ‰€æœ‰æ£‹å­æ˜¯å¦æœ‰åˆæ³•èµ°æ³•
        for (let row = 0; row < gameState.boardSize.rows; row++) {
            for (let col = 0; col < gameState.boardSize.cols; col++) {
                const piece = gameState.board[row][col];
                if (piece && piece.color === playerColor) {
                    const moves = getPossibleMoves(row, col, piece);

                    // éæ¿¾æ‰ç§»å‹•å¾Œä»æœƒè¢«å°‡è»çš„èµ°æ³•
                    const validMoves = moves.filter(move => {
                        const simulatedBoard = simulateMove(row, col, move.row, move.col);
                        return !isCheck(playerColor, simulatedBoard);
                    });

                    if (validMoves.length > 0) return false;
                }
            }
        }
        return true;
    }


    // æ¨¡æ“¬ç§»å‹•å‡½æ•¸
    function simulateMove(fromRow, fromCol, toRow, toCol) {
        const newBoard = JSON.parse(JSON.stringify(gameState.board));
        newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
        newBoard[fromRow][fromCol] = null;
        return newBoard;
    }

    // ğŸ”§ é¸æ“‡æ–°æ£‹å­å‡½æ•¸ï¼ˆæ›´æ–°ç‰ˆï¼‰
    function selectNewPiece(row, col, piece) {
        gameState.selectedPiece = { row, col, piece };

        // å¦‚æœç•¶å‰æ­£è¢«å°‡è»ï¼Œåªèƒ½é¸æ“‡èƒ½è§£é™¤å°‡è»çš„èµ°æ³•
        if (gameState.checkStatus === piece.color) {
            gameState.possibleMoves = getValidMovesUnderCheck(row, col, piece);
            if (gameState.possibleMoves.length === 0) {
                showNoValidMovesUnderCheckMessage(piece.color); // ğŸ”§ æ›¿æ› alert
                clearSelection();
            }
        } else {
            gameState.possibleMoves = getPossibleMoves(row, col, piece);
        }
        console.log('å¯ç§»å‹•ä½ç½®:', gameState.possibleMoves);
    }

    // æ¸…ç©ºé¸æ“‡
    function clearSelection() {
        gameState.selectedPiece = null;
        gameState.possibleMoves = [];
    }

    // ç²å–åœ¨å°‡è»ç‹€æ…‹ä¸‹çš„åˆæ³•ç§»å‹•ï¼ˆå¿…é ˆèƒ½è§£é™¤å°‡è»ï¼‰
    function getValidMovesUnderCheck(row, col, piece) {
        const moves = getPossibleMoves(row, col, piece);
        return moves.filter(move => {
            const simulatedBoard = deepCopyBoard(gameState.board);
            simulatedBoard[move.row][move.col] = simulatedBoard[row][col];
            simulatedBoard[row][col] = null;
            return !isCheck(piece.color, simulatedBoard);
        });
    }


    function clearHorseFootprint(horseRow, horseCol) {
        // é¦¬çš„4å€‹å¯èƒ½é¦¬è…³ä½ç½®ï¼ˆä¸­å›½è±¡æ£‹çš„é©¬æ˜¯è¹©è„šï¼Œä¸æ˜¯8ä¸ªæ–¹å‘ï¼‰
        const horseBlocks = [
            [horseRow-1, horseCol], [horseRow+1, horseCol], // ä¸Šä¸‹
            [horseRow, horseCol-1], [horseRow, horseCol+1]  // å·¦å³
        ];

        horseBlocks.forEach(([r, c]) => {
            if (r >= 0 && r < 9 && c >= 0 && c < 9) {
                // æ¸…é™¤é¦¬è…³æ¨™è¨˜
                if (gameState.board[r][c]) {
                    gameState.board[r][c].blocking = false;
                }
                // åŒæ­¥æ›´æ–°æ£‹ç›¤DOMå…ƒç´ 
                const tile = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                tile?.classList.remove('horse-block');
            }
        });
    }

    // éŸ³æ•ˆç³»çµ±
    const sounds = {
        move: [
            'voice/Piece Drop Sound/move1.m4a',
            'voice/Piece Drop Sound/move2.m4a',
            'voice/Piece Drop Sound/move3.m4a',
            'voice/Piece Drop Sound/move4.m4a',
            'voice/Piece Drop Sound/move5.m4a'
        ],
        capture: [
            'voice/Capture sound/capture1.m4a',
            'voice/Capture sound/capture2.m4a',
            'voice/Capture sound/capture3.m4a'
        ]
    };

    function playSound(type, customVolume) {
        console.log('æº–å‚™æ’­æ”¾éŸ³æ•ˆ:', type);

        // ç²å–è¨­ç½®
        const settings = window.chessSettings ? window.chessSettings.get() : { soundMove: true, soundCapture: true, volume: 70 };

        // æª¢æŸ¥è©²é¡å‹éŸ³æ•ˆæ˜¯å¦é–‹å•Ÿ
        if (type === 'move' && !settings.soundMove) {
            console.log('è½å­éŸ³æ•ˆå·²é—œé–‰');
            return;
        }
        if (type === 'capture' && !settings.soundCapture) {
            console.log('åƒå­éŸ³æ•ˆå·²é—œé–‰');
            return;
        }

        const soundArray = sounds[type];
        if (!soundArray) return;

        const randomIndex = Math.floor(Math.random() * soundArray.length);
        const selectedSound = soundArray[randomIndex];
        console.log('é¸æ“‡çš„éŸ³æª”:', selectedSound);

        const audio = new Audio(selectedSound);
        // ä½¿ç”¨è‡ªè¨‚éŸ³é‡æˆ–è¨­ç½®ä¸­çš„éŸ³é‡
        audio.volume = (customVolume !== undefined ? customVolume : settings.volume) / 100;
        audio.play()
            .then(() => console.log('æ’­æ”¾æˆåŠŸ!'))
            .catch(e => console.log('éŸ³æ•ˆæ’­æ”¾å¤±æ•—:', e));
    }

    // åŒ¯å‡ºçµ¦å…¨åŸŸä½¿ç”¨
    window.playSound = playSound;


    // æ›´æ–°é¸ä¸­ç‹€æ…‹ - ä¿®æ­£ç‰ˆ
    function refreshAllPossibleMoves() {
        // æ¸…é™¤æ‰€æœ‰å¯èƒ½çš„ç§»å‹•æ¨™è¨˜
        document.querySelectorAll('.possible-move').forEach(el => {
            el.classList.remove('possible-move');
        });

    // calculateAllPossibleMoves();
    }

    function movePiece(fromRow, fromCol, toRow, toCol) {
        // æ¸…é™¤è¢«åƒæ£‹å­çš„æ‰€æœ‰å½±å“
        const targetPiece = gameState.board[toRow][toCol];
        const isCapture = (targetPiece !== null); // è¨˜éŒ„æ˜¯å¦åƒå­


        // æ›´æ–°è®¡æ•°å™¨
        gameState.totalMoves++;  // æ€»æ­¥æ•°+1
        if (targetPiece) {
            gameState.noCaptureCount = 0; // æœ‰åƒå­ï¼Œé‡ç½®è®¡æ•°å™¨
        } else {
            gameState.noCaptureCount++;   // æ— åƒå­ï¼Œè®¡æ•°å™¨+1
        }

        // æ‰§è¡Œç§»åŠ¨
        gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
        gameState.board[fromRow][fromCol] = null;

        // æ£€æŸ¥ç‰¹æ®Šæ¡ä»¶
        checkSpecialConditions();

        // åˆ·æ–°æ£‹ç›˜
        refreshAllPossibleMoves();


        // æ’­æ”¾éŸ³æ•ˆ
        if (typeof playSound === 'function') {
            if (isCapture) {
                playSound('capture'); // åƒå­éŸ³æ•ˆ
            } else {
                playSound('move');    // ç§»å‹•éŸ³æ•ˆ
            }
        }
    }


    function updateSelection() {
        const tiles = document.querySelectorAll('.tile');

        tiles.forEach(tile => {
            // é‡ç½®æ‰€æœ‰æ¨£å¼
            tile.classList.remove('selected', 'possible-move');

            // ğŸ”¥ ä¿®æ”¹ï¼šå¾ DOM è®€å–è¦–è¦ºåº§æ¨™ï¼Œè½‰æ›ç‚ºé‚è¼¯åº§æ¨™
            const visualRow = parseInt(tile.dataset.row);
            const visualCol = parseInt(tile.dataset.col);
            const logicalRow = getLogicalRow(visualRow);
            const logicalCol = getLogicalCol(visualCol);

            // ç•¶å‰é¸ä¸­çš„æ£‹å­ï¼ˆç”¨é‚è¼¯åº§æ¨™æ¯”å°ï¼‰
            if (gameState.selectedPiece &&
                gameState.selectedPiece.row === logicalRow &&
                gameState.selectedPiece.col === logicalCol) {
                tile.classList.add('selected');
            }

            // å¯ç§»å‹•ä½ç½®ï¼ˆç”¨é‚è¼¯åº§æ¨™æ¯”å°ï¼‰
            if (gameState.possibleMoves.some(move =>
                move.row === logicalRow && move.col === logicalCol)) {
                tile.classList.add('possible-move');
            }
        });
    }


    function getLegalMoves(board, row, col, piece) {
        const allMoves = getPossibleMovesWithBoard(board, row, col, piece);
        const legalMoves = [];

        for (const move of allMoves) {
            const newBoard = makeMove(board, row, col, move.row, move.col);
            if (!isInCheck(newBoard, piece.color)) {
                legalMoves.push(move);
            }
        }

        return legalMoves;
    }


    // ğŸ”§ æ›´æ–°ä½ çš„ checkSpecialConditions å‡½æ•¸
    function checkSpecialConditions() {
        // 50å›åˆ(100æ­¥)ç„¡åƒå­å’Œæ£‹
        if (gameState.noCaptureCount >= 100) {
            console.log('ğŸ³ï¸ æª¢æ¸¬åˆ°50æ­¥æœªåƒå­ï¼Œå®£å¸ƒå’Œæ£‹ï¼');

            // è¨­ç½®éŠæˆ²çµæŸ
            gameState.gameOver = true;

            // é¡¯ç¤º50æ­¥å’Œæ£‹è¨Šæ¯
            showFiftyMoveDrawMessage(gameState.noCaptureCount);
            return;
        }

        // 35å›åˆ(70æ­¥)æ™‚æé†’
        if (gameState.noCaptureCount === 70) {
            showFiftyMoveWarning(gameState.noCaptureCount);
        }
    }

    function showReminder(message) {
        // ä½¿ç”¨alertæ˜¾ç¤ºæé†’
        alert(message);

        // æˆ–è€…ç”¨æ›´ç¾è§‚çš„æ–¹å¼ï¼ˆéœ€è¦æ·»åŠ CSSæ ·å¼ï¼‰
        /*
        const reminder = document.createElement('div');
        reminder.className = 'reminder-popup';
        reminder.textContent = message;
        document.body.appendChild(reminder);
        setTimeout(() => reminder.remove(), 3000);
        */
    }

    function declareDraw(reason) {
        gameState.gameOver = true;
        alert(reason);
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šå’Œæ£‹å¤„ç†é€»è¾‘
    }

    function getPossibleMoves(row, col, piece) {
        const moves = [];

        switch (piece.type) {
            case 'è»Š':
            case 'ä¿¥':
                getRookMoves(row, col, piece.color, moves);
                break;
            case 'é¦¬':
            case 'å‚Œ':
                getHorseMoves(row, col, piece.color, moves);
                break;
            case 'ç‚®':
            case 'åŒ…':
                getCannonMoves(row, col, piece.color, moves);
                break;
            case 'ç›¸':
            case 'è±¡':
                getElephantMoves(row, col, piece.color, piece.type, moves);
                break;
            case 'ä»•':
            case 'å£«':
                getAdvisorMoves(row, col, piece.color, moves);
                break;
            case 'å¸¥':
            case 'å°‡':
                getKingMoves(row, col, piece.color, moves);
                break;
            case 'å…µ':
            case 'å’':
                getPawnMoves(row, col, piece.color, piece.type, moves);
                break;
        }

        // éæ¿¾æœƒå°è‡´å·±æ–¹å°‡è»çš„ç§»å‹•
        return moves.filter(move => {
            const simulatedBoard = deepCopyBoard(gameState.board);
            simulatedBoard[move.row][move.col] = simulatedBoard[row][col];
            simulatedBoard[row][col] = null;

            /* ===== å…µå’ç‰¹æ®Šæª¢æŸ¥ ===== */
            let isCheckByPawn = false;
            if (piece.type === 'å¸¥' || piece.type === 'å°‡') {  // å¦‚æœç§»å‹•çš„æ˜¯å°‡è»
                const attackDir = piece.color === 'red' ? -1 : 1;  // ç´…æ–¹å…µå¾€ä¸Š(-1)ï¼Œé»‘æ–¹å’å¾€ä¸‹(+1)
                const frontRow = move.row + attackDir;  // å°‡è»ç§»å‹•å¾Œçš„å‰æ–¹ä½ç½®
                if (frontRow >= 0 && frontRow < 9) {  // ç¢ºä¿ä¸è¶Šç•Œ
                    const frontPiece = simulatedBoard[frontRow][move.col];  // æª¢æŸ¥å‰æ–¹æœ‰ä»€éº¼æ£‹å­
                    isCheckByPawn = frontPiece &&  // å¦‚æœå‰æ–¹æœ‰æ£‹å­
                        frontPiece.color !== piece.color &&  // ä¸”æ˜¯æ•µæ–¹æ£‹å­
                        (frontPiece.type === 'å…µ' || frontPiece.type === 'å’');  // ä¸”æ˜¯å…µæˆ–å’
                }
            }

            // æª¢æŸ¥ç§»å‹•å¾Œæ˜¯å¦æœƒå°è‡´å·±æ–¹å°‡è»ï¼Œä¸¦åŠ ä¸Šå…µå’ç‰¹æ®Šæª¢æŸ¥
            return !isCheck(piece.color, simulatedBoard) && !isCheckByPawn;


        });
    }
    // è»Šçš„ç§»å‹•è¦å‰‡
    function getRookMoves(row, col, color, moves) {
        // æ°´å¹³ç§»å‹•
        for (let c = col - 1; c >= 0; c--) {
            if (gameState.board[row] && !gameState.board[row][c]) {
                moves.push({ row, col: c });
            } else if (gameState.board[row] && gameState.board[row][c]) {
                if (gameState.board[row][c].color !== color) {
                    moves.push({ row, col: c });
                }
                break;
            }
        }
        for (let c = col + 1; c < gameState.boardSize.cols; c++) {
            if (gameState.board[row] && !gameState.board[row][c]) {
                moves.push({ row, col: c });
            } else if (gameState.board[row] && gameState.board[row][c]) {
                if (gameState.board[row][c].color !== color) {
                    moves.push({ row, col: c });
                }
                break;
            }
        }
        // å‚ç›´ç§»å‹• (10è¡Œæ£‹ç›¤ï¼Œä¸å†è·³éç¬¬5è¡Œ)
        for (let r = row - 1; r >= 0; r--) {
            if (gameState.board[r] && !gameState.board[r][col]) {
                moves.push({ row: r, col });
            } else if (gameState.board[r] && gameState.board[r][col]) {
                if (gameState.board[r][col].color !== color) {
                    moves.push({ row: r, col });
                }
                break;
            }
        }
        for (let r = row + 1; r < gameState.boardSize.rows; r++) {
            if (gameState.board[r] && !gameState.board[r][col]) {
                moves.push({ row: r, col });
            } else if (gameState.board[r] && gameState.board[r][col]) {
                if (gameState.board[r][col].color !== color) {
                    moves.push({ row: r, col });
                }
                break;
            }
        }
    }

    // é¦¬çš„ç§»å‹•è¦å‰‡
    function getHorseMoves(row, col, color, moves) {
        const directions = [
            { dr: -2, dc: -1, blockDr: -1, blockDc: 0 }, // ä¸Šå·¦ (ç›´ä¸Š1æ ¼)
            { dr: -2, dc: 1,  blockDr: -1, blockDc: 0 }, // ä¸Šå³ (ç›´ä¸Š1æ ¼)
            { dr: -1, dc: 2,  blockDr: 0,  blockDc: 1 }, // å³ä¸Š (ç›´å³1æ ¼)
            { dr: 1,  dc: 2,  blockDr: 0,  blockDc: 1 }, // å³ä¸‹ (ç›´å³1æ ¼)
            { dr: 2,  dc: 1,  blockDr: 1,  blockDc: 0 }, // ä¸‹å³ (ç›´ä¸‹1æ ¼)
            { dr: 2,  dc: -1, blockDr: 1,  blockDc: 0 }, // ä¸‹å·¦ (ç›´ä¸‹1æ ¼)
            { dr: 1,  dc: -2, blockDr: 0,  blockDc: -1}, // å·¦ä¸‹ (ç›´å·¦1æ ¼)
            { dr: -1, dc: -2, blockDr: 0,  blockDc: -1}  // å·¦ä¸Š (ç›´å·¦1æ ¼)
        ];

        directions.forEach(dir => {
            const newRow = row + dir.dr;
            const newCol = col + dir.dc;

            // æª¢æŸ¥ç›®æ¨™ä½ç½®æ˜¯å¦åœ¨æ£‹ç›¤å…§
            if (newRow < 0 || newRow >= 10 || newCol < 0 || newCol >= 9) return;

            // è¨ˆç®—é¦¬è…³ä½ç½®ï¼ˆé—œéµï¼ï¼‰
            const blockRow = row + dir.blockDr;
            const blockCol = col + dir.blockDc;

            // æª¢æŸ¥é¦¬è…³æ˜¯å¦åˆæ³•ä¸”ç„¡é˜»æ“‹
            if (blockRow < 0 || blockRow >= 10 || blockCol < 0 || blockCol >= 9) return;
            if (gameState.board[blockRow][blockCol] !== null) return;

            // æª¢æŸ¥ç›®æ¨™ä½ç½®æ˜¯å¦å¯èµ°
            const targetPiece = gameState.board[newRow][newCol];
            if (!targetPiece || targetPiece.color !== color) {
                moves.push({ row: newRow, col: newCol });
            }
        });
    }

    // ç›¸/è±¡çš„ç§»å‹•è¦å‰‡ (ä¿®æ­£éæ²³é™åˆ¶)
    function getElephantMoves(row, col, color, type, moves) {
        const elephantMoves = [
            { dr: -2, dc: -2, blockRow: row - 1, blockCol: col - 1 },
            { dr: -2, dc: 2, blockRow: row - 1, blockCol: col + 1 },
            { dr: 2, dc: 2, blockRow: row + 1, blockCol: col + 1 },
            { dr: 2, dc: -2, blockRow: row + 1, blockCol: col - 1 }
        ];

        elephantMoves.forEach(move => {
            const newRow = row + move.dr;
            const newCol = col + move.dc;

            // æª¢æŸ¥é‚Šç•Œ
            if (newRow >= 0 && newRow < gameState.boardSize.rows &&
                newCol >= 0 && newCol < gameState.boardSize.cols) {

                // ç›¸/è±¡ä¸èƒ½éæ²³ï¼šç´…æ–¹ç›¸åªèƒ½åœ¨5-9è¡Œï¼Œé»‘æ–¹è±¡åªèƒ½åœ¨0-4è¡Œ
                if ((color === 'red' && newRow >= 5 && newRow <= 9) ||
                    (color === 'black' && newRow >= 0 && newRow <= 4)) {

                    // æª¢æŸ¥è±¡çœ¼æ˜¯å¦è¢«å µ - æ·»åŠ é‚Šç•Œæª¢æŸ¥
                    if (move.blockRow >= 0 && move.blockRow < gameState.boardSize.rows &&
                        move.blockCol >= 0 && move.blockCol < gameState.boardSize.cols &&
                        gameState.board[move.blockRow] &&
                        !gameState.board[move.blockRow][move.blockCol]) {

                        // æª¢æŸ¥ç›®æ¨™ä½ç½® - æ·»åŠ å®‰å…¨æª¢æŸ¥
                        if (gameState.board[newRow] &&
                            (!gameState.board[newRow][newCol] || gameState.board[newRow][newCol].color !== color)) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }
            }
        });
    }

    // ä»•/å£«çš„ç§»å‹•è¦å‰‡ (ä¿®æ­£ä¹å®®æ ¼ç¯„åœ)
    function getAdvisorMoves(row, col, color, moves) {
        const advisorMoves = [
            { dr: -1, dc: -1 },
            { dr: -1, dc: 1 },
            { dr: 1, dc: 1 },
            { dr: 1, dc: -1 }
        ];

        advisorMoves.forEach(move => {
            const newRow = row + move.dr;
            const newCol = col + move.dc;

            if (isInPalace(newRow, newCol, color)) {
                if (!gameState.board[newRow][newCol] || gameState.board[newRow][newCol].color !== color) {
                    moves.push({ row: newRow, col: newCol });
                }
            }
        });
    }

    // å°‡/å¸¥çš„ç§»å‹•è¦å‰‡ (ä¿®æ­£ä¹å®®æ ¼ç¯„åœå’Œç‰¹æ®Šé™åˆ¶)
    function getKingMoves(row, col, color, moves) {
        const kingMoves = [
            { dr: -1, dc: 0 },  // ä¸Š
            { dr: 1, dc: 0 },   // ä¸‹
            { dr: 0, dc: -1 },  // å·¦
            { dr: 0, dc: 1 }    // å³
        ];

        // 1. åŸºæœ¬ç§»å‹•ï¼ˆä¸Šä¸‹å·¦å³ä¸€æ ¼ï¼‰
        kingMoves.forEach(move => {
            const newRow = row + move.dr;
            const newCol = col + move.dc;

            // ä¿®æ­£ç¦æ­¢åº§æ¨™ï¼š10è¡Œæ£‹ç›¤
            // ç´…å¸¥ç¦æ­¢åˆ°(6,3)ã€(6,4)ã€(6,5) - å› ç‚ºç´…æ–¹ä¹å®®æ ¼ç¾åœ¨æ˜¯7-9è¡Œ
            if (color === 'red' && newRow === 6 && newCol >= 3 && newCol <= 5) {
                return;
            }
            // é»‘å°‡ç¦æ­¢åˆ°(3,3)ã€(3,4)ã€(3,5) - é»‘æ–¹ä¹å®®æ ¼ä»æ˜¯0-2è¡Œ
            if (color === 'black' && newRow === 3 && newCol >= 3 && newCol <= 5) {
                return;
            }

            if (isInPalace(newRow, newCol, color)) {
                if (!gameState.board[newRow][newCol] ||
                    gameState.board[newRow][newCol].color !== color) {

                    // æª¢æŸ¥ï¼šå¦‚æœç§»å‹•å¾Œèˆ‡æ•µæ–¹ç‹åœ¨åŒä¸€ç¸±ç·š
                    const enemyKing = findEnemyKing(color);
                    if (enemyKing && newCol === enemyKing.col) {
                        // å¿…é ˆæª¢æŸ¥ä¸­é–“æ˜¯å¦æœ‰ä»»ä½•æ£‹å­ï¼ˆåŒ…æ‹¬å·±æ–¹ï¼‰
                        if (!hasBlockingPieceBetween(newRow, enemyKing.row, newCol)) {
                            return; // ç„¡é˜»æ“‹å‰‡è·³éæ­¤ç§»å‹•
                        }
                    }

                    moves.push({ row: newRow, col: newCol });
                }
            }
        });

        // 2. å°‡å¸¥å°é¢ç‰¹æ®Šè¦å‰‡
        const enemyKingType = color === 'red' ? 'å°‡' : 'å¸¥';
        const enemyColor = color === 'red' ? 'black' : 'red';

        // æª¢æŸ¥åŒä¸€ç¸±ç·šä¸Šçš„æ•µæ–¹å°‡å¸¥
        for (let r = 0; r < gameState.boardSize.rows; r++) {
            const piece = gameState.board[r][col];
            if (piece && piece.type === enemyKingType && piece.color === enemyColor) {
                // æª¢æŸ¥ä¸­é–“æ˜¯å¦æœ‰æ£‹å­é˜»æ“‹ï¼ˆåŒ…æ‹¬å·±æ–¹æ£‹å­ï¼‰
                let hasBlocking = false;
                const minRow = Math.min(row, r);
                const maxRow = Math.max(row, r);

                for (let betweenRow = minRow + 1; betweenRow < maxRow; betweenRow++) {
                    // 10è¡Œæ£‹ç›¤ä¸å†è·³éç¬¬5è¡Œ
                    if (gameState.board[betweenRow][col]) {
                        hasBlocking = true;
                        break;
                    }
                }

                // åªæœ‰ç•¶ä¸­é–“æœ‰æ£‹å­æ™‚æ‰å…è¨±å°é¢
                if (hasBlocking && isInPalace(r, col, color)) {
                    if (!gameState.board[r][col] || gameState.board[r][col].color !== color) {
                        moves.push({ row: r, col });
                    }
                }
                break;
            }
        }
    }

    // è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥æ˜¯å¦åœ¨ä¹å®®æ ¼å…§ (ä¿®æ­£ç¯„åœ)
    function isInPalace(row, col, color) {
        if (col < 3 || col > 5) return false;

        if (color === 'red') {
            // ç´…æ–¹ä¹å®®æ ¼ï¼š7-9è¡Œ
            return row >= 7 && row <= 9;
        } else {
            // é»‘æ–¹ä¹å®®æ ¼ï¼š0-2è¡Œ
            return row >= 0 && row <= 2;
        }
    }
    // å…¶ä»–è¼”åŠ©å‡½æ•¸ä¿æŒå®Œå…¨ä¸€è‡´ä¸è®Š
    function findEnemyKing(color) {
        const enemyType = color === 'red' ? 'å°‡' : 'å¸¥';
        for (let r = 0; r < gameState.boardSize.rows; r++) {
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                const piece = gameState.board[r][c];
                if (piece?.type === enemyType && piece.color !== color) {
                    return { row: r, col: c };
                }
            }
        }
        return null;
    }

    function hasBlockingPieceBetween(row1, row2, col) {
        const start = Math.min(row1, row2);
        const end = Math.max(row1, row2);
        for (let r = start + 1; r < end; r++) {
            // 10è¡Œæ£‹ç›¤ä¸å†è·³éç¬¬5è¡Œ
            if (gameState.board[r] && gameState.board[r][col]) return true;
        }
        return false;
    }

    // ç‚®çš„ç§»å‹•è¦å‰‡ (ç§»é™¤è·³éç¬¬5è¡Œçš„é‚è¼¯)
    function getCannonMoves(row, col, color, moves) {
        // æ°´å¹³ç§»å‹•
        let hasJumped = false;
        for (let c = col - 1; c >= 0; c--) {
            if (!hasJumped) {
                if (gameState.board[row] && !gameState.board[row][c]) {
                    moves.push({ row, col: c });
                } else if (gameState.board[row] && gameState.board[row][c]) {
                    hasJumped = true;
                }
            } else {
                if (gameState.board[row] && gameState.board[row][c]) {
                    if (gameState.board[row][c].color !== color) {
                        moves.push({ row, col: c });
                    }
                    break;
                }
            }
        }

        hasJumped = false;
        for (let c = col + 1; c < gameState.boardSize.cols; c++) {
            if (!hasJumped) {
                if (gameState.board[row] && !gameState.board[row][c]) {
                    moves.push({ row, col: c });
                } else if (gameState.board[row] && gameState.board[row][c]) {
                    hasJumped = true;
                }
            } else {
                if (gameState.board[row] && gameState.board[row][c]) {
                    if (gameState.board[row][c].color !== color) {
                        moves.push({ row, col: c });
                    }
                    break;
                }
            }
        }

        // å‚ç›´ç§»å‹• (ç§»é™¤è·³éç¬¬5è¡Œçš„é‚è¼¯)
        hasJumped = false;
        for (let r = row - 1; r >= 0; r--) {
            if (!hasJumped) {
                if (gameState.board[r] && !gameState.board[r][col]) {
                    moves.push({ row: r, col });
                } else if (gameState.board[r] && gameState.board[r][col]) {
                    hasJumped = true;
                }
            } else {
                if (gameState.board[r] && gameState.board[r][col]) {
                    if (gameState.board[r][col].color !== color) {
                        moves.push({ row: r, col });
                    }
                    break;
                }
            }
        }

        hasJumped = false;
        for (let r = row + 1; r < gameState.boardSize.rows; r++) {
            if (!hasJumped) {
                if (gameState.board[r] && !gameState.board[r][col]) {
                    moves.push({ row: r, col });
                } else if (gameState.board[r] && gameState.board[r][col]) {
                    hasJumped = true;
                }
            } else {
                if (gameState.board[r] && gameState.board[r][col]) {
                    if (gameState.board[r][col].color !== color) {
                        moves.push({ row: r, col });
                    }
                    break;
                }
            }
        }
    }

    // å…µ/å’ç§»å‹•è¦å‰‡ (ä¿®æ­£ç‚º10è¡Œæ£‹ç›¤)
    function getPawnMoves(row, col, color, type, moves) {
        const forward = color === 'red' ? -1 : 1; // ç´…å…µå‘ä¸Š(è¡Œæ•¸æ¸›å°‘)ï¼Œé»‘å’å‘ä¸‹(è¡Œæ•¸å¢åŠ )
        const isRed = color === 'red';

        // 1. åŸºæœ¬å‰é€²
        let newRow = row + forward;

        // ç¢ºä¿æ–°ä½ç½®åœ¨æ£‹ç›¤ç¯„åœå…§
        if (newRow >= 0 && newRow < gameState.boardSize.rows) {
            if (gameState.board[newRow]) {
                const targetPiece = gameState.board[newRow][col];
                // åªæœ‰ç•¶ç›®æ¨™ä½ç½®ç‚ºç©ºæˆ–æ˜¯æ•µæ–¹æ£‹å­æ™‚æ‰èƒ½ç§»å‹•
                if (!targetPiece || targetPiece.color !== color) {
                    moves.push({ row: newRow, col });
                }
            }
        }

        // 2. éæ²³å¾Œçš„å·¦å³ç§»å‹•
        // 10è¡Œæ£‹ç›¤ï¼šç´…æ–¹éæ²³ = row < 5ï¼Œé»‘æ–¹éæ²³ = row > 4
        const isCrossedRiver = (isRed && row < 5) || (!isRed && row > 4);
        if (isCrossedRiver) {
            // å·¦å³ç§»å‹•ï¼ˆä¿æŒåœ¨åŒä¸€è¡Œï¼‰
            [-1, 1].forEach(dc => {
                const newCol = col + dc;
                if (newCol >= 0 && newCol < gameState.boardSize.cols) {
                    if (gameState.board[row]) {
                        const targetPiece = gameState.board[row][newCol];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push({ row, col: newCol });
                        }
                    }
                }
            });
        }
    }

    /**
     * æª¢æŸ¥æŒ‡å®šç©å®¶æ˜¯å¦è¢«å°‡è»
     * @param {string} player - ç•¶å‰ç©å®¶ ('red' æˆ– 'black')
     * @param {Array|null} customBoard - å¯é¸çš„è‡ªå®šç¾©æ£‹ç›¤ç‹€æ…‹
     * @returns {boolean} æ˜¯å¦è¢«å°‡è»
     */
    function isCheck(player, customBoard = null) {
        const board = customBoard || gameState.board;
        const kingType = player === 'red' ? 'å¸¥' : 'å°‡';
        let kingPos = null;

        // å°‹æ‰¾å°‡/å¸¥çš„ä½ç½®
        for (let row = 0; row < gameState.boardSize.rows; row++) {
            for (let col = 0; col < gameState.boardSize.cols; col++) {
                if (board[row][col]?.type === kingType &&
                    board[row][col]?.color === player) {
                    kingPos = { row, col };
                    break;
                }
            }
            if (kingPos) break;
        }

        if (!kingPos) return false; // æ‰¾ä¸åˆ°å°‡/å¸¥è¦–ç‚ºæœªè¢«å°‡è»

        const opponent = player === 'red' ? 'black' : 'red';
        return (
            isAttackedByHorse(kingPos, opponent, board) ||
            isAttackedByRookOrCannon(kingPos, opponent, board) ||
            isAttackedByPawn(kingPos, opponent, board) ||
            isAttackedByKing(kingPos, opponent, board)
        );
    }

    /**
     * æª¢æŸ¥æ˜¯å¦è¢«è»Šæˆ–ç‚®æ”»æ“Š
     */
    function isAttackedByRookOrCannon(kingPos, opponentColor, board) {
        const directions = [
            { dr: 0, dc: 1 }, { dr: 0, dc: -1 }, // æ°´å¹³
            { dr: 1, dc: 0 }, { dr: -1, dc: 0 }  // å‚ç›´
        ];

        for (const dir of directions) {
            let betweenPieces = 0;
            for (let distance = 1; ; distance++) {
                const row = kingPos.row + dir.dr * distance;
                const col = kingPos.col + dir.dc * distance;

                // è¶…å‡ºé‚Šç•Œæª¢æŸ¥
                if (row < 0 || row >= gameState.boardSize.rows ||
                    col < 0 || col >= gameState.boardSize.cols) break;

                const piece = board[row][col];
                if (!piece) continue;

                // é‡åˆ°å°æ‰‹æ£‹å­æ™‚åˆ¤æ–·
                if (piece.color === opponentColor) {
                    // è»Šæ”»æ“Šï¼ˆä¸­é–“ç„¡å­ï¼‰
                    if ((piece.type === 'è»Š' || piece.type === 'ä¿¥') && betweenPieces === 0) {
                        return true;
                    }
                    // ç‚®æ”»æ“Šï¼ˆä¸­é–“å‰›å¥½ä¸€å­ï¼‰
                    if ((piece.type === 'ç‚®' || piece.type === 'åŒ…') && betweenPieces === 1) {
                        return true;
                    }
                }
                betweenPieces++;
            }
        }
        return false;
    }

    /**
     * æª¢æŸ¥æ˜¯å¦è¢«é¦¬æ”»æ“Š
     */
    function isAttackedByHorse(kingPos, opponentColor, board) {
        const horseMoves = [
            // æ ¼å¼: [è¡Œå˜åŒ–, åˆ—å˜åŒ–, é©¬è„šè¡Œå˜åŒ–, é©¬è„šåˆ—å˜åŒ–]
            [-2, -1, -1, 0], // ä¸Šå·¦
            [-2, 1, -1, 0],  // ä¸Šå³
            [-1, 2, 0, 1],   // å³ä¸Š
            [1, 2, 0, 1],    // å³ä¸‹
            [2, 1, 1, 0],    // ä¸‹å³
            [2, -1, 1, 0],   // ä¸‹å·¦
            [1, -2, 0, -1],  // å·¦ä¸‹
            [-1, -2, 0, -1]  // å·¦ä¸Š
        ];

        return horseMoves.some(([dr, dc, blockDr, blockDc]) => {
            const horseRow = kingPos.row - dr;
            const horseCol = kingPos.col - dc;

            // æ£€æŸ¥é©¬æ˜¯å¦åœ¨æ£‹ç›˜å†… (ä¿®æ­£ç‚º10è¡Œ)
            if (horseRow < 0 || horseRow >= 10 || horseCol < 0 || horseCol >= 9) return false;

            // æ£€æŸ¥æ˜¯å¦æ˜¯æ•Œæ–¹é©¬
            const piece = board[horseRow][horseCol];
            if (!piece || piece.color !== opponentColor) return false;
            if (!['é¦¬', 'å‚Œ'].includes(piece.type)) return false;

            // æ£€æŸ¥é©¬è„š
            const blockRow = horseRow + blockDr;
            const blockCol = horseCol + blockDc;
            if (blockRow < 0 || blockRow >= 10 || blockCol < 0 || blockCol >= 9) return false;
            return board[blockRow][blockCol] === null;
        });
    }

    function isAttackedByPawn(kingPos, opponentColor, board) {
        const pawnType = opponentColor === 'red' ? 'å…µ' : 'å’';

        // ğŸ”‘ ä¿®æ­£ï¼šå…µå’æ”»æ“Šä¾†æºæ–¹å‘
        // ç´…å…µåœ¨å°‡/å¸¥ä¸‹æ–¹ï¼ˆrow+1ï¼‰ï¼Œå‘ä¸Šæ”»æ“Š
        // é»‘å’åœ¨å°‡/å¸¥ä¸Šæ–¹ï¼ˆrow-1ï¼‰ï¼Œå‘ä¸‹æ”»æ“Š
        const attackFromDir = opponentColor === 'red' ? 1 : -1;
        const attackFromRow = kingPos.row + attackFromDir;

        // 1. æª¢æŸ¥æ­£å‰æ–¹æ”»æ“Šï¼ˆå¿…é ˆç·Šé„°ï¼‰
        if (attackFromRow >= 0 && attackFromRow < 10) {
            const frontPiece = board[attackFromRow][kingPos.col];
            if (frontPiece &&
                frontPiece.color === opponentColor &&
                frontPiece.type === pawnType) {
                return true;
            }
        }

        // 2. æª¢æŸ¥éæ²³å¾Œçš„å·¦å³æ”»æ“Šï¼ˆå¿…é ˆåŒè¡Œï¼‰
        for (const colOffset of [-1, 1]) {
            const sideCol = kingPos.col + colOffset;
            if (sideCol >= 0 && sideCol < 9) {
                const sidePiece = board[kingPos.row][sideCol];
                if (sidePiece &&
                    sidePiece.color === opponentColor &&
                    sidePiece.type === pawnType) {

                    // æª¢æŸ¥é€™å€‹å…µ/å’æ˜¯å¦å·²éæ²³
                    const pawnRow = kingPos.row; // åŒä¸€è¡Œ
                    const pawnHasCrossedRiver = opponentColor === 'red'
                        ? pawnRow < 5   // ç´…å…µéæ²³ï¼ˆrow < 5ï¼‰
                        : pawnRow > 4;  // é»‘å’éæ²³ï¼ˆrow > 4ï¼‰

                    if (pawnHasCrossedRiver) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * æª¢æŸ¥æ˜¯å¦è¢«å°æ–¹å°‡/å¸¥æ”»æ“Š (10è¡Œæ£‹ç›¤)
     */
    function isAttackedByKing(kingPos, opponentColor, board) {
        const opponentKingType = opponentColor === 'red' ? 'å¸¥' : 'å°‡';
        const direction = opponentColor === 'red' ? 1 : -1; // ç´…æ–¹åœ¨ä¸‹ï¼Œé»‘æ–¹åœ¨ä¸Š

        // åªæª¢æŸ¥å‚ç›´æ–¹å‘çš„å°é¢ (10è¡Œæ£‹ç›¤ä¸è·³éç¬¬5è¡Œ)
        for (let row = kingPos.row + direction;
             row >= 0 && row < gameState.boardSize.rows;
             row += direction) {
            const piece = board[row][kingPos.col];
            if (!piece) continue;
            return piece.type === opponentKingType && piece.color === opponentColor;
        }
        return false;
    }

    function isCheckmate(player) {
        console.log('ğŸ” é–‹å§‹æª¢æŸ¥', player, 'æ˜¯å¦è¢«å°‡æ­»');

        if (!isCheck(player)) {
            console.log('âŒ', player, 'æ²’æœ‰è¢«å°‡è»ï¼Œä¸æ˜¯å°‡æ­»');
            return false;
        }

        console.log('âœ…', player, 'ç¢ºå¯¦è¢«å°‡è»ï¼Œé–‹å§‹æª¢æŸ¥æ˜¯å¦æœ‰è§£åœæ–¹æ³•');

        const originalBoard = deepCopyBoard(gameState.board);

        console.log('ğŸ”„ é–‹å§‹éæ­·æ‰€æœ‰å·±æ–¹æ£‹å­å°‹æ‰¾è§£åœæ–¹æ³•...');

        // éæ­·æ‰€æœ‰å·±æ–¹æ£‹å­ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ä»»ä½•åˆæ³•ç§»å‹•å¯ä»¥è§£åœ
        for (let row = 0; row < gameState.boardSize.rows; row++) {
            for (let col = 0; col < gameState.boardSize.cols; col++) {
                const piece = gameState.board[row][col];

                // åªæª¢æŸ¥å·±æ–¹æ£‹å­
                if (piece && piece.color === player) {
                    console.log('ğŸ” æª¢æŸ¥æ£‹å­:', piece.type, 'åœ¨ [' + row + ',' + col + ']');
                    const moves = getPossibleMoves(row, col, piece);

                    console.log('   å¯èƒ½ç§»å‹•æ•¸é‡:', moves.length);
                    if (moves.length > 0) {
                        console.log('   ç§»å‹•åˆ—è¡¨:', moves);
                    }

                    // æª¢æŸ¥æ¯å€‹å¯èƒ½çš„ç§»å‹•
                    for (const move of moves) {
                        // æ¨¡æ“¬ç§»å‹•
                        const targetPiece = gameState.board[move.row][move.col];
                        gameState.board[move.row][move.col] = piece;
                        gameState.board[row][col] = null;

                        // æª¢æŸ¥ç§»å‹•å¾Œæ˜¯å¦é‚„è¢«å°‡è»
                        const stillInCheck = isCheck(player);

                        // é‚„åŸæ£‹ç›¤
                        gameState.board = deepCopyBoard(originalBoard);

                        if (!stillInCheck) {
                            console.log('âœ… æ‰¾åˆ°è§£åœæ–¹æ³•ï¼', piece.type, 'å¾ [' + row + ',' + col + '] ç§»å‹•åˆ° [' + move.row + ',' + move.col + ']');
                            if (targetPiece) {
                                console.log('   ï¼ˆåƒæ‰äº†', targetPiece.type, 'ï¼‰');
                            }
                            return false; // æ‰¾åˆ°è§£åœæ–¹æ³•ï¼Œä¸æ˜¯å°‡æ­»
                        } else {
                            console.log('   âŒ ç§»å‹•åˆ° [' + move.row + ',' + move.col + '] å¾Œä»è¢«å°‡è»');
                        }
                    }
                }
            }
        }

        console.log('ğŸ’€ æœ€çµ‚åˆ¤å®šï¼šç¢ºå¯¦æ˜¯å°‡æ­»ï¼æ²’æœ‰ä»»ä½•æ£‹å­å¯ä»¥è§£åœ');
        return true; // æ²’æœ‰ä»»ä½•åˆæ³•ç§»å‹•å¯ä»¥è§£åœï¼Œç¢ºå¯¦æ˜¯å°‡æ­»
    }

    function isAttackedByPawnOnly(kingPos, opponentColor, board) {
        const pawnType = opponentColor === 'red' ? 'å…µ' : 'å’';

        // ğŸ”‘ å…µå’åªèƒ½æ”»æ“Šç·Šé„°ä½ç½®ï¼š
        // ç´…å…µå‘ä¸Šæ”»æ“Šï¼ˆrow-1ï¼‰ï¼Œé»‘å’å‘ä¸‹æ”»æ“Šï¼ˆrow+1ï¼‰
        const attackFromRow = opponentColor === 'red'
            ? kingPos.row + 1  // ç´…å…µåœ¨å°‡/å¸¥ä¸‹æ–¹ï¼ˆrow+1ï¼‰ï¼Œå‘ä¸Šæ”»æ“Š
            : kingPos.row - 1; // é»‘å’åœ¨å°‡/å¸¥ä¸Šæ–¹ï¼ˆrow-1ï¼‰ï¼Œå‘ä¸‹æ”»æ“Š

        // æª¢æŸ¥è©²ä½ç½®æ˜¯å¦åœ¨æ£‹ç›¤ç¯„åœå…§
        if (attackFromRow < 0 || attackFromRow >= gameState.boardSize.rows) {
            return false;
        }

        // æª¢æŸ¥è©²ä½ç½®æ˜¯å¦æœ‰æ•µæ–¹å…µå’
        const attackerPiece = board[attackFromRow][kingPos.col];
        const hasPawnAttack = attackerPiece &&
            attackerPiece.color === opponentColor &&
            attackerPiece.type === pawnType;

        if (!hasPawnAttack) return false;

        // ğŸ”‘ ç¢ºèªã€Œåªã€è¢«å…µå’æ”»æ“Šï¼ˆæ²’æœ‰å…¶ä»–æ”»æ“Šä¾†æºï¼‰
        const hasOtherAttacks =
            isAttackedByHorse(kingPos, opponentColor, board) ||
            isAttackedByRookOrCannon(kingPos, opponentColor, board) ||
            isAttackedByKing(kingPos, opponentColor, board);

        return !hasOtherAttacks; // åªæœ‰åœ¨ã€Œåªè¢«å…µå’æ”»æ“Šã€æ™‚æ‰è¿”å› true
    }

    function canKingEscapePawnCheck(kingPos, player, board) {
        const king = board[kingPos.row][kingPos.col];
        const moves = []; // å‰µå»ºç©ºæ•¸çµ„ä¾†æ¥æ”¶ç§»å‹•
        getKingMoves(kingPos.row, kingPos.col, king.color, moves); // ä¿®æ­£èª¿ç”¨æ–¹å¼

        // æª¢æŸ¥å°‡/å¸¥æ˜¯å¦æœ‰åˆæ³•ç§»å‹•é¿é–‹å…µå’
        return moves.some(move => {
            const newRow = move.row;
            const newCol = move.col;

            // æ¨¡æ“¬ç§»å‹•ä¸¦æª¢æŸ¥æ˜¯å¦é‚„æœƒè¢«å°‡è»
            const originalPiece = board[newRow][newCol];
            board[newRow][newCol] = king;
            board[kingPos.row][kingPos.col] = null;

            const stillInCheck = isCheck(player, board);

            // é‚„åŸæ£‹ç›¤ç‹€æ…‹
            board[kingPos.row][kingPos.col] = king;
            board[newRow][newCol] = originalPiece;

            return !stillInCheck; // å¦‚æœç§»å‹•å¾Œä¸å†è¢«å°‡è»ï¼Œå‰‡å¯ä»¥é€ƒè„«
        });
    }

    function findKingPosition(player) {
        const kingType = player === 'red' ? 'å¸¥' : 'å°‡';
        for (let row = 0; row < gameState.boardSize.rows; row++) { // ä½¿ç”¨ gameState.boardSize.rows
            for (let col = 0; col < gameState.boardSize.cols; col++) { // ä½¿ç”¨ gameState.boardSize.cols
                const piece = gameState.board[row][col];
                if (piece && piece.type === kingType && piece.color === player) {
                    return { row, col };
                }
            }
        }
        // å¦‚æœæ‰¾ä¸åˆ°å°†/å¸…ï¼Œè¿”å›ä¸€ä¸ªé»˜è®¤ä½ç½®ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‘ç”Ÿï¼‰
        console.error("ä¸¥é‡é”™è¯¯ï¼šæ‰¾ä¸åˆ°", player, "æ–¹çš„å°†/å¸…ï¼");
        return { row: player === 'red' ? gameState.boardSize.rows - 1 : 0, col: 4 }; // è¿”å›é»˜è®¤ä½ç½®
    }

    function updateTurnIndicator() {
        turnIndicator.textContent = gameState.currentTurn === 'red' ? 'ç´…æ–¹å›åˆ' : 'é»‘æ–¹å›åˆ';
        turnIndicator.className = gameState.currentTurn === 'red' ? 'red-turn' : 'black-turn';
    }

    function saveToHistory() {
        // åªä¿ç•™å½“å‰ä½ç½®ä¹‹åçš„å†å²
        gameState.history = gameState.history.slice(0, gameState.historyIndex + 1);

        const stateCopy = {
            board: deepCopyBoard(gameState.board),
            currentTurn: gameState.currentTurn,
            gameRecord: JSON.parse(JSON.stringify(gameState.gameRecord))
        };
        gameState.history.push(stateCopy);
        gameState.historyIndex = gameState.history.length - 1;
    }


    // ğŸ¯ æ”¹è‰¯çš„æ‚”æ£‹å‡½æ•¸ - æ”¯æ´ç›´æ¥æ¢å¾©åˆå§‹ç›¤é¢
    function undoMove() {
        // å…ˆå˜—è©¦ä½¿ç”¨ HistoryManager
        if (historyManager && historyManager.canUndo()) {
            const prevState = historyManager.undo();

            if (prevState) {
                console.log("ğŸ” å¾ HistoryManager æ¢å¾©ç‹€æ…‹:", prevState);

                gameState.gameRecord = JSON.parse(JSON.stringify(prevState.gameRecord || []));

                console.log("ğŸ” æ‚”æ£‹å¾Œ gameRecord é•·åº¦:", gameState.gameRecord.length);

                // ç›´æ¥æ¢å¾©å®Œæ•´ç‹€æ…‹
                gameState.board = JSON.parse(JSON.stringify(prevState.board));

                // ğŸ”§ ä¿®å¾©ï¼šæ‚”æ£‹å¾Œæ‡‰è©²é‚„æ˜¯åŸä¾†èµ°æ£‹çš„é‚£ä¸€æ–¹
                // prevState.currentTurn æ˜¯èµ°æ£‹å¾Œåˆ‡æ›çš„å›åˆï¼Œæ‰€ä»¥è¦åˆ‡æ›å›ä¾†
                gameState.currentTurn = prevState.currentTurn === 'red' ? 'black' : 'red';

                gameState.gameRecord = JSON.parse(JSON.stringify(prevState.gameRecord || []));

                // æ¢å¾©å…¶ä»–å¯èƒ½çš„ç‹€æ…‹
                if (prevState.totalMoves !== undefined) {
                    gameState.totalMoves = prevState.totalMoves;
                }
                if (prevState.noCaptureCount !== undefined) {
                    gameState.noCaptureCount = prevState.noCaptureCount;
                }

                // é‡ç½®å…¶ä»–ç‹€æ…‹
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.gameOver = false;
                gameState.checkStatus = null;

                // æ›´æ–°é¡¯ç¤º
                renderBoard();
                updateMoveDisplay();

                console.log("âœ… æ‚”æ£‹æˆåŠŸï¼");
                console.log("- ç•¶å‰å›åˆ:", gameState.currentTurn);
                console.log("- HistoryManager ç•¶å‰ç´¢å¼•:", historyManager.currentIndex);
                console.log("- HistoryManager æ­·å²é•·åº¦:", historyManager.history.length);
                console.log("- æ£‹è­œé•·åº¦:", gameState.gameRecord.length);
                return;
            }
        }

        // HistoryManager ç„¡æ³•æ‚”æ£‹æ™‚ï¼Œç›´æ¥æ¢å¾©åˆå§‹ç›¤é¢
        console.log("ğŸ”„ HistoryManager ç„¡è³‡æ–™ï¼Œæ¢å¾©åŸå§‹ç›¤é¢");

        // æ¢å¾©åˆå§‹ç›¤é¢
        resetToInitialBoard();

        console.log("âœ… å·²æ¢å¾©åˆ°åˆå§‹ç›¤é¢ï¼");
    }

    // ========================================
    // ç¬¬ä¸‰æ­¥ï¼šä¿®æ”¹ resetToInitialBoard å‡½æ•¸
    // ========================================

    function resetToInitialBoard() {
        console.log('ğŸ”„ æ¢å¾©åˆå§‹ç›¤é¢');

        // âœ… å¦‚æœæœ‰ä¿å­˜çš„åˆå§‹å±€é¢ï¼Œå„ªå…ˆä½¿ç”¨
        if (gameState.initialBoard && gameState.initialTurn) {
            console.log('âœ… ä½¿ç”¨å·²ä¿å­˜çš„åˆå§‹å±€é¢');

            gameState.board = JSON.parse(JSON.stringify(gameState.initialBoard));
            gameState.currentTurn = gameState.initialTurn;
            gameState.gameRecord = [];
            gameState.selectedPiece = null;
            gameState.possibleMoves = [];
            gameState.gameOver = false;
            gameState.checkStatus = null;
            gameState.totalMoves = 0;
            gameState.noCaptureCount = 0;

            // æ¸…ç©º HistoryManager
            if (historyManager) {
                historyManager.clear();
            }

            // æ›´æ–°é¡¯ç¤º
            renderBoard();
            updateMoveDisplay();

            console.log('âœ… å·²æ¢å¾©åˆ°å°å…¥çš„åˆå§‹å±€é¢');
            return;
        }

        // âš ï¸ å¦‚æœæ²’æœ‰ä¿å­˜çš„åˆå§‹å±€é¢ï¼Œæ‰ä½¿ç”¨æ¨™æº–é–‹å±€
        console.log('âš ï¸ æ²’æœ‰ä¿å­˜çš„åˆå§‹å±€é¢ï¼Œä½¿ç”¨æ¨™æº–é–‹å±€');

        // åˆå§‹åŒ–æ¨™æº–é–‹å±€æ£‹ç›¤
        gameState.board = Array(10).fill(null).map(() => Array(9).fill(null));

        // ç´…æ–¹æ£‹å­ï¼ˆ5-9è¡Œï¼‰
        gameState.board[9][0] = { type: 'ä¿¥', color: 'red' };
        gameState.board[9][1] = { type: 'å‚Œ', color: 'red' };
        gameState.board[9][2] = { type: 'ç›¸', color: 'red' };
        gameState.board[9][3] = { type: 'ä»•', color: 'red' };
        gameState.board[9][4] = { type: 'å¸¥', color: 'red' };
        gameState.board[9][5] = { type: 'ä»•', color: 'red' };
        gameState.board[9][6] = { type: 'ç›¸', color: 'red' };
        gameState.board[9][7] = { type: 'å‚Œ', color: 'red' };
        gameState.board[9][8] = { type: 'ä¿¥', color: 'red' };
        gameState.board[7][1] = { type: 'ç‚®', color: 'red' };
        gameState.board[7][7] = { type: 'ç‚®', color: 'red' };
        gameState.board[6][0] = { type: 'å…µ', color: 'red' };
        gameState.board[6][2] = { type: 'å…µ', color: 'red' };
        gameState.board[6][4] = { type: 'å…µ', color: 'red' };
        gameState.board[6][6] = { type: 'å…µ', color: 'red' };
        gameState.board[6][8] = { type: 'å…µ', color: 'red' };

        // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
        gameState.board[0][0] = { type: 'è»Š', color: 'black' };
        gameState.board[0][1] = { type: 'é¦¬', color: 'black' };
        gameState.board[0][2] = { type: 'è±¡', color: 'black' };
        gameState.board[0][3] = { type: 'å£«', color: 'black' };
        gameState.board[0][4] = { type: 'å°‡', color: 'black' };
        gameState.board[0][5] = { type: 'å£«', color: 'black' };
        gameState.board[0][6] = { type: 'è±¡', color: 'black' };
        gameState.board[0][7] = { type: 'é¦¬', color: 'black' };
        gameState.board[0][8] = { type: 'è»Š', color: 'black' };
        gameState.board[2][1] = { type: 'åŒ…', color: 'black' };
        gameState.board[2][7] = { type: 'åŒ…', color: 'black' };
        gameState.board[3][0] = { type: 'å’', color: 'black' };
        gameState.board[3][2] = { type: 'å’', color: 'black' };
        gameState.board[3][4] = { type: 'å’', color: 'black' };
        gameState.board[3][6] = { type: 'å’', color: 'black' };
        gameState.board[3][8] = { type: 'å’', color: 'black' };

        // é‡ç½®éŠæˆ²ç‹€æ…‹
        gameState.currentTurn = 'red';
        gameState.gameRecord = [];
        gameState.selectedPiece = null;
        gameState.possibleMoves = [];
        gameState.gameOver = false;
        gameState.checkStatus = null;
        gameState.totalMoves = 0;
        gameState.noCaptureCount = 0;

        // æ¸…ç©º HistoryManager
        if (historyManager) {
            historyManager.clear();
        }

        // æ›´æ–°é¡¯ç¤º
        renderBoard();
        updateMoveDisplay();
    }


    function getCurrentBoardState() {
        console.log("=== æå–ç•¶å‰æ£‹ç›¤ç‹€æ…‹ ===");

        // ç²å–æ‰€æœ‰tile
        const tiles = document.querySelectorAll('.tile');

        // å‰µå»º10x9çš„æ£‹ç›¤ç‹€æ…‹é™£åˆ—
        const board = Array(10).fill().map(() => Array(9).fill(null));

        // æ£‹å­åç¨±æ˜ å°„
        const pieceMapping = {
            // ç´…æ–¹æ£‹å­
            'ä¿¥': { type: 'ä¿¥', color: 'red' },
            'å‚Œ': { type: 'å‚Œ', color: 'red' },
            'ç›¸': { type: 'ç›¸', color: 'red' },
            'ä»•': { type: 'ä»•', color: 'red' },
            'å¸¥': { type: 'å¸¥', color: 'red' },
            'ç‚®': { type: 'ç‚®', color: 'red' },
            'å…µ': { type: 'å…µ', color: 'red' },

            // é»‘æ–¹æ£‹å­
            'è»Š': { type: 'è»Š', color: 'black' },
            'é¦¬': { type: 'é¦¬', color: 'black' },
            'è±¡': { type: 'è±¡', color: 'black' },
            'å£«': { type: 'å£«', color: 'black' },
            'å°‡': { type: 'å°‡', color: 'black' },
            'åŒ…': { type: 'åŒ…', color: 'black' },  // æ³¨æ„ï¼šä½ ç”¨çš„æ˜¯"åŒ…"ä¸æ˜¯"ç ²"
            'å’': { type: 'å’', color: 'black' }
        };

        // éæ­·æ‰€æœ‰tileä¸¦æå–æ£‹å­ä¿¡æ¯
        tiles.forEach((tile, index) => {
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);

            // æª¢æŸ¥é€™å€‹tileæ˜¯å¦æœ‰æ£‹å­
            const piece = tile.querySelector('.chess-piece');

            if (piece) {
                const alt = piece.alt; // å¾altå±¬æ€§ç²å–æ£‹å­åç¨±

                if (pieceMapping[alt]) {
                    board[row][col] = pieceMapping[alt];
                } else {
                    // å¦‚æœæ‰¾ä¸åˆ°æ˜ å°„ï¼Œè¨˜éŒ„åŸå§‹ä¿¡æ¯
                    board[row][col] = {
                        type: alt,
                        color: piece.src.includes('_red') ? 'red' : 'black',
                        unknown: true
                    };
                    console.warn(`æœªçŸ¥æ£‹å­: ${alt}, src: ${piece.src}`);
                }
            }
        });

        console.log('ç•¶å‰æ£‹ç›¤ç‹€æ…‹:');
        console.log(board);

        // ä»¥æ›´ç›´è§€çš„æ–¹å¼é¡¯ç¤ºæ£‹ç›¤
        console.log('\næ£‹ç›¤è¦–è¦ºåŒ–:');
        for (let row = 0; row < 10; row++) {
            let rowStr = `ç¬¬${row}è¡Œ: `;
            for (let col = 0; col < 9; col++) {
                const piece = board[row][col];
                if (piece) {
                    // ç´…æ–¹ç”¨ç´…è‰²æ¨™è¨˜ï¼Œé»‘æ–¹æ­£å¸¸é¡¯ç¤º
                    const display = piece.color === 'red' ? `ç´…${piece.type}` : `é»‘${piece.type}`;
                    rowStr += `[${display}] `;
                } else {
                    rowStr += '[  ] ';
                }
            }
            console.log(rowStr);
        }

        // çµ±è¨ˆæ£‹å­æ•¸é‡
        let redCount = 0, blackCount = 0;
        board.forEach(row => {
            row.forEach(cell => {
                if (cell) {
                    if (cell.color === 'red') redCount++;
                    else if (cell.color === 'black') blackCount++;
                }
            });
        });

        console.log(`\næ£‹å­çµ±è¨ˆ: ç´…æ–¹ ${redCount} å­, é»‘æ–¹ ${blackCount} å­`);

        return board;
    }

    // åŸ·è¡Œä¸¦ç²å–æ£‹ç›¤ç‹€æ…‹
    const currentBoard = getCurrentBoardState();

    // é¡å¤–æä¾›ä¸€å€‹å‡½æ•¸ä¾†æª¢æŸ¥ç‰¹å®šä½ç½®çš„æ£‹å­
    function getPieceAt(row, col) {
        if (currentBoard && currentBoard[row] && currentBoard[row][col]) {
            return currentBoard[row][col];
        }
        return null;
    }

    // æä¾›ä¸€å€‹å‡½æ•¸ä¾†ç²å–æ‰€æœ‰æŸç¨®é¡è‰²çš„æ£‹å­ä½ç½®
    function getPiecesByColor(color) {
        const pieces = [];
        if (currentBoard) {
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = currentBoard[row][col];
                    if (piece && piece.color === color) {
                        pieces.push({
                            type: piece.type,
                            position: [row, col]
                        });
                    }
                }
            }
        }
        return pieces;
    }

    // ä½¿ç”¨ç¤ºä¾‹
    console.log('\nç´…æ–¹æ£‹å­ä½ç½®:', getPiecesByColor('red'));
    console.log('é»‘æ–¹æ£‹å­ä½ç½®:', getPiecesByColor('black'));






    class MoveHistoryManager {
        constructor() {
            this.moveHistory = [];  // å­˜å„²æ‰€æœ‰ç§»å‹•çš„åˆ†æçµæœ
            this.maxHistoryLength = 100;  // æœ€å¤§æ­·å²è¨˜éŒ„é•·åº¦ï¼Œé¿å…å…§å­˜æº¢å‡º
        }

        /**
         * æ·»åŠ ç§»å‹•åˆ°æ­·å²è¨˜éŒ„
         * @param {Object} moveAnalysis - ç§»å‹•åˆ†æçµæœ
         */
        addMove(moveAnalysis) {
            // ç¢ºä¿ç§»å‹•åˆ†æçµæœåŒ…å«å¿…è¦çš„ä¿¡æ¯
            const standardizedMove = {
                moveIndex: moveAnalysis.moveIndex || this.moveHistory.length + 1,
                player: moveAnalysis.player,
                notation: moveAnalysis.notation || '',
                from: moveAnalysis.from ? { ...moveAnalysis.from } : null,
                to: moveAnalysis.to ? { ...moveAnalysis.to } : null,
                piece: moveAnalysis.piece ? { ...moveAnalysis.piece } : null,
                captureInfo: moveAnalysis.captureInfo || [],
                isEscapeMove: moveAnalysis.isEscapeMove || false,
                escapedPieces: moveAnalysis.escapedPieces || [],
                escapeReason: moveAnalysis.escapeReason || '',
                targetConsistency: moveAnalysis.targetConsistency || null,
                timestamp: Date.now(),
                boardState: moveAnalysis.boardState ? this.deepCopyBoard(moveAnalysis.boardState) : null
            };

            this.moveHistory.push(standardizedMove);

            // æ§åˆ¶æ­·å²è¨˜éŒ„é•·åº¦
            if (this.moveHistory.length > this.maxHistoryLength) {
                this.moveHistory.shift();  // ç§»é™¤æœ€èˆŠçš„è¨˜éŒ„
            }

            console.log(`ğŸ“ æ·»åŠ ç§»å‹•åˆ°æ­·å²è¨˜éŒ„: ç¬¬${standardizedMove.moveIndex}æ­¥ ${standardizedMove.player}æ–¹ ${standardizedMove.notation}`);
        }

        /**
         * ç²å–å®Œæ•´çš„ç§»å‹•æ­·å²è¨˜éŒ„
         */
        getHistory() {
            return [...this.moveHistory];  // è¿”å›å‰¯æœ¬é¿å…å¤–éƒ¨ä¿®æ”¹
        }

        /**
         * ç²å–æœ€å¾Œ N æ­¥çš„æ­·å²è¨˜éŒ„
         * @param {number} count - è¦ç²å–çš„æ­¥æ•¸
         */
        getLastMoves(count = 1) {
            if (count <= 0) return [];
            return this.moveHistory.slice(-count);
        }

        /**
         * ç²å–ä¸Šä¸€æ­¥ç§»å‹•ï¼ˆç”¨æ–¼è§£æ‰æª¢æ¸¬ï¼‰
         */
        getPreviousMove() {
            return this.moveHistory.length > 0 ? { ...this.moveHistory[this.moveHistory.length - 1] } : null;
        }

        /**
         * ç²å–æŒ‡å®šç©å®¶çš„ç§»å‹•æ­·å²
         * @param {string} player - 'red' æˆ– 'black'
         * @param {number} lastN - ç²å–æœ€å¾ŒNæ­¥ï¼Œä¸æŒ‡å®šå‰‡ç²å–å…¨éƒ¨
         */
        getPlayerMoves(player, lastN = null) {
            const playerMoves = this.moveHistory.filter(move => move.player === player);
            return lastN ? playerMoves.slice(-lastN) : playerMoves;
        }

        /**
         * ç²å–å°æ‰‹æœ€å¾Œä¸€æ­¥ç§»å‹•ï¼ˆç”¨æ–¼è§£æ‰æª¢æ¸¬ï¼‰
         * @param {string} currentPlayer - ç•¶å‰ç©å®¶ 'red' æˆ– 'black'
         */
        getLastOpponentMove(currentPlayer) {
            const opponent = currentPlayer === 'red' ? 'black' : 'red';
            const opponentMoves = this.getPlayerMoves(opponent);
            return opponentMoves.length > 0 ? opponentMoves[opponentMoves.length - 1] : null;
        }

        /**
         * æª¢æŸ¥æ˜¯å¦éœ€è¦é€²è¡Œè§£æ‰æª¢æ¸¬
         * @param {string} currentPlayer - ç•¶å‰ç©å®¶
         */
        shouldCheckEscape(currentPlayer) {
            const lastOpponentMove = this.getLastOpponentMove(currentPlayer);

            if (!lastOpponentMove) {
                return {
                    shouldCheck: false,
                    reason: 'æ²’æœ‰å°æ‰‹ç§»å‹•è¨˜éŒ„'
                };
            }

            if (!lastOpponentMove.captureInfo || lastOpponentMove.captureInfo.length === 0) {
                return {
                    shouldCheck: false,
                    reason: 'å°æ‰‹ä¸Šä¸€æ­¥æ²’æœ‰æ‰å­å‹•ä½œ'
                };
            }

            // æª¢æŸ¥å°æ‰‹æ˜¯å¦æ‰åˆ°äº†ç•¶å‰ç©å®¶çš„æ£‹å­
            const capturedCurrentPlayerPieces = lastOpponentMove.captureInfo.filter(
                capture => capture.target && capture.target.color === currentPlayer
            );

            if (capturedCurrentPlayerPieces.length === 0) {
                return {
                    shouldCheck: false,
                    reason: 'å°æ‰‹æ²’æœ‰æ‰åˆ°å·±æ–¹æ£‹å­'
                };
            }

            return {
                shouldCheck: true,
                reason: `å°æ‰‹ä¸Šä¸€æ­¥æ‰åˆ°${capturedCurrentPlayerPieces.length}å€‹å·±æ–¹æ£‹å­`,
                capturedPieces: capturedCurrentPlayerPieces,
                opponentMove: lastOpponentMove
            };
        }

        /**
         * æ¸…ç©ºæ­·å²è¨˜éŒ„
         */
        clear() {
            this.moveHistory = [];
            console.log('ğŸ—‘ï¸ æ¸…ç©ºç§»å‹•æ­·å²è¨˜éŒ„');
        }

        /**
         * ç²å–æ­·å²è¨˜éŒ„çµ±è¨ˆä¿¡æ¯
         */
        getStats() {
            const totalMoves = this.moveHistory.length;
            const redMoves = this.moveHistory.filter(move => move.player === 'red').length;
            const blackMoves = this.moveHistory.filter(move => move.player === 'black').length;
            const capturesMoves = this.moveHistory.filter(move => move.captureInfo && move.captureInfo.length > 0).length;
            const escapeMoves = this.moveHistory.filter(move => move.isEscapeMove).length;

            return {
                totalMoves,
                redMoves,
                blackMoves,
                capturesMoves,
                escapeMoves,
                captureRate: totalMoves > 0 ? (capturesMoves / totalMoves * 100).toFixed(1) : 0,
                escapeRate: capturesMoves > 0 ? (escapeMoves / capturesMoves * 100).toFixed(1) : 0
            };
        }

        /**
         * æ·±æ‹·è²æ£‹ç›¤ç‹€æ…‹
         */
        deepCopyBoard(board) {
            if (!board || !Array.isArray(board)) return null;

            return board.map(row => {
                if (!Array.isArray(row)) return row;
                return row.map(cell => {
                    if (!cell) return cell;
                    return {
                        type: cell.type,
                        color: cell.color,
                        moved: cell.moved
                    };
                });
            });
        }
    }

    class HistoryManager {
        constructor() {
            this.history = [];
            this.currentIndex = -1;
        }

        addState(gameState) {
            if (this.currentIndex < this.history.length - 1) {
                this.history = this.history.slice(0, this.currentIndex + 1);
            }
            this.history.push(JSON.parse(JSON.stringify(gameState)));
            this.currentIndex++;
        }

        canUndo() {
            return this.currentIndex > 0;
        }
        // ç¢ºä¿æœ‰é€™å€‹æ–¹æ³•
        getHistory() {
            return this.history;
        }

        getHistoryLength() {
            return this.history.length;
        }

        redo() {
            if (this.canRedo()) {
                this.currentIndex++;
                return JSON.parse(JSON.stringify(this.history[this.currentIndex]));
            }
            return null;
        }

        undo() {
            if (this.canUndo()) {
                this.currentIndex--;
                return JSON.parse(JSON.stringify(this.history[this.currentIndex]));
            }
            return null;
        }

        canRedo() {
            return this.currentIndex < this.history.length - 1;
        }



        clear() {
            this.history = [];
            this.currentIndex = -1;
        }
    }

    // æ–¹æ³•2ï¼šç«‹å³ä½¿ç”¨è®Šé‡
    const historyManager = new HistoryManager();
    console.log('History manager initialized:', historyManager);

    class BoardHistoryManager {
        constructor() {
            this.history = [];
            this.currentIndex = -1;
        }

        // ç²å–å®Œæ•´æ­·å²
        getHistory() {
            return this.history;
        }

        // ç²å–æ­·å²é•·åº¦
        getHistoryLength() {
            return this.history.length;
        }



        // æ¸…ç©ºæ­·å²
        clear() {
            this.history = [];
            this.currentIndex = -1;
        }


    }

    class NotationCycleDetector {
        constructor(historyManager, gameState) {
            this.historyManager = historyManager;
            this.gameState = gameState;  // ä¿å­˜æ•´å€‹ gameState


            // Properties from first version
            this.cycleThreshold = 3; // å¾ªç¯3æ¬¡åˆ¤å’Œ/åˆ¤è´Ÿ
            this.warningThreshold = 2; // å¾ªç¯2æ¬¡æé†’
            this.minCycleLength = 2;  // æœ€å°å¾ªç¯é•¿åº¦ï¼ˆä¸€æ¥ä¸€å›ï¼‰
            this.maxCycleLength = 20; // æœ€å¤§å¾ªç¯é•¿åº¦
            this.warningShown = false; // æ˜¯å¦å·²ç»æ˜¾ç¤ºè¿‡è­¦å‘Š
            this.warningPattern = null; // è­¦å‘Šæ—¶çš„å¾ªç¯æ¨¡å¼
            this.lastWarningCycle = null; // ä¸Šæ¬¡è­¦å‘Šçš„å¾ªç¯ä¿¡æ¯

            // é•¿å°†æ£€æµ‹ç›¸å…³å±æ€§
            this.checkDetectionEnabled = true; // æ˜¯å¦å¯ç”¨é•¿å°†æ£€æµ‹
            this.perpetualCheckThreshold = 3; // é•¿å°†åˆ¤è´Ÿé˜ˆå€¼

            // ==================== ğŸ†• ç§»å‹•åˆ†æç³»çµ± ====================
            // ç•¶å‰ç§»å‹•åˆ†æ
            this.moveAnalysis = null;

            // ä¸Šä¸€æ­¥ç§»å‹•åˆ†æ (å¤šå€‹è®Šé‡åæ”¯æ´ä¸åŒçš„èª¿ç”¨æ–¹å¼)
            this.lastAnalysis = null;
            this.previousAnalysis = null;
            this.lastMoveAnalysis = null;

            // åˆ†ææ­·å²è¨˜éŒ„
            this.analysisHistory = [];

            // åˆ†æé…ç½®
            this.analysisConfig = {
                enableThreatDetection: true,
                enableOpportunityDetection: true,
                enableScoreCalculation: true,
                enableChaseAnalysis: true,
                maxHistorySize: 50,
                debugMode: true
            };

            // æ–°å¢æ£‹ç›¤æ˜ å°„è¡¨ç›¸é—œå±¬æ€§
            this.positionMap = new Map(); // key: "row,col", value: {type, color, id}
            this.pieceMap = new Map(); // key: pieceId, value: {type, color, row, col, moveHistory}
            this.pieceIdCounter = 0;
            this.redPieces = new Set();
            this.blackPieces = new Set();

            this.gameState = null;
            this.boardHistory = [];
            this.ruleResults = new Map();

            console.log('ğŸ¯ è±¡æ£‹è§£æ‰ç³»çµ±åˆå§‹åŒ–å®Œæˆ - åŒ…å«ç§»å‹•åˆ†æåŠŸèƒ½');
        }

// ==================== ğŸ“Š ç§»å‹•åˆ†ææ–¹æ³• ====================
// æ·»åŠ é€™äº›æ–¹æ³•åˆ°ä½ çš„é¡ä¸­


        createAnalysisObject(move = null, board = null) {
            if (!board) board = this.gameState.board;

            const analysis = {
                moveIndex: move ? move.moveIndex : (this.historyManager ? this.historyManager.getCurrentMoveIndex() : 0),
                player: move ? move.player : null,
                timestamp: new Date().toISOString(),
                score: 0,
                evaluation: 'æœªåˆ†æ',
                confidence: 0,
                threats: [],
                opportunities: [],
                suggestions: [],
                chaseAnalysis: {
                    isChasing: false,
                    chasedPieces: [],
                    escapeRoutes: [],
                    chaseType: null,
                    chaseLevel: 0
                },
                beingChasedAnalysis: {
                    isBeingChased: false,
                    chasingPieces: [],
                    safeSquares: [],
                    mustMove: false,
                    dangerLevel: 0
                },
                cycleAnalysis: {
                    inCycle: false,
                    cycleLength: 0,
                    cycleCount: 0,
                    cyclePattern: null,
                    isWarningCycle: false
                },
                perpetualCheckAnalysis: {
                    inPerpetualCheck: false,
                    checkCount: 0,
                    isIllegal: false
                },
                positionAnalysis: {
                    materialBalance: 0,
                    territoryControl: 0,
                    kingSafety: 0,
                    pieceActivity: 0
                },
                errors: [],
                warnings: []
            };

            return analysis;  // é€™è£¡æ”¹æˆå›å‚³ analysises
        }

// åˆ†æç§»å‹• (ä¸»è¦çš„åˆ†æå…¥å£)
        analyzeMove(move, board, gameState = null) {
            if (this.analysisConfig.debugMode) {
                console.log('ğŸ” é–‹å§‹åˆ†æç§»å‹•:', move);
            }

            try {
                // ä¿å­˜ä¸Šä¸€å€‹åˆ†æ
                this.saveCurrentAnalysisAsLast();

                const analysis = this.createAnalysisObject(move, gameState.board);

                // åŸ·è¡Œå„ç¨®åˆ†æ
                if (this.analysisConfig.enableThreatDetection) {
                    this.analyzeThreat(analysis, move, board);
                }

                if (this.analysisConfig.enableChaseAnalysis) {
                    this.analyzeChase(analysis, move, board);
                }

                // åˆ†æå¾ªç’° (åˆ©ç”¨ç¾æœ‰çš„å¾ªç’°æª¢æ¸¬)
                this.analyzeCycle(analysis, move);

                // åˆ†æé•·å°‡ (åˆ©ç”¨ç¾æœ‰çš„é•·å°‡æª¢æ¸¬)
                this.analyzePerpetualCheck(analysis, move);

                // è¨ˆç®—ç¸½é«”è©•ä¼°
                this.calculateOverallEvaluation(analysis);

                // è¨­ç½®ç•¶å‰åˆ†æ
                this.moveAnalysis = analysis;

                // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„
                this.addAnalysisToHistory(analysis);

                if (this.analysisConfig.debugMode) {
                    console.log('âœ… ç§»å‹•åˆ†æå®Œæˆ:', analysis.evaluation);
                }

                return analysis;

            } catch (error) {
                console.error('âŒ ç§»å‹•åˆ†æç™¼ç”ŸéŒ¯èª¤:', error);

                const errorAnalysis = this.createAnalysisObject(move, board);
                errorAnalysis.evaluation = 'åˆ†æéŒ¯èª¤';
                errorAnalysis.errors.push(error.message);

                this.moveAnalysis = errorAnalysis;
                return errorAnalysis;
            }
        }
        /**
         * åˆå§‹åŒ–æ£‹ç›¤æ˜ å°„è¡¨
         * @param {Array} board - äºŒç¶­æ£‹ç›¤é™£åˆ—
         */
        initializeBoardMapping(board) {
            this.clearBoardMapping();

            for (let row = 0; row < board.length; row++) {
                if (!board[row]) continue;

                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type) {
                        this.addPieceToMapping(piece.type, piece.color, row, col);
                    }
                }
            }

            console.log('âœ… NotationCycleDetector æ£‹ç›¤æ˜ å°„è¡¨åˆå§‹åŒ–å®Œæˆ');
            this.debugMappingState();
        }

        /**
         * æ·»åŠ æ£‹å­åˆ°æ˜ å°„è¡¨
         * @param {string} type - æ£‹å­é¡å‹
         * @param {string} color - æ£‹å­é¡è‰²
         * @param {number} row - è¡Œä½ç½®
         * @param {number} col - åˆ—ä½ç½®
         * @returns {string} æ£‹å­ID
         */
        addPieceToMapping(type, color, row, col) {
            const pieceId = `${color}_${type}_${this.pieceIdCounter++}`;
            const posKey = `${row},${col}`;

            // æª¢æŸ¥ä½ç½®æ˜¯å¦å·²è¢«ä½”ç”¨
            if (this.positionMap.has(posKey)) {
                console.warn(`âš ï¸ ä½ç½® (${row},${col}) å·²è¢«ä½”ç”¨ï¼Œå°‡è¦†è“‹åŸæ£‹å­`);
            }

            // å‰µå»ºæ£‹å­å°è±¡
            const pieceObj = {
                id: pieceId,
                type: type,
                color: color,
                row: row,
                col: col,
                moveHistory: [`${row},${col}`] // è¨˜éŒ„ç§»å‹•æ­·å²
            };

            // æ›´æ–°æ˜ å°„è¡¨
            this.positionMap.set(posKey, {type, color, id: pieceId});
            this.pieceMap.set(pieceId, pieceObj);

            // æ·»åŠ åˆ°é¡è‰²åˆ†é¡
            if (color === 'red') {
                this.redPieces.add(pieceId);
            } else if (color === 'black') {
                this.blackPieces.add(pieceId);
            }

            return pieceId;
        }

        /**
         * ç§»å‹•æ£‹å­ï¼ˆæ›´æ–°æ˜ å°„è¡¨ï¼‰
         * @param {number} fromRow - èµ·å§‹è¡Œ
         * @param {number} fromCol - èµ·å§‹åˆ—
         * @param {number} toRow - ç›®æ¨™è¡Œ
         * @param {number} toCol - ç›®æ¨™åˆ—
         * @returns {Object} ç§»å‹•çµæœ {success: boolean, movedPieceId: string, capturedPieceId: string}
         */
        movePieceInMapping(fromRow, fromCol, toRow, toCol) {
            const fromKey = `${fromRow},${fromCol}`;
            const toKey = `${toRow},${toCol}`;

            // æª¢æŸ¥èµ·å§‹ä½ç½®æ˜¯å¦æœ‰æ£‹å­
            const fromPiece = this.positionMap.get(fromKey);
            if (!fromPiece) {
                console.error(`âŒ ä½ç½® (${fromRow},${fromCol}) æ²’æœ‰æ£‹å­`);
                return {success: false, movedPieceId: null, capturedPieceId: null};
            }

            // æª¢æŸ¥ç›®æ¨™ä½ç½®æ˜¯å¦æœ‰æ£‹å­ï¼ˆåƒå­æƒ…æ³ï¼‰
            const toPiece = this.positionMap.get(toKey);
            let capturedPieceId = null;

            if (toPiece) {
                // è™•ç†åƒå­
                capturedPieceId = toPiece.id;
                this.removePieceFromMapping(toRow, toCol);
            }

            // ç§»å‹•æ£‹å­
            const pieceData = this.pieceMap.get(fromPiece.id);
            pieceData.row = toRow;
            pieceData.col = toCol;
            pieceData.moveHistory.push(toKey);

            // æ›´æ–°ä½ç½®æ˜ å°„
            this.positionMap.delete(fromKey);
            this.positionMap.set(toKey, fromPiece);

            console.log(`ğŸ“ æ£‹å­ ${fromPiece.type}(${fromPiece.id}) å¾ (${fromRow},${fromCol}) ç§»å‹•åˆ° (${toRow},${toCol})`);

            return {
                success: true,
                movedPieceId: fromPiece.id,
                capturedPieceId: capturedPieceId
            };
        }

        /**
         * å¾æ˜ å°„è¡¨ä¸­ç§»é™¤æ£‹å­
         * @param {number} row - è¡Œä½ç½®
         * @param {number} col - åˆ—ä½ç½®
         * @returns {string|null} è¢«ç§»é™¤çš„æ£‹å­ID
         */
        removePieceFromMapping(row, col) {
            const posKey = `${row},${col}`;
            const piece = this.positionMap.get(posKey);

            if (!piece) {
                return null;
            }

            // å¾æ‰€æœ‰æ˜ å°„è¡¨ä¸­ç§»é™¤
            this.positionMap.delete(posKey);
            this.pieceMap.delete(piece.id);
            this.redPieces.delete(piece.id);
            this.blackPieces.delete(piece.id);

            console.log(`ğŸ—‘ï¸ ç§»é™¤æ£‹å­ ${piece.type}(${piece.id}) åœ¨ä½ç½® (${row},${col})`);
            return piece.id;
        }

        /**
         * ç²å–æŒ‡å®šä½ç½®çš„æ£‹å­ä¿¡æ¯
         * @param {number} row - è¡Œä½ç½®
         * @param {number} col - åˆ—ä½ç½®
         * @returns {Object|null} æ£‹å­ä¿¡æ¯
         */


        /**
         * æ ¹æ“šæ£‹å­IDç²å–æ£‹å­ä¿¡æ¯
         * @param {string} pieceId - æ£‹å­ID
         * @returns {Object|null} æ£‹å­ä¿¡æ¯
         */
        getPieceById(pieceId) {
            return this.pieceMap.get(pieceId) || null;
        }

        /**
         * ç²å–æŒ‡å®šé¡è‰²çš„æ‰€æœ‰æ£‹å­
         * @param {string} color - é¡è‰² ('red' æˆ– 'black')
         * @returns {Array} æ£‹å­ä¿¡æ¯æ•¸çµ„
         */
        getPiecesByColor(color) {
            const pieceSet = color === 'red' ? this.redPieces : this.blackPieces;
            return Array.from(pieceSet).map(id => this.pieceMap.get(id)).filter(piece => piece);
        }

        /**
         * æª¢æŸ¥æ˜¯å¦æœ‰å¯éæ²³æ£‹å­ï¼ˆç”¨æ–¼å’Œæ£‹åˆ¤å®šï¼‰
         * @returns {Object} {red: boolean, black: boolean}
         */
        checkCrossRiverPieces() {
            const result = {red: false, black: false};

            // æª¢æŸ¥ç´…æ–¹æ˜¯å¦æœ‰æ£‹å­å¯ä»¥éæ²³ï¼ˆå¾6-10è¡Œåˆ°0-4è¡Œï¼‰
            const redPieces = this.getPiecesByColor('red');
            for (const piece of redPieces) {
                if (piece.row >= 5) { // ç´…æ–¹åœ¨è‡ªå·±åŠå ´
                    // é€™è£¡éœ€è¦çµåˆå…·é«”çš„ç§»å‹•è¦å‰‡ä¾†åˆ¤æ–·æ˜¯å¦èƒ½éæ²³
                    // ç°¡åŒ–ç‰ˆæœ¬ï¼šå‡è¨­æ‰€æœ‰åœ¨è‡ªå·±åŠå ´çš„æ£‹å­éƒ½æœ‰å¯èƒ½éæ²³
                    result.red = true;
                    break;
                }
            }

            // æª¢æŸ¥é»‘æ–¹æ˜¯å¦æœ‰æ£‹å­å¯ä»¥éæ²³ï¼ˆå¾0-4è¡Œåˆ°6-10è¡Œï¼‰
            const blackPieces = this.getPiecesByColor('black');
            for (const piece of blackPieces) {
                if (piece.row <= 4) { // é»‘æ–¹åœ¨è‡ªå·±åŠå ´
                    result.black = true;
                    break;
                }
            }

            return result;
        }

        /**
         * æ ¹æ“šæ£‹è­œè¨˜è™Ÿæ‰¾å‡ºå°æ‡‰çš„æ£‹å­ID
         * @param {string} notation - æ£‹è­œè¨˜è™Ÿï¼Œå¦‚ "ç‚®8å¹³9"
         * @param {string} color - ç•¶å‰ç§»å‹•æ–¹é¡è‰²
         * @returns {string|null} æ£‹å­ID
         */
        findPieceByNotation(notation, color) {
            // è§£ææ£‹è­œè¨˜è™Ÿ
            const pieceType = notation[0];
            const fromCol = parseInt(notation[1]) - 1; // è½‰æ›ç‚º0-basedç´¢å¼•

            // æ‰¾å‡ºè©²åˆ—ä¸ŠæŒ‡å®šé¡å‹å’Œé¡è‰²çš„æ£‹å­
            const candidates = [];

            for (const [posKey, piece] of this.positionMap) {
                if (piece.type === pieceType && piece.color === color) {
                    const [row, col] = posKey.split(',').map(Number);
                    if (col === fromCol) {
                        candidates.push({
                            id: piece.id,
                            row: row,
                            col: col
                        });
                    }
                }
            }

            if (candidates.length === 1) {
                return candidates[0].id;
            } else if (candidates.length > 1) {
                // å¦‚æœæœ‰å¤šå€‹å€™é¸ï¼Œéœ€è¦é¡å¤–çš„å‰/å¾Œæ¨™è­˜ä¾†å€åˆ†
                // é€™è£¡éœ€è¦æ ¹æ“šä½ çš„æ£‹è­œæ ¼å¼ä¾†é€²ä¸€æ­¥è§£æ
                console.warn(`âš ï¸ ç™¼ç¾å¤šå€‹ç¬¦åˆæ¢ä»¶çš„ ${pieceType}ï¼Œéœ€è¦é¡å¤–åˆ¤æ–·`);
                return candidates[0].id; // æš«æ™‚è¿”å›ç¬¬ä¸€å€‹
            }

            return null;
        }

        /**
         * æ¸…ç©ºæ‰€æœ‰æ˜ å°„è¡¨
         */
        clearBoardMapping() {
            this.positionMap.clear();
            this.pieceMap.clear();
            this.redPieces.clear();
            this.blackPieces.clear();
            this.pieceIdCounter = 0;
        }

        /**
         * èª¿è©¦æ˜ å°„è¡¨ç‹€æ…‹
         */
        debugMappingState() {
            console.log('ğŸ—ºï¸ æ£‹ç›¤æ˜ å°„è¡¨ç‹€æ…‹:');
            console.log(`ç¸½æ£‹å­æ•¸: ${this.pieceMap.size}`);
            console.log(`ç´…æ–¹æ£‹å­: ${this.redPieces.size} å€‹`);
            console.log(`é»‘æ–¹æ£‹å­: ${this.blackPieces.size} å€‹`);

            // æŒ‰ä½ç½®æ’åºé¡¯ç¤º
            const positions = Array.from(this.positionMap.keys()).sort();
            for (const posKey of positions) {
                const piece = this.positionMap.get(posKey);
                const [row, col] = posKey.split(',');
                console.log(`  ä½ç½®(${row},${col}): ${piece.color} ${piece.type} [${piece.id}]`);
            }
        }
// ä¿å­˜ç•¶å‰åˆ†æç‚ºä¸Šä¸€å€‹åˆ†æ
        saveCurrentAnalysisAsLast() {
            if (this.moveAnalysis) {
                // å‰µå»ºæ·±æ‹·è²é¿å…å¼•ç”¨å•é¡Œ
                const lastAnalysis = JSON.parse(JSON.stringify(this.moveAnalysis));

                this.lastAnalysis = lastAnalysis;
                this.previousAnalysis = lastAnalysis;
                this.lastMoveAnalysis = lastAnalysis;

                if (this.analysisConfig.debugMode) {
                    console.log('ğŸ’¾ å·²ä¿å­˜ä¸Šä¸€æ­¥åˆ†æ');
                }
            }
        }

// å¨è„…åˆ†æ
        analyzeThreat(analysis, move, board) {
            try {
                // é€™è£¡å¯ä»¥æ•´åˆä½ ç¾æœ‰çš„æ‰å­æª¢æ¸¬é‚è¼¯
                // æš«æ™‚æä¾›åŸºæœ¬çµæ§‹ï¼Œä½ éœ€è¦æ ¹æ“šå¯¦éš›çš„è§£æ‰ç®—æ³•å¡«å……

                analysis.threats = []; // ç”±ä½ çš„å¨è„…æª¢æ¸¬ç®—æ³•å¡«å……

                if (analysis.threats.length > 0) {
                    analysis.chaseAnalysis.isChasing = true;
                    analysis.chaseAnalysis.chasedPieces = analysis.threats.map(t => t.targetPiece);
                }

            } catch (error) {
                analysis.errors.push(`å¨è„…åˆ†æéŒ¯èª¤: ${error.message}`);
            }
        }

// æ‰å­åˆ†æ (æ•´åˆåˆ°è§£æ‰ç³»çµ±)
        analyzeChase(analysis, move, board) {
            try {
                // é€™è£¡æ•´åˆä½ ç¾æœ‰çš„è§£æ‰é‚è¼¯
                // ä½ å¯ä»¥èª¿ç”¨ç¾æœ‰çš„è§£æ‰æ–¹æ³•ä¸¦å°‡çµæœæ•´åˆåˆ° analysis ä¸­

                // ç¤ºä¾‹ï¼šæª¢æŸ¥æ˜¯å¦åœ¨æ‰å­
                // const chaseResult = this.checkChase(move, board);
                // analysis.chaseAnalysis = { ...analysis.chaseAnalysis, ...chaseResult };

            } catch (error) {
                analysis.errors.push(`æ‰å­åˆ†æéŒ¯èª¤: ${error.message}`);
            }
        }

// å¾ªç’°åˆ†æ (æ•´åˆç¾æœ‰å¾ªç’°æª¢æ¸¬)
        analyzeCycle(analysis, move) {
            try {
                // æ•´åˆä½ ç¾æœ‰çš„å¾ªç’°æª¢æ¸¬é‚è¼¯
                analysis.cycleAnalysis.inCycle = this.warningShown;
                analysis.cycleAnalysis.isWarningCycle = this.warningShown;

                if (this.warningPattern) {
                    analysis.cycleAnalysis.cyclePattern = this.warningPattern;
                    analysis.cycleAnalysis.cycleLength = this.warningPattern.length || 0;
                }

            } catch (error) {
                analysis.errors.push(`å¾ªç’°åˆ†æéŒ¯èª¤: ${error.message}`);
            }
        }

// é•·å°‡åˆ†æ (æ•´åˆç¾æœ‰é•·å°‡æª¢æ¸¬)
        analyzePerpetualCheck(analysis, move) {
            try {
                // æ•´åˆä½ ç¾æœ‰çš„é•·å°‡æª¢æ¸¬é‚è¼¯
                if (this.checkDetectionEnabled) {
                    // é€™è£¡å¯ä»¥èª¿ç”¨ä½ ç¾æœ‰çš„é•·å°‡æª¢æ¸¬æ–¹æ³•
                    // const perpetualResult = this.checkPerpetualCheck(move);
                    // analysis.perpetualCheckAnalysis = { ...analysis.perpetualCheckAnalysis, ...perpetualResult };
                }

            } catch (error) {
                analysis.errors.push(`é•·å°‡åˆ†æéŒ¯èª¤: ${error.message}`);
            }
        }

// è¨ˆç®—ç¸½é«”è©•ä¼°
        calculateOverallEvaluation(analysis) {
            try {
                let score = 0;
                let evaluation = 'æ™®é€š';

                // æ ¹æ“šå„ç¨®åˆ†æçµæœè¨ˆç®—åˆ†æ•¸
                if (analysis.chaseAnalysis.isChasing) {
                    score += 20;
                    evaluation = 'é€²æ”»';
                }

                if (analysis.beingChasedAnalysis.isBeingChased) {
                    score -= 30;
                    evaluation = 'é˜²å®ˆ';
                }

                if (analysis.cycleAnalysis.inCycle) {
                    score -= 10;
                    evaluation = 'é‡è¤‡';
                }

                if (analysis.perpetualCheckAnalysis.inPerpetualCheck) {
                    score -= 50;
                    evaluation = 'é•è¦';
                }

                // æ ¹æ“šéŒ¯èª¤å’Œè­¦å‘Šèª¿æ•´
                score -= analysis.errors.length * 10;
                score -= analysis.warnings.length * 5;

                analysis.score = score;
                analysis.evaluation = evaluation;
                analysis.confidence = Math.max(0, Math.min(100, 50 + Math.abs(score)));

            } catch (error) {
                analysis.errors.push(`ç¸½é«”è©•ä¼°éŒ¯èª¤: ${error.message}`);
                analysis.evaluation = 'æœªçŸ¥';
            }
        }

// æ·»åŠ åˆ†æåˆ°æ­·å²è¨˜éŒ„
        addAnalysisToHistory(analysis) {
            this.analysisHistory.push({...analysis});

            // é™åˆ¶æ­·å²è¨˜éŒ„å¤§å°
            if (this.analysisHistory.length > this.analysisConfig.maxHistorySize) {
                this.analysisHistory.shift();
            }
        }

// ç²å–ç•¶å‰åˆ†æ
        getCurrentAnalysis() {
            return this.moveAnalysis;
        }

// ç²å–ä¸Šä¸€æ­¥åˆ†æ
        getLastAnalysis() {
            return this.lastAnalysis || this.previousAnalysis || this.lastMoveAnalysis;
        }

// é‡ç½®åˆ†æç³»çµ±
        resetAnalysis() {
            this.moveAnalysis = null;
            this.lastAnalysis = null;
            this.previousAnalysis = null;
            this.lastMoveAnalysis = null;
            this.analysisHistory = [];

            if (this.analysisConfig.debugMode) {
                console.log('ğŸ”„ ç§»å‹•åˆ†æç³»çµ±å·²é‡ç½®');
            }
        }

        // Methods from first version
        // æ·±æ‹·è²æ£‹å­
        deepCopyPiece(piece) {
            if (!piece) return null;
            return {
                type: piece.type,
                color: piece.color,
                moved: piece.moved || false
            };
        }

        // æ·±æ‹·è²æ£‹ç›¤
        deepCopyBoard(board) {
            return board.map(row =>
                row.map(cell =>
                    cell ? this.deepCopyPiece(cell) : null
                )
            );
        }



        // ã€ç°¡åŒ–ç‰ˆæœ¬ã€‘ç›´æ¥åˆ©ç”¨ç¾æœ‰è™›æ“¬æ£‹ç›¤çš„ç„¡å¯éæ²³æ£‹å­æª¢æ¸¬å™¨
// ğŸ¯ ç­–ç•¥ï¼šæ—¢ç„¶è§£æ‰ç³»çµ±çš„è™›æ“¬æ£‹ç›¤å·²ç¶“æ­£ç¢ºè¿½è¹¤ï¼Œç›´æ¥ä½¿ç”¨å®ƒçš„çµæœ
        analyzeInsufficientMatingMaterial(board, gameHistory = null) {
            console.log(`\nğŸ¯ é–‹å§‹æª¢æ¸¬é›™æ–¹ç„¡å¯éæ²³æ£‹å­ç‹€æ³ï¼ˆåˆ©ç”¨ç¾æœ‰è™›æ“¬æ£‹ç›¤ï¼‰...`);

            // ã€å®šç¾©ã€‘å¯ä»¥éæ²³æ”»æ“Šçš„æ£‹å­é¡å‹ï¼ˆè»Šé¦¬ç‚®å…µï¼‰
            const offensivePieceTypes = {
                // ç´…æ–¹å¯éæ²³æ£‹å­
                red: ['ä¿¥', 'å‚Œ', 'ç‚®', 'å…µ'],
                // é»‘æ–¹å¯éæ²³æ£‹å­
                black: ['è»Š', 'é¦¬', 'åŒ…', 'å’']
            };

            // ã€æ ¸å¿ƒç­–ç•¥ã€‘ç›´æ¥å¾ç•¶å‰æ£‹ç›¤ç‹€æ…‹åˆ†æ
            function analyzeCurrentBoardState(currentBoard) {
                console.log('ğŸ“Š åˆ†æç•¶å‰æ£‹ç›¤ç‹€æ…‹ä¸­çš„æ£‹å­é¡å‹...');

                const pieceStats = {
                    red: { offensive: new Map(), defensive: new Map() },
                    black: { offensive: new Map(), defensive: new Map() }
                };

                if (!currentBoard || !Array.isArray(currentBoard)) {
                    console.warn('âš ï¸ ç•¶å‰æ£‹ç›¤ç„¡æ•ˆ');
                    return pieceStats;
                }

                // éæ­·æ•´å€‹æ£‹ç›¤çµ±è¨ˆæ£‹å­
                for (let row = 0; row < currentBoard.length; row++) {
                    if (!currentBoard[row] || !Array.isArray(currentBoard[row])) continue;

                    for (let col = 0; col < currentBoard[row].length; col++) {
                        const piece = currentBoard[row][col];
                        if (!piece || !piece.type || !piece.color) continue;

                        const { color, type } = piece;

                        // åˆ¤æ–·æ˜¯æ”»æ“Šæ€§é‚„æ˜¯é˜²ç¦¦æ€§æ£‹å­
                        const isOffensive = offensivePieceTypes[color] && offensivePieceTypes[color].includes(type);
                        const category = isOffensive ? 'offensive' : 'defensive';
                        const stats = pieceStats[color][category];

                        // çµ±è¨ˆæ•¸é‡
                        stats.set(type, (stats.get(type) || 0) + 1);

                        console.log(`   ç™¼ç¾æ£‹å­: (${row},${col}) ${color} ${type} - ${category}`);
                    }
                }

                return pieceStats;
            }

            // ã€è¼¸å‡ºçµ±è¨ˆä¿¡æ¯ã€‘
            function logPieceStats(stats) {
                console.log('\nğŸ“Š ç•¶å‰æ£‹ç›¤æ£‹å­é¡å‹çµ±è¨ˆ:');

                ['red', 'black'].forEach(color => {
                    const colorName = color === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
                    const offensive = stats[color].offensive;
                    const defensive = stats[color].defensive;

                    console.log(`   ${colorName}:`);

                    if (offensive.size > 0) {
                        const offensiveList = Array.from(offensive.entries())
                            .map(([type, count]) => `${type}Ã—${count}`)
                            .join(', ');
                        console.log(`      æ”»æ“Šæ€§: ${offensiveList}`);
                    } else {
                        console.log(`      æ”»æ“Šæ€§: ç„¡`);
                    }

                    if (defensive.size > 0) {
                        const defensiveList = Array.from(defensive.entries())
                            .map(([type, count]) => `${type}Ã—${count}`)
                            .join(', ');
                        console.log(`      é˜²ç¦¦æ€§: ${defensiveList}`);
                    } else {
                        console.log(`      é˜²ç¦¦æ€§: ç„¡`);
                    }
                });
            }

            // ã€è¨ˆç®—çµ±è¨ˆæ‘˜è¦ã€‘
            function calculateStatsSummary(stats) {
                return {
                    red: {
                        offensiveCount: Array.from(stats.red.offensive.values()).reduce((sum, count) => sum + count, 0),
                        defensiveCount: Array.from(stats.red.defensive.values()).reduce((sum, count) => sum + count, 0),
                        offensiveTypes: Object.fromEntries(stats.red.offensive),
                        defensiveTypes: Object.fromEntries(stats.red.defensive)
                    },
                    black: {
                        offensiveCount: Array.from(stats.black.offensive.values()).reduce((sum, count) => sum + count, 0),
                        defensiveCount: Array.from(stats.black.defensive.values()).reduce((sum, count) => sum + count, 0),
                        offensiveTypes: Object.fromEntries(stats.black.offensive),
                        defensiveTypes: Object.fromEntries(stats.black.defensive)
                    }
                };
            }

            // ã€ä¸»è¦åŸ·è¡Œæµç¨‹ã€‘
            console.log(`\nğŸ¯ åŸ·è¡Œç°¡åŒ–ç‰ˆé›™æ–¹ç„¡å¯éæ²³æ£‹å­æª¢æ¸¬...`);

            // 1. å„ªå…ˆä½¿ç”¨å‚³å…¥çš„ç•¶å‰æ£‹ç›¤ç‹€æ…‹
            let effectiveBoard = board;
            let dataSource = 'current_board';

            // 2. å¦‚æœæœ‰è™›æ“¬æ£‹ç›¤ç³»çµ±ï¼Œå˜—è©¦ç²å–å…¶ç‹€æ…‹
            if (typeof this !== 'undefined' && this.getCurrentBoardArray) {
                try {
                    const virtualBoard = this.getCurrentBoardArray();
                    if (virtualBoard && Array.isArray(virtualBoard)) {
                        effectiveBoard = virtualBoard;
                        dataSource = 'virtual_board';
                        console.log('âœ… ä½¿ç”¨è™›æ“¬æ£‹ç›¤ç³»çµ±çš„ç•¶å‰ç‹€æ…‹');
                    }
                } catch (error) {
                    console.log('âš ï¸ ç„¡æ³•ç²å–è™›æ“¬æ£‹ç›¤ç‹€æ…‹ï¼Œä½¿ç”¨å‚³å…¥æ£‹ç›¤');
                }
            }

            // 3. å‚™ç”¨ï¼šä½¿ç”¨gameHistoryä¸­çš„åˆå§‹æ£‹ç›¤
            if (!effectiveBoard && gameHistory && gameHistory.initialBoard) {
                effectiveBoard = gameHistory.initialBoard;
                dataSource = 'initial_board';
                console.log('âœ… ä½¿ç”¨gameHistoryä¸­çš„åˆå§‹æ£‹ç›¤');
            }

            // 4. æœ€å¾Œå‚™ç”¨ï¼šå‰µå»ºæ¨™æº–æ£‹ç›¤
            if (!effectiveBoard) {
                effectiveBoard = createStandardChessBoard();
                dataSource = 'standard_board';
                console.log('âœ… ä½¿ç”¨æ¨™æº–è±¡æ£‹æ£‹ç›¤');
            }

            console.log(`ğŸ“‹ æ•¸æ“šæº: ${dataSource}`);

            // å‰µå»ºæ¨™æº–æ£‹ç›¤çš„å‡½æ•¸
            function createStandardChessBoard() {
                const board = Array(10).fill(null).map(() => Array(9).fill(null));

                // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
                board[0][0] = { type: 'è»Š', color: 'black' };
                board[0][1] = { type: 'é¦¬', color: 'black' };
                board[0][2] = { type: 'è±¡', color: 'black' };
                board[0][3] = { type: 'å£«', color: 'black' };
                board[0][4] = { type: 'å°‡', color: 'black' };
                board[0][5] = { type: 'å£«', color: 'black' };
                board[0][6] = { type: 'è±¡', color: 'black' };
                board[0][7] = { type: 'é¦¬', color: 'black' };
                board[0][8] = { type: 'è»Š', color: 'black' };

                board[2][1] = { type: 'åŒ…', color: 'black' };
                board[2][7] = { type: 'åŒ…', color: 'black' };

                board[3][0] = { type: 'å’', color: 'black' };
                board[3][2] = { type: 'å’', color: 'black' };
                board[3][4] = { type: 'å’', color: 'black' };
                board[3][6] = { type: 'å’', color: 'black' };
                board[3][8] = { type: 'å’', color: 'black' };

                // ç´…æ–¹æ£‹å­ï¼ˆ5-9è¡Œï¼‰
                board[6][0] = { type: 'å…µ', color: 'red' };
                board[6][2] = { type: 'å…µ', color: 'red' };
                board[6][4] = { type: 'å…µ', color: 'red' };
                board[6][6] = { type: 'å…µ', color: 'red' };
                board[6][8] = { type: 'å…µ', color: 'red' };

                board[7][1] = { type: 'ç‚®', color: 'red' };
                board[7][7] = { type: 'ç‚®', color: 'red' };

                board[9][0] = { type: 'ä¿¥', color: 'red' };
                board[9][1] = { type: 'å‚Œ', color: 'red' };
                board[9][2] = { type: 'ç›¸', color: 'red' };
                board[9][3] = { type: 'ä»•', color: 'red' };
                board[9][4] = { type: 'å¸¥', color: 'red' };
                board[9][5] = { type: 'ä»•', color: 'red' };
                board[9][6] = { type: 'ç›¸', color: 'red' };
                board[9][7] = { type: 'å‚Œ', color: 'red' };
                board[9][8] = { type: 'ä¿¥', color: 'red' };

                return board;
            }

            // ã€æ ¸å¿ƒåˆ†æã€‘
            const pieceStats = analyzeCurrentBoardState(effectiveBoard);
            logPieceStats(pieceStats);

            const finalStats = calculateStatsSummary(pieceStats);

            // ã€åˆ¤å®šé‚è¼¯ã€‘
            const redOffensiveCount = finalStats.red.offensiveCount;
            const blackOffensiveCount = finalStats.black.offensiveCount;
            const totalPieces = redOffensiveCount + blackOffensiveCount + finalStats.red.defensiveCount + finalStats.black.defensiveCount;

            console.log(`\nğŸ¯ ã€æœ€çµ‚åˆ¤å®šã€‘åŸºæ–¼ç•¶å‰æ£‹ç›¤ç‹€æ…‹çš„ç„¡å¯éæ²³æ£‹å­æª¢æ¸¬:`);
            console.log(`   ç´…æ–¹æ”»æ“Šæ€§æ£‹å­: ${redOffensiveCount} å€‹`);
            console.log(`   ç´…æ–¹é˜²ç¦¦æ€§æ£‹å­: ${finalStats.red.defensiveCount} å€‹`);
            console.log(`   é»‘æ–¹æ”»æ“Šæ€§æ£‹å­: ${blackOffensiveCount} å€‹`);
            console.log(`   é»‘æ–¹é˜²ç¦¦æ€§æ£‹å­: ${finalStats.black.defensiveCount} å€‹`);
            console.log(`   æ£‹ç›¤ç¸½æ£‹å­æ•¸: ${totalPieces} å€‹`);

            // ã€åˆ¤å®šé‚è¼¯ã€‘é›™æ–¹éƒ½æ²’æœ‰æ”»æ“Šæ€§æ£‹å­ = å’Œæ£‹
            const isInsufficientMaterial = (redOffensiveCount === 0 && blackOffensiveCount === 0);

            if (isInsufficientMaterial) {
                console.log(`\nâœ… ã€æª¢æ¸¬çµæœã€‘ç¬¦åˆ"é›™æ–¹ç„¡å¯éæ²³æ£‹å­"å’Œæ£‹æ¢ä»¶ï¼`);
                console.log(`   åŸå› : é›™æ–¹éƒ½æ²’æœ‰è»Šé¦¬ç‚®å…µç­‰æ”»æ“Šæ€§æ£‹å­`);
                console.log(`   çµè«–: é›™æ–¹éƒ½ç„¡æ³•å½¢æˆæœ‰æ•ˆæ”»æ“Šï¼Œç„¡æ³•ç²å‹`);

                const drawResult = {
                    isDraw: true,
                    drawType: 'INSUFFICIENT_MATING_MATERIAL',
                    drawReason: 'é›™æ–¹ç„¡å¯éæ²³æ£‹å­',
                    drawDescription: 'é›™æ–¹éƒ½æ²’æœ‰è»Šé¦¬ç‚®å…µç­‰æ”»æ“Šæ€§æ£‹å­ï¼Œç„¡æ³•å½¢æˆæœ‰æ•ˆæ”»æ“Šï¼Œåˆ¤å®šå’Œæ£‹',
                    detectionTime: new Date().toISOString(),
                    boardLayout: {
                        totalRows: 10,
                        redTerritory: '5-9è¡Œ',
                        blackTerritory: '0-4è¡Œ',
                        note: 'å·²ç§»é™¤æ¥šæ²³æ¼¢ç•Œï¼Œèª¿æ•´ç‚º10è¡Œæ£‹ç›¤'
                    },
                    simplifiedDetection: {
                        enabled: true,
                        method: 'ç›´æ¥åˆ†æç•¶å‰æ£‹ç›¤ç‹€æ…‹',
                        dataSource: dataSource,
                        note: 'æ”¾æ£„è¤‡é›œçš„æ£‹è­œé‡æ”¾ï¼Œç›´æ¥åˆ©ç”¨ç¾æœ‰æ£‹ç›¤ç‹€æ…‹'
                    },
                    boardState: {
                        totalPieces: totalPieces,
                        red: {
                            offensivePieces: redOffensiveCount,
                            defensivePieces: finalStats.red.defensiveCount,
                            offensiveTypes: finalStats.red.offensiveTypes,
                            defensiveTypes: finalStats.red.defensiveTypes
                        },
                        black: {
                            offensivePieces: blackOffensiveCount,
                            defensivePieces: finalStats.black.defensiveCount,
                            offensiveTypes: finalStats.black.offensiveTypes,
                            defensiveTypes: finalStats.black.defensiveTypes
                        }
                    },
                    ruleReference: {
                        rule: 'ä¸­åœ‹è±¡æ£‹ç«¶è³½è¦å‰‡',
                        article: 'é›™æ–¹å‡ç„¡æ”»æ“Šæ€§æ£‹å­æ™‚åˆ¤å’Œ',
                        explanation: 'ç•¶é›™æ–¹éƒ½åªå‰©ä¸‹å¸¥(å°‡)ã€ä»•(å£«)ã€ç›¸(è±¡)ç­‰ç„¡æ³•éæ²³çš„é˜²ç¦¦æ€§æ£‹å­æ™‚ï¼Œè¦–ç‚ºç„¡æ³•å½¢æˆæœ‰æ•ˆæ”»æ“Šï¼Œåˆ¤å®šå’Œæ£‹'
                    }
                };

                return drawResult;
            } else {
                console.log(`\nâŒ ã€æª¢æ¸¬çµæœã€‘ä¸ç¬¦åˆå’Œæ£‹æ¢ä»¶`);

                if (redOffensiveCount > 0) {
                    const redOffensiveList = Object.entries(finalStats.red.offensiveTypes)
                        .map(([type, count]) => `${type}Ã—${count}`)
                        .join(', ');
                    console.log(`   ç´…æ–¹ä»æœ‰æ”»æ“ŠåŠ›: ${redOffensiveList}`);
                }
                if (blackOffensiveCount > 0) {
                    const blackOffensiveList = Object.entries(finalStats.black.offensiveTypes)
                        .map(([type, count]) => `${type}Ã—${count}`)
                        .join(', ');
                    console.log(`   é»‘æ–¹ä»æœ‰æ”»æ“ŠåŠ›: ${blackOffensiveList}`);
                }

                const continueResult = {
                    isDraw: false,
                    continueGame: true,
                    reason: 'ä»æœ‰æ”»æ“Šæ€§æ£‹å­å­˜åœ¨',
                    boardLayout: {
                        totalRows: 10,
                        redTerritory: '5-9è¡Œ',
                        blackTerritory: '0-4è¡Œ',
                        note: 'å·²ç§»é™¤æ¥šæ²³æ¼¢ç•Œï¼Œèª¿æ•´ç‚º10è¡Œæ£‹ç›¤'
                    },
                    simplifiedDetection: {
                        enabled: true,
                        method: 'ç›´æ¥åˆ†æç•¶å‰æ£‹ç›¤ç‹€æ…‹',
                        dataSource: dataSource,
                        note: 'æ”¾æ£„è¤‡é›œçš„æ£‹è­œé‡æ”¾ï¼Œç›´æ¥åˆ©ç”¨ç¾æœ‰æ£‹ç›¤ç‹€æ…‹'
                    },
                    redOffensivePieces: Object.entries(finalStats.red.offensiveTypes)
                        .map(([type, count]) => `${type}Ã—${count}`)
                        .join(', ') || 'ç„¡',
                    blackOffensivePieces: Object.entries(finalStats.black.offensiveTypes)
                        .map(([type, count]) => `${type}Ã—${count}`)
                        .join(', ') || 'ç„¡',
                    detectionTime: new Date().toISOString(),
                    finalStats: finalStats
                };

                return continueResult;
            }

            console.log(`\nâœ… ç°¡åŒ–ç‰ˆç„¡å¯éæ²³æ£‹å­æª¢æ¸¬å®Œæˆ`);
            console.log(`ğŸ“Š æª¢æ¸¬çµ±è¨ˆ:`);
            console.log(`   æª¢æ¸¬æ–¹æ³•: ç›´æ¥åˆ†æç•¶å‰æ£‹ç›¤ç‹€æ…‹`);
            console.log(`   æ•¸æ“šæº: ${dataSource}`);
            console.log(`   å„ªå‹¢: ç°¡å–®å¯é ï¼Œé¿å…è¤‡é›œçš„æ£‹è­œé‡æ”¾å•é¡Œ`);
        }

        // âœ… å®Œæ•´ä¿®æ­£ç‰ˆï¼šdetectLongCapture å‡½æ•¸
        detectLongCapture(gameRecord, startIndex, endIndex, cycleCount, cycleLength) {
            // éªŒè¯å‚æ•°
            console.log('ğŸ” é–‹å§‹é•·æ‰æª¢æ¸¬ - åƒæ•¸æª¢æŸ¥:');
            console.log('  gameRecord:', gameRecord);
            console.log('  startIndex:', startIndex);
            console.log('  endIndex:', endIndex);
            console.log('  cycleCount:', cycleCount);
            console.log('  cycleLength:', cycleLength);

            // ğŸ”§ åƒæ•¸é©—è­‰
            if (!gameRecord) {
                console.error('âŒ gameRecord ç‚º null æˆ– undefined');
                return { isLongCapture: false };
            }

            if (!Array.isArray(gameRecord)) {
                console.error('âŒ gameRecord ä¸æ˜¯æ•¸çµ„:', typeof gameRecord);
                return { isLongCapture: false };
            }

            if (gameRecord.length === 0) {
                console.error('âŒ gameRecord ç‚ºç©ºæ•¸çµ„');
                return { isLongCapture: false };
            }

            if (typeof startIndex !== 'number' || typeof endIndex !== 'number') {
                console.error('âŒ startIndex æˆ– endIndex ä¸æ˜¯æ•¸å­—:', { startIndex, endIndex });
                return { isLongCapture: false };
            }

            if (startIndex >= endIndex) {
                console.error('âŒ startIndex >= endIndex:', { startIndex, endIndex });
                return { isLongCapture: false };
            }

            // éªŒè¯ historyManager
            if (!this.historyManager) {
                console.error('âŒ historyManager æœªåˆå§‹åŒ–');
                return { isLongCapture: false };
            }

            if (typeof this.historyManager.getHistory !== 'function') {
                console.error('âŒ historyManager ç¼ºå°‘å¿…è¦çš„æ–¹æ³•');
                return { isLongCapture: false };
            }

            // ğŸ”§ æª¢æŸ¥ historyManager.getHistoryLength æ–¹æ³•
            let historyLength = 0;
            try {
                if (typeof this.historyManager.getHistoryLength === 'function') {
                    historyLength = this.historyManager.getHistoryLength();
                } else if (typeof this.historyManager.getHistory === 'function') {
                    const history = this.historyManager.getHistory();
                    historyLength = history ? history.length : 0;
                } else {
                    console.error('âŒ ç„¡æ³•ç²å–æ­·å²è¨˜éŒ„é•·åº¦');
                    return { isLongCapture: false };
                }
            } catch (error) {
                console.error('âŒ ç²å–æ­·å²è¨˜éŒ„é•·åº¦æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                return { isLongCapture: false };
            }

            if (historyLength === 0) {
                console.error('âŒ æ£‹ç›¤ç‹€æ…‹æ­·å²ç‚ºç©º');
                return { isLongCapture: false };
            }

            try {
                const boardHistory = this.historyManager.getHistory();

                // ğŸ”§ æª¢æŸ¥ boardHistory
                if (!boardHistory) {
                    console.error('âŒ boardHistory ç‚º null æˆ– undefined');
                    return { isLongCapture: false };
                }

                if (!Array.isArray(boardHistory)) {
                    console.error('âŒ boardHistory ä¸æ˜¯æ•¸çµ„:', typeof boardHistory);
                    return { isLongCapture: false };
                }

                console.log(`ğŸ” å¼€å§‹æ£€æµ‹é•¿æ‰ï¼š`);
                console.log(`ğŸ“ æ£‹è°±é•¿åº¦ï¼š${gameRecord.length}`);
                console.log(`ğŸ“Š å†å²è®°å½•æ•°é‡ï¼š${boardHistory.length} æ­¥`);
                console.log(`ğŸ¯ å¾ªç¯èŒƒå›´ï¼š${startIndex} - ${endIndex}`);
                console.log(`ğŸ”„ å¾ªç¯æ¬¡æ•°ï¼š${cycleCount}, å¾ªç¯é•¿åº¦ï¼š${cycleLength}`);

                // éªŒè¯ç´¢å¼•èŒƒå›´
                if (startIndex < 0 || endIndex > boardHistory.length) {
                    console.warn('âš ï¸ æ— æ•ˆçš„ç´¢å¼•èŒƒå›´');
                    return { isLongCapture: false };
                }

                // åªåˆ†æä¸€ä¸ªå¾ªç¯å‘¨æœŸï¼Œè€Œä¸æ˜¯æ•´ä¸ªé‡å¤åŒºé—´
                const singleCycleStart = endIndex - cycleLength;
                const singleCycleEnd = endIndex;

                // ğŸ”§ æª¢æŸ¥è¨ˆç®—å‡ºçš„ç´¢å¼•
                if (singleCycleStart < 0 || singleCycleEnd > boardHistory.length) {
                    console.warn('âš ï¸ è®¡ç®—å‡ºçš„å¾ªç¯ç´¢å¼•è¶…å‡ºèŒƒå›´:', {
                        singleCycleStart,
                        singleCycleEnd,
                        boardHistoryLength: boardHistory.length
                    });
                    return { isLongCapture: false };
                }

                console.log(`ğŸ” åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸï¼š${singleCycleStart} - ${singleCycleEnd}`);

                // ğŸ”§ æª¢æŸ¥ analyzeCycleLongCapture æ–¹æ³•æ˜¯å¦å­˜åœ¨
                if (typeof this.analyzeCycleLongCapture !== 'function') {
                    console.error('âŒ analyzeCycleLongCapture æ–¹æ³•ä¸å­˜åœ¨');
                    return { isLongCapture: false };
                }

                // åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸä¸­çš„é•¿æ‰æƒ…å†µ
                const captureAnalysis = this.analyzeCycleLongCapture(
                    gameRecord,
                    boardHistory,
                    singleCycleStart,
                    singleCycleEnd
                );

                // ğŸ”§ æª¢æŸ¥ captureAnalysis çµæœ
                if (!captureAnalysis) {
                    console.warn('âš ï¸ analyzeCycleLongCapture è¿”å› null æˆ– undefined');
                    return { isLongCapture: false };
                }

                // æ·»åŠ å¾ªç¯æ¬¡æ•°ä¿¡æ¯
                captureAnalysis.cycleCount = cycleCount;
                captureAnalysis.cycleLength = cycleLength;

                console.log('ğŸ” é•¿æ‰åˆ†æç»“æœï¼š', captureAnalysis);

                // ğŸ†• è™•ç†é•·æ‰æª¢æ¸¬çµæœ
                if (captureAnalysis.isLongCapture) {
                    // æª¢æŸ¥æ˜¯å¦ç‚ºé›™æ–¹äº’ç›¸é•·æ‰å’Œæ£‹æƒ…æ³
                    if (captureAnalysis.isDraw && captureAnalysis.drawReason === 'é›™æ–¹äº’ç›¸é•·æ‰') {
                        // æ§‹å»ºé›™æ–¹äº’ç›¸é•·æ‰æ‰€éœ€çš„æ•¸æ“šçµæ§‹
                        const mutualLongCaptureResult = {
                            filteredRedSequences: captureAnalysis.filteredRedSequences || [],
                            filteredBlackSequences: captureAnalysis.filteredBlackSequences || [],
                            redCaptureRatio: captureAnalysis.redCaptureRatio || 0,
                            blackCaptureRatio: captureAnalysis.blackCaptureRatio || 0,
                            internalCycleCount: captureAnalysis.internalCycleCount || cycleCount,
                            cycleCount: cycleCount,
                            cycleLength: cycleLength,
                            patternDisplay: this.generatePatternDisplay(gameRecord, singleCycleStart, singleCycleEnd),
                            captureMoves: captureAnalysis.captureMoves || [],
                            playerCaptureCounts: captureAnalysis.playerCaptureCounts || { red: 0, black: 0 },
                            playerMoveCounts: captureAnalysis.playerMoveCounts || { red: 0, black: 0 }
                        };

                        // æ ¹æ“šå¾ªç’°æ¬¡æ•¸æ±ºå®šé¡¯ç¤ºè­¦å‘Šé‚„æ˜¯åˆ¤å’Œæ£‹
                        if (cycleCount >= 3) {
                            // å¾ªç’°3æ¬¡æˆ–ä»¥ä¸Šï¼Œé›™æ–¹äº’ç›¸é•·æ‰åˆ¤å’Œæ£‹
                            console.log(`ğŸ¤ é›™æ–¹äº’ç›¸é•·æ‰åˆ¤å’Œæ£‹ï¼`);
                            if (typeof showMutualLongCaptureDraw === 'function') {
                                showMutualLongCaptureDraw(mutualLongCaptureResult);
                            } else {
                                console.warn('âš ï¸ showMutualLongCaptureDraw å‡½æ•¸ä¸å­˜åœ¨');
                            }

                            // æ¨™è¨˜ç‚ºå’Œæ£‹
                            captureAnalysis.isViolation = false; // ä¸æ˜¯é•è¦ï¼Œæ˜¯å’Œæ£‹
                            captureAnalysis.gameResult = 'mutual_long_capture_draw';
                            captureAnalysis.isDraw = true;
                        } else if (cycleCount === 2) {
                            // å¾ªç’°2æ¬¡ï¼Œé¡¯ç¤ºé›™æ–¹äº’ç›¸é•·æ‰è­¦å‘Š
                            console.log(`âš ï¸ é›™æ–¹äº’ç›¸é•·æ‰è­¦å‘Šï¼`);
                            if (typeof showMutualLongCaptureWarning === 'function') {
                                showMutualLongCaptureWarning(mutualLongCaptureResult);
                            } else {
                                console.warn('âš ï¸ showMutualLongCaptureWarning å‡½æ•¸ä¸å­˜åœ¨');
                            }

                            // æ¨™è¨˜ç‚ºè­¦å‘Š
                            captureAnalysis.isWarning = true;
                        }
                        // å¾ªç’°1æ¬¡ä¸é¡¯ç¤ºä»»ä½•é€šçŸ¥

                    } else {
                        // å–®æ–¹é¢é•·æ‰çš„æƒ…æ³
                        // âœ… ä¿®æ­£ï¼šæ§‹å»ºé€šçŸ¥æ‰€éœ€çš„æ•¸æ“šçµæ§‹
                        const longCaptureResult = {
                            longCapturePlayer: captureAnalysis.longCapturePlayer,  // âœ… ä¿®æ­£ï¼šä½¿ç”¨æ­£ç¢ºçš„å±¬æ€§å
                            consecutiveCaptures: captureAnalysis.playerCaptureCounts ?
                                captureAnalysis.playerCaptureCounts[captureAnalysis.longCapturePlayer] : 0,
                            cycleCount: cycleCount,
                            cycleLength: cycleLength,
                            internalCycleCount: captureAnalysis.internalCycleCount || cycleCount,  // âœ… æ–°å¢
                            patternDisplay: this.generatePatternDisplay(gameRecord, singleCycleStart, singleCycleEnd),
                            captureMoves: captureAnalysis.captureMoves || [],
                            playerCaptureCounts: captureAnalysis.playerCaptureCounts || { red: 0, black: 0 },
                            playerMoveCounts: captureAnalysis.playerMoveCounts || { red: 0, black: 0 }
                        };

                        // æ ¹æ“šå¾ªç’°æ¬¡æ•¸æ±ºå®šé¡¯ç¤ºè­¦å‘Šé‚„æ˜¯åˆ¤è² 
                        if (cycleCount >= 3) {
                            // å¾ªç’°3æ¬¡æˆ–ä»¥ä¸Šï¼Œé•·æ‰æ–¹åˆ¤è² 
                            console.log(`ğŸš« ${captureAnalysis.longCapturePlayer}æ–¹é•·æ‰åˆ¤è² ï¼`);
                            if (typeof showLongCaptureLoss === 'function') {
                                showLongCaptureLoss(longCaptureResult);
                            } else {
                                console.warn('âš ï¸ showLongCaptureLoss å‡½æ•¸ä¸å­˜åœ¨');
                            }

                            // æ¨™è¨˜ç‚ºé•è¦
                            captureAnalysis.isViolation = true;
                            captureAnalysis.gameResult = 'long_capture_loss';
                            captureAnalysis.loser = captureAnalysis.longCapturePlayer;
                        } else if (cycleCount === 2) {
                            // å¾ªç’°2æ¬¡ï¼Œé¡¯ç¤ºé•·æ‰è­¦å‘Š
                            console.log(`âš ï¸ ${captureAnalysis.longCapturePlayer}æ–¹é•·æ‰è­¦å‘Šï¼`);
                            if (typeof showLongCaptureWarning === 'function') {
                                showLongCaptureWarning(longCaptureResult);
                            } else {
                                console.warn('âš ï¸ showLongCaptureWarning å‡½æ•¸ä¸å­˜åœ¨');
                            }

                            // æ¨™è¨˜ç‚ºè­¦å‘Š
                            captureAnalysis.isWarning = true;
                        }
                        // å¾ªç’°1æ¬¡ä¸é¡¯ç¤ºä»»ä½•é€šçŸ¥
                    }
                }

                return captureAnalysis;

            } catch (error) {
                console.error('ğŸš« é•¿æ‰æ£€æµ‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š', error);
                console.error('ğŸ”§ éŒ¯èª¤å †ç–Š:', error.stack);
                return { isLongCapture: false };
            }
        }

// âœ… æ–°å¢ï¼šæ–°ç‰ˆæœ¬çš„é•·æ‰æª¢æ¸¬æ–¹æ³•ï¼ˆä¾› recordMove ä½¿ç”¨ï¼‰
        detectLongCaptureWithParams(gameRecord, startIndex, endIndex, cycleCount, cycleLength) {
            console.log('ğŸ” é–‹å§‹é•·æ‰æª¢æ¸¬ (æ–°ç‰ˆæœ¬) - åƒæ•¸æª¢æŸ¥:');
            console.log('  gameRecord:', gameRecord);
            console.log('  startIndex:', startIndex);
            console.log('  endIndex:', endIndex);
            console.log('  cycleCount:', cycleCount);
            console.log('  cycleLength:', cycleLength);

            // ğŸ”§ åƒæ•¸é©—è­‰
            if (!gameRecord) {
                console.error('âŒ gameRecord ç‚º null æˆ– undefined');
                return { isLongCapture: false };
            }

            if (!Array.isArray(gameRecord)) {
                console.error('âŒ gameRecord ä¸æ˜¯æ•¸çµ„:', typeof gameRecord);
                return { isLongCapture: false };
            }

            if (gameRecord.length === 0) {
                console.error('âŒ gameRecord ç‚ºç©ºæ•¸çµ„');
                return { isLongCapture: false };
            }

            if (typeof startIndex !== 'number' || typeof endIndex !== 'number') {
                console.error('âŒ startIndex æˆ– endIndex ä¸æ˜¯æ•¸å­—:', { startIndex, endIndex });
                return { isLongCapture: false };
            }

            if (startIndex >= endIndex) {
                console.error('âŒ startIndex >= endIndex:', { startIndex, endIndex });
                return { isLongCapture: false };
            }

            // éªŒè¯ historyManager
            if (!this.historyManager) {
                console.error('âŒ historyManager æœªåˆå§‹åŒ–');
                return { isLongCapture: false };
            }

            if (typeof this.historyManager.getHistory !== 'function') {
                console.error('âŒ historyManager ç¼ºå°‘å¿…è¦çš„æ–¹æ³•');
                return { isLongCapture: false };
            }

            // ğŸ”§ æª¢æŸ¥ historyManager.getHistoryLength æ–¹æ³•
            let historyLength = 0;
            try {
                if (typeof this.historyManager.getHistoryLength === 'function') {
                    historyLength = this.historyManager.getHistoryLength();
                } else if (typeof this.historyManager.getHistory === 'function') {
                    const history = this.historyManager.getHistory();
                    historyLength = history ? history.length : 0;
                } else {
                    console.error('âŒ ç„¡æ³•ç²å–æ­·å²è¨˜éŒ„é•·åº¦');
                    return { isLongCapture: false };
                }
            } catch (error) {
                console.error('âŒ ç²å–æ­·å²è¨˜éŒ„é•·åº¦æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                return { isLongCapture: false };
            }

            if (historyLength === 0) {
                console.error('âŒ æ£‹ç›˜çŠ¶æ€å†å²ä¸ºç©º');
                return { isLongCapture: false };
            }

            try {
                const boardHistory = this.historyManager.getHistory();

                // ğŸ”§ æª¢æŸ¥ boardHistory
                if (!boardHistory) {
                    console.error('âŒ boardHistory ç‚º null æˆ– undefined');
                    return { isLongCapture: false };
                }

                if (!Array.isArray(boardHistory)) {
                    console.error('âŒ boardHistory ä¸æ˜¯æ•¸çµ„:', typeof boardHistory);
                    return { isLongCapture: false };
                }

                console.log(`ğŸ” å¼€å§‹æ£€æµ‹é•¿æ‰ï¼š`);
                console.log(`ğŸ“ æ£‹è°±é•¿åº¦ï¼š${gameRecord.length}`);
                console.log(`ğŸ“Š å†å²è®°å½•æ•°é‡ï¼š${boardHistory.length} æ­¥`);
                console.log(`ğŸ¯ å¾ªç¯èŒƒå›´ï¼š${startIndex} - ${endIndex}`);
                console.log(`ğŸ”„ å¾ªç¯æ¬¡æ•°ï¼š${cycleCount}, å¾ªç¯é•¿åº¦ï¼š${cycleLength}`);

                // éªŒè¯ç´¢å¼•èŒƒå›´
                if (startIndex < 0 || endIndex > boardHistory.length) {
                    console.warn('âš ï¸ æ— æ•ˆçš„ç´¢å¼•èŒƒå›´');
                    return { isLongCapture: false };
                }

                // åªåˆ†æä¸€ä¸ªå¾ªç¯å‘¨æœŸï¼Œè€Œä¸æ˜¯æ•´ä¸ªé‡å¤åŒºé—´
                const singleCycleStart = endIndex - cycleLength;
                const singleCycleEnd = endIndex;

                // ğŸ”§ æª¢æŸ¥è¨ˆç®—å‡ºçš„ç´¢å¼•
                if (singleCycleStart < 0 || singleCycleEnd > boardHistory.length) {
                    console.warn('âš ï¸ è®¡ç®—å‡ºçš„å¾ªç¯ç´¢å¼•è¶…å‡ºèŒƒå›´:', { singleCycleStart, singleCycleEnd, boardHistoryLength: boardHistory.length });
                    return { isLongCapture: false };
                }

                console.log(`ğŸ” åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸï¼š${singleCycleStart} - ${singleCycleEnd}`);

                // ğŸ”§ æª¢æŸ¥ analyzeCycleLongCapture æ–¹æ³•æ˜¯å¦å­˜åœ¨
                if (typeof this.analyzeCycleLongCapture !== 'function') {
                    console.error('âŒ analyzeCycleLongCapture æ–¹æ³•ä¸å­˜åœ¨');
                    return { isLongCapture: false };
                }

                // åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸä¸­çš„é•¿æ‰æƒ…å†µ
                const captureAnalysis = this.analyzeCycleLongCapture(
                    gameRecord,
                    boardHistory,
                    singleCycleStart,
                    singleCycleEnd
                );

                // ğŸ”§ æª¢æŸ¥ captureAnalysis çµæœ
                if (!captureAnalysis) {
                    console.warn('âš ï¸ analyzeCycleLongCapture è¿”å› null æˆ– undefined');
                    return { isLongCapture: false };
                }

                // æ·»åŠ å¾ªç¯æ¬¡æ•°ä¿¡æ¯
                captureAnalysis.cycleCount = cycleCount;
                captureAnalysis.cycleLength = cycleLength;

                console.log('ğŸ” é•¿æ‰åˆ†æç»“æœï¼š', captureAnalysis);

                return captureAnalysis;

            } catch (error) {
                console.error('ğŸš« é•¿æ‰æ£€æµ‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š', error);
                console.error('ğŸ”§ éŒ¯èª¤å †ç–Š:', error.stack);
                return { isLongCapture: false };
            }
        }
// ğŸ†• æ–°å¢ï¼šç”Ÿæˆæ¨¡å¼æ˜¾ç¤ºå­—ç¬¦ä¸²çš„è¾…åŠ©å‡½æ•°ï¼ˆå¦‚æœé‚„æ²’æœ‰çš„è©±ï¼‰
        generatePatternDisplay(gameRecord, startIndex, endIndex) {
            if (!gameRecord || startIndex >= endIndex) {
                return 'æ— æ³•æ˜¾ç¤ºæ¨¡å¼';
            }

            try {
                const cycleRecord = gameRecord.slice(startIndex, endIndex);
                const patternMoves = cycleRecord.map((move, index) => {
                    const moveNumber = startIndex + index + 1;
                    const player = move.player === 'red' ? 'çº¢' : 'é»‘';
                    return `${moveNumber}.${player}${move.notation}`;
                });

                return patternMoves.join(' â†’ ');
            } catch (error) {
                console.error('ç”Ÿæˆæ¨¡å¼æ˜¾ç¤ºæ—¶å‘ç”Ÿé”™è¯¯ï¼š', error);
                return 'æ¨¡å¼æ˜¾ç¤ºé”™è¯¯';
            }
        }
        // åœ¨ detectCycles æ–¹æ³•é–‹é ­åŠ å…¥è©³ç´°çš„è¨ºæ–·ä»£ç¢¼

        detectCycles() {
            console.log('ğŸ” é–‹å§‹è¨ºæ–· historyManager...');

            // 1. æª¢æŸ¥ historyManager æ˜¯å¦å­˜åœ¨
            if (!this.historyManager) {
                console.error('âŒ historyManager æœªåˆå§‹åŒ–');
                console.log('ğŸ”§ this.historyManager =', this.historyManager);
                return [];
            }

            // 2. æª¢æŸ¥ historyManager çš„é¡å‹å’Œæ–¹æ³•
            console.log('âœ… historyManager å­˜åœ¨');
            console.log('ğŸ”§ historyManager é¡å‹:', typeof this.historyManager);
            console.log('ğŸ”§ historyManager æ§‹é€ å‡½æ•¸:', this.historyManager.constructor.name);

            // 3. åˆ—å‡º historyManager çš„æ‰€æœ‰æ–¹æ³•
            console.log('ğŸ”§ historyManager çš„æ–¹æ³•:');
            const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this.historyManager));
            methods.forEach(method => {
                if (typeof this.historyManager[method] === 'function') {
                    console.log(`   - ${method}()`);
                }
            });

            // 4. æª¢æŸ¥ getHistory æ–¹æ³•
            if (typeof this.historyManager.getHistory !== 'function') {
                console.error('âŒ historyManager æ²’æœ‰ getHistory æ–¹æ³•');

                // å˜—è©¦å…¶ä»–å¯èƒ½çš„æ–¹æ³•å
                const possibleMethods = ['getHistory', 'getBoardHistory', 'getPositionHistory', 'history', 'boardHistory'];
                console.log('ğŸ”§ å˜—è©¦å°‹æ‰¾å…¶ä»–æ­·å²è¨˜éŒ„æ–¹æ³•:');

                for (const methodName of possibleMethods) {
                    if (typeof this.historyManager[methodName] === 'function') {
                        console.log(`   âœ… æ‰¾åˆ°æ–¹æ³•: ${methodName}()`);
                        try {
                            const result = this.historyManager[methodName]();
                            console.log(`   ğŸ“Š ${methodName}() è¿”å›:`, result);
                            console.log(`   ğŸ“ ${methodName}() é•·åº¦:`, result ? result.length : 'null/undefined');
                        } catch (error) {
                            console.log(`   âŒ ${methodName}() èª¿ç”¨å¤±æ•—:`, error.message);
                        }
                    }
                }
                return [];
            }

            // 5. èª¿ç”¨ getHistory ä¸¦æª¢æŸ¥çµæœ
            console.log('âœ… getHistory æ–¹æ³•å­˜åœ¨ï¼Œé–‹å§‹èª¿ç”¨...');

            let boardHistory;
            try {
                boardHistory = this.historyManager.getHistory();
                console.log('âœ… getHistory() èª¿ç”¨æˆåŠŸ');
                console.log('ğŸ”§ è¿”å›å€¼é¡å‹:', typeof boardHistory);
                console.log('ğŸ”§ æ˜¯å¦ç‚ºæ•¸çµ„:', Array.isArray(boardHistory));
                console.log('ğŸ”§ è¿”å›å€¼:', boardHistory);
            } catch (error) {
                console.error('âŒ getHistory() èª¿ç”¨å¤±æ•—:', error);
                return [];
            }

            // 6. æª¢æŸ¥æ­·å²è¨˜éŒ„çš„å…§å®¹
            if (!boardHistory) {
                console.warn('âš ï¸ getHistory() è¿”å› null æˆ– undefined');
                return [];
            }

            if (!Array.isArray(boardHistory)) {
                console.warn('âš ï¸ getHistory() è¿”å›çš„ä¸æ˜¯æ•¸çµ„:', boardHistory);
                return [];
            }

            if (boardHistory.length === 0) {
                console.warn('âš ï¸ æ£‹ç›¤æ­·å²è¨˜éŒ„ç‚ºç©º - å¯èƒ½é‚„æ²’æœ‰èµ°ä»»ä½•æ£‹æ­¥');
                console.log('ğŸ”§ å»ºè­°æª¢æŸ¥:');
                console.log('   1. æ˜¯å¦å·²ç¶“åˆå§‹åŒ–æ£‹ç›¤?');
                console.log('   2. æ˜¯å¦å·²ç¶“èµ°äº†è‡³å°‘ä¸€æ­¥æ£‹?');
                console.log('   3. èª¿ç”¨æ™‚æ©Ÿæ˜¯å¦æ­£ç¢º?');
                return [];
            }

            // 7. æª¢æŸ¥æ­·å²è¨˜éŒ„çš„çµæ§‹
            console.log(`âœ… æ‰¾åˆ° ${boardHistory.length} æ¢æ­·å²è¨˜éŒ„`);
            console.log('ğŸ”§ ç¬¬ä¸€æ¢è¨˜éŒ„:', boardHistory[0]);
            console.log('ğŸ”§ æœ€å¾Œä¸€æ¢è¨˜éŒ„:', boardHistory[boardHistory.length - 1]);

            // æª¢æŸ¥è¨˜éŒ„çš„çµæ§‹
            const firstRecord = boardHistory[0];
            if (firstRecord) {
                console.log('ğŸ”§ ç¬¬ä¸€æ¢è¨˜éŒ„çš„å±¬æ€§:', Object.keys(firstRecord));
                if (firstRecord.board) {
                    console.log('ğŸ”§ ç¬¬ä¸€æ¢è¨˜éŒ„æœ‰ board å±¬æ€§ï¼Œå¤§å°:',
                        firstRecord.board.length + 'x' + (firstRecord.board[0] ? firstRecord.board[0].length : '?'));
                } else {
                    console.warn('âš ï¸ ç¬¬ä¸€æ¢è¨˜éŒ„æ²’æœ‰ board å±¬æ€§');
                }
            }

            // 8. ç¹¼çºŒåŸä¾†çš„é‚è¼¯
            const positions = boardHistory.map(state => state.board);
            console.log(`ğŸ” æå–åˆ° ${positions.length} å€‹æ£‹ç›¤ä½ç½®`);

            // æª¢æŸ¥æ˜¯å¦æœ‰ç„¡æ•ˆçš„æ£‹ç›¤ä½ç½®
            const invalidPositions = positions.filter((pos, index) => {
                if (!pos) {
                    console.warn(`âš ï¸ ç¬¬${index}å€‹ä½ç½®ç‚ºç©º:`, pos);
                    return true;
                }
                return false;
            });

            if (invalidPositions.length > 0) {
                console.warn(`âš ï¸ ç™¼ç¾ ${invalidPositions.length} å€‹ç„¡æ•ˆä½ç½®`);
            }

            // ... ç¹¼çºŒåŸä¾†çš„å¾ªç’°æª¢æ¸¬é‚è¼¯
            const cycles = [];

            for (let i = 0; i < positions.length - 6; i += 2) {
                for (let j = i + 4; j < positions.length; j += 2) {
                    if (this.boardsEqual(positions[i], positions[j])) {
                        const cycleLength = j - i;
                        if (cycleLength >= 4) {
                            const moves = this.extractMovesForCycle(i, j);

                            cycles.push({
                                start: i,
                                end: j,
                                length: cycleLength,
                                moves: moves
                            });

                            console.log(`ğŸ¯ æ‰¾åˆ°å¾ªç’°ï¼š${i}-${j}ï¼Œé•·åº¦=${cycleLength}`);
                        }
                    }
                }
            }

            console.log(`ğŸ” detectCycles å®Œæˆï¼Œæ‰¾åˆ°${cycles.length}å€‹å¾ªç’°`);
            return cycles;
        }

// é¡å¤–çš„è¨ºæ–·æ–¹æ³• - å¯ä»¥å–®ç¨èª¿ç”¨ä¾†æª¢æŸ¥ historyManager ç‹€æ…‹
        debugHistoryManager() {
            console.log('ğŸ”§ === historyManager èª¿è©¦ä¿¡æ¯ ===');

            if (!this.historyManager) {
                console.log('âŒ historyManager ä¸å­˜åœ¨');
                return;
            }

            // æª¢æŸ¥æ‰€æœ‰å±¬æ€§
            console.log('ğŸ”§ historyManager çš„æ‰€æœ‰å±¬æ€§:');
            for (const key in this.historyManager) {
                const value = this.historyManager[key];
                console.log(`   ${key}: ${typeof value} = `, value);
            }

            // å˜—è©¦èª¿ç”¨å¸¸è¦‹æ–¹æ³•
            const commonMethods = [
                'getHistory', 'getBoardHistory', 'getPositionHistory',
                'getMoves', 'getGameRecord', 'getHistoryLength',
                'getCurrentBoard', 'getLastMove'
            ];

            console.log('ğŸ”§ æ¸¬è©¦å¸¸è¦‹æ–¹æ³•:');
            commonMethods.forEach(methodName => {
                if (typeof this.historyManager[methodName] === 'function') {
                    try {
                        const result = this.historyManager[methodName]();
                        console.log(`   âœ… ${methodName}(): `, result);
                    } catch (error) {
                        console.log(`   âŒ ${methodName}() å¤±æ•—: ${error.message}`);
                    }
                } else {
                    console.log(`   âŒ ${methodName} ä¸æ˜¯å‡½æ•¸`);
                }
            });
        }
        // âœ… æ–°å¢ï¼šç‚º detectCycles æå–movesçš„è¼”åŠ©æ–¹æ³•
        extractMovesForCycle(startIndex, endIndex) {
            try {
                // æ–¹æ³•1ï¼šå¦‚æœ historyManager æœ‰ getMoves æ–¹æ³•
                if (typeof this.historyManager.getMoves === 'function') {
                    return this.historyManager.getMoves().slice(startIndex, endIndex);
                }

                // æ–¹æ³•2ï¼šå¦‚æœ historyManager æœ‰ getGameRecord æ–¹æ³•
                if (typeof this.historyManager.getGameRecord === 'function') {
                    const gameRecord = this.historyManager.getGameRecord();
                    return this.convertGameRecordToMoves(gameRecord, startIndex, endIndex);
                }

                // æ–¹æ³•3ï¼šå¾æ£‹ç›¤æ­·å²æ¨å°movesï¼ˆç°¡åŒ–ç‰ˆï¼‰
                const boardHistory = this.historyManager.getHistory();
                const moves = [];

                for (let i = startIndex; i < Math.min(endIndex, boardHistory.length - 1); i++) {
                    const beforeBoard = boardHistory[i].board;
                    const afterBoard = boardHistory[i + 1].board;

                    // ç°¡åŒ–çš„moveå°è±¡
                    moves.push({
                        from: null, // å¯ä»¥é€šéæ¯”è¼ƒå‰å¾Œæ£‹ç›¤ç‹€æ…‹ä¾†æ¨å°
                        to: null,
                        boardBefore: beforeBoard,
                        boardAfter: afterBoard,
                        moveIndex: i
                    });
                }

                return moves;

            } catch (error) {
                console.error('ğŸš« æå–cycle moveså¤±æ•—ï¼š', error);
                return [];
            }
        }
// ğŸ”§ ä¿®å¾©ï¼šæŠŠ convertGameRecordToMoves å¯«æˆè·Ÿé•·å°‡æª¢æ¸¬ä¸€æ¨£çš„é‚è¼¯

        convertGameRecordToMoves(gameRecord, startIndex, endIndex) {
            const moves = [];

            // âœ… ä½¿ç”¨è·Ÿé•·å°‡æª¢æ¸¬ä¸€æ¨£çš„è½‰æ›æ–¹æ³•
            const moveSequence = this.convertGameRecordToMoveSequence(gameRecord);

            const startMoveIndex = Math.max(0, startIndex);
            const endMoveIndex = Math.min(endIndex, moveSequence.length);

            console.log(`ğŸ” convertGameRecordToMoves: è½‰æ›ç¯„åœ ${startMoveIndex} - ${endMoveIndex}`);
            console.log(`ğŸ” moveSequence é•·åº¦: ${moveSequence.length}`);

            for (let i = startMoveIndex; i < endMoveIndex; i++) {
                if (i < moveSequence.length) {
                    const move = moveSequence[i];
                    console.log(`ğŸ” è™•ç†ç¬¬ ${i} æ­¥: ${move.notation} (${move.player})`);

                    // âœ… è·Ÿé•·å°‡æª¢æ¸¬ä¸€æ¨£ï¼Œå¾æ­·å²è¨˜éŒ„ä¸­ç²å–æ£‹ç›¤ç‹€æ…‹
                    let boardBefore = null;
                    let boardAfter = null;

                    if (this.historyManager && typeof this.historyManager.getHistory === 'function') {
                        const history = this.historyManager.getHistory();
                        // æ­·å²è¨˜éŒ„ç´¢å¼•ï¼šiæ˜¯ç§»å‹•å‰ï¼Œi+1æ˜¯ç§»å‹•å¾Œ
                        if (i < history.length) {
                            boardBefore = history[i].board;
                        }
                        if (i + 1 < history.length) {
                            boardAfter = history[i + 1].board;
                        }
                    }

                    // ğŸ”§ æ ¸å¿ƒä¿®å¾©ï¼šè§£ææ£‹è­œè¨˜è™Ÿç²å– from å’Œ to ä½ç½®
                    let fromPos = null;
                    let toPos = null;

                    try {
                        // è§£ææ£‹è­œè¨˜è™Ÿï¼Œç²å–ç§»å‹•çš„èµ·å§‹å’Œç›®æ¨™ä½ç½®
                        const moveInfo = this.parseNotationToMove(move.notation, boardBefore, move.player);

                        if (moveInfo) {
                            fromPos = moveInfo.from;
                            toPos = moveInfo.to;

                            console.log(`ğŸ” è§£æç§»å‹• ${move.notation}: from(${fromPos?.row},${fromPos?.col}) to(${toPos?.row},${toPos?.col})`);
                        } else {
                            console.warn(`âš ï¸ ç„¡æ³•è§£ææ£‹è­œè¨˜è™Ÿ: ${move.notation}`);
                        }
                    } catch (error) {
                        console.error(`ğŸš« è§£ææ£‹è­œè¨˜è™Ÿ ${move.notation} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                    }

                    // âœ… å‰µå»ºå®Œæ•´çš„ç§»å‹•å°è±¡çµæ§‹
                    moves.push({
                        notation: move.notation,
                        player: move.player,
                        roundIndex: move.roundIndex,
                        boardBefore: boardBefore,  // ç§»å‹•å‰çš„æ£‹ç›¤ç‹€æ…‹
                        boardAfter: boardAfter,    // ç§»å‹•å¾Œçš„æ£‹ç›¤ç‹€æ…‹
                        moveIndex: i,
                        from: fromPos,    // ğŸ”§ ä¿®å¾©ï¼šè¨­ç½®å¯¦éš›çš„èµ·å§‹ä½ç½®
                        to: toPos         // ğŸ”§ ä¿®å¾©ï¼šè¨­ç½®å¯¦éš›çš„ç›®æ¨™ä½ç½®
                    });

                    console.log(`âœ… ç§»å‹• ${i} (${move.notation}) è™•ç†å®Œæˆ - from: ${fromPos ? `(${fromPos.row},${fromPos.col})` : 'null'}, to: ${toPos ? `(${toPos.row},${toPos.col})` : 'null'}`);
                }
            }

            console.log(`ğŸ” convertGameRecordToMoves: å®Œæˆè½‰æ›ï¼Œå…± ${moves.length} æ­¥`);
            return moves;
        }

// ğŸ”§ æ–°å¢æ–¹æ³•ï¼šè§£ææ£‹è­œè¨˜è™Ÿç‚ºå…·é«”ç§»å‹•ä½ç½®
        parseNotationToMove(notation, board, player) {
            try {
                // å¦‚æœä½ å·²ç¶“æœ‰è§£ææ£‹è­œè¨˜è™Ÿçš„æ–¹æ³•ï¼Œç›´æ¥ä½¿ç”¨
                if (typeof this.parseMove === 'function') {
                    return this.parseMove(notation, board, player);
                }

                // å¦‚æœä½ æœ‰å…¶ä»–çš„è¨˜è™Ÿè§£ææ–¹æ³•ï¼Œåœ¨é€™è£¡èª¿ç”¨
                // ä¾‹å¦‚ï¼šreturn this.notationParser.parse(notation, board, player);

                // ğŸ”§ æš«æ™‚çš„è§£æ±ºæ–¹æ¡ˆï¼šå¦‚æœæ²’æœ‰è§£ææ–¹æ³•ï¼Œè¿”å› null
                // ä½ éœ€è¦æ ¹æ“šä½ çš„æ£‹è­œæ ¼å¼å¯¦ç¾å…·é«”çš„è§£æé‚è¼¯
                console.warn(`âš ï¸ parseNotationToMove: éœ€è¦å¯¦ç¾æ£‹è­œè¨˜è™Ÿè§£ææ–¹æ³•`);
                return null;

            } catch (error) {
                console.error(`ğŸš« parseNotationToMove éŒ¯èª¤:`, error);
                return null;
            }
        }
// ğŸ†• æ–°å¢ï¼šå‚™ç”¨çš„ä¸­æ–‡è¨˜è­œæ³•è§£ææ–¹æ³•
        parseChineseNotationToCoords(notation, player, moveIndex) {
            try {
                console.log(`ğŸ” parseChineseNotationToCoords: ${notation} (${player})`);

                // è§£æä¸­æ–‡è¨˜è­œæ³•ï¼Œä¾‹å¦‚ "è»Šä¸€é€²1"
                const match = notation.match(/^([è»Šé¦¬ç›¸ä»•å¸¥å…µç‚®ä¿¥å‚Œè±¡å£«å°‡å’ç ²])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™])(é€²é€€å¹³)([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™1-9])$/);

                if (!match) {
                    console.warn(`âš ï¸ ç„¡æ³•åŒ¹é…è¨˜è­œæ ¼å¼: ${notation}`);
                    return null;
                }

                const [, piece, fromCol, direction, step] = match;

                // è½‰æ›ä¸­æ–‡æ•¸å­—åˆ°é˜¿æ‹‰ä¼¯æ•¸å­—
                const colMap = {
                    'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5,
                    'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9,
                    'ï¼‘': 1, 'ï¼’': 2, 'ï¼“': 3, 'ï¼”': 4, 'ï¼•': 5,
                    'ï¼–': 6, 'ï¼—': 7, 'ï¼˜': 8, 'ï¼™': 9
                };

                const fromColNum = colMap[fromCol] || parseInt(fromCol);
                const stepNum = colMap[step] || parseInt(step);

                if (!fromColNum || (!stepNum && stepNum !== 0)) {
                    console.warn(`âš ï¸ ç„¡æ³•è§£ææ•¸å­—: fromCol=${fromCol}, step=${step}`);
                    return null;
                }

                // ç²å–ç•¶å‰æ£‹ç›¤ç‹€æ…‹ä¾†ç¢ºå®šæ£‹å­ä½ç½®
                const currentBoard = this.getCurrentBoardState(moveIndex);
                if (!currentBoard) {
                    console.warn(`âš ï¸ ç„¡æ³•ç²å–æ£‹ç›¤ç‹€æ…‹`);
                    return null;
                }

                // æ‰¾åˆ°å°æ‡‰çš„æ£‹å­ä½ç½®
                const piecePositions = this.findPiecePositions(currentBoard, piece, player, fromColNum);

                if (piecePositions.length === 0) {
                    console.warn(`âš ï¸ æ‰¾ä¸åˆ°æ£‹å­ ${piece} åœ¨ç¬¬ ${fromColNum} åˆ—`);
                    return null;
                }

                // å¦‚æœæœ‰å¤šå€‹åŒé¡æ£‹å­ï¼Œéœ€è¦æ›´ç²¾ç¢ºçš„é‚è¼¯ä¾†ç¢ºå®šæ˜¯å“ªä¸€å€‹
                const fromPos = piecePositions[0]; // ç°¡åŒ–è™•ç†ï¼Œå–ç¬¬ä¸€å€‹

                // è¨ˆç®—ç›®æ¨™ä½ç½®
                let toPos = null;
                if (direction === 'é€²') {
                    if (player === 'red') {
                        toPos = { row: fromPos.row - stepNum, col: fromPos.col };
                    } else {
                        toPos = { row: fromPos.row + stepNum, col: fromPos.col };
                    }
                } else if (direction === 'é€€') {
                    if (player === 'red') {
                        toPos = { row: fromPos.row + stepNum, col: fromPos.col };
                    } else {
                        toPos = { row: fromPos.row - stepNum, col: fromPos.col };
                    }
                } else if (direction === 'å¹³') {
                    toPos = { row: fromPos.row, col: stepNum - 1 }; // è½‰æ›ç‚º0åŸºç´¢å¼•
                }

                if (!toPos || toPos.row < 0 || toPos.row >= 10 || toPos.col < 0 || toPos.col >= 9) {
                    console.warn(`âš ï¸ è¨ˆç®—å‡ºç„¡æ•ˆçš„ç›®æ¨™ä½ç½®:`, toPos);
                    return null;
                }

                console.log(`âœ… è§£ææˆåŠŸ: ${notation} -> from:${fromPos.row},${fromPos.col} to:${toPos.row},${toPos.col}`);

                return {
                    from: fromPos,
                    to: toPos
                };

            } catch (error) {
                console.error(`ğŸš« parseChineseNotationToCoords éŒ¯èª¤:`, error);
                return null;
            }
        }

// ğŸ†• è¼”åŠ©æ–¹æ³•ï¼šç²å–ç•¶å‰æ£‹ç›¤ç‹€æ…‹
        getCurrentBoardState(moveIndex) {
            try {
                if (this.historyManager && typeof this.historyManager.getHistory === 'function') {
                    const history = this.historyManager.getHistory();
                    if (moveIndex < history.length) {
                        return history[moveIndex].board;
                    }
                }
                return null;
            } catch (error) {
                console.error(`ğŸš« ç²å–æ£‹ç›¤ç‹€æ…‹éŒ¯èª¤:`, error);
                return null;
            }
        }


// ä¿®æ­£å¾Œçš„è¨˜è­œè§£æ

// 1. ä¿®æ­£ findPiecePositions å‡½æ•¸
        findPiecePositions(board, pieceType, player) {
            const positions = [];

            try {
                for (let row = 0; row < board.length; row++) {
                    if (!board[row]) continue;

                    for (let col = 0; col < board[row].length; col++) {
                        const cell = board[row][col];
                        // ğŸ”§ ä¿®æ­£ï¼šä½¿ç”¨ color è€Œä¸æ˜¯ player
                        if (cell && cell.type === pieceType && cell.color === player) {
                            positions.push({ row, col });
                        }
                    }
                }
            } catch (error) {
                console.error(`ğŸš« æŸ¥æ‰¾æ£‹å­ä½ç½®éŒ¯èª¤:`, error);
            }

            return positions;
        }

// ä¿®å¾©å¾Œçš„ parseMove æ–¹æ³• - å®Œæ•´æ”¯æ´å‰ç¶´è©é‚è¼¯
        parseMove(notation, board, player) {
            try {
                console.log(`ğŸ” parseMove: è§£æ "${notation}" (${player})`);

                // 1. åŸºæœ¬åƒæ•¸é©—è­‰
                if (!notation || typeof notation !== 'string') {
                    console.warn('âš ï¸ parseMove: notation ç„¡æ•ˆæˆ–ç‚ºç©º');
                    return null;
                }

                if (!board || !Array.isArray(board)) {
                    console.warn('âš ï¸ parseMove: board ç„¡æ•ˆæˆ–ä¸æ˜¯é™£åˆ—');
                    return null;
                }

                if (!player || (player !== 'red' && player !== 'black')) {
                    console.warn('âš ï¸ parseMove: player åƒæ•¸ç„¡æ•ˆ');
                    return null;
                }

                // 2. é©—è­‰æ£‹ç›¤çµæ§‹
                if (board.length === 0) {
                    console.warn('âš ï¸ parseMove: æ£‹ç›¤ç‚ºç©ºé™£åˆ—');
                    return null;
                }

                for (let i = 0; i < board.length; i++) {
                    if (!Array.isArray(board[i])) {
                        console.warn(`âš ï¸ parseMove: æ£‹ç›¤ç¬¬${i}è¡Œä¸æ˜¯é™£åˆ—`);
                        return null;
                    }
                }

                const boardRows = board.length;
                const boardCols = board[0] ? board[0].length : 0;
                console.log(`ğŸ” æ£‹ç›¤å°ºå¯¸: ${boardRows} x ${boardCols}`);

                // ä¸­æ–‡æ•¸å­—å°æ‡‰
                const chineseNumbers = {
                    'ä¸€': 1, 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4, 'äº”': 5,
                    'å…­': 6, 'ä¸ƒ': 7, 'å…«': 8, 'ä¹': 9,
                    '1': 1, '2': 2, '3': 3, '4': 4, '5': 5,
                    '6': 6, '7': 7, '8': 8, '9': 9
                };

                // æ£‹å­é¡å‹å°æ‡‰ - æ”¯æ´ç´…é»‘æ–¹å°ˆç”¨æ£‹å­åç¨±
                const pieceTypes = {
                    // ç´…æ–¹å°ˆç”¨æ£‹å­åç¨±
                    'ä¿¥': 'ä¿¥',  // ç´…è»Š
                    'å‚Œ': 'å‚Œ',  // ç´…é¦¬
                    'ç›¸': 'ç›¸',  // ç´…ç›¸
                    'ä»•': 'ä»•',  // ç´…ä»•
                    'å¸¥': 'å¸¥',  // ç´…å¸¥
                    'ç‚®': 'ç‚®',  // ç´…ç‚®
                    'å…µ': 'å…µ',  // ç´…å…µ

                    // é»‘æ–¹å°ˆç”¨æ£‹å­åç¨±
                    'è»Š': 'è»Š',  // é»‘è»Š
                    'é¦¬': 'é¦¬',  // é»‘é¦¬
                    'è±¡': 'è±¡',  // é»‘è±¡
                    'å£«': 'å£«',  // é»‘å£«
                    'å°‡': 'å°‡',  // é»‘å°‡
                    'åŒ…': 'åŒ…',  // é»‘åŒ…
                    'å’': 'å’',  // é»‘å’
                };

                // ğŸ†• æ”¯æ´å‰ç¶´è©çš„æ­£å‰‡è¡¨é”å¼
                // æ ¼å¼1: [å‰ç¶´è©][æ£‹å­][å‹•ä½œ][ç›®æ¨™] - å¦‚ "å‰è»Šé€²ä¸€", "åè»Šé€²ä¸€", "å¾Œä¿¥é€²ä¸€", "äºŒå…µå¹³å››"
                // æ ¼å¼2: [æ£‹å­][åˆ—æ•¸][å‹•ä½œ][ç›®æ¨™] - å¦‚ "è»Šä¸€é€²äºŒ", "ä¿¥ä¸€é€²äºŒ"
                // åŒ…å«æ‰€æœ‰å¯èƒ½çš„æ£‹å­ï¼šç´…æ–¹(å¸¥ä»•ç›¸å‚Œä¿¥ç‚®å…µ) + é»‘æ–¹(å°‡å£«è±¡é¦¬è»ŠåŒ…å’) + é€šç”¨(è»Šé¦¬ç›¸è±¡ä»•å£«å¸¥å°‡ç‚®åŒ…å…µå’)
                const prefixMatch = notation.match(/^([å‰å¾Œåä¸­äºŒä¸‰å››])([è»Šé¦¬ç›¸è±¡ä»•å£«å¸¥å°‡ç‚®åŒ…å…µå’ä¿¥å‚Œ])([é€²é€€å¹³])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹1-9])$/);
                const normalMatch = notation.match(/^([è»Šé¦¬ç›¸è±¡ä»•å£«å¸¥å°‡ç‚®åŒ…å…µå’ä¿¥å‚Œ])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹1-9])([é€²é€€å¹³])([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹1-9])$/);

                let hasPrefix = false;
                let prefix = '';
                let pieceChar = '';
                let fromColChar = '';
                let action = '';
                let toChar = '';

                if (prefixMatch) {
                    // æœ‰å‰ç¶´è©çš„æ ¼å¼
                    hasPrefix = true;
                    [, prefix, pieceChar, action, toChar] = prefixMatch;
                    console.log(`ğŸ·ï¸ æª¢æ¸¬åˆ°å‰ç¶´è©æ ¼å¼: ${prefix}${pieceChar}${action}${toChar}`);
                } else if (normalMatch) {
                    // ç„¡å‰ç¶´è©çš„å‚³çµ±æ ¼å¼
                    [, pieceChar, fromColChar, action, toChar] = normalMatch;
                    console.log(`ğŸ·ï¸ æª¢æ¸¬åˆ°å‚³çµ±æ ¼å¼: ${pieceChar}${fromColChar}${action}${toChar}`);
                } else {
                    console.warn(`âš ï¸ parseMove: ç„¡æ³•è§£æè¨˜è™Ÿæ ¼å¼ "${notation}"`);
                    return null;
                }

                // è½‰æ›åˆ°å¯¦éš›æ£‹ç›¤ä¸Šçš„æ£‹å­é¡å‹
                const actualPieceType = pieceTypes[pieceChar];
                if (!actualPieceType) {
                    console.warn(`âš ï¸ parseMove: æœªçŸ¥æ£‹å­é¡å‹ "${pieceChar}"`);
                    return null;
                }

                // ğŸ” æª¢æŸ¥æ£‹å­åç¨±èˆ‡ç©å®¶æ˜¯å¦åŒ¹é…
                const redPieces = ['ä¿¥', 'å‚Œ', 'ç›¸', 'ä»•', 'å¸¥', 'ç‚®', 'å…µ'];
                const blackPieces = ['è»Š', 'é¦¬', 'è±¡', 'å£«', 'å°‡', 'åŒ…', 'å’'];

                const isRedPiece = redPieces.includes(pieceChar);
                const isBlackPiece = blackPieces.includes(pieceChar);

                if ((player === 'red' && isBlackPiece) || (player === 'black' && isRedPiece)) {
                    console.warn(`âš ï¸ parseMove: æ£‹å­åç¨± "${pieceChar}" èˆ‡ç©å®¶ "${player}" ä¸åŒ¹é…`);
                    return null;
                }

                console.log(`ğŸ” æ£‹å­åŒ¹é…æª¢æŸ¥é€šé: ${player}æ–¹ä½¿ç”¨ "${pieceChar}" â†’ "${actualPieceType}"`);


                // æ‰¾å‡ºè©²é¡å‹æ‰€æœ‰æ£‹å­çš„ä½ç½®
                const allPiecePositions = this.findPiecePositions(board, actualPieceType, player);
                console.log(`ğŸ” æ£‹ç›¤ä¸Šæ‰€æœ‰ ${player} çš„ ${actualPieceType}:`, allPiecePositions.map(p => `(${p.row},${p.col})`));

                if (allPiecePositions.length === 0) {
                    console.warn(`âš ï¸ parseMove: æ£‹ç›¤ä¸Šæ‰¾ä¸åˆ° ${player} çš„ ${actualPieceType}`);
                    return null;
                }

                // åº§æ¨™è½‰æ›é‚è¼¯
                const notationColToArrayCol = (notationCol, isRed) => {
                    if (isRed) {
                        return 9 - notationCol; // ç´…æ–¹è¦–è§’ï¼š1è·¯å°æ‡‰ç´¢å¼•8ï¼Œ9è·¯å°æ‡‰ç´¢å¼•0
                    } else {
                        return notationCol - 1;  // é»‘æ–¹è¦–è§’ï¼š1è·¯å°æ‡‰ç´¢å¼•0ï¼Œ9è·¯å°æ‡‰ç´¢å¼•8
                    }
                };

                // ğŸ†• æ ¸å¿ƒé‚è¼¯ï¼šæ ¹æ“šæ˜¯å¦æœ‰å‰ç¶´è©ä¾†é¸æ“‡æ£‹å­
                let selectedPiece = null;

                if (hasPrefix) {
                    // ğŸ·ï¸ **æœ‰å‰ç¶´è©ï¼šå¿½ç•¥åˆ—æ•¸ï¼Œä½¿ç”¨å‰ç¶´è©é‚è¼¯**
                    console.log(`ğŸ·ï¸ ä½¿ç”¨å‰ç¶´è©é¸æ“‡é‚è¼¯: "${prefix}"`);

                    // çµ±ä¸€è™•ç†ã€Œåã€å’Œã€Œå¾Œã€
                    const normalizedPrefix = prefix === 'å' ? 'å¾Œ' : prefix;

                    selectedPiece = this.selectPieceByPrefix(allPiecePositions, normalizedPrefix, player, pieceChar);

                    if (!selectedPiece) {
                        console.warn(`âš ï¸ parseMove: ç„¡æ³•æ ¹æ“šå‰ç¶´è© "${prefix}" é¸æ“‡æ£‹å­`);
                        return null;
                    }

                    console.log(`ğŸ·ï¸ æ ¹æ“šå‰ç¶´è© "${prefix}" é¸ä¸­æ£‹å­: (${selectedPiece.row}, ${selectedPiece.col})`);

                } else {
                    // ğŸ“ **ç„¡å‰ç¶´è©ï¼šä½¿ç”¨å‚³çµ±åˆ—æ•¸é¸æ“‡é‚è¼¯**
                    console.log(`ğŸ“ ä½¿ç”¨å‚³çµ±åˆ—æ•¸é¸æ“‡é‚è¼¯: "${fromColChar}"`);

                    const fromCol = chineseNumbers[fromColChar];
                    if (fromCol === undefined || fromCol < 1 || fromCol > 9) {
                        console.warn(`âš ï¸ parseMove: èµ·å§‹åˆ—è™Ÿè¶…å‡ºç¯„åœ "${fromColChar}" (${fromCol})`);
                        return null;
                    }

                    if (allPiecePositions.length === 1) {
                        selectedPiece = allPiecePositions[0];
                        console.log(`ğŸ“ åªæœ‰ä¸€å€‹${actualPieceType}ï¼Œé¸æ“‡ (${selectedPiece.row},${selectedPiece.col})`);
                    } else {
                        const targetColIndex = notationColToArrayCol(fromCol, player === 'red');

                        if (targetColIndex < 0 || targetColIndex >= 9) {
                            console.warn(`âš ï¸ parseMove: è½‰æ›å¾Œçš„åˆ—ç´¢å¼•è¶…å‡ºç¯„åœ ${targetColIndex}`);
                            return null;
                        }

                        const exactMatches = allPiecePositions.filter(p => p.col === targetColIndex);

                        if (exactMatches.length === 1) {
                            selectedPiece = exactMatches[0];
                            console.log(`ğŸ“ åœ¨åˆ—${fromCol}æ‰¾åˆ°å”¯ä¸€${actualPieceType}: (${selectedPiece.row},${selectedPiece.col})`);
                        } else if (exactMatches.length > 1) {
                            selectedPiece = exactMatches[0];
                            console.log(`âš ï¸ åŒä¸€åˆ—æœ‰å¤šå€‹${actualPieceType}ï¼Œé¸æ“‡ç¬¬ä¸€å€‹: (${selectedPiece.row},${selectedPiece.col})`);
                        } else {
                            console.warn(`âš ï¸ åœ¨åˆ—${fromCol}æ‰¾ä¸åˆ°${actualPieceType}`);
                            return null;
                        }
                    }
                }

                if (!selectedPiece) {
                    console.warn(`âš ï¸ parseMove: ç„¡æ³•ç¢ºå®šå…·é«”çš„æ£‹å­ä½ç½®`);
                    return null;
                }

                // è§£æç›®æ¨™æ•¸å­—
                const targetNum = chineseNumbers[toChar];
                if (targetNum === undefined || targetNum < 1 || targetNum > 9) {
                    console.warn(`âš ï¸ parseMove: ç›®æ¨™æ•¸å­—è¶…å‡ºç¯„åœ "${toChar}" (${targetNum})`);
                    return null;
                }

                // è¨ˆç®—ç›®æ¨™ä½ç½®
                let toRow, toCol;
                const fromRow = selectedPiece.row;
                const fromColIndex = selectedPiece.col;

                // ğŸ é¦¬çš„ç‰¹æ®Šç§»å‹•é‚è¼¯ï¼ˆä¿®æ­£ç‰ˆï¼‰
                if (pieceChar === 'é¦¬' || pieceChar === 'å‚Œ') {
                    console.log(`ğŸ è™•ç†${player}æ–¹é¦¬çš„ç§»å‹•: ${notation}`);
                    console.log(`ğŸ èµ·å§‹ä½ç½®: (${fromRow}, ${fromColIndex})`);

                    if (action === 'å¹³') {
                        // é¦¬å¹³ç§»ï¼šç›´æ¥ç§»å‹•åˆ°ç›®æ¨™åˆ—
                        toRow = fromRow;
                        toCol = notationColToArrayCol(targetNum, player === 'red');
                        console.log(`ğŸ é¦¬å¹³ç§»: å¾åˆ—ç´¢å¼•${fromColIndex}åˆ°åˆ—ç´¢å¼•${toCol}`);
                    } else if (action === 'é€²' || action === 'é€€') {
                        // é¦¬é€²/é€€ï¼šæ—¥å­—å½¢æ–œç§»

                        // 1. è¨ˆç®—è¨˜è­œä¸­çš„èµ·å§‹åˆ—å’Œç›®æ¨™åˆ—
                        const fromNotationCol = player === 'red' ? (9 - fromColIndex) : (fromColIndex + 1);
                        const toNotationCol = targetNum;
                        const colDiff = toNotationCol - fromNotationCol; // ä¿ç•™æ­£è² è™Ÿï¼

                        console.log(`ğŸ ${player}æ–¹é¦¬ç§»å‹•åˆ†æ:`);
                        console.log(`   èµ·å§‹: ç¬¬${fromNotationCol}è·¯(é™£åˆ—ç´¢å¼•${fromColIndex})`);
                        console.log(`   ç›®æ¨™: ç¬¬${toNotationCol}è·¯`);
                        console.log(`   è·¯æ•¸å·®: ${toNotationCol} - ${fromNotationCol} = ${colDiff}`);

                        // 2. æ ¹æ“šè·¯æ•¸å·®çš„çµ•å°å€¼æ±ºå®šç§»å‹•æ¨¡å¼
                        const absColDiff = Math.abs(colDiff);
                        let verticalSteps, horizontalSteps;

                        if (absColDiff === 1) {
                            // è·¯æ•¸å·®1ï¼šå…ˆæ©«ç§»1æ ¼ï¼Œå†ç¸±ç§»2æ ¼
                            horizontalSteps = 1;
                            verticalSteps = 2;
                            console.log(`ğŸ ç§»å‹•æ¨¡å¼: æ©«ç§»${horizontalSteps}æ ¼ + ç¸±ç§»${verticalSteps}æ ¼`);
                        } else if (absColDiff === 2) {
                            // è·¯æ•¸å·®2ï¼šå…ˆæ©«ç§»2æ ¼ï¼Œå†ç¸±ç§»1æ ¼
                            horizontalSteps = 2;
                            verticalSteps = 1;
                            console.log(`ğŸ ç§»å‹•æ¨¡å¼: æ©«ç§»${horizontalSteps}æ ¼ + ç¸±ç§»${verticalSteps}æ ¼`);
                        } else {
                            console.warn(`ğŸ éæ³•çš„é¦¬ç§»å‹•: è·¯æ•¸å·®${absColDiff} (æ‡‰ç‚º1æˆ–2)`);
                            return null;
                        }

                        // 3. è¨ˆç®—æ©«ç§»æ–¹å‘å’Œæœ€çµ‚åˆ—ä½ç½®
                        // é—œéµï¼šç´…é»‘é›™æ–¹è¨˜è­œç³»çµ±ç›¸åï¼Œéœ€è¦åˆ†åˆ¥è™•ç†
                        let horizontalDirection;
                        if (player === 'red') {
                            // ç´…æ–¹è¨˜è­œï¼š1-9å¾å³åˆ°å·¦æ’åˆ—
                            // colDiff > 0ï¼šè¨˜è­œå¢åŠ  = ç‰©ç†å‘å·¦ = é™£åˆ—ç´¢å¼•æ¸›å°
                            // colDiff < 0ï¼šè¨˜è­œæ¸›å°‘ = ç‰©ç†å‘å³ = é™£åˆ—ç´¢å¼•å¢å¤§
                            horizontalDirection = colDiff > 0 ? -horizontalSteps : horizontalSteps;
                            console.log(`ğŸ ç´…æ–¹ï¼šè¨˜è­œ${colDiff > 0 ? 'å¢åŠ ' : 'æ¸›å°‘'} = ç‰©ç†${colDiff > 0 ? 'å‘å·¦' : 'å‘å³'}`);
                        } else {
                            // é»‘æ–¹è¨˜è­œï¼š1-9å¾å·¦åˆ°å³æ’åˆ—
                            // colDiff > 0ï¼šè¨˜è­œå¢åŠ  = ç‰©ç†å‘å³ = é™£åˆ—ç´¢å¼•å¢å¤§
                            // colDiff < 0ï¼šè¨˜è­œæ¸›å°‘ = ç‰©ç†å‘å·¦ = é™£åˆ—ç´¢å¼•æ¸›å°
                            horizontalDirection = colDiff > 0 ? horizontalSteps : -horizontalSteps;
                            console.log(`ğŸ é»‘æ–¹ï¼šè¨˜è­œ${colDiff > 0 ? 'å¢åŠ ' : 'æ¸›å°‘'} = ç‰©ç†${colDiff > 0 ? 'å‘å³' : 'å‘å·¦'}`);
                        }
                        toCol = fromColIndex + horizontalDirection;

                        console.log(`ğŸ æ©«ç§»æ–¹å‘: è¨˜è­œ${colDiff > 0 ? 'å¢åŠ ' : 'æ¸›å°‘'} â†’ ç‰©ç†${
                            (player === 'red' && colDiff > 0) || (player === 'black' && colDiff < 0) ? 'å‘å·¦' : 'å‘å³'
                        } ${horizontalSteps}æ ¼`);
                        console.log(`ğŸ é™£åˆ—ç´¢å¼•è®ŠåŒ–: ${fromColIndex} â†’ ${toCol}`);

                        // 4. è¨ˆç®—ç¸±ç§»æ–¹å‘å’Œæœ€çµ‚è¡Œä½ç½®
                        if (action === 'é€²') {
                            // é€²ï¼šå‘å‰ç§»å‹•
                            toRow = player === 'red' ? (fromRow - verticalSteps) : (fromRow + verticalSteps);
                        } else {
                            // é€€ï¼šå‘å¾Œç§»å‹•
                            toRow = player === 'red' ? (fromRow + verticalSteps) : (fromRow - verticalSteps);
                        }

                        console.log(`ğŸ ç¸±ç§»: ${action === 'é€²' ? 'å‘å‰' : 'å‘å¾Œ'} ${verticalSteps}æ­¥`);
                        console.log(`ğŸ æœ€çµ‚ä½ç½®: (${toRow}, ${toCol})`);

                        // 5. é‚Šç•Œæª¢æŸ¥
                        if (toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9) {
                            console.warn(`ğŸ ç§»å‹•è¶…å‡ºé‚Šç•Œ: (${toRow}, ${toCol})`);
                            return null;
                        }

                        // 6. è¼¸å‡ºç§»å‹•æ‘˜è¦
                        const physicalDirection = (player === 'red' && colDiff > 0) || (player === 'black' && colDiff < 0) ? 'å·¦' : 'å³';
                        const actionStr = action === 'é€²' ? 'å‰' : 'å¾Œ';
                        console.log(`ğŸ ${player}æ–¹é¦¬ç§»å‹•ç¸½çµ: ç‰©ç†å‘${physicalDirection}${horizontalSteps}æ ¼å‘${actionStr}${verticalSteps}æ ¼`);
                    }

                } else {
                    // å…¶ä»–æ£‹å­çš„ç§»å‹•é‚è¼¯
                    if (action === 'å¹³') {
                        toRow = fromRow;
                        toCol = notationColToArrayCol(targetNum, player === 'red');
                    } else if (action === 'é€²' || action === 'é€€') {
                        toCol = fromColIndex;
                        if (action === 'é€²') {
                            toRow = player === 'red' ? (fromRow - targetNum) : (fromRow + targetNum);
                        } else {
                            toRow = player === 'red' ? (fromRow + targetNum) : (fromRow - targetNum);
                        }
                    }
                }

                // é‚Šç•Œæª¢æŸ¥
                if (toRow < 0 || toRow >= 10 || toCol < 0 || toCol >= 9) {
                    console.warn(`âš ï¸ parseMove: ç›®æ¨™ä½ç½®è¶…å‡ºç¯„åœ (${toRow}, ${toCol})`);
                    return null;
                }

                // é©—è­‰ç›®æ¨™ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                if (!board[toRow] || board[toRow][toCol] === undefined) {
                    console.warn(`âš ï¸ parseMove: ç›®æ¨™ä½ç½® (${toRow}, ${toCol}) åœ¨æ£‹ç›¤ä¸Šä¸å­˜åœ¨`);
                    return null;
                }

                const result = {
                    from: { row: fromRow, col: fromColIndex },
                    to: { row: toRow, col: toCol },
                    piece: board[fromRow][fromColIndex],
                    notation: notation,
                    hasPrefix: hasPrefix,
                    prefix: prefix
                };

                console.log(`âœ… parseMove æˆåŠŸè§£æ:`);
                console.log(`   è¨˜è­œ: ${notation} (${player})`);
                console.log(`   ${hasPrefix ? 'å‰ç¶´è©: ' + prefix : 'åˆ—æ•¸é¸æ“‡'}`);
                console.log(`   æ£‹å­: ${actualPieceType}`);
                console.log(`   ç§»å‹•: (${fromRow},${fromColIndex}) â†’ (${toRow},${toCol})`);

                return result;

            } catch (error) {
                console.error(`ğŸš« parseMove éŒ¯èª¤:`, error);
                return null;
            }
        }

// ğŸ†• æ ¹æ“šå‰ç¶´è©é¸æ“‡æ£‹å­çš„è¼”åŠ©æ–¹æ³•
        selectPieceByPrefix(pieces, prefix, player, pieceChar) {
            console.log(`ğŸ·ï¸ selectPieceByPrefix: è™•ç†å‰ç¶´è© "${prefix}"`);

            if (pieces.length <= 1) {
                console.log(`ğŸ·ï¸ åªæœ‰ ${pieces.length} å€‹æ£‹å­ï¼Œç›´æ¥è¿”å›`);
                return pieces[0] || null;
            }

            // æ ¹æ“šå‰ç¶´è©é¡å‹è™•ç†
            switch (prefix) {
                case 'å‰':
                case 'å¾Œ':
                    return this.selectByFrontBack(pieces, prefix, player);

                case 'ä¸­':
                    return this.selectByMiddle(pieces, player, pieceChar);

                case 'äºŒ':
                case 'ä¸‰':
                case 'å››':
                    return this.selectByNumber(pieces, prefix, player, pieceChar);

                default:
                    console.warn(`âš ï¸ æœªçŸ¥çš„å‰ç¶´è©: "${prefix}"`);
                    return null;
            }
        }

// ğŸ†• è™•ç†ã€Œå‰ã€ã€Œå¾Œã€å‰ç¶´è©
        selectByFrontBack(pieces, prefix, player) {
            console.log(`ğŸ·ï¸ è™•ç†å‰å¾Œé¸æ“‡: ${prefix} (${player})`);

            // æŒ‰åŒä¸€åˆ—åˆ†çµ„
            const columnGroups = {};
            pieces.forEach(piece => {
                if (!columnGroups[piece.col]) {
                    columnGroups[piece.col] = [];
                }
                columnGroups[piece.col].push(piece);
            });

            // æ‰¾åˆ°æœ‰å¤šå€‹æ£‹å­çš„åˆ—
            for (const col in columnGroups) {
                const columnPieces = columnGroups[col];
                if (columnPieces.length >= 2) {
                    // æŒ‰è¡Œæ’åº
                    columnPieces.sort((a, b) => a.row - b.row);

                    if (prefix === 'å‰') {
                        // å‰ï¼šé›¢å°æ–¹åº•ç·šè¼ƒè¿‘ï¼ˆæ›´é å‰çš„ä½ç½®ï¼‰
                        const frontPiece = player === 'red' ? columnPieces[0] : columnPieces[columnPieces.length - 1];
                        console.log(`ğŸ·ï¸ é¸æ“‡å‰æ£‹: (${frontPiece.row}, ${frontPiece.col})`);
                        return frontPiece;
                    } else {
                        // å¾Œï¼šé›¢æˆ‘æ–¹åº•ç·šè¼ƒè¿‘ï¼ˆæ›´é å¾Œçš„ä½ç½®ï¼‰
                        const backPiece = player === 'red' ? columnPieces[columnPieces.length - 1] : columnPieces[0];
                        console.log(`ğŸ·ï¸ é¸æ“‡å¾Œæ£‹: (${backPiece.row}, ${backPiece.col})`);
                        return backPiece;
                    }
                }
            }

            console.warn(`âš ï¸ æ‰¾ä¸åˆ°é©åˆçš„${prefix}æ£‹`);
            return null;
        }

// ğŸ†• è™•ç†ã€Œä¸­ã€å‰ç¶´è©ï¼ˆåƒ…é™å…µå’ï¼‰
        selectByMiddle(pieces, player, pieceChar) {
            console.log(`ğŸ·ï¸ è™•ç†ä¸­å…µé¸æ“‡ (${player})`);

            if (pieceChar !== 'å…µ' && pieceChar !== 'å’') {
                console.warn(`âš ï¸ "ä¸­"å‰ç¶´è©åƒ…é©ç”¨æ–¼å…µå’ï¼Œç•¶å‰æ£‹å­: ${pieceChar}`);
                return null;
            }

            // æŒ‰åŒä¸€åˆ—åˆ†çµ„
            const columnGroups = {};
            pieces.forEach(piece => {
                if (!columnGroups[piece.col]) {
                    columnGroups[piece.col] = [];
                }
                columnGroups[piece.col].push(piece);
            });

            // æ‰¾åˆ°æœ‰3å€‹æˆ–ä»¥ä¸Šå…µçš„åˆ—
            for (const col in columnGroups) {
                const columnPieces = columnGroups[col];
                if (columnPieces.length >= 3) {
                    // æŒ‰è¡Œæ’åº
                    columnPieces.sort((a, b) => a.row - b.row);

                    // é¸æ“‡ä¸­é–“çš„å…µ
                    const middleIndex = Math.floor(columnPieces.length / 2);
                    const middlePiece = columnPieces[middleIndex];
                    console.log(`ğŸ·ï¸ é¸æ“‡ä¸­å…µ: (${middlePiece.row}, ${middlePiece.col})`);
                    return middlePiece;
                }
            }

            console.warn(`âš ï¸ æ‰¾ä¸åˆ°é©åˆçš„ä¸­å…µ`);
            return null;
        }

// ğŸ†• è™•ç†ã€ŒäºŒã€ã€Œä¸‰ã€ã€Œå››ã€å‰ç¶´è©ï¼ˆåƒ…é™å…µå’ï¼‰
        selectByNumber(pieces, prefix, player, pieceChar) {
            console.log(`ğŸ·ï¸ è™•ç†æ•¸å­—å‰ç¶´é¸æ“‡: ${prefix} (${player})`);

            if (pieceChar !== 'å…µ' && pieceChar !== 'å’') {
                console.warn(`âš ï¸ æ•¸å­—å‰ç¶´è©åƒ…é©ç”¨æ–¼å…µå’ï¼Œç•¶å‰æ£‹å­: ${pieceChar}`);
                return null;
            }

            const numberMap = { 'äºŒ': 2, 'ä¸‰': 3, 'å››': 4 };
            const targetIndex = numberMap[prefix];

            // æŒ‰åŒä¸€åˆ—åˆ†çµ„
            const columnGroups = {};
            pieces.forEach(piece => {
                if (!columnGroups[piece.col]) {
                    columnGroups[piece.col] = [];
                }
                columnGroups[piece.col].push(piece);
            });

            // æ‰¾åˆ°æœ‰è¶³å¤ å…µæ•¸çš„åˆ—
            for (const col in columnGroups) {
                const columnPieces = columnGroups[col];
                if (columnPieces.length >= targetIndex) {
                    // æŒ‰è¡Œæ’åºï¼šå¾å‰å¾€å¾Œæ•¸
                    if (player === 'red') {
                        columnPieces.sort((a, b) => a.row - b.row); // ç´…æ–¹ï¼šè¡Œè™Ÿå°çš„åœ¨å‰
                    } else {
                        columnPieces.sort((a, b) => b.row - a.row); // é»‘æ–¹ï¼šè¡Œè™Ÿå¤§çš„åœ¨å‰
                    }

                    const selectedPiece = columnPieces[targetIndex - 1]; // æ•¸çµ„å¾0é–‹å§‹
                    console.log(`ğŸ·ï¸ é¸æ“‡ç¬¬${targetIndex}å…µ: (${selectedPiece.row}, ${selectedPiece.col})`);
                    return selectedPiece;
                }
            }

            console.warn(`âš ï¸ æ‰¾ä¸åˆ°é©åˆçš„ç¬¬${targetIndex}å…µ`);
            return null;
        }



        // ç‚º NotationCycleDetector é¡æ·»åŠ çš„ createInitialBoard æ–¹æ³•
        createInitialBoard() {
            try {
                console.log('ğŸ” å‰µå»ºåˆå§‹æ£‹ç›¤ç‹€æ…‹...');

                // å‰µå»º 11x9 çš„æ£‹ç›¤ï¼ˆèˆ‡æ‚¨çš„ initializePieces å‡½æ•¸ä¸€è‡´ï¼‰
                const board = Array(11).fill().map(() => Array(9).fill(null));

                // ç´…æ–¹æ£‹å­ï¼ˆ6-10è¡Œï¼‰
                board[9][0] = { type: 'ä¿¥', color: 'red' };
                board[9][1] = { type: 'å‚Œ', color: 'red' };
                board[9][2] = { type: 'ç›¸', color: 'red' };
                board[9][3] = { type: 'ä»•', color: 'red' };
                board[9][4] = { type: 'å¸¥', color: 'red' };
                board[9][5] = { type: 'ä»•', color: 'red' };
                board[9][6] = { type: 'ç›¸', color: 'red' };
                board[9][7] = { type: 'å‚Œ', color: 'red' };
                board[9][8] = { type: 'ä¿¥', color: 'red' };
                board[7][1] = { type: 'ç‚®', color: 'red' };
                board[7][7] = { type: 'ç‚®', color: 'red' };
                board[6][0] = { type: 'å…µ', color: 'red' };
                board[6][2] = { type: 'å…µ', color: 'red' };
                board[6][4] = { type: 'å…µ', color: 'red' };
                board[6][6] = { type: 'å…µ', color: 'red' };
                board[6][8] = { type: 'å…µ', color: 'red' };

                // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
                board[0][0] = { type: 'è»Š', color: 'black' };
                board[0][1] = { type: 'é¦¬', color: 'black' };
                board[0][2] = { type: 'è±¡', color: 'black' };
                board[0][3] = { type: 'å£«', color: 'black' };
                board[0][4] = { type: 'å°‡', color: 'black' };
                board[0][5] = { type: 'å£«', color: 'black' };
                board[0][6] = { type: 'è±¡', color: 'black' };
                board[0][7] = { type: 'é¦¬', color: 'black' };
                board[0][8] = { type: 'è»Š', color: 'black' };
                board[2][1] = { type: 'åŒ…', color: 'black' };
                board[2][7] = { type: 'åŒ…', color: 'black' };
                board[3][0] = { type: 'å’', color: 'black' };
                board[3][2] = { type: 'å’', color: 'black' };
                board[3][4] = { type: 'å’', color: 'black' };
                board[3][6] = { type: 'å’', color: 'black' };
                board[3][8] = { type: 'å’', color: 'black' };

                console.log('âœ… åˆå§‹æ£‹ç›¤å‰µå»ºæˆåŠŸ');
                return board;

            } catch (error) {
                console.error('ğŸš« å‰µå»ºåˆå§‹æ£‹ç›¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                return null;
            }
        }

// è¼”åŠ©æ–¹æ³•ï¼šç²å–åˆå§‹æ£‹ç›¤ç‹€æ…‹ï¼ˆå¦‚æœæœ‰å…¨å±€çš„ initializePieces å‡½æ•¸ï¼‰
        getInitialBoard() {
            try {
                // æ–¹æ³•1ï¼šå¦‚æœæœ‰å…¨åŸŸçš„ initializePieces å‡½æ•¸
                if (typeof window !== 'undefined' && typeof window.initializePieces === 'function') {
                    console.log('âœ… ä½¿ç”¨å…¨åŸŸ initializePieces å‡½æ•¸');
                    return window.initializePieces();
                }

                // æ–¹æ³•2ï¼šå¦‚æœæœ‰å…¨åŸŸçš„ initializePieces å‡½æ•¸ï¼ˆä¸åœ¨ window ä¸‹ï¼‰
                if (typeof initializePieces === 'function') {
                    console.log('âœ… ä½¿ç”¨å…¨åŸŸ initializePieces å‡½æ•¸');
                    return initializePieces();
                }

                // æ–¹æ³•3ï¼šä½¿ç”¨å…§å»ºçš„å‰µå»ºæ–¹æ³•
                console.log('âœ… ä½¿ç”¨å…§å»º createInitialBoard æ–¹æ³•');
                return this.createInitialBoard();

            } catch (error) {
                console.error('ğŸš« ç²å–åˆå§‹æ£‹ç›¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                return this.createInitialBoard(); // å›é€€åˆ°å…§å»ºæ–¹æ³•
            }
        }


// ==================== è¼”åŠ©æ–¹æ³• ====================

        /**
         * æ¯”å°å…©æ¬¡æª¢æ¸¬çµæœçš„æ ¸å¿ƒæ–¹æ³•ï¼ˆå‡ç´šç‰ˆï¼‰
         * ç¾åœ¨å¯ä»¥æª¢æ¸¬ã€Œé‡æ–°åŠ æ ¹ã€é¡å‹çš„éš±å½¢é•·æ‰
         */
        compareCaptureDetections(firstDetection, secondDetection, currentStep, nextStep, redLongCaptureSequences, blackLongCaptureSequences, previousBoard, currentBoard) {
            console.log(`\nğŸ” é–‹å§‹æ¯”å°æª¢æ¸¬çµæœ...`);

            // å°ç¬¬ä¸€æ¬¡æª¢æ¸¬çš„æ¯å€‹ç›®æ¨™é€²è¡Œæ¯”å°
            firstDetection.forEach(originalTarget => {
                // ğŸ”¥ ä¿®æ­£é€™è£¡ï¼šä½¿ç”¨ originalTarget è€Œä¸æ˜¯ originalOriginalTarget
                const targetKey = `${originalTarget.target.type}@(${originalTarget.targetPos.row},${originalTarget.targetPos.col})`;
                console.log(`\nğŸ¯ æ¯”å°ç›®æ¨™ï¼š${targetKey}`);

                // ğŸ¯ ç¬¬ä¸€æ¢è·¯ï¼šæª¢æŸ¥æ˜¯å¦é€šéé‡æ–°åŠ æ ¹ä¾†åŒ–è§£
                const reRootResult = this.checkReRootEscape(previousBoard, currentBoard, originalTarget.target.color);

                // æª¢æŸ¥é€™å€‹ç‰¹å®šçš„æ£‹å­æ˜¯å¦é€šéé‡æ–°åŠ æ ¹åŒ–è§£
                const specificReRoot = reRootResult.reRootInfo.find(info =>
                    info.escapedPos.row === originalTarget.targetPos.row &&
                    info.escapedPos.col === originalTarget.targetPos.col
                );

                if (specificReRoot) {
                    // âœ… ç™¼ç¾é‡æ–°åŠ æ ¹åŒ–è§£ â†’ è¨˜éŒ„ç‚ºé•·æ‰åºåˆ—
                    console.log(`âœ… [é‡æ–°åŠ æ ¹é•·æ‰] ${nextStep.player}æ–¹é€šéé‡æ–°åŠ æ ¹åŒ–è§£äº†å° ${targetKey} çš„æ”»æ“Š`);

                    const sequence = {
                        captureStep: currentStep.moveIndex,
                        capturePlayer: currentStep.player,
                        captureMove: currentStep.notation,
                        escapeStep: nextStep.moveIndex,
                        escapePlayer: nextStep.player,
                        escapeMove: nextStep.notation,
                        targetType: originalTarget.target.type,
                        targetPosition: originalTarget.targetPos,
                        reason: 'è¢«æ‰æ–¹é€šéé‡æ–°åŠ æ ¹åŒ–è§£æ”»æ“Šï¼ˆéš±å½¢é•·æ‰ï¼‰',
                        escapeType: 'reroot',
                        protectingRoots: specificReRoot.protectingRoots,
                        timestamp: new Date().toISOString()
                    };

                    // æ·»åŠ åˆ°å°æ‡‰ç©å®¶çš„åºåˆ—ä¸­
                    if (currentStep.player === 'red') {
                        redLongCaptureSequences.push(sequence);
                    } else {
                        blackLongCaptureSequences.push(sequence);
                    }

                    console.log(`ğŸ“ å·²è¨˜éŒ„é‡æ–°åŠ æ ¹é•·æ‰åºåˆ—ï¼š${currentStep.player}æ–¹æ‰${originalTarget.target.type}ï¼Œ${nextStep.player}æ–¹é€šéåŠ æ ¹åŒ–è§£`);
                    return; // è™•ç†å®Œæˆï¼Œè·³å‡ºé€™å€‹ç›®æ¨™çš„è™•ç†
                }

                // ğŸ¯ ç¬¬äºŒæ¢è·¯ï¼šåŸæœ‰çš„é€ƒé›¢æª¢æ¸¬é‚è¼¯ï¼ˆä¿æŒä¸è®Šï¼‰
                // åœ¨ç¬¬äºŒæ¬¡æª¢æ¸¬ä¸­å°‹æ‰¾ç›¸åŒçš„ç›®æ¨™
                const stillCapturing = secondDetection.find(currentTarget =>
                    currentTarget.targetPos.row === originalTarget.targetPos.row &&
                    currentTarget.targetPos.col === originalTarget.targetPos.col &&
                    currentTarget.target.type === originalTarget.target.type &&
                    currentTarget.target.color === originalTarget.target.color
                );

                if (stillCapturing) {
                    // é‚„åœ¨æ‰ â†’ è¢«æ‰æ–¹æ²’æœ‰æˆåŠŸåŒ–è§£
                    console.log(`âŒ [ä¸è¨˜éŒ„] ${currentStep.player}æ–¹èµ°å®Œå¾Œä»åœ¨æ‰ ${targetKey} - è¢«æ‰æ–¹ç½®ä¹‹ä¸ç†ï¼Œæ²’æœ‰åŒ–è§£`);
                } else {
                    // ä¸å†æ‰ â†’ è¢«æ‰æ–¹æˆåŠŸåŒ–è§£ï¼ˆé€šéç§»å‹•ç­‰å…¶ä»–æ–¹å¼ï¼‰
                    console.log(`âœ… [è¨˜éŒ„åºåˆ—] ${nextStep.player}æ–¹èµ°å®Œå¾Œï¼Œ${currentStep.player}æ–¹ä¸å†æ‰ ${targetKey} - è¢«æ‰æ–¹æˆåŠŸåŒ–è§£ï¼`);

                    const sequence = {
                        captureStep: currentStep.moveIndex,
                        capturePlayer: currentStep.player,
                        captureMove: currentStep.notation,
                        escapeStep: nextStep.moveIndex,
                        escapePlayer: nextStep.player,
                        escapeMove: nextStep.notation,
                        targetType: originalTarget.target.type,
                        targetPosition: originalTarget.targetPos,
                        reason: 'è¢«æ‰æ–¹æˆåŠŸåŒ–è§£ï¼Œä¸å†è¢«æ‰',
                        timestamp: new Date().toISOString()
                    };

                    // æ·»åŠ åˆ°å°æ‡‰ç©å®¶çš„åºåˆ—ä¸­
                    if (currentStep.player === 'red') {
                        redLongCaptureSequences.push(sequence);
                    } else {
                        blackLongCaptureSequences.push(sequence);
                    }

                    console.log(`ğŸ“ å·²è¨˜éŒ„é•·æ‰åºåˆ—ï¼š${currentStep.player}æ–¹ç¬¬${currentStep.moveIndex}æ­¥æ‰${originalTarget.target.type}ï¼Œ${nextStep.player}æ–¹ç¬¬${nextStep.moveIndex}æ­¥æˆåŠŸåŒ–è§£`);
                }
            });
        }

        analyzeCycleLongCapture(gameRecord, boardHistory, startIndex, endIndex) {
            console.log(`ğŸ” åˆ†æé•¿æ‰ï¼šboardHistoryé•¿åº¦=${boardHistory.length}`);
            console.log(`ğŸ” æ£€æµ‹èŒƒå›´ï¼š${startIndex} - ${endIndex}`);

            // æ·±æ‹·è´è¾…åŠ©å‡½æ•°
            const deepCopyBoard = (board) => {
                if (!board || !Array.isArray(board)) return null;
                return board.map(row => {
                    if (!Array.isArray(row)) return row;
                    return row.map(piece => {
                        if (!piece) return null;
                        return { type: piece.type, color: piece.color };
                    });
                });
            };

            const deepCopyPiece = (piece) => {
                if (!piece) return null;
                return { type: piece.type, color: piece.color };
            };

            const deepCopyPosition = (position) => {
                if (!position) return null;
                return { row: position.row, col: position.col };
            };

            // æ¨¡æ‹Ÿç§»åŠ¨å¹¶è¿”å›æ–°æ£‹ç›˜çŠ¶æ€
            const simulateMove = (board, fromPos, toPos) => {
                const newBoard = deepCopyBoard(board);
                if (!newBoard || !fromPos || !toPos) return null;

                try {
                    // éªŒè¯ä½ç½®æœ‰æ•ˆæ€§
                    if (fromPos.row < 0 || fromPos.row >= newBoard.length ||
                        fromPos.col < 0 || fromPos.col >= newBoard[0].length ||
                        toPos.row < 0 || toPos.row >= newBoard.length ||
                        toPos.col < 0 || toPos.col >= newBoard[0].length) {
                        return null;
                    }

                    // æ‰§è¡Œç§»åŠ¨
                    const movingPiece = newBoard[fromPos.row][fromPos.col];
                    if (!movingPiece) return null;

                    newBoard[toPos.row][toPos.col] = deepCopyPiece(movingPiece);
                    newBoard[fromPos.row][fromPos.col] = null;

                    return newBoard;
                } catch (error) {
                    console.error('ğŸš« æ¨¡æ‹Ÿç§»åŠ¨é”™è¯¯:', error);
                    return null;
                }
            };

            // å†…ç½®å¾ªç¯æ£€æµ‹å™¨
            const internalCycleDetector = (moves) => {
                const minCycleLength = 4; // æœ€å°å¾ªç¯é•¿åº¦
                const maxCycleLength = 10; // æœ€å¤§å¾ªç¯é•¿åº¦
                const sequence = moves.map(m => m.notation);

                for (let len = minCycleLength; len <= maxCycleLength; len++) {
                    if (sequence.length < len * 2) continue;

                    const pattern = sequence.slice(-len);
                    let cycleCount = 0;

                    for (let i = sequence.length - len; i >= 0; i -= len) {
                        if (sequence.slice(i, i + len).join('|') === pattern.join('|')) {
                            cycleCount++;
                        } else {
                            break;
                        }
                    }

                    if (cycleCount >= 2) { // è‡³å°‘æ£€æµ‹åˆ°2æ¬¡å¾ªç¯
                        return {
                            detected: true,
                            cycleCount: cycleCount,
                            cycleLength: len,
                            pattern: pattern
                        };
                    }
                }
                return { detected: false };
            };

            // è½¬æ¢æ£‹è°±æ ¼å¼ä¸ºç§»åŠ¨åºåˆ—
            const moveSequence = this.convertGameRecordToMoveSequence(gameRecord);
            console.log(`ğŸ” ç§»å‹•åºåˆ—é•·åº¦ï¼š${moveSequence.length}`);

            // æ‰§è¡Œå†…ç½®å¾ªç¯æ£€æµ‹
            const cycleResult = internalCycleDetector(moveSequence);
            console.log(`ğŸ”„ å†…ç½®å¾ªç¯æ£€æµ‹ç»“æœï¼š`, cycleResult);

            // åªæœ‰æª¢æ¸¬åˆ°å¾ªç’°æ‰é€²è¡Œé•·æ‰åˆ†æ
            if (!cycleResult.detected) {
                console.log(`âŒ æœªæª¢æ¸¬åˆ°å¾ªç’°ï¼Œä¸é€²è¡Œé•·æ‰åˆ†æ`);
                return {
                    isLongCapture: false,
                    longCapturePlayer: null,
                    reason: 'æœªæª¢æ¸¬åˆ°å±€é¢å¾ªç’°',
                    captureMoves: [],
                    playerCaptureCounts: { red: 0, black: 0 },
                    playerMoveCounts: { red: 0, black: 0 },
                    redCaptureRatio: 0,
                    blackCaptureRatio: 0,
                    totalMoves: 0,
                    internalCycleDetected: false,
                    internalCycleCount: 0,
                    internalCycleLength: 0,
                    redCaptures: [],
                    blackCaptures: []
                };
            }

            // æª¢æ¸¬åˆ°å¾ªç’°ï¼Œé–‹å§‹é€²è¡Œé•·æ‰åˆ†æ
            console.log(`âœ… æª¢æ¸¬åˆ°å¾ªç’°ï¼Œé–‹å§‹é€²è¡Œé•·æ‰åˆ†æ`);
            console.log(`ğŸ”„ å¾ªç’°ä¿¡æ¯ï¼šé•·åº¦=${cycleResult.cycleLength}, æ¬¡æ•¸=${cycleResult.cycleCount}`);

            const allCaptureMoves = [];
            const redMoves = [];
            const blackMoves = [];
            const redCaptures = [];
            const blackCaptures = [];

            // ç¡®ä¿ä¸è¶…å‡ºä»»ä½•æ•°ç»„çš„èŒƒå›´
            const actualEndIndex = Math.min(endIndex, moveSequence.length, boardHistory.length);
            console.log(`ğŸ” å®é™…æ£€æµ‹èŒƒå›´ï¼š${startIndex} - ${actualEndIndex}`);

            // æ ¹æ“šå¾ªç’°ä¿¡æ¯èª¿æ•´åˆ†æç¯„åœ
            const cycleBasedStartIndex = Math.max(
                startIndex,
                moveSequence.length - cycleResult.cycleLength * cycleResult.cycleCount
            );
            console.log(`ğŸ”„ åŸºæ–¼å¾ªç’°çš„åˆ†æç¯„åœï¼š${cycleBasedStartIndex} - ${actualEndIndex}`);

            // å­˜å„²æ¯æ­¥çš„æ‰å­ä¿¡æ¯ï¼Œç”¨æ–¼æª¢æ¸¬é€£çºŒæ‰å­
            const captureSequence = [];

            for (let i = cycleBasedStartIndex; i < actualEndIndex; i++) {
                if (i >= moveSequence.length) {
                    console.warn(`âš ï¸ ç§»åŠ¨åºåˆ—ç´¢å¼•è¶Šç•Œ: ${i}/${moveSequence.length}`);
                    break;
                }

                const originalMove = moveSequence[i];
                const boardIndex = i;

                if (boardIndex >= boardHistory.length) {
                    console.warn(`âš ï¸ æ£‹ç›˜çŠ¶æ€ç´¢å¼•è¶Šç•Œ: ${boardIndex}/${boardHistory.length}`);
                    continue;
                }

                const boardState = boardHistory[boardIndex];
                if (!boardState || !boardState.board) {
                    console.warn(`âš ï¸ æ— æ•ˆçš„æ£‹ç›˜çŠ¶æ€: ${boardIndex}`);
                    continue;
                }

                // è·å– boardBefore
                let boardBefore = null;

                if (i === 0) {
                    // è·å–åˆå§‹æ£‹ç›¤ç‹€æ…‹
                    if (boardState.boardBefore) {
                        boardBefore = boardState.boardBefore;
                        console.log(`âœ… å¾ boardHistory[0].boardBefore ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else if (typeof window !== 'undefined' && typeof window.initializePieces === 'function') {
                        boardBefore = window.initializePieces();
                        console.log(`âœ… ä½¿ç”¨ window.initializePieces() ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else if (typeof initializePieces === 'function') {
                        boardBefore = initializePieces();
                        console.log(`âœ… ä½¿ç”¨ initializePieces() ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else if (typeof this.getInitialBoard === 'function') {
                        boardBefore = this.getInitialBoard();
                        console.log(`âœ… ä½¿ç”¨ getInitialBoard() ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else if (this.historyManager && typeof this.historyManager.getInitialBoard === 'function') {
                        boardBefore = this.historyManager.getInitialBoard();
                        console.log(`âœ… ä½¿ç”¨ historyManager.getInitialBoard() ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else if (typeof this.createInitialBoard === 'function') {
                        boardBefore = this.createInitialBoard();
                        console.log(`âœ… ä½¿ç”¨ createInitialBoard() ç²å–åˆå§‹ç‹€æ…‹`);
                    }
                    else {
                        // ç¡¬ç·¨ç¢¼å‰µå»ºåˆå§‹æ£‹ç›¤
                        console.warn(`âš ï¸ æ²’æœ‰æ‰¾åˆ°ä»»ä½•åˆå§‹æ£‹ç›¤å‰µå»ºæ–¹æ³•ï¼Œä½¿ç”¨ç¡¬ç·¨ç¢¼å‰µå»º`);
                        boardBefore = Array(10).fill().map(() => Array(9).fill(null));

                        // ç´…æ–¹æ£‹å­ï¼ˆ6-10è¡Œï¼‰
                        boardBefore[9][0] = { type: 'ä¿¥', color: 'red' };
                        boardBefore[9][1] = { type: 'å‚Œ', color: 'red' };
                        boardBefore[9][2] = { type: 'ç›¸', color: 'red' };
                        boardBefore[9][3] = { type: 'ä»•', color: 'red' };
                        boardBefore[9][4] = { type: 'å¸¥', color: 'red' };
                        boardBefore[9][5] = { type: 'ä»•', color: 'red' };
                        boardBefore[9][6] = { type: 'ç›¸', color: 'red' };
                        boardBefore[9][7] = { type: 'å‚Œ', color: 'red' };
                        boardBefore[9][8] = { type: 'ä¿¥', color: 'red' };
                        boardBefore[7][1] = { type: 'ç‚®', color: 'red' };
                        boardBefore[7][7] = { type: 'ç‚®', color: 'red' };
                        boardBefore[6][0] = { type: 'å…µ', color: 'red' };
                        boardBefore[6][2] = { type: 'å…µ', color: 'red' };
                        boardBefore[6][4] = { type: 'å…µ', color: 'red' };
                        boardBefore[6][6] = { type: 'å…µ', color: 'red' };
                        boardBefore[6][8] = { type: 'å…µ', color: 'red' };

                        // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
                        boardBefore[0][0] = { type: 'è»Š', color: 'black' };
                        boardBefore[0][1] = { type: 'é¦¬', color: 'black' };
                        boardBefore[0][2] = { type: 'è±¡', color: 'black' };
                        boardBefore[0][3] = { type: 'å£«', color: 'black' };
                        boardBefore[0][4] = { type: 'å°‡', color: 'black' };
                        boardBefore[0][5] = { type: 'å£«', color: 'black' };
                        boardBefore[0][6] = { type: 'è±¡', color: 'black' };
                        boardBefore[0][7] = { type: 'é¦¬', color: 'black' };
                        boardBefore[0][8] = { type: 'è»Š', color: 'black' };
                        boardBefore[2][1] = { type: 'åŒ…', color: 'black' };
                        boardBefore[2][7] = { type: 'åŒ…', color: 'black' };
                        boardBefore[3][0] = { type: 'å’', color: 'black' };
                        boardBefore[3][2] = { type: 'å’', color: 'black' };
                        boardBefore[3][4] = { type: 'å’', color: 'black' };
                        boardBefore[3][6] = { type: 'å’', color: 'black' };
                        boardBefore[3][8] = { type: 'å’', color: 'black' };

                        console.log(`âœ… ç¡¬ç·¨ç¢¼å‰µå»ºåˆå§‹æ£‹ç›¤å®Œæˆ`);
                    }

                    if (boardBefore && Array.isArray(boardBefore) && boardBefore.length === 11) {
                        console.log(`âœ… åˆå§‹æ£‹ç›¤é©—è­‰æˆåŠŸï¼š${boardBefore.length}x${boardBefore[0]?.length || 0}`);
                    } else {
                        console.error(`ğŸš« åˆå§‹æ£‹ç›¤é©—è­‰å¤±æ•—:`, boardBefore);
                        continue;
                    }
                } else {
                    if (boardHistory[i - 1] && boardHistory[i - 1].board) {
                        boardBefore = boardHistory[i - 1].board;
                        console.log(`ğŸ” ç¬¬${i}æ­¥ï¼šå¾ boardHistory[${i-1}] ç²å– boardBefore`);
                    } else {
                        console.warn(`âš ï¸ ç¬¬${i}æ­¥ï¼šç„¡æ³•å¾ boardHistory[${i-1}] ç²å– boardBefore`);
                        continue;
                    }
                }

                console.log(`ğŸ” ç¬¬${i}æ­¥ è§£æ "${originalMove.notation}" (${originalMove.player})`);

                if (!boardBefore) {
                    console.error(`ğŸš« ç¬¬${i}æ­¥ï¼šboardBefore ç‚º nullï¼Œè·³éæ­¤æ­¥é©Ÿ`);
                    continue;
                }

                // è§£æä½ç½®ä¿¡æ¯
                let fromPos = null;
                let toPos = null;

                try {
                    console.log(`ğŸ” å¯ç”¨æ–¹æ³•æª¢æŸ¥:`, {
                        parseMove: typeof this.parseMove,
                        convertNotationToMove: typeof this.convertNotationToMove,
                        notationParser: !!this.notationParser,
                        historyManager: !!this.historyManager
                    });

                    if (typeof this.parseMove === 'function') {
                        const moveInfo = this.parseMove(originalMove.notation, boardBefore, originalMove.player);
                        if (moveInfo) {
                            fromPos = moveInfo.from;
                            toPos = moveInfo.to;
                            console.log(`âœ… parseMove æˆåŠŸ: from(${fromPos?.row},${fromPos?.col}) to(${toPos?.row},${toPos?.col})`);
                        }
                    } else if (typeof this.convertNotationToMove === 'function') {
                        const moveInfo = this.convertNotationToMove(originalMove.notation, boardBefore, originalMove.player);
                        if (moveInfo) {
                            fromPos = moveInfo.from;
                            toPos = moveInfo.to;
                            console.log(`âœ… convertNotationToMove æˆåŠŸ`);
                        }
                    } else if (this.notationParser && typeof this.notationParser.parse === 'function') {
                        const moveInfo = this.notationParser.parse(originalMove.notation, boardBefore, originalMove.player);
                        if (moveInfo) {
                            fromPos = moveInfo.from;
                            toPos = moveInfo.to;
                            console.log(`âœ… notationParser.parse æˆåŠŸ`);
                        }
                    } else {
                        console.error(`ğŸš« æ²’æœ‰æ‰¾åˆ°ä»»ä½•æ£‹è­œè§£ææ–¹æ³•ï¼`);
                    }

                } catch (error) {
                    console.error(`ğŸš« è§£æç¬¬${i}æ­¥ç§»å‹•ä½ç½®æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                }

                // å‰µå»º move å°è±¡
                const move = {
                    ...originalMove,
                    boardAfter: boardState.board,
                    boardBefore: boardBefore,
                    from: fromPos,
                    to: toPos,
                    moveIndex: i
                };

                // è®°å½•æ¯ä¸ªç©å®¶çš„ç§»åŠ¨
                if (move.player === 'red') {
                    redMoves.push(i);
                } else {
                    blackMoves.push(i);
                }

                // *** æ¯æ­¥éƒ½èª¿ç”¨ analyzeMoveCapture æª¢æ¸¬æ‰å­ ***
                let currentCaptureInfo = null;
                if (move.from && move.to) {
                    currentCaptureInfo = this.analyzeMoveCapture(move, move.player);
                    console.log(`ğŸ” ç¬¬${i}æ­¥ ${move.player} ${move.notation} æ‰å­æª¢æ¸¬ï¼š`, currentCaptureInfo);
                } else {
                    console.warn(`âš ï¸ è·³éç¬¬${i}æ­¥ ${move.notation} çš„æ‰å­åˆ†æ - ç¼ºå°‘ä½ç½®ä¿¡æ¯`);
                }

                // å°‡ç•¶å‰æ­¥é©Ÿçš„æ‰å­ä¿¡æ¯åŠ å…¥åºåˆ—
                captureSequence.push({
                    moveIndex: i,
                    player: move.player,
                    notation: move.notation,
                    captureInfo: currentCaptureInfo || [],
                    boardBefore: boardBefore,
                    boardAfter: boardState.board
                });

                if (currentCaptureInfo && currentCaptureInfo.length > 0) {
                    const captureMove = {
                        moveIndex: i,
                        player: move.player,
                        notation: move.notation,
                        captureInfo: currentCaptureInfo
                    };

                    allCaptureMoves.push(captureMove);

                    if (move.player === 'red') {
                        redCaptures.push(...currentCaptureInfo);
                    } else {
                        blackCaptures.push(...currentCaptureInfo);
                    }
                }
            }

// ---------- ä¸»æª¢æ¸¬è¿´åœˆï¼ˆä¿®æ­£ç‰ˆ - åŒ…å«é–“æ¥æ‰å­ï¼‰ ----------
            console.log(`ğŸ” é–‹å§‹ç°¡åŒ–çš„é•·æ‰æª¢æ¸¬...`);
            console.log('ğŸ“Œ captureSequence é•·åº¦:', captureSequence.length);
            if (captureSequence.length === 0) {
                console.warn('âš ï¸ captureSequence ç©ºé™£åˆ—ï¼Œç„¡æ­¥é©Ÿå¯æª¢æ¸¬ï¼');
            }

            const redLongCaptureSequences = [];
            const blackLongCaptureSequences = [];

// å»ºè­°ï¼šå…ˆç¢ºä¿ captureSequence ä»¥ moveIndex å‡åºï¼ˆè‹¥ä½ å·²ç¶“ä¿è­‰å‰‡å¯ç•¥éï¼‰
            captureSequence.sort((x, y) => (x.moveIndex || 0) - (y.moveIndex || 0));

            for (let i = 0; i < captureSequence.length - 1; i++) {
                const currentStep = captureSequence[i];
                const nextStep = captureSequence[i + 1];
                console.log(`\n--> loop i=${i} | current.moveIndex=${currentStep.moveIndex} (${currentStep.player}) -> next.moveIndex=${nextStep.moveIndex} (${nextStep.player})`);

                // ã€ä¿®æ­£ã€‘åˆä½µç›´æ¥æ‰å­å’Œé–“æ¥æ‰å­
                const directCaptures = (currentStep.captureInfo && Array.isArray(currentStep.captureInfo.captureInfo))
                    ? currentStep.captureInfo.captureInfo
                    : [];

                const indirectCaptures = (currentStep.captureInfo && Array.isArray(currentStep.captureInfo.indirectCaptureInfo))
                    ? currentStep.captureInfo.indirectCaptureInfo
                    : [];

                // åˆä½µæ‰€æœ‰æ‰å­ï¼ˆç›´æ¥ + é–“æ¥ï¼‰
                const allCaptures = [...directCaptures, ...indirectCaptures];

                if (allCaptures.length === 0) {
                    console.log(`   ğŸ“Š ç¬¬${currentStep.moveIndex}æ­¥ ${currentStep.player}æ–¹æ²’æœ‰æ‰å­ï¼Œè·³éæª¢æ¸¬`);
                    continue;
                }

                console.log(`   ğŸ“‹ ç¬¬ä¸€æ¬¡æª¢æ¸¬ - ${currentStep.player}æ–¹èµ°å®Œå¾Œæ‰å­ï¼š`);
                console.log(`      â””â”€ ç›´æ¥æ‰å­: ${directCaptures.length} å€‹`);
                console.log(`      â””â”€ é–“æ¥æ‰å­: ${indirectCaptures.length} å€‹`);
                console.log(`      â””â”€ ç¸½è¨ˆ: ${allCaptures.length} å€‹`);

                // é¡¯ç¤ºæ‰€æœ‰æ‰å­è©³æƒ…
                allCaptures.forEach((capture, index) => {
                    const captureType = index < directCaptures.length ? 'ç›´æ¥' : 'é–“æ¥';
                    console.log(`      ${index + 1}. [${captureType}] æ•æ‰ç›®æ¨™:`, capture);
                });

                // ç¬¬äºŒæ¬¡æª¢æ¸¬ï¼ˆä¿æŒä¸è®Šï¼‰
                const secondDetection = this.analyzeCurrentBoardCaptures(nextStep.boardAfter, currentStep.player);
                const secondArr = Array.isArray(secondDetection.captureInfo) ? secondDetection.captureInfo : [];
                const secondIndirectArr = Array.isArray(secondDetection.indirectCaptureInfo) ? secondDetection.indirectCaptureInfo : [];
                const allSecondCaptures = [...secondArr, ...secondIndirectArr];

                console.log(`   ğŸ“‹ ç¬¬äºŒæ¬¡æª¢æ¸¬ - å°æ‰‹èµ°å®Œå¾Œ${currentStep.player}æ–¹ä»å¯æ‰å­ï¼š`);
                console.log(`      â””â”€ ç›´æ¥æ‰å­: ${secondArr.length} å€‹`);
                console.log(`      â””â”€ é–“æ¥æ‰å­: ${secondIndirectArr.length} å€‹`);
                console.log(`      â””â”€ ç¸½è¨ˆ: ${allSecondCaptures.length} å€‹`);

                // ğŸ”¥ é—œéµä¿®æ”¹ï¼šå‚³å…¥æ£‹ç›¤å¿«ç…§
                // ç¢ºä¿ currentStep å’Œ nextStep åŒ…å« boardAfter å±¬æ€§
                this.compareCaptureDetections(
                    allCaptures,           // ç¬¬ä¸€æ¬¡æª¢æ¸¬ï¼šç›´æ¥ + é–“æ¥æ‰å­
                    allSecondCaptures,     // ç¬¬äºŒæ¬¡æª¢æ¸¬ï¼šç›´æ¥ + é–“æ¥æ‰å­
                    currentStep,
                    nextStep,
                    redLongCaptureSequences,
                    blackLongCaptureSequences,
                    currentStep.boardAfter,  // ğŸ†• ç¬¬ä¸€æ­¥å¾Œçš„æ£‹ç›¤ç‹€æ…‹
                    nextStep.boardAfter      // ğŸ†• ç¬¬äºŒæ­¥å¾Œçš„æ£‹ç›¤ç‹€æ…‹
                );
            }

// åœ¨åˆ¤å®šé•·æ‰ä¹‹å‰ï¼Œéæ¿¾æ‰äº«æœ‰å°‡å¸¥å…µå’ç‰¹æ¬Šçš„åºåˆ—
            console.log(`\nğŸ“ˆ æª¢æ¸¬çµæœæ‘˜è¦ï¼š`);
            console.log(`ğŸ”´ ç´…æ–¹é•·æ‰åºåˆ—ï¼š${redLongCaptureSequences.length} å€‹`, redLongCaptureSequences);
            console.log(`âš« é»‘æ–¹é•·æ‰åºåˆ—ï¼š${blackLongCaptureSequences.length} å€‹`, blackLongCaptureSequences);

// è©³ç´°æª¢æŸ¥é»‘æ–¹åºåˆ—çµæ§‹
            if (blackLongCaptureSequences.length > 0) {
                console.log(`\nğŸ” è©³ç´°æª¢æŸ¥é»‘æ–¹é•·æ‰åºåˆ—çµæ§‹ï¼š`);
                blackLongCaptureSequences.forEach((seq, index) => {
                    console.log(`   åºåˆ—${index + 1}:`, seq);
                    console.log(`   - moves:`, seq.moves);
                    console.log(`   - targetPiece:`, seq.targetPiece);
                });
            }

// ã€å®Œå…¨ä¿®å¾©ç‰ˆã€‘ç¨ç«‹åˆ¤å®šé‚è¼¯ - ä¿®å¾©å¤šå€‹ç›¸åŒæ£‹å­çš„è¿½è¹¤å•é¡Œ
            const checkTargetConsistencyWithTracking = (captureSequence, longCaptureSequences, playerColor, gameHistory = null, gameRecord = null) => {
                console.log(`\nğŸ¯ é–‹å§‹æª¢æŸ¥${playerColor}æ–¹ç›®æ¨™ä¸€è‡´æ€§ï¼Œå…±${longCaptureSequences.length}å€‹é•·æ‰åºåˆ—éœ€è¦é©—è­‰`);
                console.log('ğŸ“‹ è¼¸å…¥æ•¸æ“šæª¢æŸ¥:');
                console.log('   - captureSequenceé•·åº¦:', captureSequence?.length || 0);
                console.log('   - gameHistory:', gameHistory ? 'æœ‰æ•¸æ“š' : 'ç„¡æ•¸æ“š');
                console.log('   - gameRecord:', gameRecord ? 'æœ‰æ•¸æ“š' : 'ç„¡æ•¸æ“š');

                // ã€ä¿®æ­£1ã€‘å»ºç«‹å…¨å±€æ‰å­æ­¥é©Ÿæ˜ å°„è¡¨æ™‚åŒ…å«é–“æ¥æ‰å­
                const globalCaptureSteps = new Map();
                const playerCaptureSteps = [];

                captureSequence
                    .filter(step => {
                        if (step.player !== playerColor) return false;

                        // æª¢æŸ¥ç›´æ¥æ‰å­
                        const hasDirectCapture = step.captureInfo &&
                            step.captureInfo.captureInfo &&
                            step.captureInfo.captureInfo.length > 0;

                        // æª¢æŸ¥é–“æ¥æ‰å­
                        const hasIndirectCapture = step.captureInfo &&
                            step.captureInfo.indirectCaptureInfo &&
                            step.captureInfo.indirectCaptureInfo.length > 0;

                        return hasDirectCapture || hasIndirectCapture;
                    })
                    .forEach(step => {
                        globalCaptureSteps.set(step.moveIndex, step);
                        playerCaptureSteps.push(step.moveIndex);
                    });

                playerCaptureSteps.sort((a, b) => a - b);
                console.log(`ğŸ“Š ${playerColor}æ–¹çš„æ‰€æœ‰æ‰å­æ­¥é©Ÿ:`, playerCaptureSteps);
                console.log(`ğŸ“Š å…¨å±€æ‰å­æ­¥é©Ÿæ˜ å°„è¡¨:`, Array.from(globalCaptureSteps.keys()));

                // ã€ä¿®å¾©ã€‘å‰µå»ºæ¨™æº–è±¡æ£‹åˆå§‹æ£‹ç›¤
                function createStandardChessBoard() {
                    const board = Array(11).fill(null).map(() => Array(9).fill(null));

                    // ç´…æ–¹æ£‹å­ï¼ˆ6-10è¡Œï¼‰
                    board[9][0] = { type: 'ä¿¥', color: 'red' };
                    board[9][1] = { type: 'å‚Œ', color: 'red' };
                    board[9][2] = { type: 'ç›¸', color: 'red' };
                    board[9][3] = { type: 'ä»•', color: 'red' };
                    board[9][4] = { type: 'å¸¥', color: 'red' };
                    board[9][5] = { type: 'ä»•', color: 'red' };
                    board[9][6] = { type: 'ç›¸', color: 'red' };
                    board[9][7] = { type: 'å‚Œ', color: 'red' };
                    board[9][8] = { type: 'ä¿¥', color: 'red' };
                    board[7][1] = { type: 'ç‚®', color: 'red' };
                    board[7][7] = { type: 'ç‚®', color: 'red' };
                    board[6][0] = { type: 'å…µ', color: 'red' };
                    board[6][2] = { type: 'å…µ', color: 'red' };
                    board[6][4] = { type: 'å…µ', color: 'red' };
                    board[6][6] = { type: 'å…µ', color: 'red' };
                    board[6][8] = { type: 'å…µ', color: 'red' };

                    // é»‘æ–¹æ£‹å­ï¼ˆ0-4è¡Œï¼‰
                    board[0][0] = { type: 'è»Š', color: 'black' };
                    board[0][1] = { type: 'é¦¬', color: 'black' };
                    board[0][2] = { type: 'è±¡', color: 'black' };
                    board[0][3] = { type: 'å£«', color: 'black' };
                    board[0][4] = { type: 'å°‡', color: 'black' };
                    board[0][5] = { type: 'å£«', color: 'black' };
                    board[0][6] = { type: 'è±¡', color: 'black' };
                    board[0][7] = { type: 'é¦¬', color: 'black' };
                    board[0][8] = { type: 'è»Š', color: 'black' };
                    board[2][1] = { type: 'åŒ…', color: 'black' };
                    board[2][7] = { type: 'åŒ…', color: 'black' };
                    board[3][0] = { type: 'å’', color: 'black' };
                    board[3][2] = { type: 'å’', color: 'black' };
                    board[3][4] = { type: 'å’', color: 'black' };
                    board[3][6] = { type: 'å’', color: 'black' };
                    board[3][8] = { type: 'å’', color: 'black' };

                    console.log('âœ… å‰µå»ºæ¨™æº–è±¡æ£‹åˆå§‹æ£‹ç›¤');
                    return board;
                }

                // ã€æ™ºèƒ½æ•¸æ“šæºæª¢æ¸¬ã€‘
                let effectiveGameRecord = null;
                let effectiveInitialBoard = null;

                if (gameRecord && Array.isArray(gameRecord)) {
                    effectiveGameRecord = gameRecord;
                    console.log('âœ… ä½¿ç”¨ç›´æ¥å‚³å…¥çš„gameRecord');
                } else if (gameHistory && gameHistory.gameRecord && Array.isArray(gameHistory.gameRecord)) {
                    effectiveGameRecord = gameHistory.gameRecord;
                    console.log('âœ… ä½¿ç”¨gameHistory.gameRecord');
                } else if (captureSequence && captureSequence.length > 0) {
                    console.log('ğŸ”„ å˜—è©¦å¾captureSequenceé‡å»ºæ£‹è­œ...');
                    effectiveGameRecord = reconstructGameRecordFromCaptureSequence(captureSequence);
                }

                if (gameHistory && gameHistory.initialBoard) {
                    effectiveInitialBoard = gameHistory.initialBoard;
                    console.log('âœ… ä½¿ç”¨gameHistory.initialBoard');
                } else if (captureSequence.length > 0 && captureSequence[0].board) {
                    effectiveInitialBoard = captureSequence[0].board;
                    console.log('âœ… ä½¿ç”¨captureSequence[0].board');
                } else {
                    effectiveInitialBoard = createStandardChessBoard();
                    console.log('âœ… ä½¿ç”¨æ¨™æº–è±¡æ£‹åˆå§‹æ£‹ç›¤');
                }

                console.log(`ğŸ“‹ æœ€çµ‚æ•¸æ“šæº: æ£‹è­œè¨˜éŒ„${effectiveGameRecord ? effectiveGameRecord.length + 'æ¢' : 'ç„¡'}, åˆå§‹æ£‹ç›¤${effectiveInitialBoard ? 'æœ‰' : 'ç„¡'}`);

                // ã€ä¿®å¾©ã€‘å¾captureSequenceé‡å»ºæ£‹è­œ
                function reconstructGameRecordFromCaptureSequence(captureSequence) {
                    console.log('ğŸ”„ å¾captureSequenceé‡å»ºæ£‹è­œè¨˜éŒ„...');
                    console.log('ğŸ“Š captureSequenceçµæ§‹åˆ†æ:');

                    if (captureSequence.length > 0) {
                        console.log('   ç¬¬ä¸€é …çµæ§‹:', Object.keys(captureSequence[0]));
                    }

                    const gameRecord = [];
                    const moveMap = new Map();

                    for (const step of captureSequence) {
                        let move = step.notation || step.move || step.moveNotation;
                        let moveIndex = step.moveIndex;
                        let player = step.player;

                        if (move && player && moveIndex) {
                            moveMap.set(moveIndex, { player: player, move: move });
                            console.log(`   âœ… æ”¶é›†åˆ°ç§»å‹•: ç¬¬${moveIndex}æ­¥ ${player} ${move}`);
                        }
                    }

                    if (moveMap.size === 0) {
                        console.log('   âŒ æ²’æœ‰å¾captureSequenceä¸­æå–åˆ°ä»»ä½•ç§»å‹•');
                        return null;
                    }

                    const sortedMoves = Array.from(moveMap.entries()).sort((a, b) => a[0] - b[0]);
                    console.log(`   ğŸ“‹ æ’åºå¾Œçš„ç§»å‹•: ${sortedMoves.length} å€‹`);

                    for (let i = 0; i < sortedMoves.length; i += 2) {
                        const record = {};
                        const [moveIndex1, move1] = sortedMoves[i] || [];
                        const [moveIndex2, move2] = sortedMoves[i + 1] || [];

                        if (move1) {
                            if (move1.player === 'red') {
                                record.red = move1.move;
                            } else {
                                record.black = move1.move;
                            }
                        }

                        if (move2) {
                            if (move2.player === 'red') {
                                record.red = move2.move;
                            } else {
                                record.black = move2.move;
                            }
                        }

                        if (Object.keys(record).length > 0) {
                            gameRecord.push(record);
                            console.log(`   âœ… å‰µå»ºå›åˆè¨˜éŒ„:`, record);
                        }
                    }

                    console.log(`âœ… é‡å»ºäº†${gameRecord.length}è¼ªæ£‹è­œè¨˜éŒ„`);
                    return gameRecord.length > 0 ? gameRecord : null;
                }

                // ã€é—œéµä¿®å¾©ã€‘å¯¦æ™‚æ£‹ç›¤ç‹€æ…‹è¿½è¹¤å™¨
                class RealTimeBoardTracker {
                    constructor() {
                        this.boardState = new Map();
                        this.pieceById = new Map();
                        this.moveHistory = [];
                        this.pieceIdCounter = 0;
                        this.currentMoveIndex = 0;
                        // ã€æ–°å¢ã€‘ä½ç½®åˆ°æ£‹å­IDçš„æ˜ å°„ï¼Œç”¨æ–¼ç²¾ç¢ºè¿½è¹¤
                        this.positionToPieceId = new Map();
                    }

                    // åˆå§‹åŒ–æ£‹ç›¤
                    initializeBoard(initialBoard) {
                        this.boardState.clear();
                        this.pieceById.clear();
                        this.positionToPieceId.clear();
                        this.pieceIdCounter = 0;
                        this.currentMoveIndex = 0;

                        if (!initialBoard) {
                            console.log('âš ï¸ æ²’æœ‰æä¾›åˆå§‹æ£‹ç›¤');
                            return;
                        }

                        for (let row = 0; row < initialBoard.length; row++) {
                            if (!initialBoard[row]) continue;
                            for (let col = 0; col < initialBoard[row].length; col++) {
                                const piece = initialBoard[row][col];
                                if (piece && piece.type) {
                                    // ã€ä¿®å¾©ã€‘ç‚ºæ¯å€‹æ£‹å­å‰µå»ºå”¯ä¸€IDï¼ŒåŒ…å«ä½ç½®ä¿¡æ¯
                                    const pieceId = `${piece.color}_${piece.type}_${row}_${col}_${this.pieceIdCounter++}`;
                                    const pos = `${row},${col}`;

                                    const pieceInfo = {
                                        id: pieceId,
                                        type: piece.type,
                                        color: piece.color,
                                        currentPos: pos,
                                        originalPos: pos, // ã€æ–°å¢ã€‘è¨˜éŒ„åŸå§‹ä½ç½®
                                        history: [pos]
                                    };

                                    this.boardState.set(pos, pieceInfo);
                                    this.pieceById.set(pieceId, pieceInfo);
                                    this.positionToPieceId.set(pos, pieceId);
                                }
                            }
                        }
                        console.log(`âœ… åˆå§‹åŒ–æ£‹ç›¤å®Œæˆï¼Œå…± ${this.boardState.size} å€‹æ£‹å­`);
                    }

                    // ã€é—œéµã€‘åŒæ­¥åˆ°æŒ‡å®šç§»å‹•æ­¥æ•¸çš„æ£‹ç›¤ç‹€æ…‹
                    syncToMoveIndex(targetMoveIndex, captureSequence) {
                        console.log(`\nğŸ”„ åŒæ­¥æ£‹ç›¤ç‹€æ…‹åˆ°ç¬¬${targetMoveIndex}æ­¥...`);

                        if (this.currentMoveIndex >= targetMoveIndex) {
                            console.log(`   âœ… æ£‹ç›¤å·²æ˜¯ç¬¬${this.currentMoveIndex}æ­¥ç‹€æ…‹ï¼Œç„¡éœ€åŒæ­¥`);
                            return;
                        }

                        // æ‰¾åˆ°æ‰€æœ‰éœ€è¦åŸ·è¡Œçš„ç§»å‹•
                        const movesToExecute = captureSequence.filter(step =>
                            step.moveIndex > this.currentMoveIndex && step.moveIndex <= targetMoveIndex
                        ).sort((a, b) => a.moveIndex - b.moveIndex);

                        console.log(`   ğŸ“‹ éœ€è¦åŸ·è¡Œ ${movesToExecute.length} å€‹ç§»å‹•`);

                        for (const step of movesToExecute) {
                            this.executeMoveStep(step);
                        }

                        this.currentMoveIndex = targetMoveIndex;
                        console.log(`   âœ… æ£‹ç›¤ç‹€æ…‹å·²åŒæ­¥åˆ°ç¬¬${targetMoveIndex}æ­¥`);
                    }

                    // ã€æ–°å¢ã€‘åŸ·è¡Œå–®æ­¥ç§»å‹•ä¸¦æ›´æ–°æ£‹ç›¤ç‹€æ…‹
                    executeMoveStep(step) {
                        console.log(`\nğŸ¯ åŸ·è¡Œç¬¬${step.moveIndex}æ­¥: ${step.player} ${step.notation}`);

                        // ã€é—œéµã€‘ä½¿ç”¨æ­¥é©Ÿä¸­çš„boardAfterä¾†æ›´æ–°æ£‹ç›¤ç‹€æ…‹
                        if (step.boardAfter) {
                            console.log('   ğŸ”„ ä½¿ç”¨boardAfteræ›´æ–°æ£‹ç›¤ç‹€æ…‹');
                            this.updateBoardFromSnapshot(step.boardAfter);
                            return;
                        }

                        // ã€å‚™ç”¨ã€‘å¦‚æœæ²’æœ‰boardAfterï¼Œå˜—è©¦è§£æç§»å‹•
                        console.log('   âš ï¸ æ²’æœ‰boardAfterï¼Œå˜—è©¦è§£æç§»å‹•');
                    }

                    // ã€ä¿®å¾©ã€‘å¾æ£‹ç›¤å¿«ç…§æ›´æ–°ç‹€æ…‹ - ç²¾ç¢ºè¿½è¹¤æ£‹å­ç§»å‹•
                    updateBoardFromSnapshot(boardSnapshot) {
                        // ã€é‡è¦ã€‘è¨˜éŒ„æ›´æ–°å‰çš„æ£‹ç›¤ç‹€æ…‹
                        const previousState = new Map(this.boardState);
                        const previousPosToId = new Map(this.positionToPieceId);

                        this.boardState.clear();
                        this.positionToPieceId.clear();

                        // ã€ä¿®å¾©ã€‘å»ºç«‹æ–°èˆŠä½ç½®çš„æ˜ å°„é—œä¿‚
                        const newPositions = new Set();
                        for (let row = 0; row < boardSnapshot.length; row++) {
                            if (!boardSnapshot[row]) continue;
                            for (let col = 0; col < boardSnapshot[row].length; col++) {
                                const piece = boardSnapshot[row][col];
                                if (piece && piece.type) {
                                    newPositions.add(`${row},${col}`);
                                }
                            }
                        }

                        // ã€é—œéµä¿®å¾©ã€‘ç²¾ç¢ºè¿½è¹¤æ¯å€‹æ£‹å­çš„ç§»å‹•
                        const movedPieces = new Map(); // è¿½è¹¤å·²ç¶“è™•ç†éçš„æ£‹å­

                        for (let row = 0; row < boardSnapshot.length; row++) {
                            if (!boardSnapshot[row]) continue;
                            for (let col = 0; col < boardSnapshot[row].length; col++) {
                                const piece = boardSnapshot[row][col];
                                if (piece && piece.type) {
                                    const newPos = `${row},${col}`;
                                    let pieceInfo = null;

                                    // ã€ç­–ç•¥1ã€‘å…ˆæª¢æŸ¥æ˜¯å¦æ˜¯åŒä¸€ä½ç½®çš„æ£‹å­ï¼ˆæœªç§»å‹•ï¼‰
                                    const samePosPieceId = previousPosToId.get(newPos);
                                    if (samePosPieceId) {
                                        const samePosExistingPiece = this.pieceById.get(samePosPieceId);
                                        if (samePosExistingPiece &&
                                            samePosExistingPiece.type === piece.type &&
                                            samePosExistingPiece.color === piece.color &&
                                            !movedPieces.has(samePosPieceId)) {

                                            pieceInfo = samePosExistingPiece;
                                            pieceInfo.currentPos = newPos;
                                            movedPieces.set(samePosPieceId, true);
                                            console.log(`   ğŸ“ æ£‹å­æœªç§»å‹•: ${piece.color} ${piece.type}(${samePosPieceId}) ä¿æŒåœ¨ ${newPos}`);
                                        }
                                    }

                                    // ã€ç­–ç•¥2ã€‘å¦‚æœä¸æ˜¯æœªç§»å‹•çš„æ£‹å­ï¼Œå°‹æ‰¾æœ€è¿‘çš„ç›¸åŒé¡å‹æ£‹å­
                                    if (!pieceInfo) {
                                        let bestMatch = null;
                                        let minDistance = Infinity;

                                        for (const [existingPos, existingPieceId] of previousPosToId.entries()) {
                                            if (movedPieces.has(existingPieceId)) continue;

                                            const existingPiece = this.pieceById.get(existingPieceId);
                                            if (existingPiece &&
                                                existingPiece.type === piece.type &&
                                                existingPiece.color === piece.color) {

                                                const [existingRow, existingCol] = existingPos.split(',').map(Number);
                                                const distance = Math.abs(row - existingRow) + Math.abs(col - existingCol);

                                                if (distance < minDistance) {
                                                    minDistance = distance;
                                                    bestMatch = existingPiece;
                                                }
                                            }
                                        }

                                        if (bestMatch) {
                                            pieceInfo = bestMatch;
                                            pieceInfo.currentPos = newPos;
                                            pieceInfo.history.push(newPos);
                                            movedPieces.set(bestMatch.id, true);

                                            if (minDistance > 0) {
                                                console.log(`   ğŸš€ æ£‹å­ç§»å‹•: ${piece.color} ${piece.type}(${bestMatch.id}) å¾ ${bestMatch.history[bestMatch.history.length - 2]} åˆ° ${newPos} (è·é›¢: ${minDistance})`);
                                            }
                                        }
                                    }

                                    // ã€ç­–ç•¥3ã€‘å¦‚æœé‚„æ˜¯æ‰¾ä¸åˆ°ï¼Œå‰µå»ºæ–°æ£‹å­ï¼ˆå¯èƒ½æ˜¯æ–°å‡ºç¾çš„ï¼‰
                                    if (!pieceInfo) {
                                        const newPieceId = `${piece.color}_${piece.type}_${row}_${col}_${this.pieceIdCounter++}`;
                                        pieceInfo = {
                                            id: newPieceId,
                                            type: piece.type,
                                            color: piece.color,
                                            currentPos: newPos,
                                            originalPos: newPos,
                                            history: [newPos]
                                        };
                                        this.pieceById.set(newPieceId, pieceInfo);
                                        console.log(`   âœ¨ å‰µå»ºæ–°æ£‹å­: ${piece.color} ${piece.type}(${newPieceId}) åœ¨ ${newPos}`);
                                    }

                                    // æ›´æ–°ä½ç½®æ˜ å°„
                                    this.boardState.set(newPos, pieceInfo);
                                    this.positionToPieceId.set(newPos, pieceInfo.id);
                                }
                            }
                        }

                        console.log(`   âœ… æ£‹ç›¤ç‹€æ…‹æ›´æ–°å®Œæˆï¼Œç•¶å‰æœ‰ ${this.boardState.size} å€‹æ£‹å­`);
                    }

                    // ã€ä¿®æ­£ã€‘æ£‹å­è¿½è¹¤å‡½æ•¸çš„æ”¹é€²ç‰ˆæœ¬
                    trackCapturedPiecePosition(captureStep, nextMoveIndex) {
                        console.log(`\nğŸ¯ ã€ä¿®æ­£ç‰ˆã€‘è¿½è¹¤è¢«æ‰æ£‹å­çš„ä½ç½®è®ŠåŒ– (ç¬¬${captureStep.moveIndex}æ­¥ -> ç¬¬${nextMoveIndex}æ­¥)`);

                        // åŒæ­¥åˆ°ç•¶å‰æ­¥é©Ÿçš„æ£‹ç›¤ç‹€æ…‹
                        this.syncToMoveIndex(captureStep.moveIndex, captureSequence);

                        const captureTargets = this.extractCaptureTargets(captureStep);
                        console.log(`   ğŸ“Š æå–åˆ° ${captureTargets.length} å€‹è¢«æ‰ç›®æ¨™`);

                        if (captureTargets.length === 0) {
                            return [];
                        }

                        const trackedTargets = [];

                        for (const target of captureTargets) {
                            console.log(`   ğŸ“ åˆ†æç›®æ¨™: ${target.color} ${target.type} åœ¨ ${target.position}`);

                            // æª¢æŸ¥æ˜¯å¦ç‚ºå·±æ–¹æ£‹å­
                            if (target.color === playerColor) {
                                console.log(`   âš ï¸ è·³éå·±æ–¹æ£‹å­: ${target.color} ${target.type}`);
                                continue;
                            }

                            // ç²¾ç¢ºæŸ¥æ‰¾ç›®æ¨™æ£‹å­
                            let targetPiece = this.findPieceAtPosition(target.position);

                            if (targetPiece && targetPiece.color === target.color && targetPiece.type === target.type) {
                                console.log(`   âœ… æ‰¾åˆ°ç²¾ç¢ºåŒ¹é…: ${targetPiece.color} ${targetPiece.type}(${targetPiece.id}) åœ¨ ${targetPiece.currentPos}`);

                                // è¨˜éŒ„ç•¶å‰ç‹€æ…‹
                                const currentPos = targetPiece.currentPos;
                                const currentId = targetPiece.id;

                                // åŒæ­¥åˆ°ç›®æ¨™æ­¥é©Ÿï¼Œæª¢æŸ¥æ£‹å­ç‹€æ…‹
                                if (nextMoveIndex > captureStep.moveIndex) {
                                    this.syncToMoveIndex(nextMoveIndex, captureSequence);
                                    const updatedPiece = this.pieceById.get(currentId);

                                    if (updatedPiece) {
                                        trackedTargets.push({
                                            originalTarget: target,
                                            pieceId: currentId,
                                            originalPos: currentPos,
                                            newPos: updatedPiece.currentPos,
                                            piece: updatedPiece,
                                            hasEscaped: updatedPiece.currentPos !== currentPos,
                                            trackingMethod: 'precise_id_match'
                                        });

                                        if (updatedPiece.currentPos !== currentPos) {
                                            console.log(`   ğŸƒ æ£‹å­ç§»å‹•: ${currentId} å¾ ${currentPos} -> ${updatedPiece.currentPos}`);
                                        }
                                    } else {
                                        console.log(`   âŒ ç›®æ¨™æ£‹å­ ${currentId} åœ¨ç¬¬${nextMoveIndex}æ­¥æ™‚æ¶ˆå¤±`);
                                    }
                                } else {
                                    // åŒæ­¥å›ç•¶å‰æ­¥é©Ÿ
                                    this.syncToMoveIndex(captureStep.moveIndex, captureSequence);
                                    trackedTargets.push({
                                        originalTarget: target,
                                        pieceId: currentId,
                                        originalPos: currentPos,
                                        newPos: currentPos,
                                        piece: targetPiece,
                                        hasEscaped: false,
                                        trackingMethod: 'current_step_only'
                                    });
                                }
                            } else {
                                console.log(`   âŒ ç„¡æ³•æ‰¾åˆ°åŒ¹é…çš„æ£‹å­: ${target.color} ${target.type} at ${target.position}`);

                                // èª¿è©¦ä¿¡æ¯ï¼šåˆ—å‡ºè©²ä½ç½®é™„è¿‘çš„æ£‹å­
                                console.log(`   ğŸ” è©²ä½ç½®çš„å¯¦éš›æ£‹å­:`);
                                const actualPiece = this.findPieceAtPosition(target.position);
                                if (actualPiece) {
                                    console.log(`      å¯¦éš›: ${actualPiece.color} ${actualPiece.type}(${actualPiece.id})`);
                                } else {
                                    console.log(`      è©²ä½ç½®ç‚ºç©º`);
                                }
                            }
                        }

                        return trackedTargets;
                    }


                    // ã€ä¿®æ­£2ã€‘ä¿®æ”¹ extractCaptureTargets å‡½æ•¸ä»¥åŒ…å«é–“æ¥æ‰å­
                    extractCaptureTargets(captureStep) {
                        const targets = [];
                        console.log('   ğŸ” æå–è¢«æ‰ç›®æ¨™ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰ï¼ŒcaptureStepçµæ§‹:', Object.keys(captureStep));

                        // è™•ç†ç›´æ¥æ‰å­
                        if (captureStep.captureInfo && captureStep.captureInfo.captureInfo) {
                            console.log('   ğŸ“Š è™•ç†ç›´æ¥æ‰å­:', captureStep.captureInfo.captureInfo.length, 'å€‹');
                            for (const capture of captureStep.captureInfo.captureInfo) {
                                const target = this.extractSingleTarget(capture, 'direct');
                                if (target) {
                                    target.captureType = 'direct';
                                    targets.push(target);
                                }
                            }
                        }

                        // è™•ç†é–“æ¥æ‰å­
                        if (captureStep.captureInfo && captureStep.captureInfo.indirectCaptureInfo) {
                            console.log('   ğŸ“Š è™•ç†é–“æ¥æ‰å­:', captureStep.captureInfo.indirectCaptureInfo.length, 'å€‹');
                            for (const capture of captureStep.captureInfo.indirectCaptureInfo) {
                                const target = this.extractSingleTarget(capture, 'indirect');
                                if (target) {
                                    target.captureType = 'indirect';
                                    targets.push(target);
                                }
                            }
                        }

                        console.log(`   ğŸ“Š æœ€çµ‚æå–åˆ° ${targets.length} å€‹ç›®æ¨™:`, targets);
                        return targets;
                    }

                    // ã€ä¿®æ­£3ã€‘ä¿®æ”¹ extractSingleTarget å‡½æ•¸ä»¥è™•ç†ä¸åŒæ ¼å¼
                    extractSingleTarget(capture, captureType = 'direct') {
                        let targetPos = null;
                        let targetType = null;
                        let targetColor = null;
                        let attacker = null;

                        console.log(`   ğŸ” è§£æ${captureType}æ‰å­:`, capture);

                        // è™•ç†ç›®æ¨™ä½ç½®
                        if (capture.targetPos) {
                            targetPos = this.normalizePosition(capture.targetPos);
                        } else if (capture.target && capture.target.position) {
                            targetPos = this.normalizePosition(capture.target.position);
                        }

                        // è™•ç†ç›®æ¨™ä¿¡æ¯
                        if (capture.target) {
                            targetType = capture.target.type;
                            targetColor = capture.target.color;
                        } else if (capture.targetType && capture.targetColor) {
                            targetType = capture.targetType;
                            targetColor = capture.targetColor;
                        }

                        // è™•ç†æ”»æ“Šè€…ä¿¡æ¯ï¼ˆé–“æ¥æ‰å­å¯èƒ½æœ‰å¤šå€‹æ”»æ“Šè€…ï¼‰
                        if (capture.attacker) {
                            attacker = capture.attacker;
                        } else if (capture.attackers && Array.isArray(capture.attackers)) {
                            attacker = capture.attackers[0]; // å–ç¬¬ä¸€å€‹æ”»æ“Šè€…ä½œç‚ºä¸»æ”»æ“Šè€…
                        }

                        if (targetPos && targetType && targetColor) {
                            return {
                                position: targetPos,
                                type: targetType,
                                color: targetColor,
                                captureType: captureType,
                                attacker: attacker
                            };
                        }

                        console.log(`   âŒ ç„¡æ³•è§£æ${captureType}æ‰å­ç›®æ¨™ï¼Œç¼ºå°‘å¿…è¦ä¿¡æ¯`);
                        return null;
                    }

                    // æ¨™æº–åŒ–ä½ç½®
                    normalizePosition(pos) {
                        if (typeof pos === 'string') {
                            return pos;
                        } else if (pos && pos.row !== undefined && pos.col !== undefined) {
                            return `${pos.row},${pos.col}`;
                        }
                        return null;
                    }

                    // åœ¨æŒ‡å®šä½ç½®æŸ¥æ‰¾æ£‹å­
                    findPieceAtPosition(position) {
                        const normalizedPos = this.normalizePosition(position);
                        const piece = this.boardState.get(normalizedPos);
                        if (piece) {
                            console.log(`   âœ… åœ¨ä½ç½® ${normalizedPos} æ‰¾åˆ°æ£‹å­: ${piece.color} ${piece.type}(${piece.id})`);
                        } else {
                            console.log(`   âŒ ä½ç½® ${normalizedPos} æ²’æœ‰æ£‹å­`);
                        }
                        return piece;
                    }

                    // ã€ä¿®å¾©ã€‘æŸ¥æ‰¾æœ€è¿‘çš„ç›¸ä¼¼æ£‹å­ - æ›´ç²¾ç¢ºçš„åŒ¹é…é‚è¼¯
                    findNearestSimilarPiece(target) {
                        console.log(`   ğŸ” æ™ºèƒ½æœç´¢ç›¸ä¼¼æ£‹å­: ${target.color} ${target.type}`);

                        if (!target.type || !target.color) {
                            return null;
                        }

                        const normalizedType = this.normalizeChinesePieceType(target.type);
                        const [targetRow, targetCol] = target.position.split(',').map(Number);
                        let bestMatch = null;
                        let minDistance = Infinity;

                        // ã€é—œéµä¿®å¾©ã€‘åªåœ¨ç›¸åŒé¡å‹å’Œé¡è‰²çš„æ£‹å­ä¸­æŸ¥æ‰¾
                        const candidatePieces = [];
                        for (const piece of this.pieceById.values()) {
                            if (piece.color === target.color &&
                                (piece.type === target.type || piece.type === normalizedType)) {
                                candidatePieces.push(piece);
                            }
                        }

                        console.log(`   ğŸ” æ‰¾åˆ° ${candidatePieces.length} å€‹å€™é¸æ£‹å­:`);
                        candidatePieces.forEach((piece, index) => {
                            console.log(`      ${index + 1}. ${piece.id} åœ¨ ${piece.currentPos}`);
                        });

                        // å¦‚æœåªæœ‰ä¸€å€‹å€™é¸ï¼Œç›´æ¥è¿”å›
                        if (candidatePieces.length === 1) {
                            console.log(`   âœ… å”¯ä¸€åŒ¹é…: ${candidatePieces[0].id}`);
                            return candidatePieces[0];
                        }

                        // å¦‚æœæœ‰å¤šå€‹å€™é¸ï¼Œé¸æ“‡è·é›¢æœ€è¿‘çš„
                        for (const piece of candidatePieces) {
                            const [pieceRow, pieceCol] = piece.currentPos.split(',').map(Number);
                            const distance = Math.abs(targetRow - pieceRow) + Math.abs(targetCol - pieceCol);

                            console.log(`      - ${piece.id}: è·é›¢ ${distance}`);

                            if (distance < minDistance) {
                                minDistance = distance;
                                bestMatch = piece;
                            }
                        }

                        if (bestMatch && minDistance <= 8) { // å¢åŠ å®¹éŒ¯è·é›¢
                            console.log(`   âœ… æ‰¾åˆ°æœ€è¿‘åŒ¹é…: ${bestMatch.color} ${bestMatch.type}(${bestMatch.id}) è·é›¢=${minDistance}`);
                            return bestMatch;
                        }

                        console.log(`   âŒ æ²’æœ‰æ‰¾åˆ°åˆé©çš„åŒ¹é…æ£‹å­`);
                        return null;
                    }

                    // æ¨™æº–åŒ–æ£‹å­é¡å‹
                    normalizeChinesePieceType(chineseType) {
                        const typeMap = {
                            'å¸¥': 'king', 'å°†': 'king', 'å¸…': 'king', 'å°‡': 'king',
                            'ä»•': 'advisor', 'å£«': 'advisor',
                            'ç›¸': 'elephant', 'è±¡': 'elephant',
                            'ä¿¥': 'rook', 'è½¦': 'rook', 'è»Š': 'rook',
                            'å‚Œ': 'knight', 'é©¬': 'knight', 'é¦¬': 'knight',
                            'ç‚®': 'cannon', 'ç ²': 'cannon', 'åŒ…': 'cannon',
                            'å…µ': 'pawn', 'å’': 'pawn'
                        };
                        return typeMap[chineseType] || chineseType;
                    }

                    // èª¿è©¦æ£‹ç›¤ç‹€æ…‹
                    debugBoard() {
                        console.log(`\nğŸ“‹ ç•¶å‰æ£‹ç›¤ç‹€æ…‹ (ç¬¬${this.currentMoveIndex}æ­¥):`);
                        const positions = Array.from(this.boardState.keys()).sort();
                        for (const pos of positions) {
                            const piece = this.boardState.get(pos);
                            console.log(`  ${pos}: ${piece.color} ${piece.type} [${piece.id}]`);
                        }

                        if (positions.length === 0) {
                            console.log('  (ç©ºæ£‹ç›¤)');
                        }
                    }
                }

                // ã€æ ¸å¿ƒä¿®å¾©ã€‘æŸ¥æ‰¾æŒ‡å®šæ­¥é©Ÿçš„ä¸‹ä¸€å€‹æ‰å­æ­¥é©Ÿ
                function findNextCaptureStep(currentMoveIndex, playerCaptureSteps) {
                    console.log(`\nğŸ” æŸ¥æ‰¾ç¬¬${currentMoveIndex}æ­¥ä¹‹å¾Œçš„ä¸‹ä¸€å€‹æ‰å­æ­¥é©Ÿ...`);
                    console.log(`   å¯ç”¨çš„æ‰å­æ­¥é©Ÿ:`, playerCaptureSteps);

                    const nextStep = playerCaptureSteps.find(stepIndex => stepIndex > currentMoveIndex);

                    if (nextStep) {
                        console.log(`   âœ… æ‰¾åˆ°ä¸‹ä¸€å€‹æ‰å­æ­¥é©Ÿ: ç¬¬${nextStep}æ­¥`);
                        return nextStep;
                    } else {
                        console.log(`   âŒ æ²’æœ‰æ‰¾åˆ°ç¬¬${currentMoveIndex}æ­¥ä¹‹å¾Œçš„æ‰å­æ­¥é©Ÿ`);
                        return null;
                    }
                }

                // ã€ä¿®æ­£4ã€‘åœ¨ç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥ä¸­å€åˆ†ç›´æ¥å’Œé–“æ¥æ‰å­
                function performIndependentSequenceAnalysis(longCaptureSequences, playerCaptureSteps, globalCaptureSteps, tracker) {
                    console.log(`\nğŸ¯ é–‹å§‹ç¨ç«‹åºåˆ—åˆ†æ - åŒ…å«é–“æ¥æ‰å­é‚è¼¯...`);

                    const consistentSequences = [];

                    for (let seqIndex = 0; seqIndex < longCaptureSequences.length; seqIndex++) {
                        const sequence = longCaptureSequences[seqIndex];
                        const currentStep = sequence.captureStep;

                        console.log(`\nğŸ“‹ ç¨ç«‹åˆ†æåºåˆ—${seqIndex + 1}: ç¬¬${currentStep}æ­¥ ${sequence.captureMove}`);

                        // æ‰¾åˆ°è­‰æ“šæ­¥é©Ÿ
                        const evidenceStep = findNextCaptureStep(currentStep, playerCaptureSteps);

                        if (!evidenceStep) {
                            console.log(`   âŒ æ‰¾ä¸åˆ°ç¬¬${currentStep}æ­¥çš„è­‰æ“šæ­¥é©Ÿï¼Œç„¡æ³•åˆ¤å®š`);
                            continue;
                        }

                        console.log(`   âœ… æ‰¾åˆ°è­‰æ“šæ­¥é©Ÿ: ç¬¬${evidenceStep}æ­¥`);

                        // ç²å–å…©å€‹æ­¥é©Ÿçš„è©³ç´°æ•¸æ“š
                        const currentCaptureStep = globalCaptureSteps.get(currentStep);
                        const evidenceCaptureStep = globalCaptureSteps.get(evidenceStep);

                        if (!currentCaptureStep || !evidenceCaptureStep) {
                            console.log(`   âŒ ç„¡æ³•ç²å–æ­¥é©Ÿæ•¸æ“š`);
                            continue;
                        }

                        // åˆ†æç•¶å‰æ­¥é©Ÿçš„æ‰å­ç›®æ¨™ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰
                        console.log(`   ğŸ¯ åˆ†æç¬¬${currentStep}æ­¥çš„æ‰å­ç›®æ¨™ï¼ˆç›´æ¥+é–“æ¥ï¼‰:`);
                        tracker.syncToMoveIndex(currentStep, captureSequence);
                        const currentTargets = tracker.extractCaptureTargets(currentCaptureStep);

                        // çµ±è¨ˆç›´æ¥å’Œé–“æ¥æ‰å­æ•¸é‡
                        const directCurrentTargets = currentTargets.filter(t => t.captureType === 'direct');
                        const indirectCurrentTargets = currentTargets.filter(t => t.captureType === 'indirect');

                        console.log(`      ç›´æ¥æ‰å­: ${directCurrentTargets.length} å€‹`);
                        console.log(`      é–“æ¥æ‰å­: ${indirectCurrentTargets.length} å€‹`);

                        // ç‚ºæ¯å€‹ç›®æ¨™ç”Ÿæˆå”¯ä¸€çš„ä½ç½®æ¨™è­˜
                        const currentTargetMap = new Map();
                        for (const target of currentTargets) {
                            const positionKey = `${target.color}_${target.type}_${target.position}`;
                            const targetPiece = tracker.findPieceAtPosition(target.position);

                            if (targetPiece) {
                                currentTargetMap.set(positionKey, {
                                    pieceId: targetPiece.id,
                                    piece: targetPiece,
                                    position: target.position,
                                    moveIndex: currentStep,
                                    positionKey: positionKey,
                                    captureType: target.captureType, // è¨˜éŒ„æ‰å­é¡å‹
                                    attacker: target.attacker
                                });
                                console.log(`      ç›®æ¨™: ${target.color} ${target.type} åœ¨ ${target.position} (ID: ${targetPiece.id}) [${target.captureType}æ‰]`);
                            }
                        }

                        // åˆ†æè­‰æ“šæ­¥é©Ÿçš„æ‰å­ç›®æ¨™ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰
                        console.log(`   ğŸ¯ åˆ†æç¬¬${evidenceStep}æ­¥çš„æ‰å­ç›®æ¨™ï¼ˆç›´æ¥+é–“æ¥ï¼‰:`);
                        tracker.syncToMoveIndex(evidenceStep, captureSequence);
                        const evidenceTargets = tracker.extractCaptureTargets(evidenceCaptureStep);

                        // çµ±è¨ˆè­‰æ“šæ­¥é©Ÿçš„ç›´æ¥å’Œé–“æ¥æ‰å­æ•¸é‡
                        const directEvidenceTargets = evidenceTargets.filter(t => t.captureType === 'direct');
                        const indirectEvidenceTargets = evidenceTargets.filter(t => t.captureType === 'indirect');

                        console.log(`      ç›´æ¥æ‰å­: ${directEvidenceTargets.length} å€‹`);
                        console.log(`      é–“æ¥æ‰å­: ${indirectEvidenceTargets.length} å€‹`);

                        // ç‚ºè­‰æ“šæ­¥é©Ÿçš„ç›®æ¨™ç”Ÿæˆä½ç½®æ¨™è­˜
                        const evidenceTargetMap = new Map();
                        for (const target of evidenceTargets) {
                            const positionKey = `${target.color}_${target.type}_${target.position}`;
                            const targetPiece = tracker.findPieceAtPosition(target.position);

                            if (targetPiece) {
                                evidenceTargetMap.set(positionKey, {
                                    pieceId: targetPiece.id,
                                    piece: targetPiece,
                                    position: target.position,
                                    moveIndex: evidenceStep,
                                    positionKey: positionKey,
                                    captureType: target.captureType, // è¨˜éŒ„æ‰å­é¡å‹
                                    attacker: target.attacker
                                });
                                console.log(`      ç›®æ¨™: ${target.color} ${target.type} åœ¨ ${target.position} (ID: ${targetPiece.id}) [${target.captureType}æ‰]`);
                            }
                        }

                        // ç²¾ç¢ºçš„ç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰
                        console.log(`\nğŸ“Š åºåˆ—${seqIndex + 1} ç›®æ¨™ä¸€è‡´æ€§åˆ†æï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰:`);

                        const consistentTargets = [];
                        const captureTypeTransitions = []; // è¨˜éŒ„æ‰å­é¡å‹è½‰æ›

                        for (const [currentKey, currentTarget] of currentTargetMap.entries()) {
                            let foundConsistentTarget = false;

                            for (const [evidenceKey, evidenceTarget] of evidenceTargetMap.entries()) {
                                // æª¢æŸ¥æ£‹å­IDæ˜¯å¦ç›¸åŒï¼ˆæœ€ç²¾ç¢ºï¼‰
                                if (currentTarget.pieceId === evidenceTarget.pieceId) {
                                    const captureTypeChange = currentTarget.captureType !== evidenceTarget.captureType;

                                    consistentTargets.push({
                                        pieceId: currentTarget.pieceId,
                                        piece: currentTarget.piece,
                                        step1Position: currentTarget.position,
                                        step2Position: evidenceTarget.position,
                                        step1Index: currentStep,
                                        step2Index: evidenceStep,
                                        positionChanged: currentTarget.position !== evidenceTarget.position,
                                        step1CaptureType: currentTarget.captureType,
                                        step2CaptureType: evidenceTarget.captureType,
                                        captureTypeChanged: captureTypeChange,
                                        step1Attacker: currentTarget.attacker,
                                        step2Attacker: evidenceTarget.attacker
                                    });

                                    foundConsistentTarget = true;
                                    console.log(`      âœ… ä¸€è‡´ç›®æ¨™: ${currentTarget.piece.color} ${currentTarget.piece.type}(${currentTarget.pieceId})`);
                                    console.log(`         ç¬¬${currentStep}æ­¥: ${currentTarget.position} [${currentTarget.captureType}æ‰]`);
                                    console.log(`         ç¬¬${evidenceStep}æ­¥: ${evidenceTarget.position} [${evidenceTarget.captureType}æ‰]`);

                                    if (captureTypeChange) {
                                        console.log(`         ğŸ”„ æ‰å­é¡å‹è®ŠåŒ–: ${currentTarget.captureType} -> ${evidenceTarget.captureType}`);
                                        captureTypeTransitions.push({
                                            pieceId: currentTarget.pieceId,
                                            from: currentTarget.captureType,
                                            to: evidenceTarget.captureType
                                        });
                                    }
                                    break;
                                }
                            }
                        }

                        // æ”¹é€²çš„åˆ¤å®šé‚è¼¯ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰
                        if (consistentTargets.length > 0) {
                            const primaryTarget = consistentTargets[0];

                            console.log(`   âœ… ã€åºåˆ—${seqIndex + 1}åˆ¤å®šã€‘ç™¼ç¾æŒçºŒæ”»æ“Šçš„ä¸€è‡´ç›®æ¨™ï¼`);
                            console.log(`      ä¸»è¦ç›®æ¨™: ${primaryTarget.piece.color} ${primaryTarget.piece.type}(${primaryTarget.pieceId})`);
                            console.log(`      æ”»æ“Šæ­¥é©Ÿ: ç¬¬${primaryTarget.step1Index}æ­¥ -> ç¬¬${primaryTarget.step2Index}æ­¥`);
                            console.log(`      æ‰å­é¡å‹: ${primaryTarget.step1CaptureType} -> ${primaryTarget.step2CaptureType}`);

                            let judgmentReason = "";
                            if (primaryTarget.captureTypeChanged) {
                                judgmentReason = `ç›®æ¨™æ£‹å­å¾${primaryTarget.step1CaptureType}æ‰è½‰ç‚º${primaryTarget.step2CaptureType}æ‰ï¼Œä½†æŒçºŒå—åˆ°å¨è„…`;
                            } else if (primaryTarget.positionChanged) {
                                judgmentReason = `ç›®æ¨™æ£‹å­ç§»å‹•å¾Œä»è¢«æŒçºŒ${primaryTarget.step1CaptureType}æ‰`;
                            } else {
                                judgmentReason = `ç›®æ¨™æ£‹å­ä½ç½®å›ºå®šï¼ŒæŒçºŒè¢«${primaryTarget.step1CaptureType}æ‰`;
                            }

                            console.log(`      ğŸ’¡ åˆ¤å®š: ${judgmentReason}`);

                            // é¡¯ç¤ºæ‰å­é¡å‹è½‰æ›æ‘˜è¦
                            if (captureTypeTransitions.length > 0) {
                                console.log(`      ğŸ“Š æ‰å­é¡å‹è½‰æ›æ‘˜è¦:`);
                                for (const transition of captureTypeTransitions) {
                                    console.log(`         - ${transition.pieceId}: ${transition.from} -> ${transition.to}`);
                                }
                            }

                            // å‰µå»ºåŒ…å«é–“æ¥æ‰å­ä¿¡æ¯çš„åˆ¤å®šçµæœ
                            const correctedResult = {
                                ...sequence,
                                evidenceStep: evidenceStep,
                                evidenceMove: evidenceCaptureStep.notation,
                                targetConsistency: {
                                    isConsistent: true,
                                    targetPieceId: primaryTarget.pieceId,
                                    targetInfo: primaryTarget.piece,
                                    attackMoveIndexes: [primaryTarget.step1Index, primaryTarget.step2Index],
                                    positionSequence: [primaryTarget.step1Position, primaryTarget.step2Position],
                                    positionChanged: primaryTarget.positionChanged,
                                    captureTypeSequence: [primaryTarget.step1CaptureType, primaryTarget.step2CaptureType],
                                    captureTypeChanged: primaryTarget.captureTypeChanged,
                                    correctedAnalysis: {
                                        totalConsistentTargets: consistentTargets.length,
                                        primaryTargetId: primaryTarget.pieceId,
                                        analysisMethod: 'åŸºæ–¼æ£‹å­IDçš„ç²¾ç¢ºåŒ¹é…ï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰',
                                        judgmentReason: judgmentReason,
                                        consistentTargets: consistentTargets,
                                        captureTypeTransitions: captureTypeTransitions,
                                        directCaptureCount: {
                                            step1: directCurrentTargets.length,
                                            step2: directEvidenceTargets.length
                                        },
                                        indirectCaptureCount: {
                                            step1: indirectCurrentTargets.length,
                                            step2: indirectEvidenceTargets.length
                                        }
                                    }
                                }
                            };

                            consistentSequences.push(correctedResult);
                            console.log(`   ğŸ¯ åºåˆ—${seqIndex + 1}ç¢ºèªç‚ºç›®æ¨™ä¸€è‡´çš„é•·æ‰è¡Œç‚ºï¼ˆåŒ…å«é–“æ¥æ‰å­ï¼‰`);

                        } else {
                            console.log(`   âŒ æ²’æœ‰ç™¼ç¾ä¸€è‡´çš„æ”»æ“Šç›®æ¨™`);
                            console.log(`   ğŸ“Š ç•¶å‰æ­¥é©Ÿç›®æ¨™: ${Array.from(currentTargetMap.keys()).join(', ')}`);
                            console.log(`   ğŸ“Š è­‰æ“šæ­¥é©Ÿç›®æ¨™: ${Array.from(evidenceTargetMap.keys()).join(', ')}`);
                            console.log(`   ğŸ’¡ åˆ¤å®š: æ”»æ“Šç›®æ¨™ä¸ä¸€è‡´ï¼Œä¸æ§‹æˆé•·æ‰`);
                        }
                    }

                    return consistentSequences;
                }


                // åˆå§‹åŒ–å¯¦æ™‚è¿½è¹¤å™¨
                const tracker = new RealTimeBoardTracker();
                tracker.initializeBoard(effectiveInitialBoard);
                tracker.debugBoard();

                // ã€æ ¸å¿ƒä¿®å¾©ã€‘ä½¿ç”¨ç¨ç«‹åˆ¤å®šé‚è¼¯é€²è¡Œç›®æ¨™ä¸€è‡´æ€§åˆ†æ
                console.log(`\nğŸ¯ é–‹å§‹ç¨ç«‹åˆ¤å®šåˆ†æ...`);
                console.log(`ğŸ“‹ åˆ†æç­–ç•¥èªªæ˜:`);
                console.log(`   - æ¯å€‹åºåˆ—éƒ½æœƒå°‹æ‰¾å¾ŒçºŒè­‰æ“šé€²è¡Œç¨ç«‹åˆ¤å®š`);
                console.log(`   - ç¬¬6æ­¥å€Ÿç”¨ç¬¬8æ­¥ä½œè­‰æ“šåˆ¤å®šç¬¬6æ­¥çš„ä¸€è‡´æ€§`);
                console.log(`   - ç¬¬8æ­¥å€Ÿç”¨ç¬¬10æ­¥ä½œè­‰æ“šåˆ¤å®šç¬¬8æ­¥çš„ä¸€è‡´æ€§`);
                console.log(`   - æ¯å€‹åºåˆ—éƒ½æœ‰è‡ªå·±ç¨ç«‹çš„åˆ¤å®šçµæœ`);
                console.log(`   - ã€ä¿®å¾©ã€‘ç²¾ç¢ºè¿½è¹¤æ¯å€‹æ£‹å­çš„å”¯ä¸€èº«ä»½ï¼Œé¿å…æ··æ·†`);

                const consistentSequences = performIndependentSequenceAnalysis(
                    longCaptureSequences,
                    playerCaptureSteps,
                    globalCaptureSteps,
                    tracker
                );

                // ã€è£œå……ã€‘è™•ç†åŸæœ‰åºåˆ—ä¸­å¸¶æœ‰å…§ç½®movesçš„æƒ…æ³
                console.log(`\nğŸ“‹ æª¢æŸ¥åŸæœ‰åºåˆ—æ˜¯å¦æœ‰å…§ç½®movesï¼ˆè£œå……æª¢æŸ¥ï¼‰...`);
                for (let seqIndex = 0; seqIndex < longCaptureSequences.length; seqIndex++) {
                    const sequence = longCaptureSequences[seqIndex];

                    // å¦‚æœåºåˆ—å…§ç½®äº†å®Œæ•´çš„movesï¼Œä¹Ÿé€²è¡Œåˆ†æ
                    if (sequence.moves && sequence.moves.length >= 2) {
                        console.log(`\nğŸ“‹ ç™¼ç¾å…§ç½®movesåºåˆ—${seqIndex + 1}: [${sequence.moves.join(', ')}]`);

                        const moveIndexesToCheck = sequence.moves;
                        const targetAnalysis = new Map();

                        for (let i = 0; i < moveIndexesToCheck.length; i++) {
                            const moveIndex = moveIndexesToCheck[i];
                            const captureStep = globalCaptureSteps.get(moveIndex);

                            if (!captureStep) {
                                console.log(`   âŒ æ‰¾ä¸åˆ°ç¬¬${moveIndex}æ­¥çš„æ•¸æ“š`);
                                continue;
                            }

                            console.log(`\n   ğŸ“Š åˆ†æç¬¬${moveIndex}æ­¥çš„æ‰å­ç›®æ¨™:`);

                            const trackedTargets = tracker.trackCapturedPiecePosition(
                                captureStep,
                                moveIndexesToCheck[i + 1] || moveIndex + 2
                            );

                            // è¨˜éŒ„ç›®æ¨™åˆ†æ
                            for (const tracked of trackedTargets) {
                                if (!targetAnalysis.has(tracked.pieceId)) {
                                    targetAnalysis.set(tracked.pieceId, {
                                        piece: tracked.piece,
                                        positions: [],
                                        count: 0,
                                        moveIndexes: []
                                    });
                                }

                                const analysis = targetAnalysis.get(tracked.pieceId);
                                analysis.positions.push(tracked.newPos);
                                analysis.moveIndexes.push(moveIndex);
                                analysis.count++;
                            }
                        }

                        // è©•ä¼°ä¸€è‡´æ€§
                        console.log(`\nğŸ“Š å…§ç½®åºåˆ—${seqIndex + 1} ç›®æ¨™åˆ†æçµæœ:`);

                        if (targetAnalysis.size === 1) {
                            const [pieceId, analysis] = Array.from(targetAnalysis.entries())[0];
                            if (analysis.count >= 2) {
                                console.log(`   âœ… ã€å…§ç½®åºåˆ—${seqIndex + 1}ã€‘ç›®æ¨™ä¸€è‡´ï¼`);
                                console.log(`      æŒçºŒæ”»æ“Š ${analysis.piece?.color} ${analysis.piece?.type}(${pieceId}) ${analysis.count}æ¬¡`);

                                // æª¢æŸ¥æ˜¯å¦å·²ç¶“å­˜åœ¨ï¼ˆé¿å…é‡è¤‡ï¼‰
                                const alreadyExists = consistentSequences.some(seq =>
                                    seq.captureStep === sequence.captureStep
                                );

                                if (!alreadyExists) {
                                    consistentSequences.push({
                                        ...sequence,
                                        targetConsistency: {
                                            isConsistent: true,
                                            targetPieceId: pieceId,
                                            targetInfo: analysis.piece,
                                            attackCount: analysis.count,
                                            attackMoveIndexes: analysis.moveIndexes,
                                            positionSequence: analysis.positions,
                                            independentAnalysis: false,
                                            builtInMovesAnalysis: true,
                                            originalSequenceIndex: seqIndex
                                        }
                                    });
                                    console.log(`   ğŸ¯ å…§ç½®åºåˆ—${seqIndex + 1}å·²æ·»åŠ åˆ°ä¸€è‡´æ€§çµæœ`);
                                } else {
                                    console.log(`   â„¹ï¸ å…§ç½®åºåˆ—${seqIndex + 1}å·²å­˜åœ¨ï¼Œè·³éé‡è¤‡æ·»åŠ `);
                                }
                            }
                        }
                    }
                }

                // ã€æœ€çµ‚çµ±è¨ˆå’Œçµæœå±•ç¤ºã€‘
                console.log(`\nğŸ¯ ${playerColor}æ–¹ç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥å®Œæˆï¼ˆç¨ç«‹åˆ¤å®šç‰ˆï¼‰ï¼š`);
                console.log(`   åŸå§‹åºåˆ—æ•¸é‡: ${longCaptureSequences.length} å€‹`);
                console.log(`   å…¨å±€æ‰å­æ­¥é©Ÿ: [${playerCaptureSteps.join(', ')}]`);
                console.log(`   ç¨ç«‹åˆ¤å®šçµæœ: ${consistentSequences.length} å€‹`);

                if (consistentSequences.length > 0) {
                    console.log(`\nğŸ“‹ ç¨ç«‹åˆ¤å®šçµæœè©³æƒ…:`);
                    consistentSequences.forEach((seq, index) => {
                        const tc = seq.targetConsistency;
                        console.log(`\n   ${index + 1}. ã€åºåˆ—${tc.originalSequenceIndex + 1}ã€‘ç¬¬${seq.captureStep}æ­¥: ${seq.captureMove}`);
                        console.log(`      æ”»æ“Šç›®æ¨™: ${tc.targetInfo?.color} ${tc.targetInfo?.type}(${tc.targetPieceId})`);
                        console.log(`      æ”»æ“Šæ­¥é©Ÿ: [${tc.attackMoveIndexes?.join(', ')}]`);
                        console.log(`      æ”»æ“Šæ¬¡æ•¸: ${tc.attackCount}æ¬¡`);

                        if (tc.independentAnalysis) {
                            console.log(`      è­‰æ“šæ­¥é©Ÿ: ç¬¬${seq.evidenceStep}æ­¥ ${seq.evidenceMove}`);
                            console.log(`      åˆ†æé¡å‹: ç¨ç«‹åˆ¤å®šåˆ†æ`);
                        } else if (tc.builtInMovesAnalysis) {
                            console.log(`      åˆ†æé¡å‹: å…§ç½®movesåˆ†æ`);
                        }

                        console.log(`      ä½ç½®è»Œè·¡: ${tc.positionSequence?.join(' â†’ ')}`);
                        console.log(`      åˆ¤å®šçµæœ: âœ… æ§‹æˆç›®æ¨™ä¸€è‡´çš„é•·æ‰è¡Œç‚º`);
                    });

                    console.log(`\nğŸ”— ç¨ç«‹åˆ¤å®šé‚è¼¯èªªæ˜:`);
                    console.log(`   âœ… æˆåŠŸè§£æ±ºäº†"å€Ÿç”¨è­‰æ“š vs ç¨ç«‹åˆ¤å®š"çš„å•é¡Œ`);
                    console.log(`   âœ… æ¯å€‹åºåˆ—éƒ½æœ‰è‡ªå·±çš„ç¨ç«‹åˆ¤å®šçµæœ`);
                    console.log(`   âœ… ç¬¬6æ­¥å€Ÿç”¨ç¬¬8æ­¥è­‰æ“š â†’ ç¬¬6æ­¥è¢«åˆ¤å®šç‚ºé•·æ‰`);
                    console.log(`   âœ… ç¬¬8æ­¥å€Ÿç”¨ç¬¬10æ­¥è­‰æ“š â†’ ç¬¬8æ­¥è¢«åˆ¤å®šç‚ºé•·æ‰`);
                    console.log(`   âœ… æ¯å€‹åŸå§‹åºåˆ—éƒ½å¾—åˆ°äº†æ‡‰æœ‰çš„ç›®æ¨™ä¸€è‡´æ€§èªå®š`);
                    console.log(`   âœ… ã€ä¿®å¾©å®Œæˆã€‘ç²¾ç¢ºè¿½è¹¤æ¯å€‹æ£‹å­èº«ä»½ï¼Œé¿å…ç›¸åŒé¡å‹æ£‹å­æ··æ·†`);

                    // ã€é¡å¤–ä¿¡æ¯ã€‘é¡¯ç¤ºè­‰æ“šä½¿ç”¨æƒ…æ³
                    console.log(`\nğŸ“Š è­‰æ“šä½¿ç”¨æƒ…æ³çµ±è¨ˆ:`);
                    const evidenceUsage = new Map();

                    consistentSequences.forEach(seq => {
                        if (seq.evidenceStep) {
                            const key = `ç¬¬${seq.evidenceStep}æ­¥`;
                            if (!evidenceUsage.has(key)) {
                                evidenceUsage.set(key, []);
                            }
                            evidenceUsage.get(key).push(`ç¬¬${seq.captureStep}æ­¥`);
                        }
                    });

                    for (const [evidence, users] of evidenceUsage.entries()) {
                        console.log(`   ${evidence} è¢«ç”¨ä½œè­‰æ“šï¼Œå¹«åŠ©åˆ¤å®š: ${users.join(', ')}`);
                    }

                    // ã€æ–°å¢ã€‘æ£‹å­èº«ä»½è¿½è¹¤çµ±è¨ˆ
                    console.log(`\nğŸ” æ£‹å­èº«ä»½è¿½è¹¤çµ±è¨ˆ:`);
                    const pieceTrackingStats = new Map();

                    consistentSequences.forEach(seq => {
                        const pieceId = seq.targetConsistency.targetPieceId;
                        const pieceInfo = seq.targetConsistency.targetInfo;

                        if (pieceId && pieceInfo) {
                            const key = `${pieceInfo.color} ${pieceInfo.type}`;
                            if (!pieceTrackingStats.has(key)) {
                                pieceTrackingStats.set(key, new Set());
                            }
                            pieceTrackingStats.get(key).add(pieceId);
                        }
                    });

                    for (const [pieceType, pieceIds] of pieceTrackingStats.entries()) {
                        console.log(`   ${pieceType}: è¿½è¹¤åˆ° ${pieceIds.size} å€‹ä¸åŒå€‹é«” [${Array.from(pieceIds).join(', ')}]`);
                    }

                } else {
                    console.log(`\nâŒ æ²’æœ‰ç™¼ç¾ç›®æ¨™ä¸€è‡´çš„é•·æ‰è¡Œç‚º`);
                }

                return consistentSequences;
            };
// ã€æ–°å¢ã€‘è§£æä½ç½®å­—ç¬¦ä¸²çš„è¼”åŠ©å‡½æ•¸
            const parsePosition = (positionStr) => {
                if (!positionStr) return [null, null];

                // æ¸…ç†ä½ç½®å­—ç¬¦ä¸²ï¼Œç§»é™¤æ‹¬è™Ÿå’Œå¤šé¤˜å­—ç¬¦
                const cleanPos = positionStr.toString().replace(/[()]/g, '');
                const parts = cleanPos.split(',');

                if (parts.length >= 2) {
                    return [parseInt(parts[0]), parseInt(parts[1])];
                }

                return [null, null];
            };

// ã€æ–°å¢ã€‘å°‡ parsePosition æ–¹æ³•ç¶å®šåˆ° thisï¼ˆå¦‚æœä¸å­˜åœ¨çš„è©±ï¼‰
            if (!this.parsePosition) {
                this.parsePosition = parsePosition;
            }

// ã€æ–°å¢ã€‘é€²è¡Œç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥
            console.log(`\nğŸ¯ é€²è¡Œç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥...`);

            const consistentRedSequences =  checkTargetConsistencyWithTracking(captureSequence, redLongCaptureSequences, 'red');
            const consistentBlackSequences =  checkTargetConsistencyWithTracking(captureSequence, blackLongCaptureSequences, 'black');

            console.log(`ğŸ¯ ç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥çµæœï¼š`);
            console.log(`ğŸ”´ ç´…æ–¹ç›®æ¨™ä¸€è‡´çš„é•·æ‰åºåˆ—ï¼š${consistentRedSequences.length} å€‹ (åŸ${redLongCaptureSequences.length}å€‹)`);
            console.log(`âš« é»‘æ–¹ç›®æ¨™ä¸€è‡´çš„é•·æ‰åºåˆ—ï¼š${consistentBlackSequences.length} å€‹ (åŸ${blackLongCaptureSequences.length}å€‹)`);

// æª¢æŸ¥æ£‹å­é¡å‹æ˜¯å¦ç‚ºå°‡å¸¥æˆ–å…µå’
            const isKingOrPawn = (pieceType) => {
                if (!pieceType) return false;
                const normalizedType = pieceType.toLowerCase();
                return ['k', 'king', 'å°‡', 'å¸¥', 'p', 'pawn', 'å…µ', 'å’'].includes(normalizedType);
            };

// ã€æ–°å¢ã€‘æª¢æŸ¥è¯åˆæ‰å­çš„è¦å‰‡ï¼ˆæŒ‰å¯¦éš›æ£‹å­å€‹æ•¸ï¼Œä¸å»é‡ï¼‰
            const analyzeCoalitionCapture = (captureInfoArray, moveIndex, captureSequence) => {
                console.log(`\nğŸ¤ åˆ†æç¬¬${moveIndex}æ­¥çš„è¯åˆæ‰å­æƒ…æ³...`);

                if (!captureInfoArray || captureInfoArray.length === 0) {
                    return { hasKingPawn: false, totalAttackers: 0, allAttackers: [] };
                }

                // æ”¶é›†æ‰€æœ‰æ”»æ“Šæ–¹æ£‹å­ï¼ˆä¸å»é‡ï¼ŒæŒ‰å¯¦éš›å€‹æ•¸è¨ˆç®—ï¼‰
                const allAttackers = [];
                let hasKingPawnAttacker = false;

                captureInfoArray.forEach(capture => {
                    if (capture.attacker && capture.attacker.type) {
                        const attackerInfo = {
                            type: capture.attacker.type,
                            position: capture.attacker.position || 'unknown'
                        };
                        allAttackers.push(attackerInfo);

                        if (isKingOrPawn(capture.attacker.type)) {
                            hasKingPawnAttacker = true;
                            console.log(`   ğŸ‘‘ ç™¼ç¾å°‡å¸¥å…µå’åƒèˆ‡: ${capture.attacker.type} at ${attackerInfo.position}`);
                        }
                    }
                });

                console.log(`   ğŸ“Š åƒèˆ‡æ‰å­çš„æ£‹å­ç¸½æ•¸: ${allAttackers.length} éš»`);
                console.log(`   ğŸ“‹ åƒèˆ‡çš„æ£‹å­è©³ç´°:`, allAttackers);
                console.log(`   ğŸ‘‘ æ˜¯å¦åŒ…å«å°‡å¸¥å…µå’: ${hasKingPawnAttacker}`);

                return {
                    hasKingPawn: hasKingPawnAttacker,
                    totalAttackers: allAttackers.length,
                    allAttackers: allAttackers
                };
            };

// ã€ä¿®æ”¹ã€‘å°‡å¸¥å…µå’ç‰¹æ¬Šéæ¿¾å‡½æ•¸ï¼ŒåŠ å…¥è¯åˆè¦å‰‡ï¼Œä¸¦ä½¿ç”¨ç›®æ¨™ä¸€è‡´çš„åºåˆ—
            const filterByKingPawnPrivilege = (sequences, playerColor, captureSequence) => {
                console.log(`\nğŸ” é–‹å§‹éæ¿¾${playerColor}æ–¹çš„é•·æ‰åºåˆ—ï¼Œå…±${sequences.length}å€‹åºåˆ—éœ€è¦æª¢æŸ¥`);
                console.log(`ğŸ›¡ï¸ ç‰¹æ¬Šè¦å‰‡ï¼šå°‡å¸¥å…µå’å¯è¯åˆ1å­é•·æ‰ï¼Œä½†è¯åˆ2å­ä»¥ä¸Šä»ç®—é•·æ‰`);

                return sequences.filter((sequence, index) => {
                    console.log(`\nğŸ“‹ æª¢æŸ¥ç¬¬${index + 1}å€‹åºåˆ—:`, sequence);

                    // é©æ‡‰å¯¦éš›çš„åºåˆ—çµæ§‹ï¼šä½¿ç”¨ captureStep è€Œä¸æ˜¯ moves
                    let moveIndexesToCheck = [];

                    if (sequence.moves && sequence.moves.length > 0) {
                        // åŸæ ¼å¼ï¼šä½¿ç”¨ moves æ•¸çµ„
                        moveIndexesToCheck = sequence.moves;
                        console.log(`   ğŸ“Š ä½¿ç”¨ moves å±¬æ€§:`, moveIndexesToCheck);
                    } else if (sequence.captureStep !== undefined) {
                        // æ–°æ ¼å¼ï¼šä½¿ç”¨ captureStep
                        moveIndexesToCheck = [sequence.captureStep];
                        console.log(`   ğŸ“Š ä½¿ç”¨ captureStep å±¬æ€§:`, moveIndexesToCheck);
                    } else {
                        console.log(`   âš ï¸ åºåˆ—æ²’æœ‰å¯ç”¨çš„æ­¥é©Ÿå±¬æ€§ï¼Œä¿ç•™åºåˆ—`);
                        return true;
                    }

                    // ã€æ–°é‚è¼¯ã€‘æª¢æŸ¥åºåˆ—ä¸­çš„è¯åˆæ‰å­æƒ…æ³
                    let hasPrivilegeProtection = false;

                    for (const moveIndex of moveIndexesToCheck) {
                        console.log(`   ğŸ” æª¢æŸ¥ç¬¬${moveIndex}æ­¥çš„è¯åˆæ‰å­æƒ…æ³...`);

                        const captureStep = captureSequence.find(step => step.moveIndex === moveIndex);
                        if (!captureStep) {
                            console.log(`   âŒ æ‰¾ä¸åˆ°ç¬¬${moveIndex}æ­¥çš„è³‡æ–™`);
                            continue;
                        }

                        // æª¢æŸ¥ç§»å‹•å­—ç¬¦ä¸²ä¸­çš„å°‡å¸¥å…µå’
                        let hasMoveStringKingPawn = false;
                        if (sequence.captureMove) {
                            const moveStr = sequence.captureMove;
                            console.log(`   ğŸ¯ æª¢æŸ¥ç§»å‹•å­—ç¬¦ä¸²: "${moveStr}"`);

                            if (moveStr.startsWith('å°‡') || moveStr.startsWith('å¸¥') ||
                                moveStr.startsWith('å…µ') || moveStr.startsWith('å’')) {
                                hasMoveStringKingPawn = true;
                                console.log(`   ğŸ‘‘ ç§»å‹•å­—ç¬¦ä¸²é¡¯ç¤ºå°‡å¸¥å…µå’åƒèˆ‡: "${moveStr}"`);
                            }
                        }

                        // åˆ†ææ‰å­å‹•ä½œä¸­çš„è¯åˆæƒ…æ³
                        const captureInfoArray = (captureStep.captureInfo && captureStep.captureInfo.captureInfo)
                            ? captureStep.captureInfo.captureInfo
                            : [];

                        const coalitionAnalysis = analyzeCoalitionCapture(captureInfoArray, moveIndex, captureSequence);

                        // ã€é—œéµåˆ¤æ–·ã€‘æ‡‰ç”¨æ–°çš„è¯åˆè¦å‰‡
                        if (coalitionAnalysis.hasKingPawn || hasMoveStringKingPawn) {
                            console.log(`   ğŸ‘‘ ç™¼ç¾å°‡å¸¥å…µå’åƒèˆ‡æ‰å­ï¼`);
                            console.log(`   ğŸ¤ ç¸½åƒèˆ‡æ£‹å­æ•¸: ${coalitionAnalysis.totalAttackers} éš»`);

                            if (coalitionAnalysis.totalAttackers <= 2) {
                                // å°‡å¸¥å…µå’å–®ç¨è¡Œå‹• æˆ– èˆ‡1éš»å…¶ä»–æ£‹å­è¯åˆ â†’ äº«æœ‰ç‰¹æ¬Š
                                console.log(`   ğŸ›¡ï¸ å°‡å¸¥å…µå’å–®ç¨æˆ–èˆ‡1éš»å…¶ä»–æ£‹å­è¯åˆ(ç¸½æ•¸â‰¤2éš»)ï¼Œäº«æœ‰ç‰¹æ¬Šä¿è­·ï¼`);
                                hasPrivilegeProtection = true;
                                break; // æ‰¾åˆ°ä¸€å€‹äº«æœ‰ç‰¹æ¬Šçš„æ­¥é©Ÿå°±è¶³å¤ äº†
                            } else {
                                // å°‡å¸¥å…µå’èˆ‡2éš»ä»¥ä¸Šå…¶ä»–æ£‹å­è¯åˆ â†’ ä¸äº«æœ‰ç‰¹æ¬Š
                                console.log(`   âš–ï¸ å°‡å¸¥å…µå’èˆ‡å…¶ä»–${coalitionAnalysis.totalAttackers - 1}éš»æ£‹å­è¯åˆ(è¶…é1éš»)ï¼Œä¸äº«æœ‰ç‰¹æ¬Šä¿è­·ï¼`);
                            }
                        } else {
                            console.log(`   ğŸ“Š æ­¤æ­¥é©Ÿæ²’æœ‰å°‡å¸¥å…µå’åƒèˆ‡`);
                        }
                    }

                    if (hasPrivilegeProtection) {
                        console.log(`   ğŸ›¡ï¸ åºåˆ—${index + 1}äº«æœ‰å°‡å¸¥å…µå’ç‰¹æ¬Šä¿è­·ï¼Œéæ¿¾æ­¤é•·æ‰åºåˆ—`);
                        return false; // éæ¿¾æ‰ï¼ˆä¸ä¿ç•™ï¼‰
                    }

                    console.log(`   âœ… åºåˆ—${index + 1}ä¸äº«æœ‰ç‰¹æ¬Šä¿è­·ï¼Œä¿ç•™åºåˆ—`);
                    return true; // ä¿ç•™åºåˆ—
                });
            };

// éæ¿¾ç´…æ–¹å’Œé»‘æ–¹çš„é•·æ‰åºåˆ—ï¼ˆä½¿ç”¨ç›®æ¨™ä¸€è‡´çš„åºåˆ—ï¼‰
            console.log(`\nğŸ”§ é–‹å§‹éæ¿¾é•·æ‰åºåˆ—...`);
            const filteredRedSequences = filterByKingPawnPrivilege(consistentRedSequences, 'red', captureSequence);
            const filteredBlackSequences = filterByKingPawnPrivilege(consistentBlackSequences, 'black', captureSequence);
            console.log(`ğŸ”§ éæ¿¾å®Œæˆï¼`);

            console.log(`\nğŸ›¡ï¸ å°‡å¸¥å…µå’ç‰¹æ¬Šéæ¿¾å¾Œï¼š`);
            console.log(`ğŸ”´ ç´…æ–¹æœ‰æ•ˆé•·æ‰åºåˆ—ï¼š${filteredRedSequences.length} å€‹ (ç›®æ¨™ä¸€è‡´:${consistentRedSequences.length}å€‹ï¼ŒåŸå§‹:${redLongCaptureSequences.length}å€‹)`);
            console.log(`âš« é»‘æ–¹æœ‰æ•ˆé•·æ‰åºåˆ—ï¼š${filteredBlackSequences.length} å€‹ (ç›®æ¨™ä¸€è‡´:${consistentBlackSequences.length}å€‹ï¼ŒåŸå§‹:${blackLongCaptureSequences.length}å€‹)`);

// æ–°å¢ï¼šä½¿ç”¨æ¯”å€¼éæ¿¾æ¼ç¶²ä¹‹é­š
            const minRatio = 0.5; // éæ¿¾å¾Œ/åŸå§‹ å¿…é ˆ >= 1/2

// è¨ˆç®—ç´…æ–¹æ¯”å€¼ä¸¦åˆ¤æ–·æ˜¯å¦ç‚ºæ¼ç¶²ä¹‹é­š
            let finalRedSequences = filteredRedSequences;
            let redRatioNote = '';
            if (redLongCaptureSequences.length > 0) {
                const redRatio = filteredRedSequences.length / redLongCaptureSequences.length;
                console.log(`ğŸ”´ ç´…æ–¹éæ¿¾æ¯”å€¼ï¼š${filteredRedSequences.length}/${redLongCaptureSequences.length} = ${(redRatio * 100).toFixed(1)}%`);

                if (redRatio < minRatio) {
                    // æ¯”å€¼éä½ï¼Œåˆ¤å®šç‚ºæ¼ç¶²ä¹‹é­šï¼Œæ¸…ç©ºåºåˆ—
                    finalRedSequences = [];
                    redRatioNote = ' (æ¯”å€¼éä½ï¼Œåˆ¤å®šç‚ºæ¼ç¶²ä¹‹é­š)';
                    console.log(`ğŸš« ç´…æ–¹æ¯”å€¼éä½ (${(redRatio * 100).toFixed(1)}% < 50%)ï¼Œæ¸…ç©ºåºåˆ—é¿å…èª¤åˆ¤`);
                }
            }

// è¨ˆç®—é»‘æ–¹æ¯”å€¼ä¸¦åˆ¤æ–·æ˜¯å¦ç‚ºæ¼ç¶²ä¹‹é­š
            let finalBlackSequences = filteredBlackSequences;
            let blackRatioNote = '';
            if (blackLongCaptureSequences.length > 0) {
                const blackRatio = filteredBlackSequences.length / blackLongCaptureSequences.length;
                console.log(`âš« é»‘æ–¹éæ¿¾æ¯”å€¼ï¼š${filteredBlackSequences.length}/${blackLongCaptureSequences.length} = ${(blackRatio * 100).toFixed(1)}%`);

                if (blackRatio < minRatio) {
                    // æ¯”å€¼éä½ï¼Œåˆ¤å®šç‚ºæ¼ç¶²ä¹‹é­šï¼Œæ¸…ç©ºåºåˆ—
                    finalBlackSequences = [];
                    blackRatioNote = ' (æ¯”å€¼éä½ï¼Œåˆ¤å®šç‚ºæ¼ç¶²ä¹‹é­š)';
                    console.log(`ğŸš« é»‘æ–¹æ¯”å€¼éä½ (${(blackRatio * 100).toFixed(1)}% < 50%)ï¼Œæ¸…ç©ºåºåˆ—é¿å…èª¤åˆ¤`);
                }
            }

            console.log(`\nğŸ¯ æœ€çµ‚åˆ¤å®šåºåˆ—ï¼š`);
            console.log(`ğŸ”´ ç´…æ–¹æœ€çµ‚åºåˆ—ï¼š${finalRedSequences.length} å€‹${redRatioNote}`);
            console.log(`âš« é»‘æ–¹æœ€çµ‚åºåˆ—ï¼š${finalBlackSequences.length} å€‹${blackRatioNote}`);

// åˆ¤å®šé•·æ‰ (ä½¿ç”¨æœ€çµ‚åºåˆ—) - æ›´åš´è¬¹çš„åˆ¤å®šè¦å‰‡
            const minLongCaptureSequences = 1;

            const isRedLongCapture = finalRedSequences.length >= minLongCaptureSequences;
            const isBlackLongCapture = finalBlackSequences.length >= minLongCaptureSequences;

            console.log(`ğŸ” ç´…æ–¹é•·æ‰åˆ¤æ–·ï¼š${isRedLongCapture} (æª¢æ¸¬åˆ°${finalRedSequences.length}å€‹æœ‰æ•ˆé•·æ‰åºåˆ—)`);
            console.log(`ğŸ” é»‘æ–¹é•·æ‰åˆ¤æ–·ï¼š${isBlackLongCapture} (æª¢æ¸¬åˆ°${finalBlackSequences.length}å€‹æœ‰æ•ˆé•·æ‰åºåˆ—)`);

// ç¢ºå®šé•·æ‰æ–¹ - æ–°çš„åš´è¬¹åˆ¤å®šé‚è¼¯
            let longCapturePlayer = null;
            let isDraw = false;
            let drawReason = null;

            if (isRedLongCapture && isBlackLongCapture) {
                // é›™æ–¹éƒ½æœ‰é•·æ‰åºåˆ—ï¼ˆéƒ½ >= 1ï¼‰
                if (finalRedSequences.length === finalBlackSequences.length) {
                    // åºåˆ—æ•¸é‡ç›¸ç­‰ä¸”éƒ½ >= 1ï¼Œåˆ¤å®šç‚ºå’Œæ£‹
                    isDraw = true;
                    drawReason = 'é›™æ–¹äº’ç›¸é•·æ‰';
                    longCapturePlayer = 'draw'; // ç‰¹æ®Šæ¨™è¨˜è¡¨ç¤ºå’Œæ£‹
                    console.log(`âš–ï¸ å’Œæ£‹åˆ¤å®šï¼šé›™æ–¹é•·æ‰åºåˆ—æ•¸é‡ç›¸ç­‰ (ç´…æ–¹:${finalRedSequences.length}, é»‘æ–¹:${finalBlackSequences.length})`);
                } else {
                    // åºåˆ—æ•¸é‡ä¸ç›¸ç­‰ï¼Œé¸æ“‡æ•¸é‡è¼ƒå¤šçš„ä¸€æ–¹ç‚ºé•·æ‰æ–¹
                    longCapturePlayer = finalRedSequences.length > finalBlackSequences.length ? 'red' : 'black';
                    console.log(`ğŸ¯ é•·æ‰æ–¹åˆ¤å®šï¼š${longCapturePlayer}æ–¹åºåˆ—è¼ƒå¤š (ç´…æ–¹:${finalRedSequences.length}, é»‘æ–¹:${finalBlackSequences.length})`);
                }
            } else if (isRedLongCapture) {
                // åƒ…ç´…æ–¹é•·æ‰
                longCapturePlayer = 'red';
                console.log(`ğŸ”´ ç´…æ–¹å–®æ–¹é¢é•·æ‰ (${finalRedSequences.length}å€‹åºåˆ—)`);
            } else if (isBlackLongCapture) {
                // åƒ…é»‘æ–¹é•·æ‰
                longCapturePlayer = 'black';
                console.log(`âš« é»‘æ–¹å–®æ–¹é¢é•·æ‰ (${finalBlackSequences.length}å€‹åºåˆ—)`);
            } else {
                // é›™æ–¹éƒ½æ²’æœ‰é•·æ‰
                console.log(`âœ… é›™æ–¹éƒ½æ²’æœ‰é”åˆ°é•·æ‰æ¨™æº– (ç´…æ–¹:${finalRedSequences.length}, é»‘æ–¹:${finalBlackSequences.length})`);
            }
// æ§‹å»ºçµæœç‰©ä»¶ - åŒ…å«æ–°çš„å’Œæ£‹åˆ¤å®š
            const result = {
                isLongCapture: longCapturePlayer !== null,
                longCapturePlayer: longCapturePlayer,
                isDraw: isDraw, // æ–°å¢ï¼šæ˜¯å¦ç‚ºå’Œæ£‹
                drawReason: drawReason, // æ–°å¢ï¼šå’Œæ£‹åŸå› 
                reason: (() => {
                    if (isDraw) {
                        return `å’Œæ£‹ï¼šé›™æ–¹äº’ç›¸é•·æ‰ï¼Œé•·æ‰åºåˆ—æ•¸é‡ç›¸ç­‰ (ç´…æ–¹:${filteredRedSequences.length}, é»‘æ–¹:${filteredBlackSequences.length})`;
                    } else if (longCapturePlayer && longCapturePlayer !== 'draw') {
                        const sequenceCount = longCapturePlayer === 'red' ? filteredRedSequences.length : filteredBlackSequences.length;
                        return `${longCapturePlayer}æ–¹åœ¨å¾ªç’°ä¸­æª¢æ¸¬åˆ°${sequenceCount}å€‹æœ‰æ•ˆé•·æ‰åºåˆ—ï¼ˆå·²é€šéç›®æ¨™ä¸€è‡´æ€§æª¢æŸ¥ï¼‰`;
                    } else {
                        return 'æœªæª¢æ¸¬åˆ°é•·æ‰æˆ–äº«æœ‰å°‡å¸¥å…µå’ç‰¹æ¬Šä¿è­·';
                    }
                })(),
                captureMoves: allCaptureMoves || [], // ç¢ºä¿ä¸æ˜¯ undefined
                playerCaptureCounts: { red: redCaptures ? redCaptures.length : 0, black: blackCaptures ? blackCaptures.length : 0 },
                playerMoveCounts: { red: redMoves ? redMoves.length : 0, black: blackMoves ? blackMoves.length : 0 },
                redCaptureRatio: (redMoves && redMoves.length > 0 && redCaptures) ? redCaptures.length / redMoves.length : 0,
                blackCaptureRatio: (blackMoves && blackMoves.length > 0 && blackCaptures) ? blackCaptures.length / blackMoves.length : 0,
                totalMoves: actualEndIndex - cycleBasedStartIndex,
                internalCycleDetected: cycleResult.detected,
                internalCycleCount: cycleResult.cycleCount || 0,
                internalCycleLength: cycleResult.cycleLength || 0,
                internalCyclePattern: cycleResult.pattern || [],
                redCaptures: redCaptures || [],
                blackCaptures: blackCaptures || [],
                analyzedStartIndex: cycleBasedStartIndex,
                analyzedEndIndex: actualEndIndex,
                // æ›´æ–°çš„é•·æ‰åºåˆ—ä¿¡æ¯ï¼ˆåŒ…å«ç›®æ¨™ä¸€è‡´æ€§å’Œéæ¿¾çµæœï¼‰
                redLongCaptureSequences: redLongCaptureSequences, // åŸå§‹æª¢æ¸¬çµæœ
                blackLongCaptureSequences: blackLongCaptureSequences, // åŸå§‹æª¢æ¸¬çµæœ
                consistentRedSequences: consistentRedSequences, // ç›®æ¨™ä¸€è‡´çš„åºåˆ—
                consistentBlackSequences: consistentBlackSequences, // ç›®æ¨™ä¸€è‡´çš„åºåˆ—
                filteredRedSequences: filteredRedSequences, // æœ€çµ‚éæ¿¾å¾Œçš„çµæœ
                filteredBlackSequences: filteredBlackSequences, // æœ€çµ‚éæ¿¾å¾Œçš„çµæœ
                captureSequence: captureSequence
            };

// é™¤éŒ¯ä¿¡æ¯ï¼šæª¢æŸ¥è®Šæ•¸ç‹€æ…‹
            console.log(`\nğŸ”§ é™¤éŒ¯ä¿¡æ¯æª¢æŸ¥ï¼š`);
            console.log(`   allCaptureMoves:`, typeof allCaptureMoves, allCaptureMoves ? allCaptureMoves.length : 'undefined');
            console.log(`   redCaptures:`, typeof redCaptures, redCaptures ? redCaptures.length : 'undefined');
            console.log(`   blackCaptures:`, typeof blackCaptures, blackCaptures ? blackCaptures.length : 'undefined');

            console.log(`ğŸ” æœ€çµ‚é•·æ‰åˆ¤æ–·ï¼ˆå«ç›®æ¨™ä¸€è‡´æ€§å’Œå°‡å¸¥å…µå’è¯åˆç‰¹æ¬Šï¼‰ï¼š`, result);
            return result;
        }


// ä¿®å¾©å¾Œçš„ analyzeMoveCapture å‡½æ•¸é–‹é ­éƒ¨åˆ†

        analyzeMoveCapture(move, color, previousMoveAnalysis = null, allMoves = []) {
            // ç‰¹æ®Šè™•ç†ï¼šéœæ…‹æ£‹ç›¤æª¢æ¸¬
            if (move.from && move.to &&
                move.from.row === move.to.row &&
                move.from.col === move.to.col) {

                console.log(`ğŸ” [éœæ…‹æª¢æ¸¬æ¨¡å¼] æª¢æ¸¬ ${color} æ–¹åœ¨ç•¶å‰æ£‹ç›¤çš„æ‰å­èƒ½åŠ›`); // âœ… ä½¿ç”¨ color è€Œä¸æ˜¯ player
                // ç›´æ¥åˆ†æç•¶å‰æ£‹ç›¤ç‹€æ…‹çš„æ‰å­æƒ…æ³
                // é€™è£¡å¯ä»¥å¾©ç”¨ analyzeMoveCapture å…§éƒ¨çš„æ‰å­æª¢æ¸¬é‚è¼¯
                // åªæ˜¯ä¸éœ€è¦è€ƒæ…®"ç§»å‹•å‰å¾Œçš„è®ŠåŒ–"

                return this.analyzeCurrentBoardCaptures(move.boardAfter, color); // âœ… ä½¿ç”¨ color è€Œä¸æ˜¯ player
            }


            try {
                // ==================== åŸºæœ¬åƒæ•¸æª¢æŸ¥ ====================
                if (typeof this.analyzeMoveCapture !== 'function') {
                    console.error('âŒ åš´é‡éŒ¯èª¤: analyzeMoveCapture ä¸æ˜¯å‡½æ•¸');
                    return {
                        captureInfo: [],
                        isEscapeMove: false,
                        escapedPieces: [],
                        targetConsistency: null,
                        error: 'analyzeMoveCapture ä¸æ˜¯å‡½æ•¸'
                    };
                }

                const result = {
                    captureInfo: [],
                    isEscapeMove: false,
                    escapedPieces: [],
                    targetConsistency: null,
                    player: color,
                    moveIndex: move.moveIndex || 0
                };

                // æ ¸å¿ƒç©ºå€¼æª¢æŸ¥
                if (!move) {
                    console.warn('âš ï¸ analyzeMoveCapture: move åƒæ•¸ç‚ºç©º');
                    console.trace('move åƒæ•¸ç‚ºç©ºçš„å †æ£§è¿½è¸ª');
                    return result;
                }

                if (!color || (color !== 'red' && color !== 'black')) {
                    console.warn('âš ï¸ analyzeMoveCapture: color åƒæ•¸ç„¡æ•ˆ', color);
                    console.warn('ğŸ” ç•¶å‰ move å°è±¡:', JSON.stringify(move));
                    return result;
                }

                // æª¢æŸ¥ move ç‰©ä»¶çš„å¿…è¦å±¬æ€§
                const board = move.boardAfter;
                const boardBefore = move.boardBefore;
                const fromPos = move?.from;
                const toPos = move?.to;

                if (!board || !Array.isArray(board)) {
                    console.warn('âš ï¸ analyzeMoveCapture: move.boardAfter ç„¡æ•ˆ', move);
                    console.warn('ğŸ” move å°è±¡é¡å‹:', typeof move);
                    return result;
                }

                if (!fromPos || !toPos) {
                    console.warn('âš ï¸ analyzeMoveCapture: ç¼ºå°‘ from æˆ– to ä½ç½®', { from: fromPos, to: toPos });
                    console.warn('ğŸ” move å°è±¡å®Œæ•´çµæ§‹:', JSON.stringify(move));
                    return result;
                }

                // æª¢æŸ¥ä½ç½®æœ‰æ•ˆæ€§
                if (typeof toPos?.row !== 'number' || typeof toPos?.col !== 'number' ||
                    typeof fromPos?.row !== 'number' || typeof fromPos?.col !== 'number') {
                    console.warn('âš ï¸ analyzeMoveCapture: ä½ç½®åƒæ•¸ç„¡æ•ˆ');
                    console.warn('ğŸ” toPos é¡å‹:', {
                        rowType: typeof toPos?.row,
                        colType: typeof toPos?.col
                    });
                    console.warn('ğŸ” fromPos é¡å‹:', {
                        rowType: typeof fromPos?.row,
                        colType: typeof fromPos?.col
                    });
                    return result;
                }

                // æª¢æŸ¥æ£‹ç›¤å°ºå¯¸
                if (board.length < 10 || !Array.isArray(board[0]) || board[0].length < 9) {
                    console.warn('âš ï¸ analyzeMoveCapture: æ£‹ç›¤å°ºå¯¸ä¸æ­£ç¢º', {
                        rows: board.length,
                        cols: board[0]?.length,
                        expected: '11x9'
                    });
                    console.warn('ğŸ” æ£‹ç›¤å¯¦éš›çµæ§‹:', {
                        rows: board.length,
                        firstRowCols: board[0]?.length,
                        boardSample: JSON.stringify(board.slice(0, 2))
                    });
                    return result;
                }

                // é‚Šç•Œæª¢æŸ¥
                if (toPos.row < 0 || toPos.row >= 10 || toPos.col < 0 || toPos.col >= 9 ||
                    fromPos.row < 0 || fromPos.row >= 10 || fromPos.col < 0 || fromPos.col >= 9) {
                    console.warn('âš ï¸ analyzeMoveCapture: ä½ç½®è¶…å‡ºæ£‹ç›¤ç¯„åœ');
                    console.warn('ğŸ” æœ‰æ•ˆç¯„åœ:', { minRow: 0, maxRow: 10, minCol: 0, maxCol: 8 });
                    return result;
                }

                // æª¢æŸ¥ fromPos å’Œ toPos ä¸èƒ½ç›¸åŒ
                if (fromPos.row === toPos.row && fromPos.col === toPos.col) {
                    console.error('âŒ analyzeMoveCapture: fromPos å’Œ toPos ç›¸åŒ', { fromPos, toPos });
                    return result;
                }

                // ç²å–ç§»å‹•æ£‹å­
                let piece = board[toPos.row]?.[toPos.col];
                if (!piece && move.boardBefore) {
                    piece = move.boardBefore[fromPos.row]?.[fromPos.col];
                    console.log('â„¹ï¸ å¾ boardBefore ç²å–æ£‹å­ä¿¡æ¯:', piece);
                }
                if (!piece && move.piece) {
                    piece = move.piece;
                    console.log('â„¹ï¸ å¾ move.piece ç²å–æ£‹å­ä¿¡æ¯:', piece);
                }

                if (!piece || !piece.color || !piece.type || piece.color !== color) {
                    console.warn('âš ï¸ analyzeMoveCapture: ç„¡æ•ˆçš„ç§»å‹•æ£‹å­', piece);
                    return result;
                }



                // ==================== å…§å»ºå‡½æ•¸å€åŸŸ ====================

                // ä½ç½®æœ‰æ•ˆæ€§æª¢æŸ¥
                const isValidPosition = (row, col) => {
                    if (typeof row !== 'number' || typeof col !== 'number') {
                        console.error('âŒ isValidPosition: ç„¡æ•ˆçš„ row æˆ– col é¡å‹', { row, col });
                        return false;
                    }
                    return row >= 0 && row < 10 && col >= 0 && col < 9;
                };

                // æª¢æŸ¥æ˜¯å¦åœ¨å®®å…§
                const isInPalace = (row, col, pieceColor) => {
                    if (typeof row !== 'number' || typeof col !== 'number' ||
                        (pieceColor !== 'red' && pieceColor !== 'black')) {
                        console.error('âŒ isInPalace: ç„¡æ•ˆçš„åƒæ•¸', { row, col, pieceColor });
                        return false;
                    }

                    if (pieceColor === 'red') {
                        return row >= 7 && row <= 9 && col >= 3 && col <= 5;
                    } else {
                        return row >= 0 && row <= 2 && col >= 3 && col <= 5;
                    }
                };

                // æª¢æŸ¥è±¡çš„æœ‰æ•ˆç§»å‹•
                const isValidElephantMove = (testBoard, fromRow, fromCol, toRow, toCol, pieceColor) => {
                    if (!Array.isArray(testBoard) ||
                        typeof fromRow !== 'number' || typeof fromCol !== 'number' ||
                        typeof toRow !== 'number' || typeof toCol !== 'number' ||
                        (pieceColor !== 'red' && pieceColor !== 'black')) {
                        console.error('âŒ isValidElephantMove: ç„¡æ•ˆçš„åƒæ•¸', {
                            testBoard, fromRow, fromCol, toRow, toCol, pieceColor
                        });
                        return false;
                    }

                    if (!isValidPosition(toRow, toCol)) return false;

                    // ä¸èƒ½éæ²³
                    if ((pieceColor === 'red' && toRow < 5) || (pieceColor === 'black' && toRow > 4)) {
                        return false;
                    }

                    // æª¢æŸ¥å¡è±¡çœ¼
                    const midRow = (fromRow + toRow) / 2;
                    const midCol = (fromCol + toCol) / 2;

                    if (!isValidPosition(midRow, midCol)) {
                        console.error('âŒ isValidElephantMove: ä¸­é–“ä½ç½®ç„¡æ•ˆ', { midRow, midCol });
                        return false;
                    }

                    return !testBoard[midRow][midCol];
                };

                // æª¢æŸ¥é¦¬çš„æœ‰æ•ˆç§»å‹•
                const isValidHorseMove = (testBoard, fromRow, fromCol, toRow, toCol) => {
                    if (!Array.isArray(testBoard) ||
                        typeof fromRow !== 'number' || typeof fromCol !== 'number' ||
                        typeof toRow !== 'number' || typeof toCol !== 'number') {
                        console.error('âŒ isValidHorseMove: ç„¡æ•ˆçš„åƒæ•¸', {
                            testBoard, fromRow, fromCol, toRow, toCol
                        });
                        return false;
                    }

                    if (!isValidPosition(toRow, toCol)) return false;

                    // æª¢æŸ¥æ‹é¦¬è…³
                    const dr = toRow - fromRow;
                    const dc = toCol - fromCol;

                    let blockRow, blockCol;
                    if (Math.abs(dr) === 2) {
                        blockRow = fromRow + dr / 2;
                        blockCol = fromCol;
                    } else {
                        blockRow = fromRow;
                        blockCol = fromCol + dc / 2;
                    }

                    if (!isValidPosition(blockRow, blockCol)) {
                        console.error('âŒ isValidHorseMove: é˜»æ“‹ä½ç½®ç„¡æ•ˆ', { blockRow, blockCol });
                        return false;
                    }

                    return !testBoard[blockRow][blockCol];
                };

                // æ·±æ‹·è²å‡½æ•¸
                const deepCopyPiece = (piece) => {
                    if (piece === null || piece === undefined) return null;
                    const newPiece = { type: piece.type, color: piece.color };
                    if (piece.moved !== undefined) newPiece.moved = piece.moved;
                    if (piece.id !== undefined) newPiece.id = piece.id;
                    if (piece.firstMove !== undefined) newPiece.firstMove = piece.firstMove;
                    return newPiece;
                };

                const deepCopyBoard = (board) => {
                    if (!Array.isArray(board)) return null;
                    return board.map(row => {
                        if (!Array.isArray(row)) return row;
                        return row.map(cell => deepCopyPiece(cell));
                    });
                };

                const deepCopyPosition = (pos) => {
                    if (!pos) return null;
                    return { row: pos.row, col: pos.col };
                };

                // æ£‹å­é¡å‹æ˜ å°„
                const PIECE_TYPE_MAP = {
                    'king': 'king', 'KING': 'king', 'K': 'king', 'å°‡': 'king', 'å¸¥': 'king',
                    'advisor': 'advisor', 'ADVISOR': 'advisor', 'A': 'advisor', 'å£«': 'advisor', 'ä»•': 'advisor',
                    'elephant': 'elephant', 'ELEPHANT': 'elephant', 'E': 'elephant', 'è±¡': 'elephant', 'ç›¸': 'elephant',
                    'horse': 'horse', 'HORSE': 'horse', 'H': 'horse', 'é¦¬': 'horse', 'å‚Œ': 'horse',
                    'rook': 'rook', 'ROOK': 'rook', 'R': 'rook', 'è»Š': 'rook', 'ä¿¥': 'rook',
                    'cannon': 'cannon', 'CANNON': 'cannon', 'C': 'cannon', 'åŒ…': 'cannon', 'ç‚®': 'cannon',
                    'pawn': 'pawn', 'PAWN': 'pawn', 'P': 'pawn', 'å’': 'pawn', 'å…µ': 'pawn'
                };

                const getStandardPieceType = (originalType) => {
                    return PIECE_TYPE_MAP[originalType] || originalType;
                };

                // ç²å–æ£‹å­æ”»æ“Šä½ç½®
                const getPieceAttackPositions = (testBoard, pos, testPiece) => {
                    if (!Array.isArray(testBoard) || !pos || !testPiece) {
                        console.error('âŒ getPieceAttackPositions: ç„¡æ•ˆçš„åƒæ•¸', {
                            testBoard, pos, testPiece
                        });
                        return [];
                    }

                    const { row, col } = pos;

                    if (!isValidPosition(row, col)) {
                        console.error('âŒ getPieceAttackPositions: ç„¡æ•ˆçš„ä½ç½®', pos);
                        return [];
                    }

                    if (!testPiece.type || !testPiece.color) {
                        console.error('âŒ getPieceAttackPositions: ç„¡æ•ˆçš„æ£‹å­', testPiece);
                        return [];
                    }

                    const positions = [];
                    const pieceType = getStandardPieceType(testPiece.type);

                    switch (pieceType) {
                        case 'king':
                            const kingMoves = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            for (const [dr, dc] of kingMoves) {
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isInPalace(newRow, newCol, testPiece.color)) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        case 'advisor':
                            const advisorMoves = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                            for (const [dr, dc] of advisorMoves) {
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isInPalace(newRow, newCol, testPiece.color)) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        case 'elephant':
                            const elephantMoves = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
                            for (const [dr, dc] of elephantMoves) {
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isValidElephantMove(testBoard, row, col, newRow, newCol, testPiece.color)) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        case 'horse':
                            const horseMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                            for (const [dr, dc] of horseMoves) {
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isValidHorseMove(testBoard, row, col, newRow, newCol)) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        case 'rook':
                            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            for (const [dr, dc] of directions) {
                                for (let i = 1; i < 10; i++) {
                                    const newRow = row + dr * i;
                                    const newCol = col + dc * i;
                                    if (!isValidPosition(newRow, newCol)) break;

                                    const pieceAtPos = testBoard[newRow][newCol];
                                    if (pieceAtPos) {
                                        if (pieceAtPos.color !== testPiece.color) {
                                            positions.push({ row: newRow, col: newCol });
                                        }
                                        break;
                                    }
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        case 'cannon':
                            const cannonDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            for (const [dr, dc] of cannonDirections) {
                                let jumpFound = false;
                                for (let i = 1; i < 10; i++) {
                                    const newRow = row + dr * i;
                                    const newCol = col + dc * i;
                                    if (!isValidPosition(newRow, newCol)) break;

                                    const pieceAtPos = testBoard[newRow][newCol];
                                    if (pieceAtPos) {
                                        if (!jumpFound) {
                                            jumpFound = true;
                                        } else {
                                            if (pieceAtPos.color !== testPiece.color) {
                                                positions.push({ row: newRow, col: newCol });
                                            }
                                            break;
                                        }
                                    } else if (!jumpFound) {
                                        positions.push({ row: newRow, col: newCol });
                                    }
                                }
                            }
                            break;

                        case 'pawn':
                            const pawnDirection = testPiece.color === 'red' ? -1 : 1;
                            const pawnMoves = [[pawnDirection, 0]];

                            if ((testPiece.color === 'red' && row <= 4) || (testPiece.color === 'black' && row >= 5)) {
                                pawnMoves.push([0, -1], [0, 1]);
                            }

                            for (const [dr, dc] of pawnMoves) {
                                const newRow = row + dr;
                                const newCol = col + dc;
                                if (isValidPosition(newRow, newCol)) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                            }
                            break;

                        default:
                            console.error('âŒ getPieceAttackPositions: æœªçŸ¥çš„æ£‹å­é¡å‹', testPiece.type, '(åŸå§‹)', pieceType, '(è½‰æ›å¾Œ)');
                            console.error('å®Œæ•´æ£‹å­è³‡è¨Š:', testPiece);
                            return [];
                    }

                    return positions.filter(pos => isValidPosition(pos.row, pos.col));
                };

                // ç²å–å‹æ–¹æ£‹å­
                const getFriendlyPieces = (testBoard, pieceColor) => {
                    if (!Array.isArray(testBoard) || (pieceColor !== 'red' && pieceColor !== 'black')) {
                        console.error('âŒ getFriendlyPieces: ç„¡æ•ˆçš„åƒæ•¸', { testBoard, pieceColor });
                        return [];
                    }

                    const pieces = [];
                    for (let row = 0; row < 10; row++) {
                        if (!Array.isArray(testBoard[row])) {
                            console.error('âŒ getFriendlyPieces: ç„¡æ•ˆçš„è¡Œ', row);
                            continue;
                        }

                        for (let col = 0; col < 9; col++) {
                            const testPiece = testBoard[row][col];
                            if (testPiece && testPiece.color === pieceColor) {
                                pieces.push({ piece: testPiece, pos: { row, col } });
                            }
                        }
                    }
                    return pieces;
                };

                // ä¿®å¾©çš„ findKing å‡½æ•¸
                const findKing = (testBoard, pieceColor) => {
                    if (!Array.isArray(testBoard) || (pieceColor !== 'red' && pieceColor !== 'black')) {
                        console.error('âŒ findKing: ç„¡æ•ˆçš„åƒæ•¸', { testBoard, pieceColor });
                        return null;
                    }

                    console.log(`ğŸ” é–‹å§‹å°‹æ‰¾ ${pieceColor} ç‹...`);

                    // ç¢ºå®šæ£‹ç›¤é‚Šç•Œ
                    const maxRows = testBoard.length;
                    const maxCols = testBoard[0] ? testBoard[0].length : 9;
                    console.log(`æ£‹ç›¤å°ºå¯¸: ${maxRows} x ${maxCols}`);

                    for (let row = 0; row < maxRows; row++) {
                        if (!Array.isArray(testBoard[row])) {
                            console.warn(`âš ï¸ ç¬¬${row}è¡Œä¸æ˜¯æ•¸çµ„ï¼Œè·³é`);
                            continue;
                        }

                        for (let col = 0; col < maxCols; col++) {
                            const testPiece = testBoard[row][col];
                            if (!testPiece || testPiece.color !== pieceColor) continue;

                            console.log(`æª¢æŸ¥æ£‹å­: ${testPiece.type} åœ¨ (${row},${col})`);

                            // å¤šç¨®æ–¹å¼æª¢æŸ¥æ˜¯å¦ç‚ºç‹
                            const isKing = isKingPiece(testPiece);

                            if (isKing) {
                                console.log('âœ… findKing: æ‰¾åˆ°ç‹', {
                                    originalType: testPiece.type,
                                    color: pieceColor,
                                    position: { row, col }
                                });
                                return { row, col };
                            }
                        }
                    }

                    // èª¿è©¦è¼¸å‡º - é¡¯ç¤ºæ‰€æœ‰è©²é¡è‰²çš„æ£‹å­
                    console.warn('âš ï¸ findKing: æ‰¾ä¸åˆ°ç‹', pieceColor);
                    const colorPieces = [];

                    for (let row = 0; row < maxRows; row++) {
                        if (!Array.isArray(testBoard[row])) continue;

                        for (let col = 0; col < maxCols; col++) {
                            const testPiece = testBoard[row][col];
                            if (testPiece && testPiece.color === pieceColor) {
                                colorPieces.push({
                                    type: testPiece.type,
                                    isKing: isKingPiece(testPiece),
                                    position: { row, col }
                                });
                            }
                        }
                    }

                    console.warn('ğŸ” è©²é¡è‰²æ‰€æœ‰æ£‹å­:', colorPieces);
                    return null;
                };
// è¼”åŠ©å‡½æ•¸ï¼šåˆ¤æ–·æ˜¯å¦ç‚ºç‹
                const isKingPiece = (piece) => {
                    if (!piece || !piece.type) return false;

                    const type = piece.type;

                    // å¤šç¨®å¯èƒ½çš„ç‹çš„è¡¨ç¤ºæ–¹å¼
                    const kingTypes = [
                        'å¸¥', 'å°‡',           // ä¸­æ–‡
                        'king', 'King',      // è‹±æ–‡
                        'K', 'k',            // ç°¡å¯«
                        'ç‹'                 // å…¶ä»–å¯èƒ½çš„ä¸­æ–‡è¡¨ç¤º
                    ];

                    // ç›´æ¥æ¯”è¼ƒ
                    if (kingTypes.includes(type)) {
                        console.log(`âœ… è­˜åˆ¥ç‚ºç‹: ${type}`);
                        return true;
                    }

                    // ä½¿ç”¨ getStandardPieceType å‡½æ•¸ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                    try {
                        if (typeof getStandardPieceType === 'function') {
                            const standardType = getStandardPieceType(type);
                            if (standardType === 'king') {
                                console.log(`âœ… é€šéæ¨™æº–åŒ–è­˜åˆ¥ç‚ºç‹: ${type} -> ${standardType}`);
                                return true;
                            }
                        }
                    } catch (error) {
                        console.warn('âš ï¸ getStandardPieceType å‡½æ•¸å‡ºéŒ¯:', error);
                    }

                    return false;
                };

                // æª¢æŸ¥ä½ç½®æ˜¯å¦è¢«æ”»æ“Š
                const isPositionUnderAttack = (testBoard, pos, attackerColor) => {
                    if (!Array.isArray(testBoard) || !pos ||
                        (attackerColor !== 'red' && attackerColor !== 'black')) {
                        console.error('âŒ isPositionUnderAttack: ç„¡æ•ˆåƒæ•¸', { testBoard, pos, attackerColor });
                        return false;
                    }

                    // æ·±æ‹·è²æ£‹ç›¤ï¼ˆåŒ…å«æ‰€æœ‰æ£‹å­ï¼‰
                    const boardCopy = deepCopyBoard(testBoard);
                    if (!boardCopy) {
                        console.error('âŒ isPositionUnderAttack: æ£‹ç›¤æ·±æ‹·è²å¤±æ•—');
                        return false;
                    }

                    // ç²å–æ”»æ“Šæ–¹æ‰€æœ‰æ£‹å­ï¼ˆåŸºæ–¼æ‹·è²å¾Œçš„æ£‹ç›¤ï¼‰
                    const attackerPieces = getFriendlyPieces(boardCopy, attackerColor);

                    for (const piece of attackerPieces) {
                        // ç¢ºä¿æ£‹å­ç‰©ä»¶ä¹Ÿæ˜¯æ·±æ‹·è²
                        const pieceCopy = deepCopyPiece(piece.piece);
                        if (!pieceCopy) continue;

                        // ç²å–æ”»æ“Šç¯„åœï¼ˆä½¿ç”¨æ‹·è²å¾Œçš„æ£‹ç›¤å’Œæ£‹å­ï¼‰
                        const attackPositions = getPieceAttackPositions(
                            boardCopy,
                            { ...piece.pos }, // ä½ç½®ç‰©ä»¶ä¹Ÿè¤‡è£½
                            pieceCopy
                        );

                        for (const attackPos of attackPositions) {
                            if (attackPos.row === pos.row && attackPos.col === pos.col) {
                                return true;
                            }
                        }
                    }
                    return false;
                };

                // æª¢æŸ¥æ£‹å­æ˜¯å¦è¢«ç‰½åˆ¶
                const isPinned = (testBoard, piecePos, testPiece) => {
                    if (!Array.isArray(testBoard) || !piecePos || !testPiece) {
                        console.error('âŒ isPinned: ç„¡æ•ˆåƒæ•¸', { testBoard, piecePos, testPiece });
                        return false;
                    }

                    // æ·±æ‹·è²æ£‹ç›¤å’Œæ£‹å­
                    const boardCopy = deepCopyBoard(testBoard);
                    const pieceCopy = deepCopyPiece(testPiece);
                    if (!boardCopy || !pieceCopy) {
                        console.error('âŒ isPinned: æ·±æ‹·è²å¤±æ•—');
                        return false;
                    }

                    // æ¨¡æ“¬ç§»å‹•æ£‹å­ï¼ˆåœ¨æ‹·è²çš„æ£‹ç›¤ä¸Šæ“ä½œï¼‰
                    boardCopy[piecePos.row][piecePos.col] = null;

                    // æŸ¥æ‰¾å·±æ–¹ç‹çš„ä½ç½®ï¼ˆåŸºæ–¼æ‹·è²å¾Œçš„æ£‹ç›¤ï¼‰
                    const kingPos = findKing(boardCopy, pieceCopy.color);
                    if (!kingPos) {
                        console.warn('âš ï¸ isPinned: æ‰¾ä¸åˆ°ç‹', pieceCopy.color);
                        return false;
                    }

                    // æª¢æŸ¥ç‹æ˜¯å¦è¢«æ”»æ“Šï¼ˆä½¿ç”¨æ‹·è²å¾Œçš„æ£‹ç›¤ï¼‰
                    return isPositionUnderAttack(
                        boardCopy,
                        kingPos,
                        pieceCopy.color === 'red' ? 'black' : 'red'
                    );
                };

                // ä¿®æ­£ç‰ˆ testRevengeCapability å‡½æ•¸ - åˆ†ææ‰€æœ‰å¯èƒ½æ”»æ“Šè€…
                const testRevengeCapability = (testBoard, rootPos, rootPiece, targetPos, target, specificAttackerPos = null, specificAttackerPiece = null) => {
                    try {
                        console.log(`ğŸ§ª æ¸¬è©¦å ±å¾©èƒ½åŠ›: ${rootPiece.color}æ–¹${rootPiece.type} ä¿è­· ${target.color}æ–¹${target.type}`);

                        const enemyColor = rootPiece.color === 'red' ? 'black' : 'red';
                        console.log(`ğŸ¯ å·±æ–¹: ${rootPiece.color}, æ•µæ–¹: ${enemyColor}`);

                        // ğŸ”¥ æ–°é‚è¼¯ï¼šå¦‚æœæŒ‡å®šäº†ç‰¹å®šæ”»æ“Šè€…ï¼Œåªåˆ†æé€™å€‹æ”»æ“Šè€…
                        // å¦‚æœæ²’æœ‰æŒ‡å®šï¼Œå‰‡éœ€è¦æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„æ”»æ“Šè€…ä¸¦é€ä¸€åˆ†æ
                        let attackersToTest = [];

                        if (specificAttackerPos && specificAttackerPiece) {
                            console.log(`ğŸ¯ æŒ‡å®šæ”»æ“Šè€…: ${specificAttackerPiece.color}æ–¹${specificAttackerPiece.type} ä½ç½®: (${specificAttackerPos.row},${specificAttackerPos.col})`);
                            attackersToTest = [{ pos: specificAttackerPos, piece: specificAttackerPiece }];
                        } else {
                            // æ‰¾å‡ºæ‰€æœ‰å¯èƒ½æ”»æ“Šç›®æ¨™çš„æ•µæ–¹å­åŠ›
                            console.log('ğŸ” å°‹æ‰¾æ‰€æœ‰å¯èƒ½çš„æ”»æ“Šè€…...');
                            for (let row = 0; row < testBoard.length; row++) {
                                for (let col = 0; col < testBoard[row].length; col++) {
                                    const piece = testBoard[row][col];
                                    if (piece && piece.color === enemyColor) {
                                        const attackPositions = getPieceAttackPositions(testBoard, { row, col }, piece);
                                        const canAttackTarget = attackPositions.some(pos =>
                                            pos.row === targetPos.row && pos.col === targetPos.col
                                        );

                                        if (canAttackTarget) {
                                            attackersToTest.push({ pos: { row, col }, piece });
                                            console.log(`   ç™¼ç¾æ”»æ“Šè€…: ${piece.color}æ–¹${piece.type} ä½ç½®: (${row},${col})`);
                                        }
                                    }
                                }
                            }
                        }

                        if (attackersToTest.length === 0) {
                            console.log('âŒ æ²’æœ‰æ‰¾åˆ°ä»»ä½•æ”»æ“Šè€…');
                            return false;
                        }

                        console.log(`ğŸ“Š ç¸½å…±éœ€è¦åˆ†æ ${attackersToTest.length} å€‹æ”»æ“Šè€…`);

                        // ğŸ”¥ é—œéµé‚è¼¯ï¼šåªè¦æœ‰ä»»ä½•ä¸€å€‹æ”»æ“Šè€…èƒ½è®“æ ¹å­å¤±æ•ˆï¼Œå°±ç®—æ‰å­
                        for (let i = 0; i < attackersToTest.length; i++) {
                            const attacker = attackersToTest[i];
                            console.log(`\nğŸ¯ åˆ†ææ”»æ“Šè€… ${i + 1}/${attackersToTest.length}: ${attacker.piece.color}æ–¹${attacker.piece.type} (${attacker.pos.row},${attacker.pos.col})`);

                            const canSafelyRevenge = testSingleAttackerRevenge(testBoard, rootPos, rootPiece, targetPos, target, attacker.pos, attacker.piece, enemyColor);

                            if (!canSafelyRevenge) {
                                console.log(`ğŸ’€ æ”»æ“Šè€… ${i + 1} æœƒè®“æ ¹å­å¤±æ•ˆï¼`);
                                console.log(`âŒ æ ¹æ“š"ä»»ä¸€æ”»æ“Šè€…å¤±æ•ˆå³æ‰å­"åŸå‰‡ï¼Œæ­¤æ ¹å­ç„¡æ•ˆ`);
                                return false;
                            } else {
                                console.log(`âœ… æ”»æ“Šè€… ${i + 1} æƒ…æ³ä¸‹æ ¹å­å¯ä»¥å®‰å…¨å ±å¾©`);
                            }
                        }

                        console.log(`ğŸ‰ æ‰€æœ‰ ${attackersToTest.length} å€‹æ”»æ“Šè€…æƒ…æ³ä¸‹ï¼Œæ ¹å­éƒ½å¯ä»¥å®‰å…¨å ±å¾©`);
                        return true;

                    } catch (error) {
                        console.error('ğŸš« testRevengeCapability éŒ¯èª¤:', error);
                        return false;
                    }
                };

// ğŸ”¥ æ–°å¢ï¼šæ¸¬è©¦å–®å€‹æ”»æ“Šè€…çš„å ±å¾©èƒ½åŠ›
                const testSingleAttackerRevenge = (testBoard, rootPos, rootPiece, targetPos, target, attackerPos, attackerPiece, enemyColor) => {
                    try {
                        // ç¬¬ä¸€éšæ®µï¼šæª¢æŸ¥æ ¹å­ç§»å‹•å‰ç‹æ˜¯å¦å·²ç¶“å®‰å…¨
                        const originalKingPos = findKing(testBoard, rootPiece.color);
                        if (!originalKingPos) {
                            console.log('âŒ æ‰¾ä¸åˆ°å·±æ–¹ç‹');
                            return false;
                        }

                        // ç¬¬äºŒéšæ®µï¼šæª¢æŸ¥æ ¹å­ç§»å‹•æ˜¯å¦æœƒè®“ç‹æš´éœ²åœ¨å±éšªä¸­
                        let rootMoveBoard = testBoard.map(row => [...row]);
                        rootMoveBoard[rootPos.row][rootPos.col] = null;
                        const isKingExposedAfterRootMove = isPositionUnderAttack(rootMoveBoard, originalKingPos, enemyColor);

                        if (isKingExposedAfterRootMove) {
                            console.log('âŒ æ ¹å­ç§»å‹•æœƒè®“å·±æ–¹ç‹æš´éœ²åœ¨æ”»æ“Šç¯„åœå…§');
                            return false;
                        }

                        // ç¬¬ä¸‰éšæ®µï¼šå‰µå»ºæ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œçš„æ£‹ç›¤ç‹€æ…‹
                        let simulationBoard = testBoard.map(row => [...row]);
                        simulationBoard[targetPos.row][targetPos.col] = { ...attackerPiece };
                        simulationBoard[attackerPos.row][attackerPos.col] = null;

                        // æª¢æŸ¥æ ¹å­æ˜¯å¦èƒ½æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®
                        const rootAttackPositions = getPieceAttackPositions(simulationBoard, rootPos, rootPiece);
                        const canAttackBack = rootAttackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (!canAttackBack) {
                            console.log('âŒ æ ¹å­ç„¡æ³•æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®é€²è¡Œå ±å¾©');
                            return false;
                        }

                        // ğŸ”¥ é‡è¦ï¼šæª¢æŸ¥æ”»æ“Šè€…ç§»å‹•å¾Œæ•´å€‹æ£‹ç›¤çš„å°‡è»ç‹€æ³
                        const finalKingPos = originalKingPos;
                        const isKingInCheckAfterCapture = isPositionUnderAttack(simulationBoard, finalKingPos, enemyColor);

                        console.log('ğŸ” åˆ†ææ”»æ“Šè€…ç§»å‹•å¾Œçš„å®Œæ•´å¨è„…æƒ…æ³...');
                        console.log(`ğŸ“ æ”»æ“Šè€…å¾ (${attackerPos.row},${attackerPos.col}) ç§»å‹•åˆ° (${targetPos.row},${targetPos.col})`);

                        if (isKingInCheckAfterCapture) {
                            console.log('âš ï¸ æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œï¼Œå·±æ–¹ç‹å—åˆ°å°‡è»');

                            // è©³ç´°åˆ†æå°‡è»ä¾†æº
                            const checkSources = getAttackingSources(simulationBoard, finalKingPos, enemyColor);
                            console.log(`ğŸ‘ï¸ å°‡è»ä¾†æº: ${checkSources.length} å€‹`);

                            checkSources.forEach((source, index) => {
                                console.log(`   ${index + 1}. ${source.piece.color}æ–¹${source.piece.type} ä½ç½®: (${source.pos.row},${source.pos.col})`);

                                // ğŸ”¥ æª¢æŸ¥é€™å€‹å°‡è»æ˜¯å¦æ˜¯å› ç‚ºæ”»æ“Šè€…ç§»å‹•è€Œæ–°ç”¢ç”Ÿçš„
                                const wasCheckingBefore = isSpecificPieceAttacking(testBoard, source.pos, source.piece, finalKingPos);
                                if (!wasCheckingBefore) {
                                    console.log(`   âš¡ é€™æ˜¯æ”»æ“Šè€…ç§»å‹•å¾Œæ–°ç”¢ç”Ÿçš„å°‡è»å¨è„…ï¼`);
                                }
                            });

                            // æ¨¡æ“¬æ ¹å­å ±å¾©å¾Œçš„æƒ…æ³
                            let revengeBoard = simulationBoard.map(row => [...row]);
                            revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                            revengeBoard[rootPos.row][rootPos.col] = null;

                            // ç¢ºå®šå ±å¾©å¾Œç‹çš„ä½ç½®
                            let revengeKingPos;
                            if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                                revengeKingPos = targetPos;
                                console.log(`ğŸ‘‘ ç‹ä½œç‚ºæ ¹å­ç§»å‹•åˆ°æ–°ä½ç½®: (${targetPos.row},${targetPos.col})`);
                            } else {
                                revengeKingPos = findKing(revengeBoard, rootPiece.color);
                                console.log(`ğŸ‘‘ ç‹ä»åœ¨åŸä½ç½®: (${revengeKingPos?.row},${revengeKingPos?.col})`);
                            }

                            if (!revengeKingPos) {
                                console.log('âŒ å ±å¾©å¾Œæ‰¾ä¸åˆ°å·±æ–¹ç‹');
                                return false;
                            }

                            // æª¢æŸ¥å ±å¾©å¾Œæ˜¯å¦ä»å—åˆ°å°‡è»
                            const isKingStillInCheckAfterRevenge = isPositionUnderAttack(revengeBoard, revengeKingPos, enemyColor);

                            if (isKingStillInCheckAfterRevenge) {
                                console.log('âŒ æ ¹å­å ±å¾©å¾Œç‹ä»å—åˆ°å°‡è»');

                                const revengeCheckSources = getAttackingSources(revengeBoard, revengeKingPos, enemyColor);
                                console.log(`ğŸ‘ï¸ å ±å¾©å¾Œå°‡è»ä¾†æº: ${revengeCheckSources.length} å€‹`);

                                let foundCriticalThreat = false;
                                revengeCheckSources.forEach((source, index) => {
                                    console.log(`   ${index + 1}. ${source.piece.color}æ–¹${source.piece.type} ä½ç½®: (${source.pos.row},${source.pos.col})`);

                                    // ğŸ”¥ ç‰¹åˆ¥æª¢æŸ¥ï¼šæ ¹å­æ˜¯å¦æˆç‚ºäº†ç‚®æ¶æˆ–å…¶ä»–æ”»æ“Šåª’ä»‹
                                    if (source.piece.type === 'ç‚®' || source.piece.type === 'ç ²') {
                                        const cannonPath = getCannonPath(revengeBoard, source.pos, revengeKingPos);
                                        if (cannonPath && cannonPath.mount) {
                                            const mountPos = cannonPath.mount;
                                            const mountPiece = revengeBoard[mountPos.row][mountPos.col];
                                            if (mountPiece &&
                                                mountPos.row === targetPos.row &&
                                                mountPos.col === targetPos.col &&
                                                mountPiece.color === rootPiece.color) {
                                                console.log('ğŸ’€ è‡´å‘½ç™¼ç¾ï¼šæ ¹å­å ±å¾©å¾Œæˆç‚ºæ•µæ–¹ç‚®çš„ç‚®æ¶ï¼Œå°è‡´ç‹è¢«å°‡è»ï¼');
                                                console.log(`   ç‚®æ¶ä½ç½®: (${mountPos.row},${mountPos.col}) - æ­£æ˜¯æ ¹å­å ±å¾©å¾Œçš„ä½ç½®`);
                                                foundCriticalThreat = true;
                                            }
                                        }
                                    }

                                    // æª¢æŸ¥å…¶ä»–é¡å‹çš„æ”»æ“Šå¨è„…
                                    const wasThreateningBeforeRevenge = isSpecificPieceAttacking(simulationBoard, source.pos, source.piece, revengeKingPos);
                                    if (!wasThreateningBeforeRevenge) {
                                        console.log(`   âš¡ é€™æ˜¯æ ¹å­ç§»å‹•å¾Œæ–°ç”¢ç”Ÿçš„å¨è„…ï¼`);
                                        foundCriticalThreat = true;
                                    }
                                });

                                if (foundCriticalThreat) {
                                    console.log('ğŸ’€ æ ¹å­å ±å¾©ç”¢ç”Ÿæ–°çš„è‡´å‘½å¨è„…ï¼Œæ­¤æ”»æ“Šè€…æƒ…æ³ä¸‹æ ¹å­ç„¡æ•ˆ');
                                    return false;
                                }

                                console.log('âŒ æ­¤æ”»æ“Šè€…æƒ…æ³ä¸‹æ ¹å­ç„¡æ•ˆ');
                                return false;
                            }

                            console.log('âœ… æ ¹å­å ±å¾©èƒ½å¤ è§£å°‡ï¼Œç¬¦åˆå°‡è»å¿…æ‡‰åŸå‰‡');
                        } else {
                            // æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œç‹æ²’æœ‰å—åˆ°å°‡è»çš„æƒ…æ³
                            console.log('âœ… æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œå·±æ–¹ç‹å®‰å…¨ï¼Œé€²è¡Œå¸¸è¦å ±å¾©æª¢æŸ¥');

                            let revengeBoard = simulationBoard.map(row => [...row]);
                            revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                            revengeBoard[rootPos.row][rootPos.col] = null;

                            let revengeKingPos;
                            if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                                revengeKingPos = targetPos;
                            } else {
                                revengeKingPos = findKing(revengeBoard, rootPiece.color);
                            }

                            if (!revengeKingPos) {
                                console.log('âŒ å ±å¾©å¾Œæ‰¾ä¸åˆ°å·±æ–¹ç‹');
                                return false;
                            }

                            const kingUnderAttackAfterRevenge = isPositionUnderAttack(revengeBoard, revengeKingPos, enemyColor);

                            if (kingUnderAttackAfterRevenge) {
                                console.log('âŒ å ±å¾©å¾Œå·±æ–¹ç‹æœƒå—åˆ°æ–°çš„æ”»æ“Šå¨è„…');

                                const newThreats = getAttackingSources(revengeBoard, revengeKingPos, enemyColor);
                                newThreats.forEach((threat, index) => {
                                    console.log(`   å¨è„… ${index + 1}: ${threat.piece.color}æ–¹${threat.piece.type} ä½ç½®: (${threat.pos.row},${threat.pos.col})`);

                                    if (threat.piece.type === 'ç‚®' || threat.piece.type === 'ç ²') {
                                        const cannonPath = getCannonPath(revengeBoard, threat.pos, revengeKingPos);
                                        if (cannonPath && cannonPath.mount) {
                                            const mountPos = cannonPath.mount;
                                            if (mountPos.row === targetPos.row && mountPos.col === targetPos.col) {
                                                console.log('ğŸ’€ æ ¹å­å ±å¾©å¾Œæˆç‚ºç‚®æ¶ï¼Œç”¢ç”Ÿæ–°çš„å°‡è»å¨è„…ï¼');
                                            }
                                        }
                                    }
                                });

                                return false;
                            }
                        }

                        // å°‡å¸¥å°é¢è¦å‰‡æª¢æŸ¥
                        if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                            let revengeBoard = simulationBoard.map(row => [...row]);
                            revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                            revengeBoard[rootPos.row][rootPos.col] = null;

                            const enemyKingPos = findKing(revengeBoard, enemyColor);
                            if (enemyKingPos && targetPos.col === enemyKingPos.col) {
                                let hasObstacle = false;
                                const minRow = Math.min(targetPos.row, enemyKingPos.row);
                                const maxRow = Math.max(targetPos.row, enemyKingPos.row);

                                for (let r = minRow + 1; r < maxRow; r++) {
                                    if (revengeBoard[r][targetPos.col] !== null) {
                                        hasObstacle = true;
                                        break;
                                    }
                                }

                                if (!hasObstacle) {
                                    console.log('âŒ å ±å¾©å¾Œå…©å€‹å°‡å¸¥é¢å°é¢ï¼Œé•åè¦å‰‡');
                                    return false;
                                }
                            }
                        }

                        return true;

                    } catch (error) {
                        console.error('ğŸš« testSingleAttackerRevenge éŒ¯èª¤:', error);
                        return false;
                    }
                };

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥ç‰¹å®šæ£‹å­æ˜¯å¦åœ¨æ”»æ“Šç‰¹å®šä½ç½®
                const isSpecificPieceAttacking = (board, piecePos, piece, targetPos) => {
                    try {
                        const attackPositions = getPieceAttackPositions(board, piecePos, piece);
                        return attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );
                    } catch (error) {
                        console.error('æª¢æŸ¥ç‰¹å®šæ£‹å­æ”»æ“Šæ™‚å‡ºéŒ¯:', error);
                        return false;
                    }
                };

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šç²å–æ”»æ“ŠæŸä½ç½®çš„æ‰€æœ‰æ•µæ–¹å­åŠ›
                const getAttackingSources = (board, targetPos, attackerColor) => {
                    const attackingSources = [];

                    for (let row = 0; row < board.length; row++) {
                        for (let col = 0; col < board[row].length; col++) {
                            const piece = board[row][col];
                            if (piece && piece.color === attackerColor) {
                                const attackPositions = getPieceAttackPositions(board, { row, col }, piece);
                                const canAttack = attackPositions.some(pos =>
                                    pos.row === targetPos.row && pos.col === targetPos.col
                                );

                                if (canAttack) {
                                    attackingSources.push({
                                        pos: { row, col },
                                        piece: piece
                                    });
                                }
                            }
                        }
                    }

                    return attackingSources;
                };

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šç²å–ç‚®çš„æ”»æ“Šè·¯å¾‘å’Œç‚®æ¶ä¿¡æ¯
                const getCannonPath = (board, cannonPos, targetPos) => {
                    // æª¢æŸ¥æ˜¯å¦åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—
                    if (cannonPos.row !== targetPos.row && cannonPos.col !== targetPos.col) {
                        return null;
                    }

                    let mountCount = 0;
                    let mountPos = null;

                    if (cannonPos.row === targetPos.row) {
                        // åŒä¸€è¡Œ
                        const startCol = Math.min(cannonPos.col, targetPos.col);
                        const endCol = Math.max(cannonPos.col, targetPos.col);

                        for (let col = startCol + 1; col < endCol; col++) {
                            if (board[cannonPos.row][col] !== null) {
                                mountCount++;
                                if (mountCount === 1) {
                                    mountPos = { row: cannonPos.row, col };
                                } else {
                                    return null; // è¶…éä¸€å€‹ç‚®æ¶
                                }
                            }
                        }
                    } else {
                        // åŒä¸€åˆ—
                        const startRow = Math.min(cannonPos.row, targetPos.row);
                        const endRow = Math.max(cannonPos.row, targetPos.row);

                        for (let row = startRow + 1; row < endRow; row++) {
                            if (board[row][cannonPos.col] !== null) {
                                mountCount++;
                                if (mountCount === 1) {
                                    mountPos = { row, col: cannonPos.col };
                                } else {
                                    return null; // è¶…éä¸€å€‹ç‚®æ¶
                                }
                            }
                        }
                    }

                    // ç‚®éœ€è¦æ­£å¥½ä¸€å€‹ç‚®æ¶æ‰èƒ½æ”»æ“Š
                    if (mountCount === 1) {
                        return { mount: mountPos };
                    }

                    return null;
                };

                // æª¢æŸ¥æ˜¯å¦æœ‰æ ¹å­ä¿è­· - ç°¡åŒ–ç‰ˆï¼ˆåªåˆ¤æ–·æ˜¯å¦æœ‰æ ¹å­ï¼Œä¸è€ƒæ…®æ•¸é‡å°æ¯”ï¼‰
                const hasRoot = (testBoard, targetPos, target, currentAttackerPos = null) => {
                    if (!Array.isArray(testBoard) || !targetPos || !target ||
                        (target.color !== 'red' && target.color !== 'black')) {
                        console.error('âŒ hasRoot: ç„¡æ•ˆåƒæ•¸', {
                            board: testBoard,
                            pos: targetPos,
                            piece: target
                        });
                        return false;
                    }

                    console.log('ğŸ” é–‹å§‹æª¢æŸ¥æ ¹å­ | ç›®æ¨™:', `${target.color}æ–¹${target.type}`, `ä½ç½®: (${targetPos.row},${targetPos.col})`);

                    // ç²å–æ‰€æœ‰æ”»æ“Šç›®æ¨™çš„æ•µæ–¹æ£‹å­
                    const enemyColor = target.color === 'red' ? 'black' : 'red';
                    const allAttackers = [];

                    // éæ­·æ‰€æœ‰æ•µæ–¹æ£‹å­ï¼Œæ‰¾å‡ºèƒ½æ”»æ“Šç›®æ¨™çš„æ£‹å­
                    for (let row = 0; row < testBoard.length; row++) {
                        for (let col = 0; col < testBoard[row].length; col++) {
                            const piece = testBoard[row][col];
                            if (piece && piece.color === enemyColor) {
                                const attackPositions = getPieceAttackPositions(testBoard, { row, col }, piece);
                                const canAttackTarget = attackPositions.some(pos =>
                                    pos.row === targetPos.row && pos.col === targetPos.col
                                );

                                if (canAttackTarget) {
                                    allAttackers.push({
                                        piece: piece,
                                        pos: { row, col }
                                    });
                                }
                            }
                        }
                    }

                    console.log(`ğŸ¯ ç™¼ç¾ ${allAttackers.length} å€‹æ”»æ“Šè€…æ”»æ“Šç›®æ¨™:`);
                    allAttackers.forEach((attacker, index) => {
                        console.log(`   ${index + 1}. ${attacker.piece.color}æ–¹${attacker.piece.type} ä½ç½®: (${attacker.pos.row},${attacker.pos.col})`);
                    });

                    // å¦‚æœæ²’æœ‰æ”»æ“Šè€…ï¼Œå‰‡ä¸éœ€è¦æ ¹å­
                    if (allAttackers.length === 0) {
                        console.log('â„¹ï¸ æ²’æœ‰æ”»æ“Šè€…ï¼Œä¸éœ€è¦æ ¹å­ä¿è­·');
                        return true; // æ²’æœ‰å¨è„…å°±ä¸éœ€è¦ä¿è­·
                    }

                    // ç²å–æ‰€æœ‰å‹æ–¹æ£‹å­ä½œç‚ºæ½›åœ¨æ ¹å­
                    const friendlyPieces = getFriendlyPieces(testBoard, target.color)
                        .filter(p => !(p.pos.row === targetPos.row && p.pos.col === targetPos.col));

                    if (friendlyPieces.length === 0) {
                        console.log('âš ï¸ æ²’æœ‰å…¶ä»–åŒè‰²æ£‹å­å¯ä½œæ ¹å­');
                        return false;
                    }

                    // ğŸ”¥ é—œéµä¿®æ”¹ï¼šåªè¦æ‰¾åˆ°ä»»ä½•ä¸€å€‹çœŸæ ¹å­å°±è¿”å›true
                    console.log('ğŸ” é–‹å§‹æª¢æŸ¥æ˜¯å¦å­˜åœ¨çœŸæ ¹å­...');

                    for (const { piece: rootPiece, pos: rootPos } of friendlyPieces) {
                        console.log(`ğŸ” æª¢æŸ¥æ½›åœ¨æ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type}`, `ä½ç½®: (${rootPos.row},${rootPos.col})`);

                        // æª¢æŸ¥é€™å€‹æ ¹å­æ˜¯å¦èƒ½å°ä»»ä¸€æ”»æ“Šè€…é€²è¡Œæœ‰æ•ˆå ±å¾©
                        for (const attacker of allAttackers) {
                            const canRevenge = testRevengeCapability(testBoard, rootPos, rootPiece, targetPos, target, attacker.pos, attacker.piece);
                            if (canRevenge) {
                                // ğŸ”¥ ç‰¹æ®Šæª¢æŸ¥ï¼šå¦‚æœæ ¹å­æ˜¯å°‡å¸¥ï¼Œéœ€è¦é©—è­‰å ±å¾©å¾Œæ˜¯å¦å®‰å…¨
                                if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                                    console.log(`ğŸ” å°‡å¸¥æ ¹å­ç‰¹æ®Šæª¢æŸ¥: ${rootPiece.color}æ–¹${rootPiece.type}`);

                                    // æ¨¡æ“¬å°‡å¸¥åƒæ‰æ”»æ“Šè€…å¾Œçš„æ£‹å±€
                                    const simulatedBoard = JSON.parse(JSON.stringify(testBoard));

                                    // ç§»é™¤è¢«æ”»æ“Šçš„ç›®æ¨™æ£‹å­ï¼ˆå‡è¨­å·²è¢«æ”»æ“Šè€…åƒæ‰ï¼‰
                                    simulatedBoard[targetPos.row][targetPos.col] = null;

                                    // å°‡å¸¥ç§»å‹•åˆ°æ”»æ“Šè€…ä½ç½®ï¼ˆå ±å¾©ï¼‰
                                    simulatedBoard[attacker.pos.row][attacker.pos.col] = rootPiece;
                                    simulatedBoard[rootPos.row][rootPos.col] = null;

                                    // æª¢æŸ¥å°‡å¸¥åœ¨æ–°ä½ç½®æ˜¯å¦æœƒè¢«å…¶ä»–æ•µæ–¹æ£‹å­æ”»æ“Š
                                    const kingNewPos = { row: attacker.pos.row, col: attacker.pos.col };
                                    let wouldBeAttacked = false;

                                    for (let row = 0; row < simulatedBoard.length; row++) {
                                        for (let col = 0; col < simulatedBoard[row].length; col++) {
                                            const piece = simulatedBoard[row][col];
                                            if (piece && piece.color === enemyColor) {
                                                const attackPositions = getPieceAttackPositions(simulatedBoard, { row, col }, piece);
                                                const canAttackKing = attackPositions.some(pos =>
                                                    pos.row === kingNewPos.row && pos.col === kingNewPos.col
                                                );

                                                if (canAttackKing) {
                                                    console.log(`âš ï¸ ${rootPiece.type}å ±å¾©å¾Œæœƒè¢« ${piece.color}æ–¹${piece.type}(${row},${col}) æ”»æ“Š`);
                                                    wouldBeAttacked = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (wouldBeAttacked) break;
                                    }

                                    if (wouldBeAttacked) {
                                        console.log(`âŒ å°‡å¸¥æ ¹å­ç„¡æ•ˆ: ${rootPiece.type}å ±å¾©å¾Œæœƒè¢«æ”»æ“Šï¼Œä¸æ˜¯çœŸæ ¹å­`);
                                        continue; // é€™å€‹å°‡å¸¥ä¸æ˜¯çœŸæ ¹å­ï¼Œç¹¼çºŒæª¢æŸ¥å…¶ä»–æ½›åœ¨æ ¹å­
                                    } else {
                                        console.log(`âœ… å°‡å¸¥æ ¹å­æœ‰æ•ˆ: ${rootPiece.type}å ±å¾©å¾Œå®‰å…¨`);
                                    }
                                }

                                console.log(`âœ… ç™¼ç¾çœŸæ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type} å¯å ±å¾© ${attacker.piece.color}æ–¹${attacker.piece.type}`);
                                console.log(`ğŸ¯ æ ¹å­æª¢æŸ¥çµæœ: æœ‰çœŸæ ¹å­ä¿è­·`);
                                return true; // åªè¦æœ‰ä¸€å€‹çœŸæ ¹å­å°±è¶³å¤ 
                            }
                        }

                        console.log(`âŒ éçœŸæ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type} ç„¡æ³•å°ä»»ä½•æ”»æ“Šè€…å ±å¾©`);
                    }

                    console.log('âŒ æ ¹å­æª¢æŸ¥çµæœ: æ²’æœ‰çœŸæ ¹å­ä¿è­·');
                    return false;
                };


                // æª¢æŸ¥æ˜¯å¦ç‚ºåŒé¡å­äº’æ‰
                const isSameTypeChase = (attacker, target) => {
                    if (!attacker || !target) {
                        console.log('â„¹ï¸ isSameTypeChase: åƒæ•¸ç„¡æ•ˆ');
                        return false;
                    }

                    // å¿…é ˆæ˜¯ä¸åŒé¡è‰²
                    if (attacker.color === target.color) {
                        console.log('â„¹ï¸ isSameTypeChase: åŒè‰²æ£‹å­');
                        return false;
                    }

                    console.log(`ğŸ” isSameTypeChase: æª¢æŸ¥ ${attacker.color} ${attacker.type} å’Œ ${target.color} ${target.type}`);

                    const pieceTypeMap = {
                        'è»Š': 'rook', 'ä¿¥': 'rook',
                        'é¦¬': 'horse', 'å‚Œ': 'horse',
                        'åŒ…': 'cannon', 'ç‚®': 'cannon',
                        'è±¡': 'elephant', 'ç›¸': 'elephant',
                        'å£«': 'advisor', 'ä»•': 'advisor',
                        'å°‡': 'king', 'å¸¥': 'king',
                        'å’': 'pawn', 'å…µ': 'pawn'
                    };

                    const attackerStandardType = pieceTypeMap[attacker.type];
                    const targetStandardType = pieceTypeMap[target.type];

                    if (!attackerStandardType || !targetStandardType) {
                        console.warn('âš ï¸ isSameTypeChase: æœªçŸ¥æ£‹å­é¡å‹', {
                            attacker: attacker.type,
                            target: target.type
                        });
                        return false;
                    }

                    const isSameType = attackerStandardType === targetStandardType;
                    console.log(`â„¹ï¸ isSameTypeChase: çµæœ = ${isSameType} (${attackerStandardType} vs ${targetStandardType})`);

                    return isSameType;
                };

                // æª¢æŸ¥è¢«æ‰æ–¹æ˜¯å¦èƒ½ååƒæ”»æ“Šæ–¹
                const canTargetAttackAttacker = (testBoard, targetPos, target, attackerPos, attacker) => {
                    try {
                        if (!testBoard || !targetPos || !target || !attackerPos || !attacker) {
                            console.error('âŒ canTargetAttackAttacker: åƒæ•¸ç„¡æ•ˆ');
                            return false;
                        }

                        if (!isValidPosition(targetPos.row, targetPos.col) || !isValidPosition(attackerPos.row, attackerPos.col)) {
                            console.error('âŒ canTargetAttackAttacker: ä½ç½®ç„¡æ•ˆ');
                            return false;
                        }

                        const actualTarget = testBoard[targetPos.row][targetPos.col];
                        const actualAttacker = testBoard[attackerPos.row][attackerPos.col];

                        if (!actualTarget || !actualAttacker) {
                            console.error('âŒ canTargetAttackAttacker: æ£‹ç›¤ä¸Šæ‰¾ä¸åˆ°å°æ‡‰æ£‹å­', {
                                targetPos, actualTarget,
                                attackerPos, actualAttacker
                            });
                            return false;
                        }

                        console.log(`ğŸ” æª¢æŸ¥ ${target.color} ${target.type} èƒ½å¦ååƒ ${attacker.color} ${attacker.type}`);

                        // 1. åŸºæœ¬æª¢æŸ¥ï¼šè¢«æ‰æ–¹æ˜¯å¦åœ¨æ”»æ“Šç¯„åœå…§èƒ½æ”»æ“Šåˆ°æ”»æ“Šæ–¹
                        const targetAttackPositions = getPieceAttackPositions(testBoard, targetPos, target);
                        const canDirectlyAttack = targetAttackPositions.some(pos =>
                            pos.row === attackerPos.row && pos.col === attackerPos.col
                        );

                        if (!canDirectlyAttack) {
                            console.log('â„¹ï¸ è¢«æ‰æ–¹ç„¡æ³•ç›´æ¥æ”»æ“Šåˆ°æ”»æ“Šæ–¹');
                            return false;
                        }

                        // 2. ç‰¹æ®Šæª¢æŸ¥ï¼šå¦‚æœè¢«æ‰æ–¹æ˜¯é¦¬ï¼Œæª¢æŸ¥æ˜¯å¦è¢«æ‹é¦¬è…³
                        if (target.type === 'é¦¬' || target.type === 'å‚Œ') {
                            const horseCanMove = isValidHorseMove(testBoard, targetPos.row, targetPos.col, attackerPos.row, attackerPos.col);
                            if (!horseCanMove) {
                                console.log('â„¹ï¸ é¦¬è¢«æ‹è…³ï¼Œç„¡æ³•ååƒ');
                                return false;
                            }
                        }

                        // 3. é—œéµæª¢æŸ¥ï¼šæ¨¡æ“¬ååƒå‹•ä½œï¼Œçœ‹æ˜¯å¦æœƒå°è‡´å·±æ–¹ç‹è¢«æ”»æ“Š
                        let boardCopy;
                        try {
                            boardCopy = JSON.parse(JSON.stringify(testBoard));
                        } catch (copyError) {
                            console.error('âŒ æ£‹ç›¤æ‹·è²å¤±æ•—ï¼Œä½¿ç”¨å‚™ç”¨æ–¹æ³•');
                            return false;
                        }

                        // æ¨¡æ“¬ç›®æ¨™åƒæ‰æ”»æ“Šè€…
                        boardCopy[attackerPos.row][attackerPos.col] = { ...target };
                        boardCopy[targetPos.row][targetPos.col] = null;

                        // æ‰¾åˆ°å·±æ–¹ç‹çš„ä½ç½®
                        const kingPos = findKing(boardCopy, target.color);
                        if (!kingPos) {
                            console.error('âŒ æ‰¾ä¸åˆ°å·±æ–¹ç‹');
                            return false;
                        }

                        // æª¢æŸ¥ååƒå¾Œå·±æ–¹ç‹æ˜¯å¦æœƒè¢«æ”»æ“Š
                        const kingUnderAttack = isPositionUnderAttack(boardCopy, kingPos, target.color === 'red' ? 'black' : 'red');

                        if (kingUnderAttack) {
                            console.log('â„¹ï¸ ååƒæœƒå°è‡´å·±æ–¹ç‹è¢«æ”»æ“Šï¼Œç„¡æ³•ååƒ');
                            return false;
                        }

                        console.log('âœ… è¢«æ‰æ–¹å¯ä»¥å®‰å…¨åœ°ååƒæ”»æ“Šæ–¹');
                        return true;

                    } catch (error) {
                        console.error('ğŸš« canTargetAttackAttacker éŒ¯èª¤:', error);
                        return false;
                    }
                };

                // æª¢æŸ¥æ˜¯å¦ç‚ºå…Œå­
                const isExchange = (piece1, piece2) => {
                    if (!piece1 || !piece2) {
                        console.error('âŒ isExchange: ç„¡æ•ˆçš„åƒæ•¸', { piece1, piece2 });
                        return false;
                    }
                    return piece1.type === piece2.type;
                };

                // æª¢æŸ¥æ˜¯å¦é˜»æ“‹å°æ–¹æ£‹å­ç§»å‹•
                const isBlockingOpponentMovement = (testBoard, attacker, attackerPos, target, targetPos) => {
                    if (!Array.isArray(testBoard) || !attacker || !attackerPos || !target || !targetPos) {
                        console.error('âŒ isBlockingOpponentMovement: ç„¡æ•ˆçš„åƒæ•¸', {
                            testBoard, attacker, attackerPos, target, targetPos
                        });
                        return false;
                    }

                    // é€™è£¡éœ€è¦æ›´è¤‡é›œçš„é‚è¼¯ä¾†åˆ¤å®šæ˜¯å¦ç‚ºé•·æ””
                    // ç°¡åŒ–å¯¦ç¾: å¦‚æœæ”»æ“Šè€…è¢«ç‰½åˆ¶ä¸”åœ¨ç›®æ¨™çš„ç§»å‹•è·¯å¾‘ä¸Š
                    return isPinned(testBoard, attackerPos, attacker);
                };

                // æª¢æŸ¥æ˜¯å¦ç‚ºé•·æ””
                const isBlockingMove = (testBoard, attacker, attackerPos, targetPos, target) => {
                    if (!Array.isArray(testBoard) || !attacker || !attackerPos || !targetPos || !target) {
                        console.error('âŒ isBlockingMove: ç„¡æ•ˆçš„åƒæ•¸', {
                            testBoard, attacker, attackerPos, targetPos, target
                        });
                        return false;
                    }

                    // æª¢æŸ¥æ”»æ“Šè€…æ˜¯å¦å› è¢«ç‰½åˆ¶è€Œç„¡æ³•çœŸæ­£åƒæ‰ç›®æ¨™
                    if (isPinned(testBoard, attackerPos, attacker)) {
                        // é€²ä¸€æ­¥æª¢æŸ¥æ˜¯å¦ç‚ºé˜»æ“‹å°æ–¹æ£‹å­é€šé
                        return isBlockingOpponentMovement(testBoard, attacker, attackerPos, target, targetPos);
                    }
                    return false;
                };
// ==================== æ–°å¢çš„é–“æ¥æ‰å­æª¢æ¸¬å‡½æ•¸ ====================

                /**
                 * ç²å–æŸä¸€æ–¹æ‰€æœ‰è¢«å¨è„…çš„æ£‹å­ï¼ˆç°¡åŒ–ç‰ˆï¼‰
                 * @param {Array} board - æ£‹ç›¤ç‹€æ…‹
                 * @param {string} targetColor - è¢«æª¢æŸ¥çš„ä¸€æ–¹é¡è‰²
                 * @returns {Array} è¢«å¨è„…æ£‹å­çš„ä½ç½®ä¿¡æ¯
                 */
                const getAllThreatenedPieces = (board, targetColor) => {
                    try {
                        console.log(`ğŸ” getAllThreatenedPieces: æª¢æŸ¥ ${targetColor} æ–¹è¢«å¨è„…çš„æ£‹å­`);

                        const threatenedPieces = [];
                        const opponentColor = targetColor === 'red' ? 'black' : 'red';

                        let attackerCount = 0;
                        let targetCount = 0;

                        // éæ­·æ£‹ç›¤æ‰¾å‡ºæ‰€æœ‰å°æ–¹æ£‹å­ï¼Œæª¢æŸ¥å®ƒå€‘èƒ½æ”»æ“Šå“ªäº›ç›®æ¨™æ–¹æ£‹å­
                        for (let attackerRow = 0; attackerRow < 10; attackerRow++) {
                            for (let attackerCol = 0; attackerCol < 9; attackerCol++) {
                                const attacker = board[attackerRow][attackerCol];
                                if (!attacker || attacker.color !== opponentColor) continue;

                                attackerCount++;
                                console.log(`ğŸ¯ æª¢æŸ¥æ”»æ“Šè€…: ${attacker.type}(${attacker.color}) at (${attackerRow},${attackerCol})`);

                                // ç²å–é€™å€‹æ”»æ“Šè€…çš„æ”»æ“Šä½ç½®
                                const attackPositions = getPieceAttackPositions(board, { row: attackerRow, col: attackerCol }, attacker);
                                console.log(`   å¯æ”»æ“Šä½ç½®æ•¸é‡: ${attackPositions.length}`);

                                for (const attackPos of attackPositions) {
                                    const target = board[attackPos.row]?.[attackPos.col];
                                    if (!target || target.color !== targetColor) continue;

                                    targetCount++;
                                    console.log(`   æª¢æŸ¥ç›®æ¨™: ${target.type}(${target.color}) at (${attackPos.row},${attackPos.col})`);

                                    // ä½¿ç”¨ç¾æœ‰çš„ isCaptureMove å‡½æ•¸æª¢æŸ¥æ˜¯å¦ç‚ºæœ‰æ•ˆæ‰å­
                                    const isCaptureResult = isCaptureMove(board, attacker, { row: attackerRow, col: attackerCol }, attackPos, target);
                                    console.log(`   æ˜¯å¦ç‚ºæœ‰æ•ˆæ‰å­: ${isCaptureResult}`);

                                    if (isCaptureResult) {
                                        const threatKey = `${attackPos.row}-${attackPos.col}`;
                                        if (!threatenedPieces.some(t => t.key === threatKey)) {
                                            threatenedPieces.push({
                                                key: threatKey,
                                                targetPos: { row: attackPos.row, col: attackPos.col },
                                                target: target,
                                                attackerPos: { row: attackerRow, col: attackerCol },
                                                attacker: attacker
                                            });
                                            console.log(`   âœ… æ·»åŠ å¨è„…: ${attacker.type} å¨è„… ${target.type}`);
                                        }
                                    }
                                }
                            }
                        }

                        console.log(`ğŸ“Š getAllThreatenedPieces çµæœ: æª¢æŸ¥äº†${attackerCount}å€‹æ”»æ“Šè€…, ${targetCount}å€‹ç›®æ¨™, æ‰¾åˆ°${threatenedPieces.length}å€‹å¨è„…`);
                        return threatenedPieces;
                    } catch (error) {
                        console.error('ğŸš« getAllThreatenedPieces éŒ¯èª¤:', error);
                        return [];
                    }
                };


                const detectIndirectCaptures = (move, color, currentBoard) => {
                    try {
                        const opponentColor = color === 'red' ? 'black' : 'red';
                        let indirectCaptures = [];

                        console.log('ğŸ” é–‹å§‹æª¢æ¸¬é–“æ¥æ‰å­');
                        console.log('ğŸ“‹ move ç‰©ä»¶å…§å®¹:', move);

                        // å¾ move æˆ–åƒæ•¸ä¸­ç²å–å¿…è¦ä¿¡æ¯
                        const board = currentBoard || move.boardAfter;
                        const boardBefore = move.boardBefore;
                        const fromPos = move.from;
                        const toPos = move.to;

                        // å¾ boardBefore å’Œ boardAfter æ¨æ–·ç§»å‹•çš„æ£‹å­
                        let piece = null;
                        if (boardBefore && fromPos) {
                            piece = boardBefore[fromPos.row][fromPos.col];
                        }

                        // åƒæ•¸æª¢é©—
                        if (!board) {
                            console.log('âŒ detectIndirectCaptures: board åƒæ•¸ç¼ºå¤±');
                            console.log('move çµæ§‹:', Object.keys(move));
                            return [];
                        }
                        if (!boardBefore) {
                            console.log('âŒ detectIndirectCaptures: boardBefore åƒæ•¸ç¼ºå¤±');
                            return [];
                        }
                        if (!fromPos) {
                            console.log('âŒ detectIndirectCaptures: fromPos åƒæ•¸ç¼ºå¤±');
                            return [];
                        }
                        if (!toPos) {
                            console.log('âŒ detectIndirectCaptures: toPos åƒæ•¸ç¼ºå¤±');
                            return [];
                        }
                        if (!piece) {
                            console.log('âŒ detectIndirectCaptures: ç„¡æ³•ç²å–ç§»å‹•çš„æ£‹å­');
                            return [];
                        }

                        console.log('âœ… åƒæ•¸æª¢æŸ¥é€šé:', {
                            boardExists: !!board,
                            boardBeforeExists: !!boardBefore,
                            fromPos: fromPos,
                            toPos: toPos,
                            piece: piece
                        });



                        // å¦‚æœæ²’æœ‰è»Šç‚®ç›®æ¨™å¸¥å¨è„…ï¼Œç¹¼çºŒåŸæœ‰çš„é–“æ¥æ‰å­æª¢æ¸¬é‚è¼¯
                        console.log('ğŸ”„ é€²è¡Œå¸¸è¦é–“æ¥æ‰å­æª¢æ¸¬');

                        // æ­¥é©Ÿ2: ç²å–èµ°å­å‰å¾Œçš„å¨è„…ç‹€æ…‹
                        const beforeThreatened = getAllThreatenedPieces(boardBefore, opponentColor);
                        const afterThreatened = getAllThreatenedPieces(board, opponentColor);

                        console.log(`èµ°å­å‰è¢«å¨è„…æ£‹å­: ${beforeThreatened.length}, èµ°å­å¾Œ: ${afterThreatened.length}`);

                        // æ­¥é©Ÿ3: æ‰¾å‡ºæ–°å¢çš„å¨è„…
                        const beforeKeys = new Set(beforeThreatened.map(t => t.key));

                        for (const afterThreat of afterThreatened) {
                            // å¦‚æœé€™å€‹å¨è„…ä¹‹å‰ä¸å­˜åœ¨ï¼Œä¸”æ”»æ“Šè€…ä¸æ˜¯å‰›ç§»å‹•çš„æ£‹å­
                            if (!beforeKeys.has(afterThreat.key)) {
                                const isMovedPieceAttack = (
                                    afterThreat.attackerPos.row === toPos.row &&
                                    afterThreat.attackerPos.col === toPos.col
                                );

                                if (!isMovedPieceAttack) {
                                    console.log(`ğŸ¯ ç™¼ç¾é–“æ¥æ‰å­: ${afterThreat.attacker.type} æ‰ ${afterThreat.target.type}`);

                                    indirectCaptures.push({
                                        attacker: { type: afterThreat.attacker.type, color: afterThreat.attacker.color },
                                        attackerPos: { row: afterThreat.attackerPos.row, col: afterThreat.attackerPos.col },
                                        target: { type: afterThreat.target.type, color: afterThreat.target.color },
                                        targetPos: { row: afterThreat.targetPos.row, col: afterThreat.targetPos.col },
                                        isExchange: isExchange(afterThreat.attacker, afterThreat.target),
                                        targetHasRoot: hasRoot(board, afterThreat.targetPos, afterThreat.target),
                                        boardState: board,
                                        type: 'indirect' // æ¨™è¨˜ç‚ºé–“æ¥æ‰å­
                                    });
                                }
                            }
                        }

                        return indirectCaptures;

                    } catch (error) {
                        console.error('ğŸš« detectIndirectCaptures éŒ¯èª¤:', error);
                        return [];
                    }
                };



// ==================== åŸæœ‰ä»£ç¢¼çš„æœ€å°ä¿®æ”¹ ====================

// åªåœ¨åŸæœ‰é‚è¼¯åŸºç¤ä¸Šæ·»åŠ é–“æ¥æ‰å­æª¢æ¸¬

                const isCaptureMove = (testBoard, attacker, attackerPos, targetPos, target, previousCaptureInfo = null) => {
                    try {
                        if (!testBoard || !attacker || !attackerPos || !targetPos || !target) {
                            console.error('âŒ isCaptureMove: ç„¡æ•ˆçš„åƒæ•¸');
                            return false;
                        }

                        console.log('ğŸ” åˆ¤å®šæ‰å­:', attacker.type, attacker.color, 'æ”»æ“Š', target.type, target.color);

                        // æª¢æŸ¥æ˜¯å¦ç‚ºé•·æ””è€Œéé•·æ‰
                        if (isBlockingMove(testBoard, attacker, attackerPos, targetPos, target)) {
                            console.log('â„¹ï¸ isCaptureMove: åˆ¤å®šç‚ºé•·æ””è€Œéé•·æ‰');
                            return false;
                        }

                        // æª¢æŸ¥æ”»æ“Šè€…æ˜¯å¦çœŸçš„èƒ½æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®
                        const attackPositions = getPieceAttackPositions(testBoard, attackerPos, attacker);
                        const canAttack = attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (!canAttack) {
                            console.log('â„¹ï¸ isCaptureMove: æ”»æ“Šè€…ç„¡æ³•æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®');
                            return false;
                        }

                        // åŒé¡å­äº’æ‰ç‰¹æ®Šè¦å‰‡æª¢æŸ¥
                        if (isSameTypeChase(attacker, target)) {
                            console.log('ğŸ”„ æª¢æŸ¥åŒé¡å­äº’æ‰ç‰¹æ®Šè¦å‰‡');

                            // æª¢æŸ¥è¢«æ‰æ–¹æ˜¯å¦èƒ½å¤ ååƒæ”»æ“Šæ–¹
                            const canCounterAttack = canTargetAttackAttacker(testBoard, targetPos, target, attackerPos, attacker);
                            console.log(`è¢«æ‰æ–¹èƒ½å¦ååƒ: ${canCounterAttack}`);

                            if (canCounterAttack) {
                                // è¢«æ‰æ–¹èƒ½ååƒï¼Œæª¢æŸ¥æ˜¯å¦å—åˆ°ç‰½åˆ¶
                                const isTargetPinned = isPinned(testBoard, targetPos, target);
                                console.log(`è¢«æ‰æ–¹æ˜¯å¦å—ç‰½åˆ¶: ${isTargetPinned}`);

                                if (isTargetPinned) {
                                    console.log('âœ… åŒé¡å­äº’æ‰ï¼šè¢«æ‰æ–¹å—ç‰½åˆ¶ï¼Œç®—é•·æ‰');
                                    return true;
                                } else {
                                    console.log('âŒ åŒé¡å­äº’æ‰ï¼šè¢«æ‰æ–¹æœªå—ç‰½åˆ¶ä¸”èƒ½ååƒï¼Œä¸ç®—é•·æ‰');
                                    return false;
                                }
                            } else {
                                console.log('âœ… åŒé¡å­äº’æ‰ï¼šè¢«æ‰æ–¹ç„¡æ³•ååƒï¼Œç®—é•·æ‰');
                                return true;
                            }
                        }

                        // æª¢æŸ¥æ˜¯å¦ç‚ºå…Œå­ï¼ˆåƒ¹å€¼ç›¸ç­‰çš„äº’æ›ï¼‰
                        if (isExchange(attacker, target)) {
                            console.log('â„¹ï¸ isCaptureMove: åˆ¤å®šç‚ºå…Œå­ï¼Œä¸ç®—æ‰');
                            return false;
                        }

                        // æª¢æŸ¥æ˜¯å¦æœ‰çœŸæ ¹ä¿è­·
                        const hasTrueRoot = hasRoot(testBoard, targetPos, target);

                        // ==================== é¦¬ç‚®é•·æ‰æœ‰çœŸæ ¹è»Šç‰¹æ®Šè¦å‰‡ ====================
                        const attackerType = getStandardPieceType(attacker.type);
                        const targetType = getStandardPieceType(target.type);
                        const isHorseOrCannon = (attackerType === 'horse' || attackerType === 'cannon');
                        const isTargetRook = (targetType === 'rook');

                        if (isHorseOrCannon && isTargetRook && hasTrueRoot) {
                            console.log(`ğŸğŸ”« æª¢æ¸¬åˆ°${attackerType === 'horse' ? 'é¦¬' : 'ç‚®'}æ‰æœ‰çœŸæ ¹çš„è»Š`);
                            console.log('âŒ é¦¬ç‚®é•·æ‰æœ‰çœŸæ ¹çš„è»Šä¾ç„¶ç®—æ˜¯é•·æ‰');
                            return true; // é¦¬ç‚®æ‰æœ‰çœŸæ ¹çš„è»Šä¾ç„¶ç®—æ‰å­
                        }

                        if (hasTrueRoot) {
                            console.log('âœ… isCaptureMove: ç›®æ¨™æœ‰çœŸæ ¹ä¿è­·ï¼Œä¸ç®—æ‰');
                            return false;
                        } else {
                            console.log('âŒ isCaptureMove: ç›®æ¨™æ²’æœ‰çœŸæ ¹ä¿è­·ï¼Œç®—æ‰å­');
                            return true;
                        }

                    } catch (error) {
                        console.error('ğŸš« isCaptureMove éŒ¯èª¤:', error);
                        return false;
                    }
                };

// æª¢æ¸¬å°‡å¸¥å…µå’è¯åˆæ‰å­æ¯”ä¾‹
                const checkKingPawnAllianceRatio = (allMoves, playerColor, currentMoveIndex) => {
                    try {
                        // æ”¶é›†åŒä¸€æ–¹çš„æ‰å­å‹•ä½œ
                        const playerCaptureMoves = allMoves.filter(m =>
                            m.player === playerColor &&
                            m.captureInfo &&
                            m.captureInfo.length > 0
                        );

                        if (playerCaptureMoves.length === 0) {
                            return { canChaseBySpecialRule: false, reason: 'æ²’æœ‰æ‰å­å‹•ä½œ' };
                        }

                        // çµ±è¨ˆåƒèˆ‡æ‰å­çš„æ‰€æœ‰æ£‹å­
                        const participatingPieces = new Set();
                        let kingPawnCount = 0;

                        for (const move of playerCaptureMoves) {
                            for (const capture of move.captureInfo) {
                                if (capture.attacker && capture.attacker.color === playerColor) {
                                    const pieceKey = `${capture.attackerPos.row}-${capture.attackerPos.col}-${capture.attacker.type}`;

                                    if (!participatingPieces.has(pieceKey)) {
                                        participatingPieces.add(pieceKey);

                                        const pieceType = getStandardPieceType(capture.attacker.type);
                                        if (pieceType === 'king' || pieceType === 'pawn') {
                                            kingPawnCount++;
                                        }
                                    }
                                }
                            }
                        }

                        const totalPieces = participatingPieces.size;
                        const kingPawnRatio = totalPieces > 0 ? kingPawnCount / totalPieces : 0;
                        const canChaseBySpecialRule = kingPawnRatio >= 0.5; // 50%ä»¥ä¸Šç®—é•·æ‰

                        console.log(`ğŸ“Š è¯åˆæ‰å­åˆ†æ: ç¸½æ£‹å­${totalPieces}, å°‡å¸¥å…µå’${kingPawnCount}, æ¯”ä¾‹${(kingPawnRatio*100).toFixed(1)}%`);

                        return {
                            totalPieces,
                            kingPawnCount,
                            kingPawnRatio,
                            canChaseBySpecialRule,
                            reason: canChaseBySpecialRule ?
                                `å°‡å¸¥å…µå’æ¯”ä¾‹${(kingPawnRatio*100).toFixed(1)}% >= 50%ï¼Œäº«æœ‰é•·æ‰ç‰¹æ¬Š` :
                                `å°‡å¸¥å…µå’æ¯”ä¾‹${(kingPawnRatio*100).toFixed(1)}% < 50%ï¼Œä¸äº«æœ‰é•·æ‰ç‰¹æ¬Š`
                        };

                    } catch (error) {
                        console.error('ğŸš« checkKingPawnAllianceRatio éŒ¯èª¤:', error);
                        return { canChaseBySpecialRule: false, reason: 'æª¢æ¸¬éç¨‹å‡ºéŒ¯' };
                    }
                };


                        // ==================== åŸæœ‰çš„ç›´æ¥æ‰å­æª¢æ¸¬é‚è¼¯ ====================
                        const attackPositions = getPieceAttackPositions(board, toPos, piece);
                        if (!Array.isArray(attackPositions) || attackPositions.length > 100) {
                            console.warn('âš ï¸ æ”»æ“Šä½ç½®ç•°å¸¸');
                            return result;
                        }

                        // éæ­·æ”»æ“Šä½ç½®é€²è¡Œæ‰å­æª¢æ¸¬
                        for (const attackPos of attackPositions) {
                            try {
                                if (!attackPos || !isValidPosition(attackPos.row, attackPos.col)) continue;

                                const targetPiece = board[attackPos.row]?.[attackPos.col];
                                if (!targetPiece || !targetPiece.color || !targetPiece.type || targetPiece.color === color) {
                                    continue;
                                }

                                const isCaptureResult = isCaptureMove(board, piece, toPos, attackPos, targetPiece);

                                if (isCaptureResult) {
                                    const captureInfo = {
                                        attacker: deepCopyPiece(piece),
                                        attackerPos: deepCopyPosition(toPos),
                                        target: deepCopyPiece(targetPiece),
                                        targetPos: deepCopyPosition(attackPos),
                                        isExchange: isExchange(piece, targetPiece),
                                        targetHasRoot: hasRoot(board, attackPos, targetPiece),
                                        boardState: deepCopyBoard(board)
                                    };

                                    if (captureInfo.attacker && captureInfo.target) {
                                        result.captureInfo.push(captureInfo);
                                    }
                                }

                            } catch (error) {
                                console.error('ğŸš« è™•ç†æ”»æ“Šä½ç½®æ™‚ç™¼ç”ŸéŒ¯èª¤', error);
                                continue;
                            }
                        }

                        console.log(`ğŸ“Š æª¢æ¸¬åˆ° ${result.captureInfo.length} å€‹ç›´æ¥æ‰å­å‹•ä½œ`);

                        // ==================== æ–°å¢ï¼šé–“æ¥æ‰å­æª¢æ¸¬ ====================
                result.indirectCaptureInfo = detectIndirectCaptures(move, color);
                        console.log(`ğŸ“Š æª¢æ¸¬åˆ° ${result.indirectCaptureInfo.length} å€‹é–“æ¥æ‰å­å‹•ä½œ`);

                        // ==================== åŸæœ‰çš„å°‡å¸¥å…µå’ç‰¹æ®Šè¦å‰‡æª¢æ¸¬ ====================
                        const totalCaptures = result.captureInfo.length + result.indirectCaptureInfo.length; // ä¿®æ”¹ï¼šåŒ…å«é–“æ¥æ‰å­
                        if (totalCaptures > 0) {
                            // æª¢æŸ¥ç•¶å‰ç§»å‹•æ£‹å­æ˜¯å¦ç‚ºå°‡å¸¥æˆ–å…µå’
                            const currentPieceType = getStandardPieceType(piece.type);
                            const isKingOrPawn = (currentPieceType === 'king' || currentPieceType === 'pawn');

                            if (isKingOrPawn) {
                                console.log(`ğŸ” æª¢æ¸¬åˆ°${currentPieceType === 'king' ? 'å°‡å¸¥' : 'å…µå’'}åƒèˆ‡æ‰å­ï¼Œæª¢æŸ¥ç‰¹æ®Šè¦å‰‡`);

                                // æª¢æŸ¥æ˜¯å¦æ‰å°æ–¹å°‡å¸¥ï¼ˆå…µå’ä¸å¯é•·æ‰å°æ–¹å°‡å¸¥ï¼‰
                                let chaseEnemyKing = false;
                                if (currentPieceType === 'pawn') {
                                    // æª¢æŸ¥ç›´æ¥æ‰å­
                                    for (const capture of result.captureInfo) {
                                        const targetType = getStandardPieceType(capture.target.type);
                                        if (targetType === 'king') {
                                            chaseEnemyKing = true;
                                            console.log('âŒ å…µå’ä¸å¯é•·æ‰å°æ–¹å°‡å¸¥ï¼ˆé•·å°‡è¦å‰‡ï¼‰');
                                            break;
                                        }
                                    }
                                    // æ–°å¢ï¼šæª¢æŸ¥é–“æ¥æ‰å­æ˜¯å¦æ‰å°æ–¹å°‡å¸¥
                                    if (!chaseEnemyKing) {
                                        for (const capture of result.indirectCaptureInfo) {
                                            const targetType = getStandardPieceType(capture.target.type);
                                            if (targetType === 'king') {
                                                chaseEnemyKing = true;
                                                console.log('âŒ å…µå’ä¸å¯é–“æ¥é•·æ‰å°æ–¹å°‡å¸¥ï¼ˆé•·å°‡è¦å‰‡ï¼‰');
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (!chaseEnemyKing) {
                                    // å¦‚æœéœ€è¦æª¢æŸ¥è¯åˆæ‰å­çš„æƒ…æ³ï¼Œéœ€è¦allMovesåƒæ•¸
                                    if (allMoves && allMoves.length > 0) {
                                        // æª¢æ¸¬è¯åˆæ‰å­æ¯”ä¾‹
                                        const allianceCheck = checkKingPawnAllianceRatio(allMoves, color, move.moveIndex);
                                        result.kingPawnSpecialRule = {
                                            isKingOrPawn: true,
                                            pieceType: currentPieceType,
                                            canChaseBySpecialRule: allianceCheck.canChaseBySpecialRule,
                                            allianceInfo: allianceCheck,
                                            chaseEnemyKing: chaseEnemyKing
                                        };
                                        console.log(`ğŸ“Š å°‡å¸¥å…µå’ç‰¹æ®Šè¦å‰‡æª¢æ¸¬: å¯é•·æ‰=${allianceCheck.canChaseBySpecialRule}`);
                                    } else {
                                        // å–®ç¨çš„å°‡å¸¥æˆ–å…µå’æ‰å­ï¼Œäº«æœ‰é•·æ‰ç‰¹æ¬Š
                                        result.kingPawnSpecialRule = {
                                            isKingOrPawn: true,
                                            pieceType: currentPieceType,
                                            canChaseBySpecialRule: true,
                                            reason: `${currentPieceType === 'king' ? 'å°‡å¸¥' : 'å…µå’'}äº«æœ‰é•·æ‰ç‰¹æ¬Š`,
                                            chaseEnemyKing: chaseEnemyKing
                                        };
                                        console.log(`âœ… ${currentPieceType === 'king' ? 'å°‡å¸¥' : 'å…µå’'}äº«æœ‰é•·æ‰ç‰¹æ¬Š`);
                                    }
                                } else {
                                    result.kingPawnSpecialRule = {
                                        isKingOrPawn: true,
                                        pieceType: currentPieceType,
                                        canChaseBySpecialRule: false,
                                        reason: 'å…µå’ä¸å¯é•·æ‰å°æ–¹å°‡å¸¥ï¼ˆé•·å°‡è¦å‰‡ï¼‰',
                                        chaseEnemyKing: true
                                    };
                                }
                            }
                        }

                        // 3. æœ€çµ‚çµæœæ•´ç†
                        console.log(`âœ… åˆ†æå®Œæˆ - ç›´æ¥æ‰å­:${result.captureInfo.length}, é–“æ¥æ‰å­:${result.indirectCaptureInfo.length}`);

                        return result;

            } catch (error) {
                console.error('ğŸš« analyzeMoveCapture: æ•´é«”æ–¹æ³•ç™¼ç”ŸéŒ¯èª¤', error);
                console.error('ğŸ“ éŒ¯èª¤åƒæ•¸:', { move, color });
                console.error('ğŸ” éŒ¯èª¤å †æ£§:', error.stack);

                return {
                    captureInfo: [],
                    isEscapeMove: false,
                    escapedPieces: [],
                    error: error.message,
                    player: color,
                    moveIndex: move.moveIndex || 0
                };
            }
        }
// ç°¡åŒ–çš„éœæ…‹æ£‹ç›¤æ‰å­æª¢æ¸¬
// åªæª¢æŸ¥ç•¶å‰ä½ç½®èƒ½ç›´æ¥æ‰åˆ°çš„æ£‹å­ï¼Œä¸è€ƒæ…®ç§»å‹•å¾Œçš„æƒ…æ³

        analyzeCurrentBoardCaptures(board, player) {
            console.log(`ğŸ” [éœæ…‹æª¢æ¸¬] åˆ†æ ${player} æ–¹åœ¨ç•¶å‰æ£‹ç›¤çš„æ‰å­èƒ½åŠ›`);

            const captureInfo = [];

            // éæ­·æ£‹ç›¤æ‰¾åˆ°è©²ç©å®¶çš„æ‰€æœ‰æ£‹å­
            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];

                    // åªæª¢æŸ¥ç•¶å‰ç©å®¶çš„æ£‹å­
                    if (!piece || piece.color !== player) continue;

                    console.log(`ğŸ” æª¢æŸ¥ ${piece.type} åœ¨ (${row},${col}) çš„ç›´æ¥æ‰å­èƒ½åŠ›`);

                    // æª¢æŸ¥ç•¶å‰ä½ç½®èƒ½ç›´æ¥æ‰åˆ°çš„æ£‹å­
                    const directCaptures = this.findCaptureThreats(board, player, row, col);

                    for (const capture of directCaptures) {
                        captureInfo.push({
                            attacker: piece,
                            attackerPos: { row, col },
                            target: capture.target,
                            targetPos: capture.targetPos,
                            moveToCapture: { row, col }, // ä¸éœ€è¦ç§»å‹•ï¼Œå°±åœ¨ç•¶å‰ä½ç½®
                            captureType: this.determineCaptureType(piece, capture.target)
                        });

                        console.log(`  âœ… ç™¼ç¾ç›´æ¥æ‰å­ï¼š${piece.type}(${row},${col}) æ­£åœ¨æ‰ ${capture.target.type}(${capture.targetPos.row},${capture.targetPos.col})`);
                    }
                }
            }

            console.log(`ğŸ” [éœæ…‹æª¢æ¸¬å®Œæˆ] ${player} æ–¹ç¸½å…±æœ‰ ${captureInfo.length} å€‹æ‰å­å¨è„…`);

            // è¿”å›èˆ‡ analyzeMoveCapture ç›¸åŒæ ¼å¼çš„çµæœ
            return {
                captureInfo: captureInfo,
                isEscapeMove: false,
                escapedPieces: [],
                targetConsistency: null,
                player: player
            };
        }

// ä¿®æ­£å¾Œçš„ findCaptureThreats æ–¹æ³•
// ä½¿ç”¨çµ±ä¸€çš„ getAttackPositions æ–¹æ³•
        findCaptureThreats(board, player, pieceRow, pieceCol) {
            const piece = board[pieceRow][pieceCol];
            if (!piece || piece.color !== player) return [];

            const threats = [];
            const enemyColor = player === 'red' ? 'black' : 'red';

            // ä½¿ç”¨çµ±ä¸€çš„æ”»æ“Šä½ç½®ç²å–æ–¹æ³•
            const attackPositions = this.getAttackPositions(board, piece, pieceRow, pieceCol);

            for (const pos of attackPositions) {
                const targetPiece = board[pos.row][pos.col];
                if (targetPiece && targetPiece.color === enemyColor) {
                    // æª¢æŸ¥æ˜¯å¦æ§‹æˆæ‰å­ï¼ˆè€Œéå°‡è»ï¼‰
                    if (this.isCaptureNotCheck(piece, targetPiece, pieceRow, pieceCol, pos.row, pos.col)) {
                        threats.push({
                            target: targetPiece,
                            targetPos: { row: pos.row, col: pos.col }
                        });

                        console.log(`    ğŸ‘ï¸ ${piece.type}(${pieceRow},${pieceCol}) å¨è„… ${targetPiece.type}(${pos.row},${pos.col})`);
                    }
                }
            }

            return threats;
        }

// ä¿®æ­£å¾Œçš„ getAttackPositions æ–¹æ³•
// ä½¿ç”¨ç¬¬äºŒå€‹æ–‡ä»¶ä¸­å·²æœ‰çš„å®Œæ•´å¯¦ä½œ

// è¼”åŠ©å‡½æ•¸ï¼šç²å–æ£‹å­çš„æ”»æ“Šä½ç½®
        getAttackPositions(board, piece, fromRow, fromCol) {
            if (!Array.isArray(board) || !piece) {
                console.error('âŒ getAttackPositions: ç„¡æ•ˆçš„åƒæ•¸', {
                    board: !!board, piece
                });
                return [];
            }

            if (!this.isValidPosition(fromRow, fromCol)) {
                console.error('âŒ getAttackPositions: ç„¡æ•ˆçš„ä½ç½®', { fromRow, fromCol });
                return [];
            }

            if (!piece.type || !piece.color) {
                console.error('âŒ getAttackPositions: ç„¡æ•ˆçš„æ£‹å­', piece);
                return [];
            }

            const positions = [];
            const pieceType = this.getStandardPieceType(piece.type);

            switch (pieceType) {
                case 'king':
                    const kingMoves = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of kingMoves) {
                        const newRow = fromRow + dr;
                        const newCol = fromCol + dc;
                        if (this.isInPalace(newRow, newCol, piece.color)) {
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                case 'advisor':
                    const advisorMoves = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    for (const [dr, dc] of advisorMoves) {
                        const newRow = fromRow + dr;
                        const newCol = fromCol + dc;
                        if (this.isInPalace(newRow, newCol, piece.color)) {
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                case 'elephant':
                    const elephantMoves = [[-2, -2], [-2, 2], [2, -2], [2, 2]];
                    for (const [dr, dc] of elephantMoves) {
                        const newRow = fromRow + dr;
                        const newCol = fromCol + dc;
                        if (this.isValidElephantMove(board, fromRow, fromCol, newRow, newCol, piece.color)) {
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                case 'horse':
                    const horseMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    for (const [dr, dc] of horseMoves) {
                        const newRow = fromRow + dr;
                        const newCol = fromCol + dc;
                        if (this.isValidHorseMove(board, fromRow, fromCol, newRow, newCol)) {
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                case 'rook':
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of directions) {
                        for (let i = 1; i < 10; i++) {
                            const newRow = fromRow + dr * i;
                            const newCol = fromCol + dc * i;
                            if (!this.isValidPosition(newRow, newCol)) break;

                            const pieceAtPos = board[newRow][newCol];
                            if (pieceAtPos) {
                                if (pieceAtPos.color !== piece.color) {
                                    positions.push({ row: newRow, col: newCol });
                                }
                                break;
                            }
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                case 'cannon':
                    const cannonDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of cannonDirections) {
                        let jumpFound = false;
                        for (let i = 1; i < 10; i++) {
                            const newRow = fromRow + dr * i;
                            const newCol = fromCol + dc * i;
                            if (!this.isValidPosition(newRow, newCol)) break;

                            const pieceAtPos = board[newRow][newCol];
                            if (pieceAtPos) {
                                if (!jumpFound) {
                                    jumpFound = true;
                                } else {
                                    if (pieceAtPos.color !== piece.color) {
                                        positions.push({ row: newRow, col: newCol });
                                    }
                                    break;
                                }
                            } else if (!jumpFound) {
                                positions.push({ row: newRow, col: newCol });
                            }
                        }
                    }
                    break;

                case 'pawn':
                    const pawnDirection = piece.color === 'red' ? -1 : 1;
                    const pawnMoves = [[pawnDirection, 0]];

                    if ((piece.color === 'red' && fromRow <= 4) || (piece.color === 'black' && fromRow >= 5)) {
                        pawnMoves.push([0, -1], [0, 1]);
                    }

                    for (const [dr, dc] of pawnMoves) {
                        const newRow = fromRow + dr;
                        const newCol = fromCol + dc;
                        if (this.isValidPosition(newRow, newCol)) {
                            positions.push({ row: newRow, col: newCol });
                        }
                    }
                    break;

                default:
                    console.error('âŒ getAttackPositions: æœªçŸ¥çš„æ£‹å­é¡å‹', piece.type, '(åŸå§‹)', pieceType, '(è½‰æ›å¾Œ)');
                    console.error('å®Œæ•´æ£‹å­è³‡è¨Š:', piece);
                    return [];
            }

            return positions.filter(pos => this.isValidPosition(pos.row, pos.col));
        }

// éœ€è¦çš„è¼”åŠ©æ–¹æ³•ï¼ˆå¦‚æœä½ çš„é¡åˆ¥ä¸­é‚„æ²’æœ‰çš„è©±ï¼‰
        getStandardPieceType(originalType) {
            const PIECE_TYPE_MAP = {
                'king': 'king', 'KING': 'king', 'K': 'king', 'å°‡': 'king', 'å¸¥': 'king',
                'advisor': 'advisor', 'ADVISOR': 'advisor', 'A': 'advisor', 'å£«': 'advisor', 'ä»•': 'advisor',
                'elephant': 'elephant', 'ELEPHANT': 'elephant', 'E': 'elephant', 'è±¡': 'elephant', 'ç›¸': 'elephant',
                'horse': 'horse', 'HORSE': 'horse', 'H': 'horse', 'é¦¬': 'horse', 'å‚Œ': 'horse',
                'rook': 'rook', 'ROOK': 'rook', 'R': 'rook', 'è»Š': 'rook', 'ä¿¥': 'rook',
                'cannon': 'cannon', 'CANNON': 'cannon', 'C': 'cannon', 'åŒ…': 'cannon', 'ç‚®': 'cannon',
                'pawn': 'pawn', 'PAWN': 'pawn', 'P': 'pawn', 'å’': 'pawn', 'å…µ': 'pawn'
            };
            return PIECE_TYPE_MAP[originalType] || originalType;
        }
// 2. é¦¬çš„ç§»å‹•é©—è­‰ï¼ˆä½¿ç”¨ä½ ç¾æœ‰çš„é‚è¼¯ï¼‰
        isValidHorseMove(board, fromRow, fromCol, toRow, toCol) {
            if (!this.isValidPosition(toRow, toCol)) return false;

            const fromPos = { row: fromRow, col: fromCol };
            const toPos = { row: toRow, col: toCol };

            return this.canHorseAttack(board, fromPos, toPos);
        }
// 4. è±¡çš„ç§»å‹•é©—è­‰
        isValidElephantMove(board, fromRow, fromCol, toRow, toCol, color) {
            if (!this.isValidPosition(toRow, toCol)) return false;

            const fromPos = { row: fromRow, col: fromCol };
            const toPos = { row: toRow, col: toCol };

            return this.canElephantAttack(board, fromPos, toPos);
        }

        isValidPosition(row, col) {
            return row >= 0 && row < 10 && col >= 0 && col < 9;
        }

        // 5. å®®å…§ä½ç½®æª¢æŸ¥
        isInPalace(row, col, color) {
            if (color === 'red') {
                // ç´…æ–¹å®®æ®¿åœ¨8-10è¡Œï¼Œ3-5åˆ—
                return row >= 7 && row <= 9 && col >= 3 && col <= 5;
            } else {
                // é»‘æ–¹å®®æ®¿åœ¨0-2è¡Œï¼Œ3-5åˆ—
                return row >= 0 && row <= 2 && col >= 3 && col <= 5;
            }
        }
// è¼”åŠ©å‡½æ•¸ï¼šåˆ¤æ–·æ˜¯å¦ç‚ºæ‰å­è€Œéå°‡è»
        isCaptureNotCheck(attacker, target, fromRow, fromCol, toRow, toCol) {
            // å¦‚æœç›®æ¨™æ˜¯å¸¥/å°‡ï¼Œé€™æ˜¯å°‡è»è€Œéæ‰å­
            if (target.type === 'å¸¥' || target.type === 'å°‡') {
                return false;
            }

            // å…¶ä»–æƒ…æ³éƒ½ç®—æ‰å­
            return true;
        }
// 3. è±¡çš„æ”»æ“Šå‡½æ•¸ï¼ˆæ–°å¢ï¼‰
        canElephantAttack(board, fromPos, toPos) {
            const rowDiff = Math.abs(toPos.row - fromPos.row);
            const colDiff = Math.abs(toPos.col - fromPos.col);

            // è±¡èµ°ç”°å­—æ ¼
            if (rowDiff !== 2 || colDiff !== 2) return false;

            // æª¢æŸ¥è±¡çœ¼ï¼ˆç”°å­—ä¸­å¿ƒï¼‰
            const blockRow = fromPos.row + (toPos.row > fromPos.row ? 1 : -1);
            const blockCol = fromPos.col + (toPos.col > fromPos.col ? 1 : -1);

            // è±¡çœ¼ä¸èƒ½æœ‰æ£‹å­
            if (board[blockRow][blockCol]) return false;

            // æª¢æŸ¥æ˜¯å¦éæ²³ï¼ˆè±¡ä¸èƒ½éæ²³ï¼‰
            // ç´…æ–¹è±¡åœ¨6-10è¡Œï¼Œé»‘æ–¹è±¡åœ¨0-4è¡Œ
            const piece = board[fromPos.row][fromPos.col];
            if (piece.color === 'red' && toPos.row < 5) return false;
            if (piece.color === 'black' && toPos.row > 5) return false;

            return true;
        }
// è¼”åŠ©å‡½æ•¸ï¼šç¢ºå®šæ‰å­é¡å‹
        determineCaptureType(attacker, target) {
            return `${attacker.type}æ‰${target.type}`;
        }

        // ğŸ”„ æ–°å¢ï¼šæª¢æ¸¬æ˜¯å¦é€éé‡æ–°åŠ æ ¹ä¾†è§£æ‰
        // é©ç”¨æ–¼é•·æ‰æª¢æ¸¬ä¸­ï¼ŒåŸæœ¬ç„¡æ ¹çš„æ£‹å­é‡æ–°ç²å¾—æ ¹å­ä¿è­·çš„æƒ…æ³
        checkReRootEscape(previousBoard, currentBoard, player) {
            console.log(`ğŸ”„ [é‡æ–°åŠ æ ¹æª¢æ¸¬] æª¢æŸ¥ ${player} æ–¹æ˜¯å¦é€éé‡æ–°åŠ æ ¹è§£æ‰`);

            const escapedPieces = [];
            const reRootInfo = [];

            // 1. åˆ†æå‰ä¸€å€‹æ£‹ç›¤ç‹€æ…‹ï¼Œæ‰¾å‡ºæ‰€æœ‰è¢«æ‰çš„æ£‹å­ï¼ˆç„¡æ ¹ï¼‰
            const enemyColor = player === 'red' ? 'black' : 'red';
            const previousCaptureAnalysis = this.analyzeCurrentBoardCaptures(previousBoard, enemyColor);
            console.log(`ğŸ” å‰ä¸€æ­¥æ£‹ç›¤ç™¼ç¾ ${previousCaptureAnalysis.captureInfo.length} å€‹æ‰å­å¨è„…`);

            // æå–æ‰€æœ‰è¢«æ‰çš„å·±æ–¹æ£‹å­ï¼ˆåœ¨å‰ä¸€æ­¥ç„¡æ ¹ï¼‰
            const threatenedPieces = [];
            for (const capture of previousCaptureAnalysis.captureInfo) {
                if (capture.target.color === player) {
                    // æª¢æŸ¥é€™å€‹è¢«æ‰çš„æ£‹å­åœ¨å‰ä¸€æ­¥æ˜¯å¦çœŸçš„ç„¡æ ¹
                    const hadRoot = this.hasRoot(previousBoard, capture.targetPos, capture.target);
                    if (!hadRoot) {
                        threatenedPieces.push({
                            piece: capture.target,
                            pos: capture.targetPos,
                            attacker: capture.attacker,
                            attackerPos: capture.attackerPos
                        });
                        console.log(`ğŸ“ è¨˜éŒ„ç„¡æ ¹è¢«æ‰æ£‹å­: ${capture.target.color}æ–¹${capture.target.type} ä½ç½®(${capture.targetPos.row},${capture.targetPos.col})`);
                    }
                }
            }

            if (threatenedPieces.length === 0) {
                console.log(`â„¹ï¸ å‰ä¸€æ­¥æ²’æœ‰ ${player} æ–¹æ£‹å­è¢«ç„¡æ ¹æ‰å­ï¼Œç„¡éœ€æª¢æŸ¥é‡æ–°åŠ æ ¹`);
                return {
                    isReRootEscape: false,
                    escapedPieces: [],
                    reRootInfo: []
                };
            }

            // 2. æª¢æŸ¥ç•¶å‰æ£‹ç›¤ç‹€æ…‹ï¼Œé€™äº›åŸæœ¬è¢«æ‰çš„æ£‹å­ç¾åœ¨æ˜¯å¦æœ‰æ ¹äº†
            console.log(`ğŸ” æª¢æŸ¥ç•¶å‰æ£‹ç›¤ç‹€æ…‹ä¸­ï¼Œé€™ ${threatenedPieces.length} å€‹æ£‹å­æ˜¯å¦é‡æ–°ç²å¾—æ ¹å­ä¿è­·...`);

            for (const threatened of threatenedPieces) {
                // é¦–å…ˆæª¢æŸ¥æ£‹å­æ˜¯å¦é‚„åœ¨åŒä¸€ä½ç½®ï¼ˆæ²’æœ‰è¢«ç§»èµ°æˆ–åƒæ‰ï¼‰
                const currentPiece = currentBoard[threatened.pos.row][threatened.pos.col];

                if (!currentPiece ||
                    currentPiece.color !== threatened.piece.color ||
                    currentPiece.type !== threatened.piece.type) {
                    console.log(`âš ï¸ æ£‹å­ ${threatened.piece.color}æ–¹${threatened.piece.type} å·²ä¸åœ¨åŸä½ç½®(${threatened.pos.row},${threatened.pos.col})ï¼Œè·³éæª¢æŸ¥`);
                    continue;
                }

                // æª¢æŸ¥æ˜¯å¦é‚„æœ‰æ”»æ“Šè€…èƒ½æ”»æ“Šåˆ°é€™å€‹ä½ç½®
                const currentThreats = this.findCurrentThreats(currentBoard, threatened.pos, threatened.piece, enemyColor);

                if (currentThreats.length === 0) {
                    console.log(`â„¹ï¸ æ£‹å­ ${threatened.piece.color}æ–¹${threatened.piece.type} å·²ç„¡æ”»æ“Šè€…å¨è„…ï¼Œä¸æ˜¯é‡æ–°åŠ æ ¹æƒ…æ³`);
                    continue;
                }

                // æª¢æŸ¥åœ¨ç•¶å‰æ£‹ç›¤ç‹€æ…‹ä¸‹æ˜¯å¦æœ‰æ ¹å­ä¿è­·
                const hasRootNow = this.hasRoot(currentBoard, threatened.pos, threatened.piece);

                if (hasRootNow) {
                    console.log(`âœ… ç™¼ç¾é‡æ–°åŠ æ ¹: ${threatened.piece.color}æ–¹${threatened.piece.type}(${threatened.pos.row},${threatened.pos.col}) é‡æ–°ç²å¾—æ ¹å­ä¿è­·`);

                    // æ‰¾å‡ºæä¾›ä¿è­·çš„æ ¹å­
                    const protectingRoots = this.findProtectingRoots(currentBoard, threatened.pos, threatened.piece);

                    escapedPieces.push(threatened.piece);
                    reRootInfo.push({
                        escapedPiece: threatened.piece,
                        escapedPos: threatened.pos,
                        protectingRoots: protectingRoots,
                        escapeType: 'reroot'
                    });

                    console.log(`ğŸ›¡ï¸ ä¿è­·è©²æ£‹å­çš„æ ¹å­:`);
                    protectingRoots.forEach((root, index) => {
                        console.log(`   ${index + 1}. ${root.piece.color}æ–¹${root.piece.type} ä½ç½®(${root.pos.row},${root.pos.col})`);
                    });
                } else {
                    console.log(`âŒ ${threatened.piece.color}æ–¹${threatened.piece.type}(${threatened.pos.row},${threatened.pos.col}) ä»ç„¶ç„¡æ ¹`);
                }
            }

            const isReRootEscape = escapedPieces.length > 0;
            console.log(`ğŸ”„ [é‡æ–°åŠ æ ¹æª¢æ¸¬å®Œæˆ] ${isReRootEscape ? `ç™¼ç¾ ${escapedPieces.length} å€‹é‡æ–°åŠ æ ¹è§£æ‰` : 'æ²’æœ‰é‡æ–°åŠ æ ¹è§£æ‰'}`);

            return {
                isReRootEscape: isReRootEscape,
                escapedPieces: escapedPieces,
                reRootInfo: reRootInfo
            };
        }

        // è¼”åŠ©å‡½æ•¸ï¼šæ‰¾å‡ºç•¶å‰å¨è„…æŸå€‹ä½ç½®çš„æ‰€æœ‰æ”»æ“Šè€…
        findCurrentThreats(board, targetPos, targetPiece, attackerColor) {
            const threats = [];

            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === attackerColor) {
                        const attackPositions = this.getAttackPositions(board, piece, row, col);
                        const canAttack = attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (canAttack) {
                            threats.push({
                                piece: piece,
                                pos: { row, col }
                            });
                        }
                    }
                }
            }

            return threats;
        }

        // è¼”åŠ©å‡½æ•¸ï¼šæ‰¾å‡ºä¿è­·æŸå€‹æ£‹å­çš„æ‰€æœ‰æ ¹å­
        findProtectingRoots(board, targetPos, targetPiece) {
            const protectingRoots = [];

            // éæ­·æ‰€æœ‰å·±æ–¹æ£‹å­ï¼Œæª¢æŸ¥å“ªäº›èƒ½ä½œç‚ºæ ¹å­
            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece &&
                        piece.color === targetPiece.color &&
                        !(row === targetPos.row && col === targetPos.col)) {

                        // æª¢æŸ¥é€™å€‹æ£‹å­æ˜¯å¦èƒ½æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®ï¼ˆä½œç‚ºæ ¹å­ï¼‰
                        const attackPositions = this.getAttackPositions(board, piece, row, col);
                        const canProtect = attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (canProtect) {
                            // é€²ä¸€æ­¥æª¢æŸ¥æ˜¯å¦ç‚ºçœŸæ ¹å­ï¼ˆèƒ½å¤ æœ‰æ•ˆå ±å¾©ï¼‰
                            const isValidRoot = this.testRevengeCapability(
                                board,
                                { row, col },
                                piece,
                                targetPos,
                                targetPiece
                            );

                            if (isValidRoot) {
                                protectingRoots.push({
                                    piece: piece,
                                    pos: { row, col }
                                });
                                console.log(`ğŸ›¡ï¸ ç™¼ç¾ä¿è­·æ ¹å­: ${piece.color}æ–¹${piece.type}(${row},${col})`);
                            }
                        }
                    }
                }
            }

            return protectingRoots;
        }

// ä¿®æ­£ç‰ˆ testRevengeCapability å‡½æ•¸ - åˆ†ææ‰€æœ‰å¯èƒ½æ”»æ“Šè€…
        testRevengeCapability(testBoard, rootPos, rootPiece, targetPos, target, specificAttackerPos = null, specificAttackerPiece = null) {
            try {
                console.log(`ğŸ§ª æ¸¬è©¦å ±å¾©èƒ½åŠ›: ${rootPiece.color}æ–¹${rootPiece.type} ä¿è­· ${target.color}æ–¹${target.type}`);

                const enemyColor = rootPiece.color === 'red' ? 'black' : 'red';
                console.log(`ğŸ¯ å·±æ–¹: ${rootPiece.color}, æ•µæ–¹: ${enemyColor}`);

                // ğŸ”¥ æ–°é‚è¼¯ï¼šå¦‚æœæŒ‡å®šäº†ç‰¹å®šæ”»æ“Šè€…ï¼Œåªåˆ†æé€™å€‹æ”»æ“Šè€…
                // å¦‚æœæ²’æœ‰æŒ‡å®šï¼Œå‰‡éœ€è¦æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„æ”»æ“Šè€…ä¸¦é€ä¸€åˆ†æ
                let attackersToTest = [];

                if (specificAttackerPos && specificAttackerPiece) {
                    console.log(`ğŸ¯ æŒ‡å®šæ”»æ“Šè€…: ${specificAttackerPiece.color}æ–¹${specificAttackerPiece.type} ä½ç½®: (${specificAttackerPos.row},${specificAttackerPos.col})`);
                    attackersToTest = [{ pos: specificAttackerPos, piece: specificAttackerPiece }];
                } else {
                    // æ‰¾å‡ºæ‰€æœ‰å¯èƒ½æ”»æ“Šç›®æ¨™çš„æ•µæ–¹å­åŠ›
                    console.log('ğŸ” å°‹æ‰¾æ‰€æœ‰å¯èƒ½çš„æ”»æ“Šè€…...');
                    for (let row = 0; row < testBoard.length; row++) {
                        for (let col = 0; col < testBoard[row].length; col++) {
                            const piece = testBoard[row][col];
                            if (piece && piece.color === enemyColor) {
                                const attackPositions = this.getPieceAttackPositions(testBoard, { row, col }, piece);
                                const canAttackTarget = attackPositions.some(pos =>
                                    pos.row === targetPos.row && pos.col === targetPos.col
                                );

                                if (canAttackTarget) {
                                    attackersToTest.push({ pos: { row, col }, piece });
                                    console.log(`   ç™¼ç¾æ”»æ“Šè€…: ${piece.color}æ–¹${piece.type} ä½ç½®: (${row},${col})`);
                                }
                            }
                        }
                    }
                }

                if (attackersToTest.length === 0) {
                    console.log('âŒ æ²’æœ‰æ‰¾åˆ°ä»»ä½•æ”»æ“Šè€…');
                    return false;
                }

                console.log(`ğŸ“Š ç¸½å…±éœ€è¦åˆ†æ ${attackersToTest.length} å€‹æ”»æ“Šè€…`);

                // ğŸ”¥ é—œéµé‚è¼¯ï¼šåªè¦æœ‰ä»»ä½•ä¸€å€‹æ”»æ“Šè€…èƒ½è®“æ ¹å­å¤±æ•ˆï¼Œå°±ç®—æ‰å­
                for (let i = 0; i < attackersToTest.length; i++) {
                    const attacker = attackersToTest[i];
                    console.log(`\nğŸ¯ åˆ†ææ”»æ“Šè€… ${i + 1}/${attackersToTest.length}: ${attacker.piece.color}æ–¹${attacker.piece.type} (${attacker.pos.row},${attacker.pos.col})`);

                    const canSafelyRevenge = this.testSingleAttackerRevenge(testBoard, rootPos, rootPiece, targetPos, target, attacker.pos, attacker.piece, enemyColor);

                    if (!canSafelyRevenge) {
                        console.log(`ğŸ’€ æ”»æ“Šè€… ${i + 1} æœƒè®“æ ¹å­å¤±æ•ˆï¼`);
                        console.log(`âŒ æ ¹æ“š"ä»»ä¸€æ”»æ“Šè€…å¤±æ•ˆå³æ‰å­"åŸå‰‡ï¼Œæ­¤æ ¹å­ç„¡æ•ˆ`);
                        return false;
                    } else {
                        console.log(`âœ… æ”»æ“Šè€… ${i + 1} æƒ…æ³ä¸‹æ ¹å­å¯ä»¥å®‰å…¨å ±å¾©`);
                    }
                }

                console.log(`ğŸ‰ æ‰€æœ‰ ${attackersToTest.length} å€‹æ”»æ“Šè€…æƒ…æ³ä¸‹ï¼Œæ ¹å­éƒ½å¯ä»¥å®‰å…¨å ±å¾©`);
                return true;

            } catch (error) {
                console.error('ğŸš« testRevengeCapability éŒ¯èª¤:', error);
                return false;
            }
        }

// ğŸ”¥ æ–°å¢ï¼šæ¸¬è©¦å–®å€‹æ”»æ“Šè€…çš„å ±å¾©èƒ½åŠ›
        testSingleAttackerRevenge(testBoard, rootPos, rootPiece, targetPos, target, attackerPos, attackerPiece, enemyColor) {
            try {
                // ç¬¬ä¸€éšæ®µï¼šæª¢æŸ¥æ ¹å­ç§»å‹•å‰ç‹æ˜¯å¦å·²ç¶“å®‰å…¨
                const originalKingPos = this.findKing(testBoard, rootPiece.color);
                if (!originalKingPos) {
                    console.log('âŒ æ‰¾ä¸åˆ°å·±æ–¹ç‹');
                    return false;
                }

                // ç¬¬äºŒéšæ®µï¼šæª¢æŸ¥æ ¹å­ç§»å‹•æ˜¯å¦æœƒè®“ç‹æš´éœ²åœ¨å±éšªä¸­
                let rootMoveBoard = testBoard.map(row => [...row]);
                rootMoveBoard[rootPos.row][rootPos.col] = null;
                const isKingExposedAfterRootMove = this.isPositionUnderAttack(rootMoveBoard, originalKingPos, enemyColor);

                if (isKingExposedAfterRootMove) {
                    console.log('âŒ æ ¹å­ç§»å‹•æœƒè®“å·±æ–¹ç‹æš´éœ²åœ¨æ”»æ“Šç¯„åœå…§');
                    return false;
                }

                // ç¬¬ä¸‰éšæ®µï¼šå‰µå»ºæ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œçš„æ£‹ç›¤ç‹€æ…‹
                let simulationBoard = testBoard.map(row => [...row]);
                simulationBoard[targetPos.row][targetPos.col] = { ...attackerPiece };
                simulationBoard[attackerPos.row][attackerPos.col] = null;

                // æª¢æŸ¥æ ¹å­æ˜¯å¦èƒ½æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®
                const rootAttackPositions = this.getPieceAttackPositions(simulationBoard, rootPos, rootPiece);
                const canAttackBack = rootAttackPositions.some(pos =>
                    pos.row === targetPos.row && pos.col === targetPos.col
                );

                if (!canAttackBack) {
                    console.log('âŒ æ ¹å­ç„¡æ³•æ”»æ“Šåˆ°ç›®æ¨™ä½ç½®é€²è¡Œå ±å¾©');
                    return false;
                }

                // ğŸ”¥ é‡è¦ï¼šæª¢æŸ¥æ”»æ“Šè€…ç§»å‹•å¾Œæ•´å€‹æ£‹ç›¤çš„å°‡è»ç‹€æ³
                const finalKingPos = originalKingPos;
                const isKingInCheckAfterCapture = this.isPositionUnderAttack(simulationBoard, finalKingPos, enemyColor);

                console.log('ğŸ” åˆ†ææ”»æ“Šè€…ç§»å‹•å¾Œçš„å®Œæ•´å¨è„…æƒ…æ³...');
                console.log(`ğŸ“ æ”»æ“Šè€…å¾ (${attackerPos.row},${attackerPos.col}) ç§»å‹•åˆ° (${targetPos.row},${targetPos.col})`);

                if (isKingInCheckAfterCapture) {
                    console.log('âš ï¸ æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œï¼Œå·±æ–¹ç‹å—åˆ°å°‡è»');

                    // è©³ç´°åˆ†æå°‡è»ä¾†æº
                    const checkSources = this.getAttackingSources(simulationBoard, finalKingPos, enemyColor);
                    console.log(`ğŸ‘ï¸ å°‡è»ä¾†æº: ${checkSources.length} å€‹`);

                    checkSources.forEach((source, index) => {
                        console.log(`   ${index + 1}. ${source.piece.color}æ–¹${source.piece.type} ä½ç½®: (${source.pos.row},${source.pos.col})`);

                        // ğŸ”¥ æª¢æŸ¥é€™å€‹å°‡è»æ˜¯å¦æ˜¯å› ç‚ºæ”»æ“Šè€…ç§»å‹•è€Œæ–°ç”¢ç”Ÿçš„
                        const wasCheckingBefore = this.isSpecificPieceAttacking(testBoard, source.pos, source.piece, finalKingPos);
                        if (!wasCheckingBefore) {
                            console.log(`   âš¡ é€™æ˜¯æ”»æ“Šè€…ç§»å‹•å¾Œæ–°ç”¢ç”Ÿçš„å°‡è»å¨è„…ï¼`);
                        }
                    });

                    // æ¨¡æ“¬æ ¹å­å ±å¾©å¾Œçš„æƒ…æ³
                    let revengeBoard = simulationBoard.map(row => [...row]);
                    revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                    revengeBoard[rootPos.row][rootPos.col] = null;

                    // ç¢ºå®šå ±å¾©å¾Œç‹çš„ä½ç½®
                    let revengeKingPos;
                    if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                        revengeKingPos = targetPos;
                        console.log(`ğŸ‘‘ ç‹ä½œç‚ºæ ¹å­ç§»å‹•åˆ°æ–°ä½ç½®: (${targetPos.row},${targetPos.col})`);
                    } else {
                        revengeKingPos = this.findKing(revengeBoard, rootPiece.color);
                        console.log(`ğŸ‘‘ ç‹ä»åœ¨åŸä½ç½®: (${revengeKingPos?.row},${revengeKingPos?.col})`);
                    }

                    if (!revengeKingPos) {
                        console.log('âŒ å ±å¾©å¾Œæ‰¾ä¸åˆ°å·±æ–¹ç‹');
                        return false;
                    }

                    // æª¢æŸ¥å ±å¾©å¾Œæ˜¯å¦ä»å—åˆ°å°‡è»
                    const isKingStillInCheckAfterRevenge = this.isPositionUnderAttack(revengeBoard, revengeKingPos, enemyColor);

                    if (isKingStillInCheckAfterRevenge) {
                        console.log('âŒ æ ¹å­å ±å¾©å¾Œç‹ä»å—åˆ°å°‡è»');

                        const revengeCheckSources = this.getAttackingSources(revengeBoard, revengeKingPos, enemyColor);
                        console.log(`ğŸ‘ï¸ å ±å¾©å¾Œå°‡è»ä¾†æº: ${revengeCheckSources.length} å€‹`);

                        let foundCriticalThreat = false;
                        revengeCheckSources.forEach((source, index) => {
                            console.log(`   ${index + 1}. ${source.piece.color}æ–¹${source.piece.type} ä½ç½®: (${source.pos.row},${source.pos.col})`);

                            // ğŸ”¥ ç‰¹åˆ¥æª¢æŸ¥ï¼šæ ¹å­æ˜¯å¦æˆç‚ºäº†ç‚®æ¶æˆ–å…¶ä»–æ”»æ“Šåª’ä»‹
                            if (source.piece.type === 'ç‚®' || source.piece.type === 'ç ²') {
                                const cannonPath = this.getCannonPath(revengeBoard, source.pos, revengeKingPos);
                                if (cannonPath && cannonPath.mount) {
                                    const mountPos = cannonPath.mount;
                                    const mountPiece = revengeBoard[mountPos.row][mountPos.col];
                                    if (mountPiece &&
                                        mountPos.row === targetPos.row &&
                                        mountPos.col === targetPos.col &&
                                        mountPiece.color === rootPiece.color) {
                                        console.log('ğŸ’€ è‡´å‘½ç™¼ç¾ï¼šæ ¹å­å ±å¾©å¾Œæˆç‚ºæ•µæ–¹ç‚®çš„ç‚®æ¶ï¼Œå°è‡´ç‹è¢«å°‡è»ï¼');
                                        console.log(`   ç‚®æ¶ä½ç½®: (${mountPos.row},${mountPos.col}) - æ­£æ˜¯æ ¹å­å ±å¾©å¾Œçš„ä½ç½®`);
                                        foundCriticalThreat = true;
                                    }
                                }
                            }

                            // æª¢æŸ¥å…¶ä»–é¡å‹çš„æ”»æ“Šå¨è„…
                            const wasThreateningBeforeRevenge = this.isSpecificPieceAttacking(simulationBoard, source.pos, source.piece, revengeKingPos);
                            if (!wasThreateningBeforeRevenge) {
                                console.log(`   âš¡ é€™æ˜¯æ ¹å­ç§»å‹•å¾Œæ–°ç”¢ç”Ÿçš„å¨è„…ï¼`);
                                foundCriticalThreat = true;
                            }
                        });

                        if (foundCriticalThreat) {
                            console.log('ğŸ’€ æ ¹å­å ±å¾©ç”¢ç”Ÿæ–°çš„è‡´å‘½å¨è„…ï¼Œæ­¤æ”»æ“Šè€…æƒ…æ³ä¸‹æ ¹å­ç„¡æ•ˆ');
                            return false;
                        }

                        console.log('âŒ æ­¤æ”»æ“Šè€…æƒ…æ³ä¸‹æ ¹å­ç„¡æ•ˆ');
                        return false;
                    }

                    console.log('âœ… æ ¹å­å ±å¾©èƒ½å¤ è§£å°‡ï¼Œç¬¦åˆå°‡è»å¿…æ‡‰åŸå‰‡');
                } else {
                    // æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œç‹æ²’æœ‰å—åˆ°å°‡è»çš„æƒ…æ³
                    console.log('âœ… æ”»æ“Šè€…åƒæ‰ç›®æ¨™å¾Œå·±æ–¹ç‹å®‰å…¨ï¼Œé€²è¡Œå¸¸è¦å ±å¾©æª¢æŸ¥');

                    let revengeBoard = simulationBoard.map(row => [...row]);
                    revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                    revengeBoard[rootPos.row][rootPos.col] = null;

                    let revengeKingPos;
                    if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                        revengeKingPos = targetPos;
                    } else {
                        revengeKingPos = this.findKing(revengeBoard, rootPiece.color);
                    }

                    if (!revengeKingPos) {
                        console.log('âŒ å ±å¾©å¾Œæ‰¾ä¸åˆ°å·±æ–¹ç‹');
                        return false;
                    }

                    const kingUnderAttackAfterRevenge = this.isPositionUnderAttack(revengeBoard, revengeKingPos, enemyColor);

                    if (kingUnderAttackAfterRevenge) {
                        console.log('âŒ å ±å¾©å¾Œå·±æ–¹ç‹æœƒå—åˆ°æ–°çš„æ”»æ“Šå¨è„…');

                        const newThreats = this.getAttackingSources(revengeBoard, revengeKingPos, enemyColor);
                        newThreats.forEach((threat, index) => {
                            console.log(`   å¨è„… ${index + 1}: ${threat.piece.color}æ–¹${threat.piece.type} ä½ç½®: (${threat.pos.row},${threat.pos.col})`);

                            if (threat.piece.type === 'ç‚®' || threat.piece.type === 'ç ²') {
                                const cannonPath = this.getCannonPath(revengeBoard, threat.pos, revengeKingPos);
                                if (cannonPath && cannonPath.mount) {
                                    const mountPos = cannonPath.mount;
                                    if (mountPos.row === targetPos.row && mountPos.col === targetPos.col) {
                                        console.log('ğŸ’€ æ ¹å­å ±å¾©å¾Œæˆç‚ºç‚®æ¶ï¼Œç”¢ç”Ÿæ–°çš„å°‡è»å¨è„…ï¼');
                                    }
                                }
                            }
                        });

                        return false;
                    }
                }

                // å°‡å¸¥å°é¢è¦å‰‡æª¢æŸ¥
                if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                    let revengeBoard = simulationBoard.map(row => [...row]);
                    revengeBoard[targetPos.row][targetPos.col] = { ...rootPiece };
                    revengeBoard[rootPos.row][rootPos.col] = null;

                    const enemyKingPos = this.findKing(revengeBoard, enemyColor);
                    if (enemyKingPos && targetPos.col === enemyKingPos.col) {
                        let hasObstacle = false;
                        const minRow = Math.min(targetPos.row, enemyKingPos.row);
                        const maxRow = Math.max(targetPos.row, enemyKingPos.row);

                        for (let r = minRow + 1; r < maxRow; r++) {
                            if (revengeBoard[r][targetPos.col] !== null) {
                                hasObstacle = true;
                                break;
                            }
                        }

                        if (!hasObstacle) {
                            console.log('âŒ å ±å¾©å¾Œå…©å€‹å°‡å¸¥é¢å°é¢ï¼Œé•åè¦å‰‡');
                            return false;
                        }
                    }
                }

                return true;

            } catch (error) {
                console.error('ğŸš« testSingleAttackerRevenge éŒ¯èª¤:', error);
                return false;
            }
        }

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥ç‰¹å®šæ£‹å­æ˜¯å¦åœ¨æ”»æ“Šç‰¹å®šä½ç½®
        isSpecificPieceAttacking(board, piecePos, piece, targetPos) {
            try {
                const attackPositions = this.getPieceAttackPositions(board, piecePos, piece);
                return attackPositions.some(pos =>
                    pos.row === targetPos.row && pos.col === targetPos.col
                );
            } catch (error) {
                console.error('æª¢æŸ¥ç‰¹å®šæ£‹å­æ”»æ“Šæ™‚å‡ºéŒ¯:', error);
                return false;
            }
        }

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šç²å–æ”»æ“ŠæŸä½ç½®çš„æ‰€æœ‰æ•µæ–¹å­åŠ›
        getAttackingSources(board, targetPos, attackerColor) {
            const attackingSources = [];

            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === attackerColor) {
                        const attackPositions = this.getPieceAttackPositions(board, { row, col }, piece);
                        const canAttack = attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (canAttack) {
                            attackingSources.push({
                                pos: { row, col },
                                piece: piece
                            });
                        }
                    }
                }
            }

            return attackingSources;
        }

// ğŸ”¥ æ–°å¢è¼”åŠ©å‡½æ•¸ï¼šç²å–ç‚®çš„æ”»æ“Šè·¯å¾‘å’Œç‚®æ¶ä¿¡æ¯
        getCannonPath(board, cannonPos, targetPos) {
            // æª¢æŸ¥æ˜¯å¦åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—
            if (cannonPos.row !== targetPos.row && cannonPos.col !== targetPos.col) {
                return null;
            }

            let mountCount = 0;
            let mountPos = null;

            if (cannonPos.row === targetPos.row) {
                // åŒä¸€è¡Œ
                const startCol = Math.min(cannonPos.col, targetPos.col);
                const endCol = Math.max(cannonPos.col, targetPos.col);

                for (let col = startCol + 1; col < endCol; col++) {
                    if (board[cannonPos.row][col] !== null) {
                        mountCount++;
                        if (mountCount === 1) {
                            mountPos = { row: cannonPos.row, col };
                        } else {
                            return null; // è¶…éä¸€å€‹ç‚®æ¶
                        }
                    }
                }
            } else {
                // åŒä¸€åˆ—
                const startRow = Math.min(cannonPos.row, targetPos.row);
                const endRow = Math.max(cannonPos.row, targetPos.row);

                for (let row = startRow + 1; row < endRow; row++) {
                    if (board[row][cannonPos.col] !== null) {
                        mountCount++;
                        if (mountCount === 1) {
                            mountPos = { row, col: cannonPos.col };
                        } else {
                            return null; // è¶…éä¸€å€‹ç‚®æ¶
                        }
                    }
                }
            }

            // ç‚®éœ€è¦æ­£å¥½ä¸€å€‹ç‚®æ¶æ‰èƒ½æ”»æ“Š
            if (mountCount === 1) {
                return { mount: mountPos };
            }

            return null;
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰æ ¹å­ä¿è­· - ç°¡åŒ–ç‰ˆï¼ˆåªåˆ¤æ–·æ˜¯å¦æœ‰æ ¹å­ï¼Œä¸è€ƒæ…®æ•¸é‡å°æ¯”ï¼‰
        hasRoot(testBoard, targetPos, target, currentAttackerPos = null) {
            if (!Array.isArray(testBoard) || !targetPos || !target ||
                (target.color !== 'red' && target.color !== 'black')) {
                console.error('âŒ hasRoot: ç„¡æ•ˆåƒæ•¸', {
                    board: testBoard,
                    pos: targetPos,
                    piece: target
                });
                return false;
            }

            console.log('ğŸ” é–‹å§‹æª¢æŸ¥æ ¹å­ | ç›®æ¨™:', `${target.color}æ–¹${target.type}`, `ä½ç½®: (${targetPos.row},${targetPos.col})`);

            // ç²å–æ‰€æœ‰æ”»æ“Šç›®æ¨™çš„æ•µæ–¹æ£‹å­
            const enemyColor = target.color === 'red' ? 'black' : 'red';
            const allAttackers = [];

            // éæ­·æ‰€æœ‰æ•µæ–¹æ£‹å­ï¼Œæ‰¾å‡ºèƒ½æ”»æ“Šç›®æ¨™çš„æ£‹å­
            for (let row = 0; row < testBoard.length; row++) {
                for (let col = 0; col < testBoard[row].length; col++) {
                    const piece = testBoard[row][col];
                    if (piece && piece.color === enemyColor) {
                        const attackPositions = this.getPieceAttackPositions(testBoard, { row, col }, piece);
                        const canAttackTarget = attackPositions.some(pos =>
                            pos.row === targetPos.row && pos.col === targetPos.col
                        );

                        if (canAttackTarget) {
                            allAttackers.push({
                                piece: piece,
                                pos: { row, col }
                            });
                        }
                    }
                }
            }

            console.log(`ğŸ¯ ç™¼ç¾ ${allAttackers.length} å€‹æ”»æ“Šè€…æ”»æ“Šç›®æ¨™:`);
            allAttackers.forEach((attacker, index) => {
                console.log(`   ${index + 1}. ${attacker.piece.color}æ–¹${attacker.piece.type} ä½ç½®: (${attacker.pos.row},${attacker.pos.col})`);
            });

            // å¦‚æœæ²’æœ‰æ”»æ“Šè€…ï¼Œå‰‡ä¸éœ€è¦æ ¹å­
            if (allAttackers.length === 0) {
                console.log('â„¹ï¸ æ²’æœ‰æ”»æ“Šè€…ï¼Œä¸éœ€è¦æ ¹å­ä¿è­·');
                return true; // æ²’æœ‰å¨è„…å°±ä¸éœ€è¦ä¿è­·
            }

            // ç²å–æ‰€æœ‰å‹æ–¹æ£‹å­ä½œç‚ºæ½›åœ¨æ ¹å­
            const friendlyPieces = this.getFriendlyPieces(testBoard, target.color)
                .filter(p => !(p.pos.row === targetPos.row && p.pos.col === targetPos.col));

            if (friendlyPieces.length === 0) {
                console.log('âš ï¸ æ²’æœ‰å…¶ä»–åŒè‰²æ£‹å­å¯ä½œæ ¹å­');
                return false;
            }

            // ğŸ”¥ é—œéµä¿®æ”¹ï¼šåªè¦æ‰¾åˆ°ä»»ä½•ä¸€å€‹çœŸæ ¹å­å°±è¿”å›true
            console.log('ğŸ” é–‹å§‹æª¢æŸ¥æ˜¯å¦å­˜åœ¨çœŸæ ¹å­...');

            for (const { piece: rootPiece, pos: rootPos } of friendlyPieces) {
                console.log(`ğŸ” æª¢æŸ¥æ½›åœ¨æ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type}`, `ä½ç½®: (${rootPos.row},${rootPos.col})`);

                // æª¢æŸ¥é€™å€‹æ ¹å­æ˜¯å¦èƒ½å°ä»»ä¸€æ”»æ“Šè€…é€²è¡Œæœ‰æ•ˆå ±å¾©
                for (const attacker of allAttackers) {
                    const canRevenge = this.testRevengeCapability(testBoard, rootPos, rootPiece, targetPos, target, attacker.pos, attacker.piece);
                    if (canRevenge) {
                        // ğŸ”¥ ç‰¹æ®Šæª¢æŸ¥ï¼šå¦‚æœæ ¹å­æ˜¯å°‡å¸¥ï¼Œéœ€è¦é©—è­‰å ±å¾©å¾Œæ˜¯å¦å®‰å…¨
                        if (rootPiece.type === 'å¸¥' || rootPiece.type === 'å°‡') {
                            console.log(`ğŸ” å°‡å¸¥æ ¹å­ç‰¹æ®Šæª¢æŸ¥: ${rootPiece.color}æ–¹${rootPiece.type}`);

                            // æ¨¡æ“¬å°‡å¸¥åƒæ‰æ”»æ“Šè€…å¾Œçš„æ£‹å±€
                            const simulatedBoard = JSON.parse(JSON.stringify(testBoard));

                            // ç§»é™¤è¢«æ”»æ“Šçš„ç›®æ¨™æ£‹å­ï¼ˆå‡è¨­å·²è¢«æ”»æ“Šè€…åƒæ‰ï¼‰
                            simulatedBoard[targetPos.row][targetPos.col] = null;

                            // å°‡å¸¥ç§»å‹•åˆ°æ”»æ“Šè€…ä½ç½®ï¼ˆå ±å¾©ï¼‰
                            simulatedBoard[attacker.pos.row][attacker.pos.col] = rootPiece;
                            simulatedBoard[rootPos.row][rootPos.col] = null;

                            // æª¢æŸ¥å°‡å¸¥åœ¨æ–°ä½ç½®æ˜¯å¦æœƒè¢«å…¶ä»–æ•µæ–¹æ£‹å­æ”»æ“Š
                            const kingNewPos = { row: attacker.pos.row, col: attacker.pos.col };
                            let wouldBeAttacked = false;

                            for (let row = 0; row < simulatedBoard.length; row++) {
                                for (let col = 0; col < simulatedBoard[row].length; col++) {
                                    const piece = simulatedBoard[row][col];
                                    if (piece && piece.color === enemyColor) {
                                        const attackPositions = this.getPieceAttackPositions(simulatedBoard, { row, col }, piece);
                                        const canAttackKing = attackPositions.some(pos =>
                                            pos.row === kingNewPos.row && pos.col === kingNewPos.col
                                        );

                                        if (canAttackKing) {
                                            console.log(`âš ï¸ ${rootPiece.type}å ±å¾©å¾Œæœƒè¢« ${piece.color}æ–¹${piece.type}(${row},${col}) æ”»æ“Š`);
                                            wouldBeAttacked = true;
                                            break;
                                        }
                                    }
                                }
                                if (wouldBeAttacked) break;
                            }

                            if (wouldBeAttacked) {
                                console.log(`âŒ å°‡å¸¥æ ¹å­ç„¡æ•ˆ: ${rootPiece.type}å ±å¾©å¾Œæœƒè¢«æ”»æ“Šï¼Œä¸æ˜¯çœŸæ ¹å­`);
                                continue; // é€™å€‹å°‡å¸¥ä¸æ˜¯çœŸæ ¹å­ï¼Œç¹¼çºŒæª¢æŸ¥å…¶ä»–æ½›åœ¨æ ¹å­
                            } else {
                                console.log(`âœ… å°‡å¸¥æ ¹å­æœ‰æ•ˆ: ${rootPiece.type}å ±å¾©å¾Œå®‰å…¨`);
                            }
                        }

                        console.log(`âœ… ç™¼ç¾çœŸæ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type} å¯å ±å¾© ${attacker.piece.color}æ–¹${attacker.piece.type}`);
                        console.log(`ğŸ¯ æ ¹å­æª¢æŸ¥çµæœ: æœ‰çœŸæ ¹å­ä¿è­·`);
                        return true; // åªè¦æœ‰ä¸€å€‹çœŸæ ¹å­å°±è¶³å¤ 
                    }
                }

                console.log(`âŒ éçœŸæ ¹å­: ${rootPiece.color}æ–¹${rootPiece.type} ç„¡æ³•å°ä»»ä½•æ”»æ“Šè€…å ±å¾©`);
            }

            console.log('âŒ æ ¹å­æª¢æŸ¥çµæœ: æ²’æœ‰çœŸæ ¹å­ä¿è­·');
            return false;
        }

        // éœ€è¦çš„å…¶ä»–è¼”åŠ©å‡½æ•¸ï¼Œå¦‚æœä½ çš„ä»£ç¢¼ä¸­é‚„æ²’æœ‰çš„è©±ï¼š
        getFriendlyPieces(board, color) {
            const pieces = [];
            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        pieces.push({
                            piece: piece,
                            pos: { row, col }
                        });
                    }
                }
            }
            return pieces;
        }

        findKing(board, color) {
            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color &&
                        (piece.type === 'å¸¥' || piece.type === 'å°‡')) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

           // å‡è¨­ä½ å·²ç¶“æœ‰ getPieceAttackPositions å‡½æ•¸ï¼Œå¦‚æœæ²’æœ‰å¯ä»¥ä½¿ç”¨ getAttackPositions
        getPieceAttackPositions(board, pos, piece) {
            return this.getAttackPositions(board, piece, pos.row, pos.col);
        }

        // Methods from second version
        // æ£€æµ‹æ£‹è°±ä¸­çš„å¾ªç¯æ¨¡å¼ï¼ˆä¿®æ”¹ç‰ˆï¼ŒåŒ…å«é•¿å°†æ£€æµ‹ï¼‰
        detectCycle(gameRecord) {
            if (gameRecord.length < this.minCycleLength) return null;

            // å°†æ£‹è°±è½¬æ¢ä¸ºè¿ç»­çš„èµ°æ³•åºåˆ—
            const moveSequence = this.convertToMoveSequence(gameRecord);

            // ä»æœ€å°å¾ªç¯é•¿åº¦å¼€å§‹æ£€æµ‹
            for (let cycleLen = this.minCycleLength; cycleLen <= Math.min(this.maxCycleLength, Math.floor(moveSequence.length / 2)); cycleLen++) {
                const cycle = this.findCyclePattern(moveSequence, cycleLen, gameRecord);
                if (cycle) {
                    return cycle;
                }
            }

            return null;
        }

        // é‡ç½®è­¦å‘ŠçŠ¶æ€ï¼ˆæ–°æ¸¸æˆæˆ–èµ°æ³•æ”¹å˜æ—¶è°ƒç”¨ï¼‰
        resetWarning() {
            this.warningShown = false;
            this.warningPattern = null;
            this.lastWarningCycle = null;
        }

        // å°†æ¸¸æˆè®°å½•è½¬æ¢ä¸ºç§»åŠ¨åºåˆ—
        convertToMoveSequence(gameRecord) {
            const sequence = [];
            gameRecord.forEach(move => {
                if (move.red) sequence.push(move.red);
                if (move.black) sequence.push(move.black);
            });
            return sequence;
        }

        // æŸ¥æ‰¾æŒ‡å®šé•¿åº¦çš„å¾ªç¯æ¨¡å¼ï¼ˆä¿®æ”¹ç‰ˆï¼ŒåŒ…å«é•¿å°†æ£€æµ‹å’Œé•¿æ‰æ£€æµ‹ï¼‰
        findCyclePattern(sequence, cycleLength, gameRecord) {
            // ğŸ”§ ä¿®æ”¹1ï¼šå¾ªç’°æ¨¡å¼é•·åº¦è‡³å°‘è¦4æ­¥
            if (cycleLength < 4) return null;

            // ğŸ”§ ä¿®æ”¹2ï¼šèª¿æ•´æœ€å°åºåˆ—é•·åº¦è¦æ±‚
            // åŸæœ¬ï¼šcycleLength * this.warningThreshold (ä¾‹å¦‚ï¼š4 * 2 = 8)
            // æ–°ç‰ˆï¼šè‡³å°‘éœ€è¦èƒ½å®¹ç´2æ¬¡å¾ªç’°çš„é•·åº¦
            const minRequiredLength = cycleLength * 2;
            if (sequence.length < minRequiredLength) return null;

            // ä»åºåˆ—æœ«å°¾å¼€å§‹ï¼Œå‘å‰æŸ¥æ‰¾å¾ªç¯
            const end = sequence.length;
            const pattern = sequence.slice(end - cycleLength, end);

            let cycleCount = 1;
            let currentPos = end - cycleLength;

            // å‘å‰æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çš„æ¨¡å¼
            while (currentPos >= cycleLength) {
                const comparePattern = sequence.slice(currentPos - cycleLength, currentPos);
                if (this.arraysEqual(pattern, comparePattern)) {
                    cycleCount++;
                    currentPos -= cycleLength;
                } else {
                    break;
                }
            }

            const patternKey = pattern.join('|');

            // å¦‚æœå¾ªç’°æ¬¡æ•¸ä¸è¶³è­¦å‘Šé–¾å€¼ï¼Œç›´æ¥è¿”å›null
            if (cycleCount < this.warningThreshold) {
                return null;
            }

            // è¨­å®šç•¶å‰å¾ªç’°ä¿¡æ¯ä¾›æª¢æ¸¬ä½¿ç”¨
            this.currentCycleInfo = {
                start: currentPos,
                end: end,
                length: cycleLength,
                pattern: pattern,
                cycleCount: cycleCount,
                gameRecord: gameRecord
            };

            // æª¢æŸ¥é•·å°‡æƒ…æ³
            let perpetualCheckResult = null;
            if (this.checkDetectionEnabled && this.historyManager) {
                try {
                    perpetualCheckResult = this.detectPerpetualCheck(
                        gameRecord,
                        currentPos,  // æ•´å€‹å¾ªç’°å€é–“çš„èµ·å§‹ä½ç½®
                        end,         // æ•´å€‹å¾ªç’°å€é–“çš„çµæŸä½ç½®
                        cycleCount,  // å¾ªç’°æ¬¡æ•¸
                        cycleLength  // å–®å€‹å¾ªç’°çš„é•·åº¦
                    );
                } catch (error) {
                    console.error('ğŸš« é•·å°‡æª¢æ¸¬å¤±æ•—ï¼š', error);
                }
            }

            // ğŸ”§ é—œéµä¿®æ­£ï¼šåªæœ‰æ²’æª¢æ¸¬åˆ°é•·å°‡æ‰æª¢æ¸¬é•·æ‰
            let longCaptureResult = null;
            if (!perpetualCheckResult || !perpetualCheckResult.isPerpetualCheck) {
                if (this.historyManager) {
                    try {
                        // ä¿®æ”¹é€™è£¡ï¼šå‚³éæ‰€æœ‰å¿…è¦åƒæ•¸
                        longCaptureResult = this.detectLongCapture(
                            gameRecord,
                            currentPos,
                            end,
                            cycleCount,
                            cycleLength
                        );
                    } catch (error) {
                        console.error('ğŸš« ç¬¬ä¸€å¥—é•·æ‰æª¢æ¸¬å¤±æ•—ï¼Œå˜—è©¦å‚™ç”¨æ–¹æ¡ˆï¼š', error);
                        // ä½¿ç”¨ç°¡åŒ–çš„é•·æ‰æª¢æ¸¬ä½œç‚ºå‚™ç”¨æ–¹æ¡ˆ
                        try {
                            longCaptureResult = this.simplifiedLongCaptureDetection(this.currentCycleInfo);
                        } catch (backupError) {
                            console.error('ğŸš« å‚™ç”¨é•·æ‰æª¢æ¸¬ä¹Ÿå¤±æ•—ï¼š', backupError);
                        }
                    }
                }
            }

            // ============ å„ªå…ˆç´šè™•ç† ============

            // ã€æœ€é«˜å„ªå…ˆç´šã€‘é•·å°‡åˆ¤è² ï¼ˆ3æ¬¡å¾ªç’°ï¼‰
            if (perpetualCheckResult && perpetualCheckResult.isPerpetualCheck && cycleCount >= this.perpetualCheckThreshold) {
                return {
                    type: 'loss',
                    pattern: pattern,
                    cycleCount: cycleCount,
                    cycleLength: cycleLength,
                    startIndex: currentPos,
                    endIndex: end,
                    perpetualCheckPlayer: perpetualCheckResult.perpetualCheckPlayer,
                    description: `ğŸš« ${perpetualCheckResult.perpetualCheckPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}é•·å°‡åˆ¤è² `,
                    patternDisplay: pattern.join(' â†’ '),
                    perpetualCheckMoves: perpetualCheckResult.checkMoves
                };
            }

            // ã€ç¬¬äºŒå„ªå…ˆç´šã€‘é•·æ‰åˆ¤è² ï¼ˆ3æ¬¡å¾ªç’°ï¼‰
            if (longCaptureResult && longCaptureResult.isLongCapture && cycleCount >= this.cycleThreshold) {
                return {
                    type: 'loss',
                    pattern: pattern,
                    cycleCount: cycleCount,
                    cycleLength: cycleLength,
                    startIndex: currentPos,
                    endIndex: end,
                    longCapturePlayer: longCaptureResult.longCapturePlayer || longCaptureResult.violator,
                    description: `ğŸš« ${longCaptureResult.longCapturePlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}é•·æ‰åˆ¤è² `,
                    patternDisplay: pattern.join(' â†’ '),
                    longCaptureDetails: longCaptureResult
                };
            }

            // ã€è­¦å‘Šç´šåˆ¥ - å„ªå…ˆç´šï¼šé•·å°‡ > é•·æ‰ã€‘
            if (cycleCount >= this.warningThreshold && cycleCount < this.cycleThreshold) {
                const isNewPattern = !this.warningPattern || this.warningPattern !== patternKey;
                const isSamePatternButNotWarned = this.warningPattern === patternKey && !this.warningShown;

                if (isNewPattern || isSamePatternButNotWarned) {
                    // é•·å°‡è­¦å‘Šï¼ˆ2æ¬¡å¾ªç’°ï¼‰
                    if (perpetualCheckResult && perpetualCheckResult.isPerpetualCheck) {
                        return {
                            type: 'perpetual_warning',
                            pattern: pattern,
                            cycleCount: cycleCount,
                            cycleLength: cycleLength,
                            startIndex: currentPos,
                            endIndex: end,
                            perpetualCheckPlayer: perpetualCheckResult.perpetualCheckPlayer,
                            description: `âš ï¸ æ³¨æ„ï¼š${perpetualCheckResult.perpetualCheckPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}é•·å°‡è­¦å‘Šï¼å†å¾ªç’°1æ¬¡å°‡åˆ¤è² `,
                            patternDisplay: pattern.join(' â†’ '),
                            perpetualCheckMoves: perpetualCheckResult.checkMoves
                        };
                    }

                    // é•·æ‰è­¦å‘Šï¼ˆ2æ¬¡å¾ªç’°ï¼‰
                    if (longCaptureResult && longCaptureResult.isLongCapture) {
                        return {
                            type: 'long_capture_warning',
                            pattern: pattern,
                            cycleCount: cycleCount,
                            cycleLength: cycleLength,
                            startIndex: currentPos,
                            endIndex: end,
                            longCapturePlayer: longCaptureResult.longCapturePlayer || longCaptureResult.violator,
                            description: `âš ï¸ æ³¨æ„ï¼š${longCaptureResult.longCapturePlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}é•·æ‰è­¦å‘Šï¼å†å¾ªç’°1æ¬¡å°‡åˆ¤è² `,
                            patternDisplay: pattern.join(' â†’ '),
                            longCaptureDetails: longCaptureResult
                        };
                    }

                    // æ™®é€šå¾ªç’°è­¦å‘Šï¼ˆ2æ¬¡å¾ªç’°ï¼‰
                    return {
                        type: 'warning',
                        pattern: pattern,
                        cycleCount: cycleCount,
                        cycleLength: cycleLength,
                        startIndex: currentPos,
                        endIndex: end,
                        description: `âš ï¸ æ³¨æ„ï¼šæª¢æ¸¬åˆ°${cycleCount}æ¬¡å¾ªç’°ï¼å†å¾ªç’°1æ¬¡å°‡åˆ¤å’Œ`,
                        patternDisplay: pattern.join(' â†’ ')
                    };
                }
            }

            // ã€æœ€ä½å„ªå…ˆç´šã€‘æ™®é€šå¾ªç’°åˆ¤å’Œï¼ˆ3æ¬¡å¾ªç’°ï¼‰
            if (cycleCount >= this.cycleThreshold) {
                return {
                    type: 'draw',
                    pattern: pattern,
                    cycleCount: cycleCount,
                    cycleLength: cycleLength,
                    startIndex: currentPos,
                    endIndex: end,
                    description: `ğŸ”„ æª¢æ¸¬åˆ°${cycleCount}æ¬¡å¾ªç’°åˆ¤å’Œ`,
                    patternDisplay: pattern.join(' â†’ ')
                };
            }

            return null;
        }


        detectPerpetualCheck(gameRecord, startIndex, endIndex, cycleCount, cycleLength) {
            // éªŒè¯ historyManager
            if (!this.historyManager) {
                console.error('âŒ historyManager æœªåˆå§‹åŒ–');
                return { isPerpetualCheck: false };
            }

            if (typeof this.historyManager.getHistory !== 'function') {
                console.error('âŒ historyManager ç¼ºå°‘å¿…è¦çš„æ–¹æ³•');
                return { isPerpetualCheck: false };
            }

            if (this.historyManager.getHistoryLength() === 0) {
                console.error('âŒ æ£‹ç›˜çŠ¶æ€å†å²ä¸ºç©º');
                return { isPerpetualCheck: false };
            }

            try {
                const boardHistory = this.historyManager.getHistory();

                console.log(`ğŸ” å¼€å§‹æ£€æµ‹é•¿å°†ï¼š`);
                console.log(`ğŸ“ æ£‹è°±é•¿åº¦ï¼š${gameRecord.length}`);
                console.log(`ğŸ“Š å†å²è®°å½•æ•°é‡ï¼š${boardHistory.length} æ­¥`);
                console.log(`ğŸ¯ å¾ªç¯èŒƒå›´ï¼š${startIndex} - ${endIndex}`);
                console.log(`ğŸ”„ å¾ªç¯æ¬¡æ•°ï¼š${cycleCount}, å¾ªç¯é•¿åº¦ï¼š${cycleLength}`);

                // éªŒè¯ç´¢å¼•èŒƒå›´
                if (startIndex >= endIndex || startIndex < 0 || endIndex > boardHistory.length) {
                    console.warn('âš ï¸ æ— æ•ˆçš„ç´¢å¼•èŒƒå›´');
                    return { isPerpetualCheck: false };
                }

                // åªåˆ†æä¸€ä¸ªå¾ªç¯å‘¨æœŸï¼Œè€Œä¸æ˜¯æ•´ä¸ªé‡å¤åŒºé—´
                const singleCycleStart = endIndex - cycleLength;
                const singleCycleEnd = endIndex;

                console.log(`ğŸ” åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸï¼š${singleCycleStart} - ${singleCycleEnd}`);

                // åˆ†æå•ä¸ªå¾ªç¯å‘¨æœŸä¸­çš„å°†å†›æƒ…å†µ
                const checkAnalysis = this.analyzeCycleChecks(
                    gameRecord,
                    boardHistory,
                    singleCycleStart,
                    singleCycleEnd
                );

                // æ·»åŠ å¾ªç¯æ¬¡æ•°ä¿¡æ¯
                checkAnalysis.cycleCount = cycleCount;
                checkAnalysis.cycleLength = cycleLength;

                console.log('ğŸ” å°†å†›åˆ†æç»“æœï¼š', checkAnalysis);

                // ğŸ†• æ·»åŠ é€šçŸ¥å¤„ç†é€»è¾‘
                if (checkAnalysis.isPerpetualCheck) {
                    // æ„å»ºé€šçŸ¥æ‰€éœ€çš„æ•°æ®ç»“æ„
                    const perpetualCheckResult = {
                        player: checkAnalysis.perpetualCheckPlayer,
                        consecutiveChecks: Math.max(
                            checkAnalysis.playerCheckCounts.red,
                            checkAnalysis.playerCheckCounts.black
                        ),
                        cycleCount: cycleCount,
                        cycleLength: cycleLength,
                        patternDisplay: this.generatePatternDisplay(gameRecord, singleCycleStart, singleCycleEnd),
                        checkMoves: checkAnalysis.checkMoves,
                        playerCheckCounts: checkAnalysis.playerCheckCounts,
                        playerMoveCounts: checkAnalysis.playerMoveCounts,
                        // æ·»åŠ  analyzeCycleChecks è¿”å›çš„æ–°å­—æ®µ
                        isMutualPerpetualCheck: checkAnalysis.isMutualPerpetualCheck,
                        redCheckRatio: checkAnalysis.redCheckRatio,
                        blackCheckRatio: checkAnalysis.blackCheckRatio,
                        gameResult: checkAnalysis.gameResult
                    };

                    // æ ¹æ®å¾ªç¯æ¬¡æ•°å’Œé•¿å°†ç±»å‹å†³å®šæ˜¾ç¤ºæ¶ˆæ¯
                    if (cycleCount >= 3) {
                        // å¾ªç¯3æ¬¡æˆ–ä»¥ä¸Š
                        if (checkAnalysis.isMutualPerpetualCheck) {
                            // åŒæ–¹äº’ç›¸é•¿å°† â†’ å’Œæ£‹
                            console.log(`ğŸ¤ åŒæ–¹äº’ç›¸é•¿å°†ï¼Œåˆ¤å®šå’Œæ£‹ï¼`);
                            showMutualPerpetualCheckDraw(perpetualCheckResult);
                            checkAnalysis.isViolation = true;
                            checkAnalysis.gameResult = 'draw';
                            checkAnalysis.winner = null;
                        } else {
                            // å•æ–¹é•¿å°† â†’ è¯¥æ–¹åˆ¤è´Ÿ
                            console.log(`ğŸš« ${checkAnalysis.perpetualCheckPlayer}æ–¹é•¿å°†åˆ¤è´Ÿï¼`);
                            showPerpetualCheckLoss(perpetualCheckResult);
                            checkAnalysis.isViolation = true;
                            checkAnalysis.gameResult = 'perpetual_check_loss';
                            checkAnalysis.loser = checkAnalysis.perpetualCheckPlayer;
                        }
                    } else if (cycleCount === 2) {
                        // å¾ªç¯2æ¬¡ï¼Œæ˜¾ç¤ºè­¦å‘Š
                        if (checkAnalysis.isMutualPerpetualCheck) {
                            // åŒæ–¹äº’ç›¸é•¿å°†è­¦å‘Š
                            console.log(`âš ï¸ åŒæ–¹äº’ç›¸é•¿å°†è­¦å‘Šï¼`);
                            showMutualPerpetualCheckWarning(perpetualCheckResult);
                        } else {
                            // å•æ–¹é•¿å°†è­¦å‘Š
                            console.log(`âš ï¸ ${checkAnalysis.perpetualCheckPlayer}æ–¹é•¿å°†è­¦å‘Šï¼`);
                            showPerpetualCheckWarning(perpetualCheckResult);
                        }
                        checkAnalysis.isWarning = true;
                    }
                    // å¾ªç¯1æ¬¡ä¸æ˜¾ç¤ºä»»ä½•é€šçŸ¥
                }

                return checkAnalysis;

            } catch (error) {
                console.error('ğŸš« é•¿å°†æ£€æµ‹è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š', error);
                return { isPerpetualCheck: false };
            }
        }
        analyzeCycleChecks(gameRecord, boardHistory, startIndex, endIndex) {
            console.log(`ğŸ” åˆ†æé•¿å°†ï¼šboardHistoryé•¿åº¦=${boardHistory.length}`);
            console.log(`ğŸ” æ£€æµ‹èŒƒå›´ï¼š${startIndex} - ${endIndex}`);

            // å†…ç½®å¾ªç¯æ£€æµ‹å™¨ (ä¸å¤–éƒ¨é€»è¾‘ç›¸åŒä½†ç‹¬ç«‹è¿ä½œ)
            const internalCycleDetector = (moves) => {
                const minCycleLength = 4; // æœ€å°å¾ªç¯é•¿åº¦
                const maxCycleLength = 10; // æœ€å¤§å¾ªç¯é•¿åº¦
                const sequence = moves.map(m => m.notation);

                for (let len = minCycleLength; len <= maxCycleLength; len++) {
                    if (sequence.length < len * 2) continue;

                    const pattern = sequence.slice(-len);
                    let cycleCount = 0;

                    for (let i = sequence.length - len; i >= 0; i -= len) {
                        if (sequence.slice(i, i + len).join('|') === pattern.join('|')) {
                            cycleCount++;
                        } else {
                            break;
                        }
                    }

                    if (cycleCount >= 2) { // è‡³å°‘æ£€æµ‹åˆ°2æ¬¡å¾ªç¯
                        return {
                            detected: true,
                            cycleCount: cycleCount,
                            cycleLength: len,
                            pattern: pattern
                        };
                    }
                }
                return { detected: false };
            };

            const checkMoves = [];
            const redMoves = [];
            const blackMoves = [];
            const redChecks = [];
            const blackChecks = [];

            // è½¬æ¢æ£‹è°±æ ¼å¼ä¸ºç§»åŠ¨åºåˆ—
            const moveSequence = this.convertGameRecordToMoveSequence(gameRecord);
            console.log(`ğŸ” ç§»åŠ¨åºåˆ—é•¿åº¦ï¼š${moveSequence.length}`);

            // æ‰§è¡Œå†…ç½®å¾ªç¯æ£€æµ‹
            const cycleResult = internalCycleDetector(moveSequence);
            console.log(`ğŸ”„ å†…ç½®å¾ªç¯æ£€æµ‹ç»“æœï¼š`, cycleResult);

            // ç¡®ä¿ä¸è¶…å‡ºä»»ä½•æ•°ç»„çš„èŒƒå›´
            const actualEndIndex = Math.min(endIndex, moveSequence.length, boardHistory.length);
            console.log(`ğŸ” å®é™…æ£€æµ‹èŒƒå›´ï¼š${startIndex} - ${actualEndIndex}`);

            for (let i = startIndex; i < actualEndIndex; i++) {
                if (i >= moveSequence.length) {
                    console.warn(`âš ï¸ ç§»åŠ¨åºåˆ—ç´¢å¼•è¶Šç•Œ: ${i}/${moveSequence.length}`);
                    break;
                }

                const move = moveSequence[i];
                const boardIndex = i;

                if (boardIndex >= boardHistory.length) {
                    console.warn(`âš ï¸ æ£‹ç›˜çŠ¶æ€ç´¢å¼•è¶Šç•Œ: ${boardIndex}/${boardHistory.length}`);
                    continue;
                }

                const boardState = boardHistory[boardIndex];
                if (!boardState || !boardState.board) {
                    console.warn(`âš ï¸ æ— æ•ˆçš„æ£‹ç›˜çŠ¶æ€: ${boardIndex}`);
                    continue;
                }

                // è®°å½•æ¯ä¸ªç©å®¶çš„ç§»åŠ¨
                if (move.player === 'red') {
                    redMoves.push(i);
                } else {
                    blackMoves.push(i);
                }

                // æ£€æŸ¥æ˜¯å¦å°†å†›
                const opponent = move.player === 'red' ? 'black' : 'red';
                const isCheck = this.isKingInCheck(boardState, opponent);

                console.log(`ğŸ” æ£€æŸ¥ç¬¬${i}æ­¥ ${move.player} ${move.notation}ï¼Œæ˜¯å¦å°†å†›${opponent}ï¼š${isCheck}`);

                if (isCheck) {
                    checkMoves.push({
                        moveIndex: i,
                        player: move.player,
                        notation: move.notation,
                        targetPlayer: opponent
                    });

                    if (move.player === 'red') {
                        redChecks.push(i);
                    } else {
                        blackChecks.push(i);
                    }
                }
            }

            // è®¡ç®—å°†å†›æ¯”ä¾‹
            const redCheckRatio = redMoves.length > 0 ? redChecks.length / redMoves.length : 0;
            const blackCheckRatio = blackMoves.length > 0 ? blackChecks.length / blackMoves.length : 0;

            console.log(`ğŸ” çº¢æ–¹ç§»åŠ¨æ¬¡æ•°ï¼š${redMoves.length}ï¼Œå°†å†›æ¬¡æ•°ï¼š${redChecks.length}`);
            console.log(`ğŸ” é»‘æ–¹ç§»åŠ¨æ¬¡æ•°ï¼š${blackMoves.length}ï¼Œå°†å†›æ¬¡æ•°ï¼š${blackChecks.length}`);
            console.log(`ğŸ” çº¢æ–¹å°†å†›æ¯”ä¾‹ï¼š${redCheckRatio.toFixed(2)} (${redChecks.length}/${redMoves.length})`);
            console.log(`ğŸ” é»‘æ–¹å°†å†›æ¯”ä¾‹ï¼š${blackCheckRatio.toFixed(2)} (${blackChecks.length}/${blackMoves.length})`);

            // é•¿å°†åˆ¤å®šé€»è¾‘ä¿®æ­£
            const isRedPerpetual = redCheckRatio === 1.0 && redMoves.length > 0;
            const isBlackPerpetual = blackCheckRatio === 1.0 && blackMoves.length > 0;

            // æ–°å¢ï¼šåŒæ–¹äº’ç›¸é•¿å°†åˆ¤å®š
            const isMutualPerpetualCheck = isRedPerpetual && isBlackPerpetual;

            let gameResult = null;
            let perpetualCheckPlayer = null;

            if (isMutualPerpetualCheck) {
                // åŒæ–¹äº’ç›¸é•¿å°† = å’Œæ£‹
                gameResult = 'draw';
                perpetualCheckPlayer = 'both';
                console.log(`ğŸ¤ åŒæ–¹äº’ç›¸é•¿å°†ï¼Œåˆ¤å®šä¸ºå’Œæ£‹`);
            } else if (isRedPerpetual) {
                // åªæœ‰çº¢æ–¹é•¿å°† = çº¢æ–¹åˆ¤è´Ÿ
                gameResult = 'black_wins';
                perpetualCheckPlayer = 'red';
                console.log(`âŒ çº¢æ–¹é•¿å°†åˆ¤è´Ÿ`);
            } else if (isBlackPerpetual) {
                // åªæœ‰é»‘æ–¹é•¿å°† = é»‘æ–¹åˆ¤è´Ÿ
                gameResult = 'red_wins';
                perpetualCheckPlayer = 'black';
                console.log(`âŒ é»‘æ–¹é•¿å°†åˆ¤è´Ÿ`);
            }

            console.log(`ğŸ” çº¢æ–¹é•¿å°†åˆ¤æ–­ï¼š${isRedPerpetual} (æ¯”ä¾‹=1.0: ${redCheckRatio === 1.0}, æœ‰ç§»åŠ¨: ${redMoves.length > 0})`);
            console.log(`ğŸ” é»‘æ–¹é•¿å°†åˆ¤æ–­ï¼š${isBlackPerpetual} (æ¯”ä¾‹=1.0: ${blackCheckRatio === 1.0}, æœ‰ç§»åŠ¨: ${blackMoves.length > 0})`);
            console.log(`ğŸ” åŒæ–¹äº’ç›¸é•¿å°†ï¼š${isMutualPerpetualCheck}`);

            const result = {
                isPerpetualCheck: isRedPerpetual || isBlackPerpetual,
                perpetualCheckPlayer,
                isMutualPerpetualCheck,
                gameResult,
                checkMoves,
                playerCheckCounts: { red: redChecks.length, black: blackChecks.length },
                playerMoveCounts: { red: redMoves.length, black: blackMoves.length },
                redCheckRatio,
                blackCheckRatio,
                totalMoves: actualEndIndex - startIndex,
                // å¾ªç¯æ£€æµ‹ç»“æœ
                internalCycleDetected: cycleResult.detected,
                internalCycleCount: cycleResult.cycleCount || 0,
                internalCycleLength: cycleResult.cycleLength || 0
            };

            console.log(`ğŸ” æœ€ç»ˆé•¿å°†åˆ¤æ–­ï¼š`, result);
            return result;
        }
// æ–°å¢è½‰æ›æ–¹æ³•
        convertGameRecordToMoveSequence(gameRecord) {
            const sequence = [];
            for (let i = 0; i < gameRecord.length; i++) {
                const round = gameRecord[i];
                if (round.red) {
                    sequence.push({
                        player: 'red',
                        notation: round.red,
                        roundIndex: i
                    });
                }
                if (round.black) {
                    sequence.push({
                        player: 'black',
                        notation: round.black,
                        roundIndex: i
                    });
                }
            }
            return sequence;
        }
        // å°†æ¸¸æˆè®°å½•è½¬æ¢ä¸ºå¸¦ç©å®¶ä¿¡æ¯çš„ç§»åŠ¨åºåˆ—
        convertToMoveSequenceWithPlayer(gameRecord) {


            const sequence = [];
            gameRecord.forEach((move, index) => {
                if (move.red) {
                    sequence.push({
                        notation: move.red,
                        player: 'red',
                        moveIndex: index * 2
                    });
                }
                if (move.black) {
                    sequence.push({
                        notation: move.black,
                        player: 'black',
                        moveIndex: index * 2 + 1
                    });
                }
            });
            return sequence;
        }

        // æ£€æŸ¥å°†å†›çŠ¶æ€
        isKingInCheck(boardState, player) {
            if (!boardState || !boardState.board) {
                console.warn('âš ï¸ æ£‹ç›˜çŠ¶æ€æ— æ•ˆï¼Œæ— æ³•æ£€æŸ¥å°†å†›');
                return false;
            }

            try {
                // æ‰¾åˆ°è¢«æ£€æŸ¥æ–¹çš„å°†/å¸…ä½ç½®
                const kingPosition = this.findKingPosition(boardState.board, player);
                if (!kingPosition) {
                    console.warn(`âš ï¸ æ‰¾ä¸åˆ°${player}æ–¹çš„å°†/å¸…`);
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦è¢«å¯¹æ–¹æ£‹å­æ”»å‡»
                const opponent = player === 'red' ? 'black' : 'red';
                return this.isPositionUnderAttack(boardState.board, kingPosition, opponent);

            } catch (error) {
                console.error('ğŸš« æ£€æŸ¥å°†å†›çŠ¶æ€æ—¶å‘ç”Ÿé”™è¯¯ï¼š', error);
                return false;
            }
        }

        // æ‰¾åˆ°å°†/å¸…çš„ä½ç½®
        findKingPosition(board, player) {
            const kingType = player === 'red' ? 'å¸¥' : 'å°‡';

            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === kingType && piece.color === player) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«æ”»å‡»
        isPositionUnderAttack(board, position, attackerColor) {
            for (let row = 0; row < board.length; row++) {
                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === attackerColor) {
                        // æ£€æŸ¥è¿™ä¸ªæ£‹å­æ˜¯å¦èƒ½æ”»å‡»åˆ°ç›®æ ‡ä½ç½®
                        if (this.canPieceAttackPosition(board, {row, col}, position, piece)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // æ£€æŸ¥æ£‹å­æ˜¯å¦èƒ½æ”»å‡»åˆ°æŒ‡å®šä½ç½®
        canPieceAttackPosition(board, fromPos, toPos, piece) {
            switch (piece.type) {
                case 'è»Š':
                case 'ä¿¥':
                    return this.canRookAttack(board, fromPos, toPos);
                case 'é¦¬':
                case 'å‚Œ':
                    return this.canHorseAttack(board, fromPos, toPos);
                case 'ç‚®':
                case 'åŒ…':
                    return this.canCannonAttack(board, fromPos, toPos);
                case 'å…µ':
                case 'å’':
                    return this.canPawnAttack(board, fromPos, toPos, piece.color);
                case 'å°‡':
                case 'å¸¥':
                    return this.canKingAttack(board, fromPos, toPos);
                default:
                    return false;
            }
        }

        // è½¦çš„æ”»å‡»åˆ¤æ–­
        canRookAttack(board, fromPos, toPos) {
            if (fromPos.row !== toPos.row && fromPos.col !== toPos.col) return false;

            // æ£€æŸ¥è·¯å¾„æ˜¯å¦ç•…é€š
            if (fromPos.row === toPos.row) {
                const minCol = Math.min(fromPos.col, toPos.col);
                const maxCol = Math.max(fromPos.col, toPos.col);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (board[fromPos.row][col]) return false;
                }
            } else {
                const minRow = Math.min(fromPos.row, toPos.row);
                const maxRow = Math.max(fromPos.row, toPos.row);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (board[row][fromPos.col]) return false;
                }
            }
            return true;
        }

        // é©¬çš„æ”»å‡»åˆ¤æ–­
        canHorseAttack(board, fromPos, toPos) {
            const rowDiff = Math.abs(toPos.row - fromPos.row);
            const colDiff = Math.abs(toPos.col - fromPos.col);

            if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) return false;

            // æ£€æŸ¥é©¬è„š
            let blockRow, blockCol;
            if (rowDiff === 2) {
                blockRow = fromPos.row + (toPos.row > fromPos.row ? 1 : -1);
                blockCol = fromPos.col;
            } else {
                blockRow = fromPos.row;
                blockCol = fromPos.col + (toPos.col > fromPos.col ? 1 : -1);
            }

            return !board[blockRow][blockCol];
        }

        // ç‚®çš„æ”»å‡»åˆ¤æ–­
        canCannonAttack(board, fromPos, toPos) {
            if (fromPos.row !== toPos.row && fromPos.col !== toPos.col) return false;

            let pieceCount = 0;

            if (fromPos.row === toPos.row) {
                const minCol = Math.min(fromPos.col, toPos.col);
                const maxCol = Math.max(fromPos.col, toPos.col);
                for (let col = minCol + 1; col < maxCol; col++) {
                    if (board[fromPos.row][col]) pieceCount++;
                }
            } else {
                const minRow = Math.min(fromPos.row, toPos.row);
                const maxRow = Math.max(fromPos.row, toPos.row);
                for (let row = minRow + 1; row < maxRow; row++) {
                    if (board[row][fromPos.col]) pieceCount++;
                }
            }

            return pieceCount === 1; // ç‚®éœ€è¦éš”ä¸€ä¸ªæ£‹å­
        }

        // å…µ/å’çš„æ”»å‡»åˆ¤æ–­
        canPawnAttack(board, fromPos, toPos, color) {
            const rowDiff = toPos.row - fromPos.row;
            const colDiff = Math.abs(toPos.col - fromPos.col);

            if (color === 'red') {
                // çº¢æ–¹å…µåªèƒ½å‘å‰ï¼ˆä¸Šï¼‰
                if (fromPos.row >= 5) { // è¿‡æ²³å‰
                    return rowDiff === -1 && colDiff === 0;
                } else { // è¿‡æ²³å
                    return (rowDiff === -1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
                }
            } else {
                // é»‘æ–¹å’åªèƒ½å‘å‰ï¼ˆä¸‹ï¼‰
                if (fromPos.row <= 4) { // è¿‡æ²³å‰
                    return rowDiff === 1 && colDiff === 0;
                } else { // è¿‡æ²³å
                    return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
                }
            }
        }

        // å°†/å¸…çš„æ”»å‡»åˆ¤æ–­ï¼ˆç”¨äºæ£€æŸ¥"å¯¹è„¸"å°†å†›ï¼‰
        canKingAttack(board, fromPos, toPos) {
            // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€åˆ—
            if (fromPos.col !== toPos.col) return false;

            // æ£€æŸ¥ä¸­é—´æ˜¯å¦æœ‰æ£‹å­
            const minRow = Math.min(fromPos.row, toPos.row);
            const maxRow = Math.max(fromPos.row, toPos.row);
            for (let row = minRow + 1; row < maxRow; row++) {
                if (board[row][fromPos.col]) return false;
            }

            return true;
        }
        extractMovesFromGameRecord(gameRecord, startIndex, endIndex, cycleLength) {
            try {
                const moves = [];
                const moveSequence = this.convertToMoveSequenceWithPlayer(gameRecord);

                // æå–ä¸€å€‹å¾ªç’°å‘¨æœŸçš„moves
                const cycleStart = endIndex - cycleLength;
                const cycleMoves = moveSequence.slice(cycleStart, endIndex);

                // ç‚ºæ¯å€‹moveæ·»åŠ æ£‹ç›¤ç‹€æ…‹
                const boardHistory = this.historyManager.getHistory();

                for (let i = 0; i < cycleMoves.length; i++) {
                    const move = cycleMoves[i];
                    const boardIndex = cycleStart + i + 1; // +1 å› ç‚ºè¦ç²å–ç§»å‹•å¾Œçš„ç‹€æ…‹

                    if (boardIndex < boardHistory.length) {
                        moves.push({
                            notation: move.notation,
                            player: move.player,
                            from: null, // é€™äº›ä¿¡æ¯éœ€è¦å¾å…¶ä»–åœ°æ–¹ç²å–æˆ–çœç•¥
                            to: null,
                            boardAfter: boardHistory[boardIndex].board
                        });
                    }
                }

                return moves;
            } catch (error) {
                console.error('æå–moveså¤±æ•—ï¼š', error);
                return [];
            }
        }
        // æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„æ˜¯å¦ç›¸ç­‰
        arraysEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        // æ ‡è®°è­¦å‘Šå·²æ˜¾ç¤º
        markWarningShown(cycleResult) {
            this.warningShown = true;
            this.warningPattern = cycleResult.pattern.join('|');
            this.lastWarningCycle = cycleResult;
        }

        // å¯ç”¨/ç¦ç”¨é•¿å°†æ£€æµ‹
        setCheckDetectionEnabled(enabled) {
            this.checkDetectionEnabled = enabled;
        }

        // è®¾ç½®é•¿å°†åˆ¤è´Ÿé˜ˆå€¼
        setPerpetualCheckThreshold(threshold) {
            this.perpetualCheckThreshold = threshold;
        }
    }
    // åˆå§‹åŒ–å¾ªç’°æª¢æ¸¬å™¨
    // æ­£ç¢ºçš„åˆå§‹åŒ–æ–¹å¼

    const cycleDetector = new NotationCycleDetector(historyManager); // â† å‚³å…¥åƒæ•¸ï¼
    this.historyManager = new MoveHistoryManager();
    this.historyManager = new BoardHistoryManager();



    // ============================================
    // AI å¯¹æˆ˜å¤šé€‰èµ°æ³•é…ç½®ç³»ç»Ÿ
    // ============================================

    // ğŸ¯ å„éš¾åº¦çš„èµ°æ³•é€‰æ‹©æœºç‡é…ç½®
    const AI_MOVE_SELECTION_CONFIG = {
        easy: {
            name: 'ç®€å•',
            depth: 3,
            multipv: 3,  // éœ€è¦åˆ†æ3ä¸ªé€‰é¡¹
            probabilities: {
                first: 0.50,   // 50% èµ°æœ€ä½³
                second: 0.30,  // 30% èµ°æ¬¡ä¼˜
                third: 0.20    // 20% èµ°ç¬¬ä¸‰é€‰
            },
            description: 'æ¨¡æ‹Ÿæ–°æ‰‹ï¼ŒåŠæ•°èµ°æœ€ä½³ï¼Œå¶å°”å¤±è¯¯'
        },
        medium: {
            name: 'ä¸­çº§',
            depth: 6,
            multipv: 3,
            probabilities: {
                first: 0.60,   // 60% èµ°æœ€ä½³
                second: 0.30,  // 30% èµ°æ¬¡ä¼˜
                third: 0.10    // 10% èµ°ç¬¬ä¸‰é€‰
            },
            description: 'æ¨¡æ‹Ÿä¸šä½™çˆ±å¥½è€…ï¼Œå¶å°”å¤±è¯¯'
        },
        hard: {
            name: 'é«˜çº§',
            depth: 9,
            multipv: 3,
            probabilities: {
                first: 0.80,   // 80% èµ°æœ€ä½³
                second: 0.15,  // 15% èµ°æ¬¡ä¼˜
                third: 0.05    // 5% èµ°ç¬¬ä¸‰é€‰
            },
            description: 'æ¨¡æ‹Ÿé«˜æ‰‹ï¼Œå¾ˆå°‘å¤±è¯¯'
        },
        expert: {
            name: 'ä¸“ä¸š',
            depth: 12,
            multipv: 3,
            probabilities: {
                first: 0.90,   // 90% èµ°æœ€ä½³
                second: 0.08,  // 8% èµ°æ¬¡ä¼˜
                third: 0.02    // 2% èµ°ç¬¬ä¸‰é€‰
            },
            description: 'æ¥è¿‘å¤§å¸ˆæ°´å¹³ï¼Œæå°‘å¤±è¯¯'
        },
        master: {
            name: 'å¤§å¸ˆ',
            depth: 15,
            multipv: 1,  // åªåˆ†ææœ€ä½³æ‹›
            probabilities: {
                first: 1.00,   // 100% èµ°æœ€ä½³
                second: 0.00,
                third: 0.00
            },
            description: 'æ°¸è¿œèµ°æœ€å¼ºæ‹›ï¼Œæ— å¤±è¯¯'
        }
    };


    // ğŸ”§ å®Œæ•´é›™æ¨¡å¼æ”¯æ´ - IPC (Electronæ‰“åŒ…) + UCI (ç€è¦½å™¨æ¸¬è©¦)

    // ============================================
    // å®Œæ•´ä¿®æ”¹ç‰ˆæœ¬ - CompleteXiangqiAI Class
    // ============================================

    class CompleteXiangqiAI {
        constructor(pikafishPath = './pikafish.exe') {
            this.pikafishPath = pikafishPath;
            this.engineProcess = null;
            this.isReady = false;
            this.isThinking = false;
            this.analysisMode = 'analysis';
            this.defaultAnalysisDepth = 15;
            this.savedBattleMode = null;

            // ç¿»è­¯å®˜
            this.translator = new XiangqiTranslator();

            // UCI é€šä¿¡
            this.messageQueue = [];
            this.pendingCommands = new Map();
            this.commandId = 0;

            // ç‹€æ…‹
            this.difficulty = 'medium';
            this.thinkingTime = 5000;

            // äº‹ä»¶ç³»çµ±
            this.eventListeners = {};

            // CPåˆ†æ•¸ç›¸é—œå±¬æ€§
            this.latestCpScore = null;
            this.cpScoreHistory = [];

            this.gameMode = null;
            this.historyManager = historyManager;

            // Node.js æ¨¡çµ„ï¼ˆéœ€è¦åœ¨ Node.js ç’°å¢ƒä¸­é‹è¡Œï¼‰
            this.spawn = null;
            this.readline = null;

            // ğŸ”¥ æ–°å¢: MultiPV ç›¸é—œå±¬æ€§
            this.currentMultiPV = 1;
            this.multiPVResults = [];
            this.isCollectingMultiPV = false;

            // ğŸ”¥ æ·»åŠ ä¼šè¯ ID
            this.analysisSessionId = 0;
            this.currentSessionId = 0;

            // ğŸ”¥ æ–°å¢: WASM ç›¸é—œå±¬æ€§
            this.useWASM = false;
            this.wasmModule = null;
            this.wasmReady = false;

            // ğŸ”¥ æ–°å¢ï¼šè‡ªå‹•è¨­ç‚ºå…¨å±€è®Šæ•¸
            if (typeof window !== 'undefined') {
                window.xiangqiAI = this;
                console.log('âœ… CompleteXiangqiAI å·²è¨­ç‚º window.xiangqiAI');
            }

            // ğŸ”¥ æ–°å¢: WASM åˆå§‹åŒ–ç‹€æ…‹è¿½è¹¤
            this.wasmInitializing = false;
            this.wasmInitPromise = null;

            // âœ… æª¢æŸ¥é‹è¡Œç’°å¢ƒä¸¦åˆå§‹åŒ–
            this.initializeEnvironment();


        }

        // ============================================
        // å®Œæ•´ä¿®æ”¹: initializeEnvironment()
        // ============================================
        initializeEnvironment() {
            try {
                const isElectron = (
                    (typeof process !== 'undefined' && process.versions && process.versions.electron) ||
                    (typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().includes('electron')) ||
                    (typeof window !== 'undefined' && window.process && window.process.type)
                );

                console.log('ğŸ” ç’°å¢ƒæª¢æ¸¬:');
                console.log('  - isElectron:', isElectron);
                console.log('  - window.pikafish å­˜åœ¨:', typeof window.pikafish !== 'undefined');
                console.log('  - window.appPath å­˜åœ¨:', typeof window.appPath !== 'undefined');
                console.log('  - window.electronEnv å­˜åœ¨:', typeof window.electronEnv !== 'undefined');
                console.log('  - Module (WASM) å­˜åœ¨:', typeof Module !== 'undefined');

                // âœ… å„ªå…ˆç´š 1: æª¢æ¸¬ window.pikafish (IPC)
                if (typeof window !== 'undefined' && window.pikafish) {
                    this.usePikafishAPI = true;
                    this.isNodeEnvironment = false;
                    this.useHttpAPI = false;
                    this.useWASM = false;
                    console.log('ğŸ”§ é‹è¡Œæ¨¡å¼: Electron (IPC API)');
                    console.log('âœ… æª¢æ¸¬åˆ° window.pikafishï¼Œä½¿ç”¨ IPC é€šè¨Š');
                    return;
                }

                // ğŸ”¥ å„ªå…ˆç´š 2: å¦‚æœåœ¨ Electron ç’°å¢ƒä½†æ²’æœ‰ window.pikafishï¼Œç­‰å¾…æ³¨å…¥
                if (isElectron) {
                    console.log('âš ï¸ æª¢æ¸¬åˆ° Electron ç’°å¢ƒï¼Œä½† window.pikafish å°šæœªæ³¨å…¥');
                    console.log('ğŸ”„ ç­‰å¾… preload.js æ³¨å…¥ API...');

                    let waitCount = 0;
                    const checkInterval = setInterval(() => {
                        waitCount++;

                        if (window.pikafish) {
                            clearInterval(checkInterval);
                            console.log('âœ… window.pikafish å·²æ³¨å…¥ï¼Œé‡æ–°åˆå§‹åŒ–');
                            this.usePikafishAPI = true;
                            this.isNodeEnvironment = false;
                            this.useHttpAPI = false;
                            this.useWASM = false;

                            this.initialize().then(() => {
                                console.log('âœ… AI å¼•æ“å»¶é²åˆå§‹åŒ–å®Œæˆ');
                                this.emit('engine-ready');
                            }).catch(err => {
                                console.error('âŒ å»¶é²åˆå§‹åŒ–å¤±æ•—:', err);
                            });

                        } else if (waitCount > 50) {
                            clearInterval(checkInterval);
                            console.error('âŒ ç­‰å¾…è¶…æ™‚ï¼Œwindow.pikafish æœªæ³¨å…¥');
                            console.error('è«‹æª¢æŸ¥:');
                            console.error('1. preload.js æ˜¯å¦æ­£ç¢ºè¼‰å…¥');
                            console.error('2. contextBridge æ˜¯å¦æˆåŠŸåŸ·è¡Œ');
                            console.error('3. BrowserWindow é…ç½®æ˜¯å¦æ­£ç¢º');

                            this.isNodeEnvironment = false;
                            this.usePikafishAPI = false;
                            this.useHttpAPI = false;
                            this.useWASM = false;
                        }
                    }, 100);

                    this.isNodeEnvironment = false;
                    this.usePikafishAPI = false;
                    this.useHttpAPI = false;
                    this.useWASM = false;
                    return;
                }

                // âœ… å„ªå…ˆç´š 3: æª¢æ¸¬ WASM å¼•æ“ (ç€è¦½å™¨ + WASM) ğŸ”¥ æ–°å¢
                // âœ… å„ªå…ˆç´š 3: æª¢æ¸¬ WASM å¼•æ“ (ç€è¦½å™¨ + WASM) ğŸ”¥ æ–°å¢
                if (window.pikafishReady || this.checkWASMFiles()) {
                    console.log('ğŸ”§ é‹è¡Œæ¨¡å¼: ç€è¦½å™¨ (WASM å¼•æ“)');
                    console.log('âœ… æª¢æ¸¬åˆ° WASM ç’°å¢ƒï¼Œä½¿ç”¨ Pikafish WASM');
                    this.useWASM = true;
                    this.isNodeEnvironment = false;
                    this.usePikafishAPI = false;
                    this.useHttpAPI = false;
                    return;
                }

                // âœ… å„ªå…ˆç´š 4: ç´”ç€è¦½å™¨ç’°å¢ƒï¼ˆç„¡å¼•æ“ï¼‰
                console.log('ğŸ”§ é‹è¡Œæ¨¡å¼: ç€è¦½å™¨ (ç„¡å¼•æ“æ”¯æ´)');
                console.log('â„¹ï¸ å°‡ä»¥é›™äººå°æˆ°æ¨¡å¼é‹è¡Œ');
                this.isNodeEnvironment = false;
                this.usePikafishAPI = false;
                this.useHttpAPI = false;
                this.useWASM = false;

            } catch (error) {
                console.error('âŒ ç’°å¢ƒåˆå§‹åŒ–å¤±æ•—:', error);
                this.isNodeEnvironment = false;
                this.usePikafishAPI = false;
                this.useHttpAPI = false;
                this.useWASM = false;
            }
        }

        // ============================================
// ğŸ”¥ æ”¹é€²: checkWASMFiles()
// ============================================
        checkWASMFiles() {
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰ Module ç‰©ä»¶
            if (typeof Module !== 'undefined') {
                console.log('âœ… æª¢æ¸¬åˆ° WASM Module ç‰©ä»¶');
                return true;
            }

            // æª¢æŸ¥ script æ¨™ç±¤
            const scripts = document.getElementsByTagName('script');
            for (let script of scripts) {
                if (script.src && (
                    script.src.includes('pikafish.js') ||
                    script.src.includes('pikafish.wasm')
                )) {
                    console.log('âœ… æ‰¾åˆ° Pikafish WASM æª”æ¡ˆ:', script.src);
                    return true;
                }
            }

            // æª¢æŸ¥æ˜¯å¦æœ‰ .wasm æª”æ¡ˆåœ¨åŒç›®éŒ„
            console.log('ğŸ” å˜—è©¦æª¢æ¸¬ pikafish.wasm...');
            return false;
        }

        /**
         * æª¢æŸ¥ AI æ˜¯å¦å°±ç·’
         */
        isAIReady() {
            const ready = this.isReady || (this.engine && this.engine.isReady);
            console.log('ğŸ” AI å°±ç·’ç‹€æ…‹:', {
                isReadyFlag: this.isReady,
                engineReady: this.engine?.isReady,
                finalResult: ready
            });
            return ready;
        }

        setCurrentMode(mode) {
            this.gameMode = mode;
            console.log(`ğŸ”§ [MODE] AIå¼•æ“æ¥æ”¶åˆ° gameMode:`, mode);
        }

        /**
         * å®Œæ•´çš„äº‹ä»¶ç³»çµ±å¯¦ç¾
         */
        once(event, callback) {
            if (!this.eventListeners) this.eventListeners = {};
            if (!this.eventListeners[event]) this.eventListeners[event] = [];

            const onceCallback = (...args) => {
                callback(...args);
                this.off(event, onceCallback);
            };

            this.eventListeners[event].push(onceCallback);
        }

        emit(event, ...args) {
            if (this.eventListeners && this.eventListeners[event]) {
                const listeners = [...this.eventListeners[event]];
                listeners.forEach(callback => {
                    try {
                        callback(...args);
                    } catch (error) {
                        console.error('äº‹ä»¶å›èª¿éŒ¯èª¤:', error);
                    }
                });
            }
        }

        off(event, callback) {
            if (this.eventListeners && this.eventListeners[event]) {
                const index = this.eventListeners[event].indexOf(callback);
                if (index > -1) {
                    this.eventListeners[event].splice(index, 1);
                }
            }
        }

        on(event, callback) {
            if (!this.eventListeners) this.eventListeners = {};
            if (!this.eventListeners[event]) this.eventListeners[event] = [];
            this.eventListeners[event].push(callback);
        }

        // ============================================
        // å®Œæ•´ä¿®æ”¹: initialize()
        // ============================================
        async initialize() {
            try {
                console.log('ğŸ¤– æ­£åœ¨åˆå§‹åŒ– AI å¼•æ“...');

                if (window.aiMonitor) {
                    window.aiMonitor.startMonitoring();
                }

                // âœ… æ ¹æ“šç’°å¢ƒé¸æ“‡åˆå§‹åŒ–æ–¹å¼
                if (this.usePikafishAPI) {
                    await this.initializeWithIPC();
                } else if (this.useWASM) {
                    await this.initializeWithWASM();  // ğŸ”¥ æ–°å¢
                } else {
                    console.log('â„¹ï¸ ç„¡å¯ç”¨ AI å¼•æ“ï¼Œå°‡ä»¥é›™äººå°æˆ°æ¨¡å¼é‹è¡Œ');
                    this.isReady = false;
                    this.noEngineMode = true;

                    if (window.aiMonitor) {
                        window.aiMonitor.showAIWarning('no_engine');
                    }

                    return false;
                }

                // åˆå§‹åŒ– UCI å”è­°
                await this.initializeUCI();
                this.isReady = true;

                console.log('âœ… è±¡æ£‹ AI å¼•æ“åˆå§‹åŒ–å®Œæˆï¼');

                if (window.aiMonitor) {
                    window.aiMonitor.markCheckpoint('engineInitComplete');
                }

                return true;
            } catch (error) {
                console.error('âŒ AI å¼•æ“åˆå§‹åŒ–å¤±æ•—:', error);

                if (window.aiMonitor) {
                    window.aiMonitor.showAIWarning('error');
                }

                return false;
            }
        }




        /**
         * ä½¿ç”¨ HTTP API åˆå§‹åŒ–ï¼ˆç€è¦½å™¨é–‹ç™¼æ¨¡å¼ï¼‰
         */
        async initializeWithHTTP() {
            try {
                console.log('ğŸŒ ä½¿ç”¨ HTTP API åˆå§‹åŒ–å¼•æ“...');

                // å˜—è©¦é€£æ¥åˆ°å¾Œç«¯æœå‹™å™¨
                const response = await fetch('http://localhost:3001/api/xiangqi/initialize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        enginePath: this.pikafishPath
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP åˆå§‹åŒ–å¤±æ•—: ${response.status}`);
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'API åˆå§‹åŒ–å¤±æ•—');
                }

                this.apiSessionId = result.sessionId;
                console.log('âœ… HTTP API é€£æ¥æˆåŠŸï¼Œæœƒè©±ID:', this.apiSessionId);

                // è¨­ç½®è¼ªè©¢ä¾†æ¥æ”¶å¼•æ“æ¶ˆæ¯
                this.startMessagePolling();

                if (window.aiMonitor) {
                    window.aiMonitor.markCheckpoint('apiConnected');
                }

            } catch (error) {
                console.error('HTTP API åˆå§‹åŒ–å¤±æ•—:', error);
                throw new Error('ç„¡æ³•é€£æ¥åˆ°å¾Œç«¯å¼•æ“æœå‹™ï¼Œè«‹ç¢ºä¿ server.js æ­£åœ¨é‹è¡Œ (node server.js)');
            }
        }

        /**
         * é–‹å§‹è¼ªè©¢å¼•æ“æ¶ˆæ¯
         */
        startMessagePolling() {
            // é€™è£¡æš«æ™‚ä¸éœ€è¦ï¼Œå› ç‚ºä½ çš„ server.js åœ¨ command API ä¸­æœƒè¿”å›è¼¸å‡º
            console.log('ğŸ“¡ HTTP API æ¨¡å¼å°±ç·’');
        }

        // ğŸ”¥ ä¿®æ­£ IPC åˆå§‹åŒ–æ–¹æ³•
        async initializeWithIPC() {
            console.log('ğŸ“¦ ä½¿ç”¨ IPC API å•Ÿå‹•å¼•æ“...');

            // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ window.pikafishï¼ˆä¸æ˜¯ pikafishAPIï¼‰
            if (!window.pikafish) {
                throw new Error('window.pikafish ä¸å­˜åœ¨');
            }

            const result = await window.pikafish.start();

            if (!result.success) {
                throw new Error(result.error || 'å¼•æ“å•Ÿå‹•å¤±æ•—');
            }

            console.log('âœ… Pikafish é€²ç¨‹å•Ÿå‹•æˆåŠŸ (IPC)');

            // ç›£è½å¼•æ“è¼¸å‡º
            window.pikafish.onMessage((message) => {
                this.handleEngineMessage(message);
            });

            // ç›£è½å¼•æ“é€€å‡º
            window.pikafish.onExit((code) => {
                console.log(`âš ï¸ Pikafish é€²ç¨‹é€€å‡ºï¼Œä»£ç¢¼: ${code}`);
                this.isReady = false;
                if (window.aiMonitor) {
                    window.aiMonitor.showAIWarning('not_working');
                }
            });

            // ç›£è½å¼•æ“éŒ¯èª¤
            window.pikafish.onError((error) => {
                console.error('âŒ Pikafish éŒ¯èª¤:', error);
                this.isReady = false;
            });

            if (window.aiMonitor) {
                window.aiMonitor.markCheckpoint('apiConnected');
            }
        }

        /**
         * ä½¿ç”¨ spawn ç›´æ¥å•Ÿå‹•å¼•æ“ï¼ˆé–‹ç™¼/æ¸¬è©¦ç‰ˆï¼‰
         */
        async initializeWithSpawn() {
            return new Promise((resolve, reject) => {
                try {
                    console.log('ğŸ”§ ä½¿ç”¨ spawn å•Ÿå‹•å¼•æ“:', this.pikafishPath);

                    // æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    const fs = require('fs');
                    if (!fs.existsSync(this.pikafishPath)) {
                        throw new Error(`Pikafish å¼•æ“æ–‡ä»¶ä¸å­˜åœ¨: ${this.pikafishPath}`);
                    }

                    // å•Ÿå‹•é€²ç¨‹
                    this.engineProcess = this.spawn(this.pikafishPath, [], {
                        stdio: ['pipe', 'pipe', 'pipe']
                    });

                    // è¨­ç½®è¼¸å…¥è¼¸å‡º
                    this.engineInput = this.engineProcess.stdin;
                    this.engineOutput = this.readline.createInterface({
                        input: this.engineProcess.stdout
                    });

                    // ç›£è½è¼¸å‡º
                    this.engineOutput.on('line', (line) => {
                        this.handleEngineMessage(line);
                    });

                    // ç›£è½éŒ¯èª¤
                    this.engineProcess.stderr.on('data', (data) => {
                        console.log('Pikafish èª¿è©¦ä¿¡æ¯:', data.toString().trim());
                    });

                    // ç›£è½é€²ç¨‹é€€å‡º
                    this.engineProcess.on('exit', (code) => {
                        console.log(`Pikafish é€²ç¨‹é€€å‡ºï¼Œä»£ç¢¼: ${code}`);
                        this.isReady = false;
                    });

                    // ç›£è½éŒ¯èª¤
                    this.engineProcess.on('error', (error) => {
                        console.error('Pikafish é€²ç¨‹éŒ¯èª¤:', error);
                        reject(error);
                    });

                    // ç­‰å¾…é€²ç¨‹å•Ÿå‹•
                    setTimeout(() => {
                        if (this.engineProcess && !this.engineProcess.killed) {
                            console.log('âœ… Pikafish é€²ç¨‹å•Ÿå‹•æˆåŠŸ (spawn)');
                            resolve();
                        } else {
                            reject(new Error('Pikafish é€²ç¨‹å•Ÿå‹•å¤±æ•—'));
                        }
                    }, 2000);

                } catch (error) {
                    console.error('å•Ÿå‹• Pikafish é€²ç¨‹å¤±æ•—:', error);
                    reject(error);
                }
            });
        }

        // ============================================
        // ğŸ”¥ å®Œæ•´ç‰ˆ: handleEngineMessage() - é˜²æ­¢æ­»å¾ªç’°
        // ============================================
        handleEngineMessage(message) {
            const msgStr = String(message).trim();

            // ğŸ”¥ éæ¿¾ç©ºè¨Šæ¯
            if (!msgStr) return;

            console.log('ğŸ“¥ å¼•æ“è¨Šæ¯:', msgStr);

            try {
                // ============================================
                // 1. è™•ç†å¼•æ“è­˜åˆ¥è¨Šæ¯
                // ============================================
                if (msgStr.includes('id name Pikafish')) {
                    console.log('âœ… å¼•æ“å·²è­˜åˆ¥: Pikafish');
                    if (window.aiMonitor) {
                        window.aiMonitor.markCheckpoint('engineIdentified');
                    }
                }

                // ============================================
                // 2. è™•ç† UCI é€šä¿¡è¨Šæ¯
                // ============================================
                if (msgStr.includes('uciok')) {
                    console.log('âœ… æ”¶åˆ° uciok');
                    this.emit('uciok');
                    if (window.aiMonitor) {
                        window.aiMonitor.markCheckpoint('uciOkReceived');
                    }
                    return;
                }

                if (msgStr.includes('readyok')) {
                    console.log('âœ… æ”¶åˆ° readyok');
                    this.emit('readyok');
                    if (window.aiMonitor) {
                        window.aiMonitor.markCheckpoint('readyOkReceived');
                    }
                    return;
                }

                // ============================================
                // 3. è™•ç† MultiPV è¨Šæ¯
                // ============================================
                if (msgStr.includes('info') && msgStr.includes('multipv')) {
                    this.handleMultiPVInfo(msgStr);
                }

                // ============================================
                // 4. è™•ç†åˆ†æ•¸è¨Šæ¯ (CP æˆ– Mate)
                // ============================================
                if (msgStr.includes('score cp') || msgStr.includes('score mate')) {
                    this.processScoreMessage(msgStr);
                }

                // ============================================
                // 5. è™•ç†æœç´¢æ·±åº¦è¨Šæ¯
                // ============================================
                if (msgStr.includes('info depth')) {
                    const depthMatch = msgStr.match(/depth (\d+)/);
                    if (depthMatch) {
                        const depth = parseInt(depthMatch[1]);
                        console.log(`ğŸ” æœç´¢æ·±åº¦: ${depth}`);
                        this.emit('depth', depth);
                    }
                }

                // ============================================
                // 6. è™•ç† bestmove è¨Šæ¯ï¼ˆæœ€é‡è¦ï¼‰
                // ============================================
                if (msgStr.includes('bestmove')) {
                    console.log('ğŸ“Œ æ”¶åˆ° bestmove å®Œæ•´è¨Šæ¯:', msgStr);

                    const match = msgStr.match(/bestmove\s+(\S+)/);

                    if (match) {
                        let move = match[1];

                        // ğŸ”¥ å»¶é²è™•ç†ï¼Œç¢ºä¿æ‰€æœ‰ MultiPV éƒ½æ”¶é›†å®Œæˆ
                        setTimeout(() => {
                            if (move === '(none)' || move === 'none') {
                                console.log('âš ï¸ å¼•æ“è¿”å› none - ç„¡åˆæ³•ç§»å‹•');

                                // åˆ¤æ–·ç•¶å‰ç©å®¶
                                const isRedTurn = this.getCurrentPlayer ? this.getCurrentPlayer() : true;
                                const checkmateScore = isRedTurn ? -10000 : 10000;

                                console.log(`${isRedTurn ? 'ç´…æ–¹' : 'é»‘æ–¹'}è¢«å°‡æ­»ï¼Œåˆ†æ•¸: ${checkmateScore}`);

                                // æ›´æ–°åˆ†æ•¸
                                this.latestCpScore = checkmateScore;
                                this.cpScoreHistory.push({
                                    score: checkmateScore,
                                    perspective: isRedTurn ? 'black' : 'red',
                                    timestamp: Date.now(),
                                    message: `bestmove none - ${isRedTurn ? 'ç´…æ–¹' : 'é»‘æ–¹'}è¢«å°‡æ­»`,
                                    isMate: true,
                                    mateSteps: 0,
                                    isCheckmatePosition: true
                                });

                                // ç™¼é€äº‹ä»¶
                                this.emit('cpscore', checkmateScore, msgStr, isRedTurn ? 'black' : 'red', true, 0);
                                this.emit('bestmove', 'CHECKMATE', msgStr);

                            } else {
                                console.log('âœ… è§£æå‡ºæœ€ä½³ç§»å‹•:', move);
                                console.log(`ğŸ“Š æ”¶é›†åˆ° ${this.multiPVResults.length} å€‹ MultiPV çµæœ`);

                                // ç™¼é€ bestmove äº‹ä»¶ï¼ˆåŒ…å« MultiPV çµæœï¼‰
                                if (this.multiPVResults.length > 0) {
                                    this.emit('bestmove', move, msgStr, this.multiPVResults);
                                    // æ¸…ç©º MultiPV çµæœ
                                    this.multiPVResults = [];
                                } else {
                                    this.emit('bestmove', move, msgStr);
                                }
                            }
                        }, 200); // ğŸ”¥ ç­‰å¾… 200ms ç¢ºä¿æ‰€æœ‰ MultiPV éƒ½æ”¶åˆ°

                    } else {
                        console.warn('âš ï¸ ç„¡æ³•è§£æ bestmove:', msgStr);
                        this.emit('bestmove', 'none', msgStr);
                    }

                    return;
                }

                // ============================================
                // 7. è™•ç†å¼•æ“é¸é …è¨Šæ¯
                // ============================================
                if (msgStr.includes('option name')) {
                    console.log('âš™ï¸ å¼•æ“é¸é …:', msgStr);
                }

                // ============================================
                // 8. è™•ç†ç¯€é»æ•¸è¨Šæ¯
                // ============================================
                if (msgStr.includes('nodes')) {
                    const nodesMatch = msgStr.match(/nodes (\d+)/);
                    if (nodesMatch) {
                        const nodes = parseInt(nodesMatch[1]);
                        this.emit('nodes', nodes);
                    }
                }

                // ============================================
                // 9. è™•ç†æ™‚é–“è¨Šæ¯
                // ============================================
                if (msgStr.includes('time')) {
                    const timeMatch = msgStr.match(/time (\d+)/);
                    if (timeMatch) {
                        const time = parseInt(timeMatch[1]);
                        this.emit('time', time);
                    }
                }

                // ============================================
                // 10. è™•ç† PV åºåˆ—è¨Šæ¯
                // ============================================
                if (msgStr.includes('pv') && !msgStr.includes('multipv')) {
                    const pvMatch = msgStr.match(/pv\s+(.+)$/);
                    if (pvMatch) {
                        const pvMoves = pvMatch[1].split(/\s+/);
                        this.emit('pv', pvMoves);
                    }
                }

            } catch (error) {
                console.error('âŒ è™•ç†å¼•æ“è¨Šæ¯å¤±æ•—:', error);
                console.error('  è¨Šæ¯å…§å®¹:', msgStr);
            }
        }
        // ============================================
// ä¿®å¤ 2ï¼šæ”¹è¿›æ·±åº¦è¿‡æ»¤é€»è¾‘ï¼ˆæ¯ä¸ª PV ç‹¬ç«‹è¿½è¸ªï¼‰
// ============================================

        // ============================================
// ä¿®å¤ 3ï¼šä¿®æ”¹ handleMultiPVInfo æ·»åŠ ä¼šè¯ ID
// ============================================

        handleMultiPVInfo(msgStr) {
            try {
                const multipvMatch = msgStr.match(/multipv (\d+)/);
                if (!multipvMatch) return;
                const pvIndex = parseInt(multipvMatch[1]);

                const depthMatch = msgStr.match(/depth (\d+)/);
                const depth = depthMatch ? parseInt(depthMatch[1]) : 0;

                // ä¸ºæ¯ä¸ª PV ç´¢å¼•ç‹¬ç«‹è¿½è¸ªæœ€é«˜æ·±åº¦
                if (!this.pvMaxDepths) this.pvMaxDepths = {};

                const currentMaxDepth = this.pvMaxDepths[pvIndex] || 0;

                if (depth >= currentMaxDepth) {
                    if (depth > currentMaxDepth) {
                        console.log(`ğŸ“Š MultiPV ${pvIndex} æ›´æ–°æ·±åº¦: ${currentMaxDepth} -> ${depth}`);
                        this.pvMaxDepths[pvIndex] = depth;
                    }
                } else {
                    console.log(`â­ï¸ MultiPV ${pvIndex} å¿½ç•¥æ—§æ·±åº¦ ${depth} (å½“å‰: ${currentMaxDepth})`);
                    return;
                }

                // è§£æ PV åºåˆ—
                const pvMatch = msgStr.match(/\spv\s+([a-i][0-9][a-i][0-9][qrbnk]?\s*)+/);
                if (!pvMatch) {
                    console.warn('âš ï¸ æ— æ³•åŒ¹é… PV èµ°æ³•:', msgStr);
                    return;
                }

                const pvString = pvMatch[0].replace(/\spv\s+/, '').trim();
                const pvMoves = pvString.split(/\s+/).filter(m => /^[a-i][0-9][a-i][0-9][qrbnk]?$/.test(m));

                if (pvMoves.length === 0) {
                    console.warn('âš ï¸ æ²¡æœ‰æœ‰æ•ˆçš„ PV èµ°æ³•');
                    return;
                }

                const firstMove = pvMoves[0];

                // è§£æåˆ†æ•°
                let score = null;
                const cpMatch = msgStr.match(/score cp (-?\d+)/);
                const mateMatch = msgStr.match(/score mate (-?\d+)/);

                if (cpMatch) {
                    score = parseInt(cpMatch[1]);
                } else if (mateMatch) {
                    const mateSteps = parseInt(mateMatch[1]);
                    score = mateSteps > 0 ? 9999 - mateSteps : -9999 + Math.abs(mateSteps);
                }

                console.log(`ğŸ“Š MultiPV ${pvIndex} (æ·±åº¦${depth}, ä¼šè¯#${this.currentSessionId}): ${firstMove} (åˆ†æ•¸: ${score})`);

                // ğŸ”¥ å­˜å‚¨ç»“æœæ—¶æ·»åŠ ä¼šè¯ ID
                const result = {
                    index: pvIndex,
                    move: firstMove,
                    score: score,
                    depth: depth,
                    pv: pvMoves,
                    raw: msgStr,
                    sessionId: this.currentSessionId,  // ğŸ”¥ æ ‡è®°ä¼šè¯ ID
                    timestamp: Date.now()
                };

                // æŒ‰ index æ›´æ–°æˆ–æ–°å¢
                const existingIndex = this.multiPVResults.findIndex(r => r.index === pvIndex);
                if (existingIndex >= 0) {
                    this.multiPVResults[existingIndex] = result;
                    console.log(`âœ… æ›´æ–° MultiPV ${pvIndex}: ${firstMove}`);
                } else {
                    this.multiPVResults.push(result);
                    console.log(`âœ… æ–°å¢ MultiPV ${pvIndex}: ${firstMove}`);
                }

                // æ’åº
                this.multiPVResults.sort((a, b) => a.index - b.index);

                console.log(`ğŸ“Š å½“å‰æ”¶é›†: ${this.multiPVResults.length} ä¸ª (ä¼šè¯#${this.currentSessionId})`);

            } catch (error) {
                console.error('è§£æ MultiPV è¨Šæ¯å¤±æ•—:', error);
            }
        }


        // ============================================
        // ğŸ”¥ ä¿®å¾©: initializeUCI() - æ·»åŠ è¶…æ™‚ä¿è­·
        // ============================================
        async initializeUCI() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.error('âŒ UCI åˆå§‹åŒ–è¶…æ™‚ (15ç§’)');
                    reject(new Error('UCI åˆå§‹åŒ–è¶…æ™‚'));
                }, 15000);

                try {
                    console.log('ğŸ”§ åˆå§‹åŒ– UCI é€šä¿¡...');

                    // ğŸ”¥ è¨»å†Šç›£è½å™¨ï¼ˆå¸¶è¶…æ™‚ä¿è­·ï¼‰
                    let uciOkReceived = false;
                    let readyOkReceived = false;

                    const uciOkHandler = () => {
                        if (uciOkReceived) return;
                        uciOkReceived = true;

                        console.log('âœ… æ”¶åˆ° uciok');

                        // ğŸ”¥ å»¶é²ç™¼é€å¾ŒçºŒå‘½ä»¤
                        setTimeout(() => {
                            this.sendCommand('setoption name UCI_Variant value xiangqi');
                            this.sendCommand('setoption name Threads value 1');
                            this.sendCommand('isready');
                        }, 100);
                    };

                    const readyOkHandler = () => {
                        if (readyOkReceived) return;
                        readyOkReceived = true;

                        console.log('âœ… æ”¶åˆ° readyok');
                        clearTimeout(timeout);
                        this.off('uciok', uciOkHandler);
                        this.off('readyok', readyOkHandler);
                        resolve();
                    };

                    this.once('uciok', uciOkHandler);
                    this.once('readyok', readyOkHandler);

                    // ğŸ”¥ å»¶é²ç™¼é€ uci å‘½ä»¤
                    setTimeout(() => {
                        console.log('ğŸ“¤ ç™¼é€ uci å‘½ä»¤');
                        this.sendCommand('uci');
                    }, 500);

                } catch (error) {
                    clearTimeout(timeout);
                    console.error('âŒ UCI åˆå§‹åŒ–å¤±æ•—:', error);
                    reject(error);
                }
            });
        }

        // ============================================
        // ğŸ”¥ ä¿®å¾©: initializeWithWASM() - é˜²æ­¢å¡æ­»
        // ============================================
        async initializeWithWASM() {
            // ğŸ”¥ é˜²æ­¢é‡è¤‡åˆå§‹åŒ–
            if (this.wasmInitializing) {
                console.log('â³ WASM æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œç­‰å¾…å®Œæˆ...');
                return this.wasmInitPromise;
            }

            this.wasmInitializing = true;

            this.wasmInitPromise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.error('âŒ WASM åˆå§‹åŒ–è¶…æ™‚ (30ç§’)');
                    this.wasmInitializing = false;
                    reject(new Error('WASM åˆå§‹åŒ–è¶…æ™‚'));
                }, 30000);

                try {
                    console.log('ğŸŒ é–‹å§‹ WASM å¼•æ“åˆå§‹åŒ–...');

                    // ğŸ”¥ æƒ…æ³ 1: WASM å·²ç¶“å®Œå…¨å°±ç·’
                    if (window.pikafishReady === true && typeof Module !== 'undefined') {
                        console.log('âœ… WASM å·²å°±ç·’ï¼Œç›´æ¥ä½¿ç”¨');
                        clearTimeout(timeout);
                        this.wasmModule = Module;
                        this.wasmReady = true;
                        this.wasmInitializing = false;
                        this.setupWASMHandlers();
                        this.processBufferedMessages();
                        resolve();
                        return;
                    }

                    // ğŸ”¥ æƒ…æ³ 2: Module å­˜åœ¨ä½†æœªå®Œå…¨åˆå§‹åŒ–
                    if (typeof Module !== 'undefined' && typeof Module.sendCommand === 'function') {
                        console.log('âœ… Module å­˜åœ¨ä¸”å¯ç”¨');
                        clearTimeout(timeout);
                        this.wasmModule = Module;
                        this.wasmReady = true;
                        this.wasmInitializing = false;
                        this.setupWASMHandlers();
                        this.processBufferedMessages();
                        resolve();
                        return;
                    }

                    // ğŸ”¥ æƒ…æ³ 3: ç­‰å¾… pikafish-ready äº‹ä»¶
                    console.log('â³ ç­‰å¾… pikafish-ready äº‹ä»¶...');

                    const onReady = (event) => {
                        console.log('ğŸ‰ æ”¶åˆ° pikafish-ready äº‹ä»¶');
                        clearTimeout(timeout);
                        window.removeEventListener('pikafish-ready', onReady);

                        this.wasmModule = Module;
                        this.wasmReady = true;
                        this.wasmInitializing = false;
                        this.setupWASMHandlers();
                        this.processBufferedMessages();

                        if (window.aiMonitor) {
                            window.aiMonitor.markCheckpoint('wasmEngineReady');
                        }

                        resolve();
                    };

                    window.addEventListener('pikafish-ready', onReady);

                } catch (error) {
                    clearTimeout(timeout);
                    this.wasmInitializing = false;
                    console.error('âŒ WASM åˆå§‹åŒ–ç•°å¸¸:', error);
                    reject(error);
                }
            });

            return this.wasmInitPromise;
        }

        // ============================================
        // ğŸ”¥ æ–°å¢: è™•ç†æš«å­˜è¨Šæ¯ï¼ˆéé˜»å¡ï¼‰
        // ============================================
        processBufferedMessages() {
            if (!window.pikafishMessageBuffer || window.pikafishMessageBuffer.length === 0) {
                return;
            }

            console.log(`ğŸ“¬ è™•ç† ${window.pikafishMessageBuffer.length} æ¢æš«å­˜è¨Šæ¯`);

            // ğŸ”¥ ä½¿ç”¨ setTimeout é¿å…é˜»å¡
            const messages = [...window.pikafishMessageBuffer];
            window.pikafishMessageBuffer = [];

            setTimeout(() => {
                messages.forEach(msg => {
                    try {
                        this.handleEngineMessage(msg);
                    } catch (error) {
                        console.error('âŒ è™•ç†æš«å­˜è¨Šæ¯å¤±æ•—:', error);
                    }
                });
            }, 100);
        }


// ============================================
// ğŸ”¥ ä¿®æ”¹: setupWASMHandlers()
// ============================================
        setupWASMHandlers() {
            if (!this.wasmModule) {
                console.error('âŒ wasmModule ä¸å­˜åœ¨');
                return;
            }

            console.log('âœ… WASM è™•ç†å™¨è¨­ç½®å®Œæˆ');
            console.log('å¯ç”¨æ–¹æ³•:', {
                sendCommand: typeof this.wasmModule.sendCommand,
                terminate: typeof this.wasmModule.terminate
            });
        }

        // ============================================
        // ğŸ”¥ ä¿®å¾©: sendCommand() - é˜²æ­¢å¡æ­»
        // ============================================
        async sendCommand(command) {
            try {
                console.log('ğŸ“¤ ç™¼é€æŒ‡ä»¤:', command);

                // IPC æ¨¡å¼
                if (this.usePikafishAPI && window.pikafish) {
                    const result = await window.pikafish.send(command);
                    if (!result.success) {
                        throw new Error(result.error || 'å‘½ä»¤ç™¼é€å¤±æ•—');
                    }
                    return;
                }

                // WASM æ¨¡å¼
                if (this.useWASM) {
                    // ğŸ”¥ ç­‰å¾… WASM å®Œå…¨å°±ç·’
                    if (this.wasmInitializing) {
                        console.log('â³ WASM æ­£åœ¨åˆå§‹åŒ–ï¼Œç­‰å¾…å®Œæˆ...');
                        await this.wasmInitPromise;
                    }

                    if (!this.wasmReady || !this.wasmModule) {
                        throw new Error('WASM å¼•æ“æœªå°±ç·’');
                    }

                    // ğŸ”¥ ä½¿ç”¨ setTimeout é¿å…é˜»å¡
                    return new Promise((resolve, reject) => {
                        setTimeout(() => {
                            try {
                                if (typeof this.wasmModule.sendCommand === 'function') {
                                    this.wasmModule.sendCommand(command);
                                    console.log('âœ… WASM å‘½ä»¤ç™¼é€æˆåŠŸ');
                                    resolve();
                                } else if (typeof this.wasmModule.stdin === 'function') {
                                    this.wasmModule.stdin(command + '\n');
                                    console.log('âœ… WASM stdin ç™¼é€æˆåŠŸ');
                                    resolve();
                                } else {
                                    reject(new Error('æ‰¾ä¸åˆ°å¯ç”¨çš„ WASM ç™¼é€æ–¹æ³•'));
                                }
                            } catch (error) {
                                console.error('âŒ WASM ç™¼é€å¤±æ•—:', error);
                                reject(error);
                            }
                        }, 0);
                    });
                }

                // Spawn æ¨¡å¼
                if (this.engineInput) {
                    this.engineInput.write(command + '\n');
                    return;
                }

                // ç„¡å¼•æ“æ¨¡å¼
                if (this.noEngineMode) {
                    console.log('â„¹ï¸ ç„¡å¼•æ“æ¨¡å¼ï¼Œå‘½ä»¤è¢«å¿½ç•¥');
                    return;
                }

                throw new Error('ç„¡å¯ç”¨çš„å‘½ä»¤ç™¼é€æ–¹å¼');

            } catch (error) {
                console.error('âŒ ç™¼é€æŒ‡ä»¤å¤±æ•—:', error);
                throw error;
            }
        }


// ğŸ”¥ ä¿®æ­£é—œé–‰æ–¹æ³•
        async close() {
            if (this.usePikafishAPI && window.pikafish) {
                await window.pikafish.stop();
            } else if (this.useWASM && this.wasmReady) {
                // ğŸ”¥ æ–°å¢: WASM æ¸…ç†
                console.log('ğŸ§¹ æ¸…ç† WASM è³‡æº');
                if (this.wasmModule) {
                    try {
                        this.wasmModule.ccall('uci_command', 'void', ['string'], ['quit']);
                    } catch (e) {
                        console.warn('WASM quit å‘½ä»¤å¤±æ•—:', e);
                    }
                }
                this.wasmReady = false;
                this.wasmModule = null;
            } else if (this.engineProcess) {
                this.sendCommand('quit');
                this.engineProcess.kill();
            }
        }

        /**
         * è™•ç†åˆ†æ•¸è¨Šæ¯(CPåˆ†æ•¸æˆ–mateåˆ†æ•¸)
         */
        processScoreMessage(msgStr) {
            let cpScore = null;
            let isMate = false;
            let mateSteps = null;

            const mateMatch = msgStr.match(/score mate (-?\d+)/);
            if (mateMatch) {
                mateSteps = parseInt(mateMatch[1]);
                isMate = true;

                if (mateSteps === 0) {
                    const getCurrentPlayer = this.getCurrentPlayer();

                    if (getCurrentPlayer) {
                        cpScore = -10000;
                        console.log('âš ï¸ æª¢æ¸¬åˆ° mate 0(ç´…æ–¹è¢«å°‡æ­»),è½‰æ›ç‚º CP -10000');
                    } else {
                        cpScore = 10000;
                        console.log('âš ï¸ æª¢æ¸¬åˆ° mate 0(é»‘æ–¹è¢«å°‡æ­»),è½‰æ›ç‚º CP +10000');
                    }
                } else if (mateSteps > 0) {
                    cpScore = 9999 - mateSteps;
                    console.log(`è½‰æ› mate ${mateSteps} â†’ CP ${cpScore}(${mateSteps}æ­¥å¾Œå°‡æ­»)`);
                } else {
                    cpScore = -9999 + Math.abs(mateSteps);
                    console.log(`è½‰æ› mate ${mateSteps} â†’ CP ${cpScore}(å°æ‰‹${Math.abs(mateSteps)}æ­¥å¾Œå°‡æ­»æˆ‘)`);
                }
            } else {
                const cpMatch = msgStr.match(/score cp (-?\d+)/);
                if (cpMatch) {
                    cpScore = parseInt(cpMatch[1]);
                }
            }

            if (cpScore !== null) {
                const perspective = this.determineScorePerspective(cpScore, msgStr);

                const scoreRecord = {
                    score: cpScore,
                    perspective: perspective,
                    timestamp: Date.now(),
                    message: msgStr,
                    isMate: isMate,
                    mateSteps: mateSteps,
                    isCheckmatePosition: (mateSteps === 0)
                };

                this.latestCpScore = cpScore;
                this.cpScoreHistory.push(scoreRecord);
                console.log(`æ””æˆªåˆ° ${perspective} è¦–è§’çš„ CP åˆ†æ•¸: ${cpScore}${isMate ? `(mate ${mateSteps})` : ''}`);

                this.emit('cpscore', cpScore, msgStr, perspective, isMate, mateSteps);
            }
        }

        /**
         * ğŸ”¥ æ–°å¢: è¨­ç½® MultiPV å€¼
         */
        async setMultiPV(value) {
            if (value < 1 || value > 5) {
                console.warn('MultiPV å€¼å¿…é ˆåœ¨ 1-5 ä¹‹é–“');
                return false;
            }

            console.log(`ğŸ”§ è¨­ç½® MultiPV = ${value}`);
            this.currentMultiPV = value;

            try {
                await this.sendCommand(`setoption name MultiPV value ${value}`);
                await this.waitForReady(200);
                return true;
            } catch (error) {
                console.error('è¨­ç½® MultiPV å¤±æ•—:', error);
                return false;
            }
        }

        /**
         * ç²å–ç•¶å‰æ˜¯å¦ç‚ºç´…æ–¹å›åˆ
         */
        getCurrentPlayer() {
            if (this.historyManager) {
                const moveCount = this.historyManager.getHistoryLength();
                if (moveCount > 0) {
                    const isRedTurn = (moveCount % 2 === 1);
                    console.log(`ğŸ“ æ­·å²è¨˜éŒ„æ•¸: ${moveCount} â†’ ${isRedTurn ? 'ç´…æ–¹' : 'é»‘æ–¹'}å›åˆ`);
                    return isRedTurn;
                }
            }

            const fenString = this.board?.fen?.() ||
                this.board?.getFen?.() ||
                this.currentFen ||
                this.gameState?.fen;

            if (fenString) {
                const fenParts = fenString.split(' ');
                if (fenParts.length >= 2) {
                    const turnIndicator = fenParts[1];
                    const isRedTurn = (turnIndicator === 'r' || turnIndicator === 'w');
                    console.log(`ğŸ“ FENå›åˆæ¨™è¨˜: "${turnIndicator}" â†’ ${isRedTurn ? 'ç´…æ–¹' : 'é»‘æ–¹'}å›åˆ`);
                    return isRedTurn;
                }
            }

            console.warn('âš ï¸ ç„¡æ³•åˆ¤æ–·ç•¶å‰å›åˆï¼Œé è¨­ç‚ºç´…æ–¹');
            return true;
        }

        /**
         * åˆ¤æ–·åˆ†æ•¸è¦–è§’
         */
        determineScorePerspective(cpScore, msgStr) {
            if (!this.cpScoreHistory || this.cpScoreHistory.length === 0) {
                return 'ç´…æ–¹';
            }

            const recentScores = this.cpScoreHistory.slice(-2);
            const currentTime = Date.now();
            const timeThreshold = 1000;

            if (recentScores.length > 0) {
                const lastScore = recentScores[recentScores.length - 1];
                const timeDiff = currentTime - lastScore.timestamp;

                if (timeDiff < timeThreshold) {
                    if (recentScores.length === 1 ||
                        (recentScores.length === 2 && currentTime - recentScores[0].timestamp < timeThreshold * 2)) {
                        return 'ç´…æ–¹';
                    }
                }
            }

            if (this.lastPlayer === 'é»‘æ–¹') {
                const recentBlackScore = recentScores.find(score =>
                    score.perspective === 'é»‘æ–¹' &&
                    currentTime - score.timestamp < timeThreshold
                );

                if (recentBlackScore) {
                    return 'ç´…æ–¹';
                } else {
                    return 'é»‘æ–¹';
                }
            } else {
                const recentRedScore = recentScores.find(score =>
                    score.perspective === 'ç´…æ–¹' &&
                    currentTime - score.timestamp < timeThreshold
                );

                if (recentRedScore) {
                    return 'é»‘æ–¹';
                } else {
                    return 'ç´…æ–¹';
                }
            }
        }

        startCpCollectionForPosition(fenString) {
            this.currentPositionFen = fenString;
            this.isCollectingCpForPosition = true;

            if (!this.positionCpScores) this.positionCpScores = new Map();
            if (!this.positionCpScores.has(fenString)) {
                this.positionCpScores.set(fenString, []);
            }

            console.log(`å¼€å§‹æ”¶é›†å±€é¢CPåˆ†æ•°: ${fenString}`);
        }

        stopCpCollectionForPosition() {
            this.isCollectingCpForPosition = false;
            this.currentPositionFen = null;
        }

        getLatestCpScore() {
            return this.latestCpScore;
        }

        async waitForCpScore(timeoutMs = 3000) {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('ç­‰å¾… CP åˆ†æ•°è¶…æ—¶'));
                }, timeoutMs);

                if (this.latestCpScore !== null) {
                    clearTimeout(timeout);
                    resolve(this.latestCpScore);
                    return;
                }

                const handler = (cpScore) => {
                    clearTimeout(timeout);
                    resolve(cpScore);
                };

                this.once('cpscore', handler);
            });
        }


        /**
         * è·å–AIå°±ç»ªçŠ¶æ€çš„ä¾¿æ·æ–¹æ³•
         */
        getAIReadyState() {
            return {
                isReady: this.isReady,
                isThinking: this.isThinking,
                hasEngine: !!(this.engineProcess || this.apiSessionId)
            };
        }

        /**
         * å°ˆé–€ç”¨æ–¼åˆ†æçš„æ–¹æ³•ï¼ˆå§‹çµ‚ä½¿ç”¨15å±¤æ·±åº¦ï¼‰
         * åœ¨å°æˆ°ä¸­èª¿ç”¨é€™å€‹æ–¹æ³•ä¸æœƒå½±éŸ¿å°æˆ°æ¨¡å¼
         */
        async getAnalysisSuggestion(yourBoardArray) {
            // ä¿å­˜ç•¶å‰æ¨¡å¼
            const originalMode = this.analysisMode;

            try {
                // è‡¨æ™‚åˆ‡æ›åˆ°åˆ†ææ¨¡å¼
                this.analysisMode = 'analysis';
                console.log('è‡¨æ™‚åˆ‡æ›åˆ°åˆ†ææ¨¡å¼é€²è¡Œé«˜å“è³ªåˆ†æ...');

                // èª¿ç”¨åŸæœ‰çš„ getAISuggestion æ–¹æ³•
                const result = await this.getAISuggestion(yourBoardArray);

                // æ¨™è¨˜é€™æ˜¯åˆ†æçµæœ
                result.isAnalysis = true;
                result.analysisDepth = this.defaultAnalysisDepth;

                return result;

            } finally {
                // æ¢å¾©åŸä¾†çš„æ¨¡å¼
                this.analysisMode = originalMode;
                console.log(`æ¢å¾©åˆ°åŸæ¨¡å¼: ${originalMode}`);
            }
        }

        /**
         * å®Œæ•´çš„å¯¹æˆ˜æ¨¡å¼ä¿®å¤æ–¹æ¡ˆ
         * åŸºäºä½ æä¾›çš„ getAISuggestion ä»£ç åˆ†æ
         */

// 1. ä¿®å¤åçš„ getBattleMoveSuggestion æ–¹æ³•
        async getBattleMoveSuggestion(yourBoardArray, difficulty = null) {
            console.log(`ğŸ”§ [BATTLE] getBattleMoveSuggestion å¼€å§‹`);

            // ä¿å­˜åŸå§‹çŠ¶æ€
            const originalMode = this.analysisMode;
            const originalDifficulty = this.difficulty;

            // é˜²æ­¢å¹¶å‘è°ƒç”¨
            if (this.isThinking) {
                throw new Error('AI æ­£åœ¨æ€è€ƒä¸­ï¼Œè¯·ç­‰å¾…å½“å‰åˆ†æå®Œæˆ');
            }

            try {
                // è®¾ç½®å¯¹æˆ˜æ¨¡å¼
                if (difficulty) {
                    this.difficulty = difficulty;
                }
                this.analysisMode = 'battle';

                console.log(`ğŸ® [BATTLE] æ¨¡å¼è®¾ç½®å®Œæˆ - analysisMode: "${this.analysisMode}", difficulty: "${this.difficulty}"`);

                // **å…³é”®ä¿®å¤ï¼šç«‹å³éªŒè¯è®¾ç½®æ˜¯å¦ç”Ÿæ•ˆ**
                const verifyDepth = this.getContextualDepth();
                const expectedDepth = this.getDifficultyDepth();

                if (verifyDepth !== expectedDepth) {
                    console.error(`âŒ [BATTLE] æ·±åº¦è®¾ç½®å¤±è´¥! æœŸæœ›: ${expectedDepth}, å®é™…: ${verifyDepth}`);
                    console.error(`âŒ [BATTLE] å½“å‰çŠ¶æ€ - mode: "${this.analysisMode}", difficulty: "${this.difficulty}"`);

                    // å¼ºåˆ¶ä¿®å¤ï¼šç›´æ¥ä¼ é€’å‚æ•°
                    return await this.getAISuggestionWithBattleMode(yourBoardArray, this.difficulty);
                }

                console.log(`âœ… [BATTLE] æ·±åº¦éªŒè¯æˆåŠŸ: ${verifyDepth}`);

                const result = await this.getAISuggestion(yourBoardArray);

                // æ·»åŠ å¯¹æˆ˜æ ‡è¯†
                result.isBattleMove = true;
                result.battleDepth = expectedDepth;
                result.difficulty = this.difficulty;
                result.moveType = 'battle';

                return result;

            } finally {
                // æ¢å¤åŸå§‹çŠ¶æ€
                this.analysisMode = originalMode;
                this.difficulty = originalDifficulty;
                console.log(`ğŸ”„ [BATTLE] çŠ¶æ€å·²æ¢å¤`);
            }
        }

        // ============================================
// ğŸ”¥ ä¿®æ”¹ selectMoveByProbability æ–¹æ³•
// æ·»åŠ å°†å†›æ£€æµ‹é€»è¾‘
// ============================================


        /**
         * ğŸ”¥ è·å–é€‰æ‹©åŸå› çš„ä¸­æ–‡æè¿°ï¼ˆå¢å¼ºç‰ˆï¼‰
         */
        getSelectionReason(selectionType) {
            const reasons = {
                'best': 'æœ€ä½³æ‹›æ³•',
                'second': 'æ¬¡ä¼˜æ‹›æ³•',
                'third': 'ç¬¬ä¸‰é€‰æ‹›æ³•'
            };
            return reasons[selectionType] || 'æœªçŸ¥';
        }

// ============================================
// AI å¯¹æˆ˜å°†å†›æ£€æµ‹è¡¥ä¸
// åœ¨ CompleteXiangqiAI ç±»ä¸­æ·»åŠ ä»¥ä¸‹æ–¹æ³•
// ============================================

        /**
         * ğŸ”¥ æ£€æŸ¥æŒ‡å®šé¢œè‰²çš„å°†/å¸…æ˜¯å¦è¢«å°†å†›
         * @param {string} color - 'red' æˆ– 'black'
         * @param {Array} board - æ£‹ç›˜æ•°ç»„
         * @returns {boolean} true=è¢«å°†å†›, false=æœªè¢«å°†å†›
         */
        isKingInCheck(color, board = null) {
            const checkBoard = board || this.getCurrentBoard();

            // 1. æ‰¾åˆ°å·±æ–¹å°†/å¸…çš„ä½ç½®
            const kingPos = this.findKingPosition(color, checkBoard);

            if (!kingPos) {
                console.warn(`âš ï¸ æ‰¾ä¸åˆ°${color === 'red' ? 'çº¢æ–¹å¸…' : 'é»‘æ–¹å°†'}`);
                return false;
            }

            console.log(`ğŸ‘‘ æ£€æŸ¥${color === 'red' ? 'çº¢æ–¹å¸…' : 'é»‘æ–¹å°†'}ä½ç½®: (${kingPos.row}, ${kingPos.col})`);

            // 2. æ£€æŸ¥æ˜¯å¦è¢«å¯¹æ–¹æ”»å‡»
            const isUnderAttack = this.isPositionUnderAttack(
                kingPos.row,
                kingPos.col,
                color,
                checkBoard
            );

            if (isUnderAttack) {
                console.log(`âš ï¸ ${color === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹'}è¢«å°†å†›!`);
            }

            return isUnderAttack;
        }

        // ============================================
// ğŸ”¥ è±¡æ£‹ AI å°‡è»æª¢æ¸¬ä¿®å¾©æ–¹æ¡ˆ
// æ•´åˆç¾æœ‰çš„ isCheck é‚è¼¯åˆ° CompleteXiangqiAI é¡ä¸­
// ============================================

        /**
         * ğŸ”§ ä¿®å¾©æ­¥é©Ÿ 1ï¼šåœ¨ selectMoveByProbability ä¸­æ·»åŠ å®‰å…¨æª¢æŸ¥
         */
        selectMoveByProbability(multiPVResults, difficulty) {
            const config = AI_MOVE_SELECTION_CONFIG[difficulty];

            if (!config) {
                console.warn(`æœªçŸ¥éš¾åº¦: ${difficulty}ï¼Œä½¿ç”¨é»˜è®¤(medium)`);
                return this.selectMoveByProbability(multiPVResults, 'medium');
            }

            // å¤§å¸ˆéš¾åº¦æˆ–åªæœ‰ä¸€ä¸ªç»“æœæ—¶ï¼Œç›´æ¥è¿”å›æœ€ä½³æ‹›
            if (config.multipv === 1 || multiPVResults.length === 1) {
                return {
                    selectedMove: multiPVResults[0],
                    selectionType: 'best',
                    selectionIndex: 1,
                    probability: 1.0,
                    reason: 'æœ€ä½³æ‹›æ³•'
                };
            }

            // ğŸ”¥ å…³é”®ï¼šä½¿ç”¨ç°æœ‰çš„ isCheck å‡½æ•°æ£€æŸ¥æ˜¯å¦è¢«å°†å†›
            const aiColor = this.getCurrentAIColor();
            const board = this.getCurrentBoard();

            if (board && typeof isCheck === 'function' && isCheck(aiColor, board)) {
                console.log('ğŸš¨ AIè¢«å°†å†›ï¼å¼ºåˆ¶é€‰æ‹©æœ€ä½³æ‹›æ³•');

                return {
                    selectedMove: multiPVResults[0],
                    selectionType: 'best',
                    selectionIndex: 1,
                    probability: 1.0,
                    reason: 'è¢«å°†å†›ï¼Œå¼ºåˆ¶èµ°æœ€ä½³æ‹›',
                    isCheckResponse: true
                };
            }

            // åŸæœ‰çš„æœºç‡é€‰æ‹©é€»è¾‘...
            const availableChoices = Math.min(multiPVResults.length, 3);
            const sortedResults = [...multiPVResults].sort((a, b) => b.score - a.score);

            const random = Math.random();
            let cumulative = 0;
            let selectedIndex = 0;
            let selectionType = 'best';

            if (availableChoices >= 1) {
                cumulative += config.probabilities.first;
                if (random < cumulative) {
                    selectedIndex = 0;
                    selectionType = 'best';
                }
            }

            if (availableChoices >= 2 && selectedIndex === 0 && random >= config.probabilities.first) {
                cumulative += config.probabilities.second;
                if (random < cumulative) {
                    selectedIndex = 1;
                    selectionType = 'second';
                }
            }

            if (availableChoices >= 3 && selectedIndex === 0 &&
                random >= (config.probabilities.first + config.probabilities.second)) {
                selectedIndex = 2;
                selectionType = 'third';
            }

            const selectedMove = sortedResults[selectedIndex];

            console.log(`ğŸ² AIé€‰æ‹©èµ°æ³•: ${selectionType} (éšæœºæ•°: ${random.toFixed(3)}, ç´¢å¼•: ${selectedIndex + 1})`);
            console.log(`   æ‹›æ³•: ${selectedMove.move}, åˆ†æ•°: ${selectedMove.score}`);

            return {
                selectedMove: selectedMove,
                selectionType: selectionType,
                selectionIndex: selectedIndex + 1,
                probability: selectedIndex === 0 ? config.probabilities.first :
                    selectedIndex === 1 ? config.probabilities.second :
                        config.probabilities.third,
                reason: this.getSelectionReason(selectionType),
                isCheckResponse: false,
                allChoices: sortedResults.slice(0, 3).map((m, i) => ({
                    index: i + 1,
                    move: m.move,
                    score: m.score,
                    isSelected: i === selectedIndex
                }))
            };
        }

        /**
         * ğŸ”§ ä¿®å¾©æ­¥é©Ÿ 2ï¼šæ·»åŠ è¼”åŠ©æ–¹æ³•åˆ° CompleteXiangqiAI é¡
         */

        /**
         * ç²å–ç•¶å‰ AI çš„é¡è‰²
         */
        getCurrentAIColor() {
            // æ–¹æ³• 1: å¾ gameMode ç²å–
            if (this.gameMode && this.gameMode.aiColor) {
                return this.gameMode.aiColor;
            }

            // æ–¹æ³• 2: å¾ aiBattleManager ç²å–
            if (typeof aiBattleManager !== 'undefined' && aiBattleManager.aiColor) {
                return aiBattleManager.aiColor;
            }

            // æ–¹æ³• 3: å¾å…¨å±€è®Šé‡ç²å–
            if (typeof gameState !== 'undefined') {
                // AI é€šå¸¸æ˜¯èˆ‡ç•¶å‰ç©å®¶ç›¸åçš„é¡è‰²
                return gameState.currentTurn === 'red' ? 'black' : 'red';
            }

            console.warn('âš ï¸ ç„¡æ³•ç¢ºå®š AI é¡è‰²ï¼Œé»˜èªä½¿ç”¨é»‘æ–¹');
            return 'black';
        }


        /**
         * ğŸ”¥ è·å–å½“å‰æ£‹ç›˜çŠ¶æ€ï¼ˆå¦‚æœä½ çš„ä»£ç ä¸­è¿˜æ²¡æœ‰ï¼‰
         */
        getCurrentBoard() {
            // æ–¹æ³•1: ä»å…¨å±€å˜é‡è·å–
            if (typeof gameState !== 'undefined' && gameState.board) {
                return gameState.board;
            }

            // æ–¹æ³•2: ä» this.board è·å–
            if (this.board) {
                return this.board;
            }

            // æ–¹æ³•3: ä» AIBattleManager è·å–
            if (typeof aiBattleManager !== 'undefined' && aiBattleManager.getCurrentBoard) {
                return aiBattleManager.getCurrentBoard();
            }

            console.warn('âš ï¸ æ— æ³•è·å–å½“å‰æ£‹ç›˜çŠ¶æ€');
            return null;
        }

        /**
         * ğŸ”¥ æ‰¾åˆ°æŒ‡å®šé¢œè‰²å°†/å¸…çš„ä½ç½® (ä¿®æ­£ç‰ˆ)
         */
        findKingPosition(color, board = null) {
            const checkBoard = board || this.getCurrentBoard();
            const kingType = color === 'red' ? 'å¸¥' : 'å°‡';  // âœ… ä½¿ç”¨ç¹é«”å­—

            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = checkBoard[i][j];
                    if (piece && piece.type === kingType && piece.color === color) {
                        console.log(`âœ… æ‰¾åˆ°${color === 'red' ? 'ç´…æ–¹å¸¥' : 'é»‘æ–¹å°‡'}: (${i}, ${j})`);
                        return { row: i, col: j };
                    }
                }
            }

            console.warn(`âš ï¸ æ‰¾ä¸åˆ°${color === 'red' ? 'ç´…æ–¹å¸¥' : 'é»‘æ–¹å°‡'}`);
            return null;
        }

        /**
         * ğŸ”¥ æ£€æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦è¢«å¯¹æ–¹æ”»å‡»
         */
        isPositionUnderAttack(row, col, color, board) {
            const opponent = color === 'red' ? 'black' : 'red';

            // éå†æ‰€æœ‰å¯¹æ–¹æ£‹å­
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = board[i][j];
                    if (piece && piece.color === opponent) {
                        // æ£€æŸ¥è¿™ä¸ªå¯¹æ–¹æ£‹å­æ˜¯å¦èƒ½æ”»å‡»ç›®æ ‡ä½ç½®
                        if (this.canPieceAttack(i, j, row, col, piece, board)) {
                            console.log(`ğŸ¯ ${piece.type}(${i},${j}) æ­£åœ¨æ”»å‡» (${row},${col})`);
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * ğŸ”¥ æ£€æŸ¥æ£‹å­æ˜¯å¦èƒ½æ”»å‡»ç›®æ ‡ä½ç½®ï¼ˆç®€åŒ–ç‰ˆè§„åˆ™ï¼‰
         */
        canPieceAttack(fromRow, fromCol, toRow, toCol, piece, board) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch(piece.type) {
                case 'è»Š':
                case 'ä¿¥':
                    if (fromRow === toRow || fromCol === toCol) {
                        return this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                    }
                    return false;

                case 'é¦¬':
                case 'å‚Œ':
                    if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {
                        let blockRow, blockCol;
                        if (rowDiff === 2) {
                            blockRow = fromRow + (toRow > fromRow ? 1 : -1);
                            blockCol = fromCol;
                        } else {
                            blockRow = fromRow;
                            blockCol = fromCol + (toCol > fromCol ? 1 : -1);
                        }
                        return !board[blockRow][blockCol];
                    }
                    return false;

                case 'ç‚®':
                case 'åŒ…':
                case 'ç ²':
                    if (fromRow === toRow || fromCol === toCol) {
                        const between = this.countPiecesBetween(fromRow, fromCol, toRow, toCol, board);
                        return between === 1; // ç‚®å¿…é¡»éš”ä¸€å­
                    }
                    return false;

                case 'å…µ':
                case 'å’':
                    const isRed = piece.color === 'red';
                    const forward = isRed ? -1 : 1;
                    const crossedRiver = isRed ? fromRow <= 4 : fromRow >= 5;

                    // å‘å‰èµ°
                    if (toRow === fromRow + forward && toCol === fromCol) {
                        return true;
                    }
                    // è¿‡æ²³åå¯æ¨ªèµ°
                    if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) {
                        return true;
                    }
                    return false;

                case 'å°‡':
                case 'å¸¥':
                    // 1. ä¹å®«æ ¼å†…èµ°ä¸€æ ¼
                    if (this.isInPalace(toRow, toCol, piece.color)) {
                        if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                            return true;
                        }
                    }

                    // 2. å°†å¸…å¯¹è‡‰æ”»å‡»
                    if (fromCol === toCol) {
                        const targetPiece = board[toRow][toCol];
                        if (targetPiece &&
                            (targetPiece.type === 'å°†' || targetPiece.type === 'å¸…') &&
                            targetPiece.color !== piece.color) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                        }
                    }
                    return false;

                case 'å£«':
                case 'ä»•':
                    return rowDiff === 1 && colDiff === 1 &&
                        this.isInPalace(toRow, toCol, piece.color);

                case 'è±¡':
                case 'ç›¸':
                    if (rowDiff === 2 && colDiff === 2) {
                        const midRow = (fromRow + toRow) / 2;
                        const midCol = (fromCol + toCol) / 2;
                        return !board[midRow][midCol] &&
                            this.isInTerritory(toRow, toCol, piece.color);
                    }
                    return false;
            }
            return false;
        }

        /**
         * ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥è·¯å¾„æ˜¯å¦ç•…é€š
         */
        isPathClear(fromRow, fromCol, toRow, toCol, board) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) {
                    return false;
                }
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }

        /**
         * ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—ä¸¤ç‚¹é—´çš„æ£‹å­æ•°é‡
         */
        countPiecesBetween(fromRow, fromCol, toRow, toCol, board) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let count = 0;
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) {
                    count++;
                }
                currentRow += rowStep;
                currentCol += colStep;
            }
            return count;
        }

        /**
         * ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åœ¨ä¹å®«æ ¼å†…
         */
        isInPalace(row, col, color) {
            if (color === 'red') {
                return row >= 7 && row <= 9 && col >= 3 && col <= 5;
            } else {
                return row >= 0 && row <= 2 && col >= 3 && col <= 5;
            }
        }

        /**
         * ğŸ”¥ è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åœ¨å·±æ–¹é¢†åŸŸ
         */
        isInTerritory(row, col, color) {
            if (color === 'red') {
                return row >= 5; // çº¢æ–¹åœ¨ä¸‹åŠéƒ¨åˆ†
            } else {
                return row <= 4; // é»‘æ–¹åœ¨ä¸ŠåŠéƒ¨åˆ†
            }
        }

        /**
         * ğŸ”¥ ä¿®æ”¹ï¼šgetAISuggestionWithBattleMode - åŠ å…¥å¤šé€‰èµ°æ³•é€»è¾‘
         * åœ¨åŸæœ‰æ–¹æ³•çš„ bestmove å¤„ç†éƒ¨åˆ†æ·»åŠ é€‰æ‹©é€»è¾‘
         */
        async getAISuggestionWithBattleMode(yourBoardArray, battleDifficulty) {
            console.log(`ğŸ”§ [BATTLE_MODE] ä½¿ç”¨å¯¹æˆ˜æ–¹æ³•ï¼Œéš¾åº¦: ${battleDifficulty}`);

            if (!this.isAIReady()) {
                throw new Error('AI å¼•æ“å°šæœªå‡†å¤‡å°±ç»ª');
            }

            if (this.isThinking) {
                throw new Error('AI æ­£åœ¨æ€è€ƒä¸­ï¼Œè¯·ç¨å');
            }

            try {
                this.isThinking = true;
                console.log('AI å¼€å§‹å¯¹æˆ˜æ¨¡å¼åˆ†æ...');

                this.latestCpScore = null;
                this.multiPVResults = [];
                this.maxDepthSeen = 0;

                this.debugBoardState(yourBoardArray);

                const fen = this.translator.boardToFEN(yourBoardArray, this.currentPlayer);
                console.log('å½“å‰å±€é¢ FEN:', fen);

                if (!this.isValidFEN(fen)) {
                    throw new Error('ç”Ÿæˆçš„ FEN æ ¼å¼æ— æ•ˆ: ' + fen);
                }

                // ğŸ”¥ å…³é”®ï¼šæ ¹æ®éš¾åº¦è®¾ç½® MultiPV
                const difficultyConfig = AI_MOVE_SELECTION_CONFIG[battleDifficulty] ||
                    AI_MOVE_SELECTION_CONFIG.medium;

                console.log(`ğŸ¯ è®¾ç½® MultiPV = ${difficultyConfig.multipv}`);
                await this.setMultiPV(difficultyConfig.multipv);

                this.off('bestmove');
                this.off('cpscore');

                console.log('è®¾å®šæ£‹ç›˜å±€é¢...');
                await this.sendCommand(`position fen ${fen}`);
                await new Promise(resolve => setTimeout(resolve, 500));

                let battleDepth;
                if (this.gameMode && typeof this.gameMode.depth === 'number') {
                    battleDepth = this.gameMode.depth;
                } else if (typeof battleDifficulty === 'number') {
                    battleDepth = battleDifficulty;
                } else {
                    battleDepth = this.getDifficultyDepth(battleDifficulty);
                }

                console.log(`ğŸ® [BATTLE_MODE] æœ€ç»ˆç¡®å®šæ·±åº¦: ${battleDepth}`);

                // ğŸ”¥ è·å– MultiPV ç»“æœ
                const analysisResult = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        console.warn('AI æ€è€ƒè¶…æ—¶ï¼Œå°è¯•åœæ­¢æœç´¢...');
                        this.sendCommand('stop');
                        setTimeout(() => reject(new Error('AI æ€è€ƒè¶…æ—¶')), 2000);
                    }, 5000);

                    this.once('bestmove', (move, rawMsg, multiPVResults) => {
                        clearTimeout(timeout);
                        console.log('AI è¿”å›ç§»åŠ¨:', move);
                        console.log('MultiPV ç»“æœ:', multiPVResults);

                        if (move && move !== '(none)' && move !== 'none' && move.length >= 4) {
                            resolve({
                                bestMove: move,
                                multiPVResults: multiPVResults || []
                            });
                        } else {
                            reject(new Error('AI æ— æ³•æ‰¾åˆ°æœ‰æ•ˆç§»åŠ¨: ' + move));
                        }
                    });

                    console.log(`ğŸ® å¼€å§‹å¯¹æˆ˜åˆ†æï¼Œæ·±åº¦: ${battleDepth}`);
                    this.sendCommand(`go depth ${battleDepth}`).catch(error => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });

                // ğŸ² æ ¹æ“šæ©Ÿç‡é¸æ“‡èµ°æ³•
                let finalMove;
                let moveSelection;

                if (analysisResult.multiPVResults && analysisResult.multiPVResults.length > 1) {
                    moveSelection = this.selectMoveByProbability(
                        analysisResult.multiPVResults,
                        battleDifficulty
                    );
                    finalMove = moveSelection.selectedMove.move;

                    console.log(`ğŸ² æ ¹æ“šæ©Ÿç‡é¸æ“‡: ${moveSelection.reason}`);

                    // ğŸ”¥ ä¿®å¾©ï¼šæ·»åŠ å®‰å…¨æª¢æŸ¥
                    if (moveSelection.allChoices && Array.isArray(moveSelection.allChoices)) {
                        console.log(`   æ‰€æœ‰é¸é …:`, moveSelection.allChoices.map(c =>
                            `${c.index}é¸(${c.move}, ${c.score})${c.isSelected ? ' âœ“' : ''}`
                        ).join(', '));
                    } else if (moveSelection.isCheckResponse) {
                        console.log(`   è¢«å°‡è»å¼·åˆ¶é¸æ“‡æœ€ä½³æ‹›`);
                    }
                } else {
                    finalMove = analysisResult.bestMove;
                    moveSelection = {
                        selectionType: 'best',
                        selectionIndex: 1,
                        reason: 'å”¯ä¸€æ‹›æ³•'
                    };
                    console.log('åªæœ‰ä¸€å€‹å¯é¸æ‹›æ³•');
                }

                // è½¬æ¢ç§»åŠ¨æ ¼å¼
                console.log(`è§£æç§»åŠ¨: ${finalMove}`);

                let engineMove;
                if (this.translator && typeof this.translator.convertDisplayToEngineMove === 'function') {
                    engineMove = this.translator.convertDisplayToEngineMove(finalMove);
                } else if (typeof translator !== 'undefined' && translator.convertDisplayToEngineMove) {
                    engineMove = translator.convertDisplayToEngineMove(finalMove);
                } else {
                    engineMove = this.manualConvertDisplayToEngine(finalMove);
                }

                const fromCol = engineMove[0];
                const fromRow = parseInt(engineMove[1]);
                const toCol = engineMove[2];
                const toRow = parseInt(engineMove[3]);

                const moveResult = {
                    moveString: engineMove,
                    from: {
                        col: fromCol,
                        row: fromRow,
                        notation: `${fromCol}${fromRow}`
                    },
                    to: {
                        col: toCol,
                        row: toRow,
                        notation: `${toCol}${toRow}`
                    },
                    description: `ç§»åŠ¨ä» ${fromCol}${fromRow} åˆ° ${toCol}${toRow}`,
                    cpScore: this.latestCpScore,
                    usedDepth: battleDepth,
                    configuredDepth: this.gameMode?.depth,
                    analysisMode: 'battle',
                    difficulty: battleDifficulty,
                    isBattleMove: true,
                    moveType: 'battle',
                    // ğŸ”¥ æ–°å¢ï¼šé€‰æ‹©ä¿¡æ¯
                    moveSelection: moveSelection
                };

                console.log('ğŸ® å¯¹æˆ˜åˆ†æå®Œæˆï¼Œç»“æœ:', moveResult);

                return moveResult;

            } catch (error) {
                console.error('ğŸ® å¯¹æˆ˜åˆ†æå¤±è´¥:', error);
                throw error;
            } finally {
                this.isThinking = false;
            }
        }



        getContextualDepth(forceAnalysis = false) {
            console.log(`ğŸ”§ [DEPTH] ===== getContextualDepth è°ƒç”¨ =====`);
            console.log(`ğŸ”§ [DEPTH] analysisMode: "${this.analysisMode}" (${typeof this.analysisMode})`);
            console.log(`ğŸ”§ [DEPTH] gameMode:`, this.gameMode);
            console.log(`ğŸ”§ [DEPTH] forceAnalysis:`, forceAnalysis);

            // **å…³é”®ä¿®æ­£ï¼šæ·»åŠ  forceAnalysis å‚æ•°æ¥å¼ºåˆ¶ä½¿ç”¨åˆ†ææ·±åº¦**
            if (forceAnalysis) {
                const analysisDepth = this.defaultAnalysisDepth || 15;
                console.log(`ğŸ” [DEPTH] å¼ºåˆ¶åˆ†ææ¨¡å¼ - æ·±åº¦: ${analysisDepth}`);
                return analysisDepth;
            }

            const mode = String(this.analysisMode || 'analysis').toLowerCase().trim();

            // **ä¿®æ­£ï¼šåœ¨å¯¹æˆ˜æ¨¡å¼ç¯å¢ƒä¸­ï¼Œä¼˜å…ˆä½¿ç”¨æ¸¸æˆæ¨¡å¼æ·±åº¦**
            if (this.gameMode && this.gameMode.depth) {
                // å¦‚æœåœ¨å¯¹æˆ˜ç¯å¢ƒä¸­ï¼Œä¸”ä¸æ˜¯å¼ºåˆ¶åˆ†æï¼Œä¼˜å…ˆä½¿ç”¨å¯¹æˆ˜æ·±åº¦
                if (mode === 'battle') {
                    console.log(`âš”ï¸ [DEPTH] å¯¹æˆ˜æ¨¡å¼ä½¿ç”¨æ¸¸æˆæ·±åº¦: ${this.gameMode.depth}`);
                    return this.gameMode.depth;
                } else if (mode === 'analysis' && !forceAnalysis) {
                    // åœ¨å¯¹æˆ˜ç¯å¢ƒä¸­ï¼Œå¦‚æœä¸æ˜¯å¼ºåˆ¶åˆ†æï¼ˆå³AIèµ°æ£‹ï¼‰ï¼Œä½¿ç”¨å¯¹æˆ˜æ·±åº¦
                    console.log(`âš”ï¸ [DEPTH] å¯¹æˆ˜ç¯å¢ƒä¸­AIèµ°æ£‹ï¼Œä½¿ç”¨æ¸¸æˆæ·±åº¦: ${this.gameMode.depth}`);
                    return this.gameMode.depth;
                } else if (mode === 'analysis' && forceAnalysis) {
                    // å¼ºåˆ¶åˆ†ææ¨¡å¼ï¼ˆç”¨æˆ·ç‚¹å‡»åˆ†ææŒ‰é’®ï¼‰
                    console.log(`ğŸ” [DEPTH] å¼ºåˆ¶åˆ†ææ¨¡å¼ï¼Œä½¿ç”¨åˆ†ææ·±åº¦: ${this.defaultAnalysisDepth || 15}`);
                    return this.defaultAnalysisDepth || 15;

                    // éå¯¹æˆ˜ç¯å¢ƒçš„é€»è¾‘
                    if (mode === 'analysis') {
                        const analysisDepth = this.defaultAnalysisDepth || 15;
                        console.log(`ğŸ” [DEPTH] çº¯åˆ†ææ¨¡å¼ - æ·±åº¦: ${analysisDepth}`);
                        return analysisDepth;
                    } else if (mode === 'battle') {
                        const depth = this.getDifficultyDepth();
                        console.log(`âš”ï¸ [DEPTH] å¯¹æˆ˜æ¨¡å¼ä½¿ç”¨éš¾åº¦æ·±åº¦: ${depth}`);
                        return depth;
                    } else {
                        console.log(`ğŸ” [DEPTH] é»˜è®¤åˆ†ææ·±åº¦: ${this.defaultAnalysisDepth || 15}`);
                        return this.defaultAnalysisDepth || 15;
                    }
                }
            }
        }
        // ============================================
// ä¿®å¤ 2ï¼šä¿®æ”¹ getAISuggestion
// ============================================

        async getAISuggestion(yourBoardArray) {
            if (!this.isAIReady()) {
                throw new Error('AI å¼•æ“å°šæœªå‡†å¤‡å°±ç»ª');
            }

            if (this.isThinking) {
                throw new Error('AI æ­£åœ¨æ€è€ƒä¸­ï¼Œè¯·ç¨å');
            }

            try {
                this.isThinking = true;

                // ğŸ”¥ ç”Ÿæˆæ–°çš„ä¼šè¯ ID
                this.analysisSessionId++;
                this.currentSessionId = this.analysisSessionId;

                console.log(`\nğŸ†” === å¼€å§‹åˆ†æä¼šè¯ #${this.currentSessionId} ===`);

                // è°ƒè¯•æ£‹ç›˜çŠ¶æ€
                this.debugBoardState(yourBoardArray);

                // 1. ç”Ÿæˆ FEN
                const fen = this.translator.boardToFEN(yourBoardArray, this.currentPlayer);
                console.log('å½“å‰å±€é¢ FEN:', fen);

                // 2. éªŒè¯ FEN æ ¼å¼
                if (!this.isValidFEN(fen)) {
                    throw new Error('ç”Ÿæˆçš„ FEN æ ¼å¼æ— æ•ˆ: ' + fen);
                }

                // 3. è·å–å½“å‰åˆ†ææ¨¡å¼è®¾ç½®
                const analysisMode = currentSettings?.aiAnalysisMode || 'single';
                const modeConfig = SETTINGS_CONFIG.aiAnalysisModes.find(m => m.id === analysisMode);

                console.log(`ğŸ”§ åˆ†ææ¨¡å¼: ${modeConfig.name} (MultiPV=${modeConfig.multipv})`);

                // 4. è®¾ç½® MultiPV
                console.log(`âš™ï¸ è®¾ç½® MultiPV=${modeConfig.multipv}...`);
                await this.setMultiPV(modeConfig.multipv);

                // ğŸ”¥ğŸ”¥ğŸ”¥ å…³é”®ï¼šç­‰å¾…ä¸€ä¸‹ç¡®ä¿è®¾ç½®ç”Ÿæ•ˆ
                await new Promise(resolve => setTimeout(resolve, 100));

                // ğŸ”¥ğŸ”¥ğŸ”¥ åœ¨è®¾ç½® MultiPV ä¹‹åç«‹å³æ¸…ç©º
                console.log(`ğŸ§¹ æ¸…ç©ºæ—§æ•°æ®ï¼ˆä¼šè¯ #${this.currentSessionId}ï¼‰...`);
                this.latestCpScore = null;
                this.multiPVResults = [];
                this.maxDepthSeen = 0;
                this.pvMaxDepths = {};

                console.log(`âœ… MultiPV=${modeConfig.multipv} è®¾ç½®å®Œæˆå¹¶æ¸…ç©º`);

                // 5. æ¸…é™¤ä¹‹å‰çš„ç›‘å¬å™¨
                this.off('bestmove');
                this.off('cpscore');

                // 6. è®¾å®šå±€é¢
                console.log('è®¾å®šæ£‹ç›˜å±€é¢...');
                await this.sendCommand(`position fen ${fen}`);
                await new Promise(resolve => setTimeout(resolve, 300));

                // ğŸ”¥ğŸ”¥ğŸ”¥ åœ¨å‘é€ go å‘½ä»¤å‰æœ€åä¸€æ¬¡æ¸…ç©º
                console.log(`ğŸ§¹ å‘é€ go å‘½ä»¤å‰æœ€åæ¸…ç©ºï¼ˆä¼šè¯ #${this.currentSessionId}ï¼‰...`);
                this.multiPVResults = [];
                this.pvMaxDepths = {};

                // 7. å¼€å§‹åˆ†æ
                const results = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        console.warn('AI æ€è€ƒè¶…æ—¶ï¼Œå°è¯•åœæ­¢æœç´¢...');
                        this.sendCommand('stop');
                        setTimeout(() => {
                            reject(new Error('AI æ€è€ƒè¶…æ—¶'));
                        }, 2000);
                    }, 1000);

                    this.once('bestmove', (move, rawMsg, multiPVResults) => {
                        clearTimeout(timeout);
                        console.log(`\nğŸ“¨ bestmove äº‹ä»¶ (ä¼šè¯ #${this.currentSessionId})`);
                        console.log('AI è¿”å›ç§»åŠ¨:', move);
                        console.log('ä¼ å…¥çš„ multiPVResults:', multiPVResults?.length || 0);
                        console.log('this.multiPVResults:', this.multiPVResults.length);

                        // ğŸ”¥ è¯¦ç»†æ‰“å°æ”¶é›†åˆ°çš„ç»“æœ
                        if (this.multiPVResults.length > 0) {
                            console.log('ğŸ” æ”¶é›†åˆ°çš„ MultiPV ç»“æœï¼š');
                            this.multiPVResults.forEach((r, i) => {
                                const sessionMatch = r.sessionId === this.currentSessionId ? 'âœ…' : 'âŒ';
                                console.log(`  ${sessionMatch} [${i}] session=${r.sessionId}, index=${r.index}, move=${r.move}, depth=${r.depth}`);
                            });

                            // ğŸ”¥ å…³é”®ï¼šè¿‡æ»¤æ‰ä¸å±äºå½“å‰ä¼šè¯çš„ç»“æœ
                            const currentSessionResults = this.multiPVResults.filter(
                                r => r.sessionId === this.currentSessionId
                            );

                            if (currentSessionResults.length !== this.multiPVResults.length) {
                                console.warn(`âš ï¸ æ£€æµ‹åˆ°è·¨ä¼šè¯æ±¡æŸ“ï¼è¿‡æ»¤å‰${this.multiPVResults.length}ä¸ªï¼Œè¿‡æ»¤å${currentSessionResults.length}ä¸ª`);
                                this.multiPVResults = currentSessionResults;
                            }

                            // ğŸ”¥ å†æ¬¡è¿‡æ»¤ï¼šæ£€æŸ¥æ·±åº¦å·®å¼‚
                            if (this.multiPVResults.length > 1) {
                                const maxDepth = Math.max(...this.multiPVResults.map(r => r.depth));
                                const minDepth = Math.min(...this.multiPVResults.map(r => r.depth));

                                if (maxDepth - minDepth > 5) {
                                    console.warn(`âš ï¸ æ£€æµ‹åˆ°æ·±åº¦å·®å¼‚è¿‡å¤§ï¼æœ€å¤§${maxDepth} vs æœ€å°${minDepth}`);
                                    const filtered = this.multiPVResults.filter(r => r.depth >= maxDepth - 2);
                                    console.log(`âœ… æ·±åº¦è¿‡æ»¤ï¼š${this.multiPVResults.length} -> ${filtered.length}`);
                                    this.multiPVResults = filtered;
                                }
                            }

                            console.log(`ğŸ“Š æœ€ç»ˆæœ‰æ•ˆç»“æœï¼š${this.multiPVResults.length} ä¸ª`);
                        }

                        if (move === 'CHECKMATE') {
                            resolve({
                                isCheckmate: true,
                                results: []
                            });
                            return;
                        }

                        if (move && move !== '(none)' && move !== 'none' && move.length >= 4) {
                            resolve({
                                isCheckmate: false,
                                bestMove: move,
                                results: this.multiPVResults
                            });
                        } else {
                            console.warn('AI è¿”å›æ— æ•ˆç§»åŠ¨:', move);
                            reject(new Error('AI æ— æ³•æ‰¾åˆ°æœ‰æ•ˆç§»åŠ¨: ' + move));
                        }
                    });

                    const depth = this.getContextualDepth(true);
                    console.log(`ğŸš€ å‘é€å‘½ä»¤: go depth ${depth} (ä¼šè¯ #${this.currentSessionId})`);
                    this.sendCommand(`go depth ${depth}`).catch(error => {
                        clearTimeout(timeout);
                        reject(error);
                    });
                });

                // 8. å¤„ç†å°†æ­»ç»“æœ
                if (results.isCheckmate) {
                    return {
                        moveString: 'CHECKMATE',
                        isCheckmate: true,
                        cpScore: 10000,
                        description: 'å°‡æ­»',
                        usedDepth: this.getContextualDepth(),
                        analysisMode: this.analysisMode,
                        difficulty: this.difficulty
                    };
                }

                // 9. å¦‚æœæ˜¯è¿ç»­å¯¹å¼ˆæ¨¡å¼
                if (modeConfig.sequence) {
                    const pvMoves = results.results?.[0]?.pv || [];

                    console.log(`ğŸ”„ é€£çºŒå°å¼ˆæ¨¡å¼ï¼ŒPV é•·åº¦: ${pvMoves.length}`);

                    if (pvMoves.length >= 5) {
                        return this.parseSequenceFromPV(pvMoves.slice(0, 5));
                    } else if (pvMoves.length > 0) {
                        return this.parseSequenceFromPV(pvMoves);
                    } else {
                        console.warn('âš ï¸ ç„¡æ³•å–å¾— PV åºåˆ—ï¼Œé€€å›å–®ä¸€çµæœæ¨¡å¼');
                        const moveData = this.parseMoveResult(results.bestMove);
                        return {
                            moves: [{
                                ...moveData,
                                cpScore: this.latestCpScore
                            }],
                            mode: 'single',
                            usedDepth: this.getContextualDepth(),
                            analysisMode: this.analysisMode,
                            difficulty: this.difficulty
                        };
                    }
                }

                // 10. è¿”å›å•ä¸€æˆ–å¤šä¸ªç»“æœ
                const allMoves = [];

                if (results.results && results.results.length > 0) {
                    // MultiPV æ¨¡å¼ - è¿”å›å¤šä¸ªç»“æœ
                    for (const pvResult of results.results) {
                        const moveData = this.parseMoveResult(pvResult.move);
                        allMoves.push({
                            ...moveData,
                            cpScore: pvResult.score,
                            depth: pvResult.depth,
                            pvIndex: pvResult.index,
                            pv: pvResult.pv
                        });
                    }
                } else {
                    // å•ä¸€ç»“æœæ¨¡å¼
                    const moveData = this.parseMoveResult(results.bestMove);
                    allMoves.push({
                        ...moveData,
                        cpScore: this.latestCpScore
                    });
                }

                console.log(`âœ… åˆ†æå®Œæˆï¼Œè¿”å› ${allMoves.length} å€‹çµæœ`);

                return {
                    moves: allMoves,
                    mode: modeConfig.id,
                    usedDepth: this.getContextualDepth(),
                    analysisMode: this.analysisMode,
                    difficulty: this.difficulty
                };

            } catch (error) {
                console.error('AI åˆ†æå¤±è´¥:', error);
                throw error;
            } finally {
                this.isThinking = false;
            }
        }


// ============================================
// ç¢ºèª getCurrentPlayer æ–¹æ³•å­˜åœ¨æ–¼ CompleteXiangqiAI é¡ä¸­
// ============================================
// å¦‚æœ parseSequenceFromPV åœ¨ CompleteXiangqiAI é¡ä¸­ï¼Œ
// é‚£éº¼ this.getCurrentPlayer() æ‡‰è©²å¯ä»¥æ­£å¸¸ä½¿ç”¨

// å¦‚æœé€™å€‹æ–¹æ³•éœ€è¦å¾å¤–éƒ¨å–å¾—ç•¶å‰ç©å®¶ï¼Œå¯ä»¥æ”¹ç‚ºï¼š
        parseSequenceFromPV(pvMoves, startingPlayer = null) {
            console.log(`ğŸ”„ å¾ PV ç›´æ¥è§£æ ${pvMoves.length} æ­¥èµ°æ³•:`, pvMoves);

            // ğŸ”¥ å¦‚æœæ²’æœ‰å‚³å…¥ï¼Œå˜—è©¦è‡ªå‹•åˆ¤æ–·
            if (!startingPlayer) {
                // æ–¹æ³•1: å¾ gameState å–å¾—
                if (typeof gameState !== 'undefined' && gameState.currentTurn) {
                    startingPlayer = gameState.currentTurn;
                }
                // æ–¹æ³•2: å¾ this å–å¾—
                else if (this.getCurrentPlayer) {
                    startingPlayer = this.getCurrentPlayer();
                }
                // æ–¹æ³•3: é è¨­ç´…æ–¹
                else {
                    startingPlayer = 'red';
                }
            }

            console.log(`ğŸ¨ èµ·å§‹èµ°æ£‹æ–¹: ${startingPlayer}`);

            const sequence = pvMoves.map((move, index) => {
                const moveData = this.parseMoveResult(move);

                let player;
                if (startingPlayer === 'red') {
                    player = index % 2 === 0 ? 'red' : 'black';
                } else {
                    player = index % 2 === 0 ? 'black' : 'red';
                }

                return {
                    ...moveData,
                    step: index + 1,
                    player: player
                };
            });

            return {
                sequence: sequence,
                mode: 'sequence',
                steps: pvMoves.length,
                isSequence: true,
                startingPlayer: startingPlayer
            };
        }

        /**
         * æ‰‹åŠ¨è½¬æ¢æ–¹æ³•ï¼ˆå¤‡ç”¨ï¼‰
         */
        manualConvertDisplayToEngine(displayMove) {
            if (!displayMove || displayMove.length < 4) {
                return displayMove;
            }

            try {
                const fromCol = displayMove[0];
                const fromRow = parseInt(displayMove[1]);
                const toCol = displayMove[2];
                const toRow = parseInt(displayMove[3]);

                // ç¿»è½¬è¡Œåæ ‡ï¼šæ˜¾ç¤ºè¡Œ = 9 - å¼•æ“è¡Œ
                const engineFromRow = 9 - fromRow;
                const engineToRow = 9 - toRow;

                const engineMove = `${fromCol}${engineFromRow}${toCol}${engineToRow}`;
                console.log(`æ‰‹åŠ¨è½¬æ¢: ${displayMove} -> ${engineMove}`);
                return engineMove;
            } catch (error) {
                console.error('æ‰‹åŠ¨è½¬æ¢å¤±è´¥:', error);
                return displayMove;
            }
        }

        /**
         * ç­‰å¾…å°±ç·’ç‹€æ…‹çš„è¼”åŠ©æ–¹æ³•
         */
        async waitForReady(ms = 300) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * ç§»é™¤æ‰€æœ‰ç›£è½å™¨çš„è¼”åŠ©æ–¹æ³•
         */
        removeAllListeners(event) {
            if (this.eventListeners && this.eventListeners[event]) {
                this.eventListeners[event] = [];
                console.log(`å·²æ¸…é™¤æ‰€æœ‰ ${event} ç›£è½å™¨`);
            }
        }

        /**
         * èª¿è©¦æ£‹ç›¤ç‹€æ…‹ - ä¿®æ­£ç‰ˆæœ¬
         */
        debugBoardState(board) {
            console.log('èª¿è©¦æ£‹ç›¤ç‹€æ…‹:');
            console.log('æ£‹ç›¤ç¶­åº¦:', board.length, 'x', board[0]?.length);

            // é¡¯ç¤ºå¯¦éš›çš„æ£‹ç›¤ä½ˆå±€ï¼ˆ0-9è¡Œï¼Œä¸­é–“æ²’æœ‰ç©ºè¡Œï¼‰
            for (let row = 0; row < 10; row++) {
                if (!board[row]) {
                    console.log(`ç¬¬ ${row} è¡Œä¸å­˜åœ¨`);
                    continue;
                }

                let rowStr = `ç¬¬ ${row} è¡Œ: `;
                let pieceCount = 0;

                for (let col = 0; col < 9; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type) {
                        rowStr += piece.type + ' ';
                        pieceCount++;
                    } else {
                        rowStr += '_ ';
                    }
                }

                rowStr += ` (${pieceCount} å€‹æ£‹å­)`;
                console.log(rowStr);
            }
        }

        /**
         * ä¸­åœ‹è±¡æ£‹ FEN æ ¼å¼é©—è­‰
         */
        isValidFEN(fen) {
            const parts = fen.split(' ');
            if (parts.length !== 6) {
                console.error('FEN æ ¼å¼éŒ¯èª¤ï¼šéƒ¨åˆ†æ•¸é‡ä¸æ­£ç¢º', parts.length);
                return false;
            }

            const boardPart = parts[0];
            const rows = boardPart.split('/');

            if (rows.length !== 10) {
                console.error('FEN æ ¼å¼éŒ¯èª¤ï¼šè¡Œæ•¸ä¸æ­£ç¢ºï¼Œæ‡‰ç‚º10è¡Œï¼Œå¯¦éš›ç‚º', rows.length);
                return false;
            }

            // æª¢æŸ¥æ¯ä¸€è¡Œ
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                let columnCount = 0;

                for (let j = 0; j < row.length; j++) {
                    const char = row[j];
                    if (/\d/.test(char)) {
                        const num = parseInt(char);
                        if (num < 1 || num > 9) {
                            console.error('FEN æ ¼å¼éŒ¯èª¤ï¼šç„¡æ•ˆçš„ç©ºæ ¼æ•¸å­—', num, 'in row', i);
                            return false;
                        }
                        columnCount += num;
                    } else if (/[rnbakcp]/i.test(char)) {
                        columnCount += 1;
                    } else {
                        console.error('FEN æ ¼å¼éŒ¯èª¤ï¼šç„¡æ•ˆå­—ç¬¦', char, 'in row', i);
                        return false;
                    }
                }

                if (columnCount !== 9) {
                    console.error('FEN æ ¼å¼éŒ¯èª¤ï¼šç¬¬', i, 'è¡Œåˆ—æ•¸ä¸æ­£ç¢ºï¼Œæ‡‰ç‚º9åˆ—ï¼Œå¯¦éš›ç‚º', columnCount);
                    return false;
                }
            }

            console.log('FEN æ ¼å¼é©—è­‰é€šéï¼š', rows.length, 'è¡Œ');
            return true;
        }

        // æ‰¾åˆ°é€™å€‹æ–¹æ³•ä¸¦å®Œæ•´æ›¿æ›ï¼š
        getDifficultyDepth(difficultyParam) {
            const targetDifficulty = difficultyParam || this.difficulty;

            // å¦‚æœå‚³å…¥æ•¸å­—ï¼Œç›´æ¥è¿”å›
            if (typeof targetDifficulty === 'number') {
                console.log(`ğŸ¯ [DEPTH] ç›´æ¥ä½¿ç”¨æ·±åº¦: ${targetDifficulty}`);
                return targetDifficulty;
            }

            const depthMap = {
                'easy': 3,
                'medium': 6,
                'hard': 9,
                'expert': 12,
                'master': 15
            };

            const depth = depthMap[String(targetDifficulty).toLowerCase()] || 6;
            console.log(`ğŸ¯ é›£åº¦ "${targetDifficulty}" å°æ‡‰æ·±åº¦: ${depth}`);
            return depth;
        }

        /**
         * ç²å¾—æ‹›æ³•çš„ä¸­æ–‡æè¿° - å®Œå…¨å®‰å…¨ç‰ˆæœ¬
         */
        getMoveDescription(moveData, board) {
            try {
                // æª¢æŸ¥è¼¸å…¥åƒæ•¸
                if (!moveData || !moveData.from || !moveData.to || !board) {
                    return 'ç„¡æ•ˆæ‹›æ³•';
                }

                const piece = board[moveData.from.row]?.[moveData.from.col];
                if (!piece) return 'æœªçŸ¥æ‹›æ³•';

                // ç›´æ¥ä½¿ç”¨å®‰å…¨çš„åº§æ¨™è½‰æ›ï¼Œä¸ä¾è³´å¯èƒ½æœ‰å•é¡Œçš„ translator
                const fromCoord = this.safeGetCoordString(moveData.from.row, moveData.from.col);
                const toCoord = this.safeGetCoordString(moveData.to.row, moveData.to.col);

                return `${piece.type || 'æ£‹å­'} å¾ ${fromCoord} ç§»å‹•åˆ° ${toCoord}`;
            } catch (error) {
                console.error('getMoveDescription éŒ¯èª¤:', error);
                // æœ€å®‰å…¨çš„å¾Œå‚™æ–¹æ¡ˆ
                return `æ£‹å­ç§»å‹•`;
            }
        }

        /**
         * æœ€å®‰å…¨çš„åº§æ¨™è½‰æ›æ–¹æ³•
         */
        safeGetCoordString(row, col) {
            try {
                // ç°¡åŒ–çš„ä¸­åœ‹è±¡æ£‹åº§æ¨™ç³»çµ±
                const files = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
                const ranks = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];

                // åš´æ ¼æª¢æŸ¥è¼¸å…¥
                if (typeof row !== 'number' || typeof col !== 'number') {
                    return `(${row},${col})`;
                }

                if (row < 0 || row >= 10 || col < 0 || col >= 9) {
                    return `(${row},${col})`;
                }

                return `${files[col]}${ranks[row]}`;
            } catch (error) {
                console.error('safeGetCoordString éŒ¯èª¤:', error);
                return `(${row},${col})`;
            }
        }

        /**
         * åˆå§‹åŒ– translatorï¼ˆå¦‚æœéœ€è¦çš„è©±ï¼‰
         */
        initializeTranslator() {
            if (!this.translator) {
                this.translator = {
                    indexToCoord: (row, col) => {
                        try {
                            const files = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
                            const ranks = ['ï¼‘', 'ï¼’', 'ï¼“', 'ï¼”', 'ï¼•', 'ï¼–', 'ï¼—', 'ï¼˜', 'ï¼™', 'ï¼‘ï¼'];

                            if (row < 0 || row >= 10 || col < 0 || col >= 9) {
                                return `(${row},${col})`;
                            }

                            return `${files[col]}${ranks[row]}`;
                        } catch (error) {
                            console.error('indexToCoord éŒ¯èª¤:', error);
                            return `(${row},${col})`;
                        }
                    }
                };
            }
        }


        /**
         * ğŸ”¥ æ–°å¢: è§£æå–®ä¸€ç§»å‹•çµæœ
         */
        parseMoveResult(rawMove) {
            let engineMove;

            if (this.translator && typeof this.translator.convertDisplayToEngineMove === 'function') {
                engineMove = this.translator.convertDisplayToEngineMove(rawMove);
            } else if (typeof translator !== 'undefined' && translator.convertDisplayToEngineMove) {
                engineMove = translator.convertDisplayToEngineMove(rawMove);
            } else {
                engineMove = this.manualConvertDisplayToEngine(rawMove);
            }

            const fromCol = engineMove[0];
            const fromRow = parseInt(engineMove[1]);
            const toCol = engineMove[2];
            const toRow = parseInt(engineMove[3]);

            return {
                moveString: engineMove,
                from: {
                    col: fromCol,
                    row: fromRow,
                    notation: `${fromCol}${fromRow}`
                },
                to: {
                    col: toCol,
                    row: toRow,
                    notation: `${toCol}${toRow}`
                },
                description: `ç§»åŠ¨ä» ${fromCol}${fromRow} åˆ° ${toCol}${toRow}`
            };
        }

        /**
         * ğŸ”¥ æ–°å¢: é€£çºŒå°å¼ˆåˆ†æ (ç´…é»‘ç´…é»‘ç´…)
         */
        async analyzeSequence(boardArray, firstMove, steps = 5) {
            console.log(`ğŸ”„ é–‹å§‹é€£çºŒå°å¼ˆåˆ†æ ${steps} æ­¥`);

            const sequence = [];
            let currentBoard = JSON.parse(JSON.stringify(boardArray));
            let currentMove = firstMove;

            for (let i = 0; i < steps; i++) {
                const moveData = this.parseMoveResult(currentMove);
                sequence.push({
                    ...moveData,
                    step: i + 1,
                    player: i % 2 === 0 ? 'red' : 'black'
                });

                // å¦‚æœä¸æ˜¯æœ€å¾Œä¸€æ­¥ï¼Œç¹¼çºŒåˆ†æ
                if (i < steps - 1) {
                    // åŸ·è¡Œç§»å‹•
                    currentBoard = this.applyMove(currentBoard, moveData);

                    // åˆ†æä¸‹ä¸€æ­¥
                    const fen = this.translator.boardToFEN(currentBoard, i % 2 === 0 ? 'black' : 'red');
                    await this.sendCommand(`position fen ${fen}`);
                    await new Promise(resolve => setTimeout(resolve, 300));

                    // ç²å–ä¸‹ä¸€æ­¥æœ€ä½³ç§»å‹•
                    const nextMove = await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => reject(new Error('è¶…æ™‚')), 10000);

                        this.once('bestmove', (move) => {
                            clearTimeout(timeout);
                            resolve(move);
                        });

                        this.sendCommand(`go depth ${this.getContextualDepth(true)}`);
                    });

                    currentMove = nextMove;
                }
            }

            return {
                sequence: sequence,
                mode: 'sequence',
                steps: steps,
                isSequence: true
            };
        }

        /**
         * ğŸ”¥ æ–°å¢: åœ¨æ£‹ç›¤ä¸ŠåŸ·è¡Œç§»å‹• (ä¸ä¿®æ”¹åŸæ£‹ç›¤)
         */
        applyMove(board, moveData) {
            const newBoard = JSON.parse(JSON.stringify(board));
            const piece = newBoard[moveData.from.row][moveData.from.col];
            newBoard[moveData.to.row][moveData.to.col] = piece;
            newBoard[moveData.from.row][moveData.from.col] = null;
            return newBoard;
        }


        /**
         * è¨­å®š AI é›£åº¦
         */
        setDifficulty(level) {
            this.difficulty = level;
            console.log(`AI é›£åº¦è¨­å®šç‚º: ${level}`);
        }
    }



    /**
     * ğŸ”¥ ä¿®å¾©ï¼šæ”¹é€²çš„ç¿»è­¯å®˜é¡åˆ¥ - åŠ å…¥åº§æ¨™ç¿»è½‰åŠŸèƒ½
     */
    class XiangqiTranslator {
        constructor() {
            this.pieceToFEN = {
                'è»Š': 'r', 'é¦¬': 'n', 'è±¡': 'b', 'å£«': 'a', 'å°‡': 'k', 'åŒ…': 'c', 'å’': 'p',
                'ä¿¥': 'R', 'å‚Œ': 'N', 'ç›¸': 'B', 'ä»•': 'A', 'å¸¥': 'K', 'ç‚®': 'C', 'å…µ': 'P'
            };

            this.colLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šåº§æ¨™ç¿»è½‰åŠŸèƒ½ - å°‡å¼•æ“åº§æ¨™è½‰æ›ç‚ºæ£‹ç›¤é¡¯ç¤ºåº§æ¨™
         * å¼•æ“åº§æ¨™ï¼š0-9 (0=é»‘æ–¹åº•ç·š, 9=ç´…æ–¹åº•ç·š)
         * é¡¯ç¤ºåº§æ¨™ï¼š0-9 (0=ç´…æ–¹åº•ç·š, 9=é»‘æ–¹åº•ç·š)
         * è½‰æ›å…¬å¼ï¼šé¡¯ç¤ºè¡Œ = 9 - å¼•æ“è¡Œ
         */
        flipCoordinate(row) {
            return 9 - row;
        }

        /**
         * ğŸ”¥ ä¿®æ­£ï¼šå°‡å¼•æ“ç§»å‹•è½‰æ›ç‚ºé¡¯ç¤ºåº§æ¨™ç§»å‹•
         * å¼•æ“è¼¸å‡ºå¦‚ g6g5ï¼Œæ‡‰è©²è½‰æ›ç‚ºé¡¯ç¤ºçš„ g3g4
         * @param {string} engineMove - å¼•æ“æ ¼å¼çš„ç§»å‹• (ä¾‹å¦‚: "g6g5")
         * @returns {string} é¡¯ç¤ºæ ¼å¼çš„ç§»å‹• (ä¾‹å¦‚: "g3g4")
         */
        convertEngineToDisplayMove(engineMove) {
            if (!engineMove || engineMove.length < 4) {
                console.warn(`âš ï¸ ç„¡æ•ˆçš„å¼•æ“ç§»å‹•æ ¼å¼: ${engineMove}`);
                return engineMove;
            }

            try {
                // è§£æå¼•æ“ç§»å‹• (ä¾‹å¦‚: "g6g5")
                const fromCol = engineMove[0]; // 'g'
                const fromRow = parseInt(engineMove[1]); // 6
                const toCol = engineMove[2]; // 'g'
                const toRow = parseInt(engineMove[3]); // 5

                // ç¿»è½‰è¡Œåº§æ¨™ï¼šå¼•æ“6 -> é¡¯ç¤º3, å¼•æ“5 -> é¡¯ç¤º4
                const displayFromRow = this.flipCoordinate(fromRow); // 9-6=3
                const displayToRow = this.flipCoordinate(toRow); // 9-5=4

                // çµ„åˆé¡¯ç¤ºæ ¼å¼ç§»å‹•
                const displayMove = `${fromCol}${displayFromRow}${toCol}${displayToRow}`;

                console.log(`ğŸ”„ å¼•æ“->é¡¯ç¤ºè½‰æ›: ${engineMove} -> ${displayMove}`);
                return displayMove;

            } catch (error) {
                console.error(`âŒ è½‰æ›ç§»å‹•æ™‚å‡ºéŒ¯: ${engineMove}`, error);
                return engineMove;
            }
        }

        /**
         * ğŸ”¥ ä¿®æ­£ï¼šå°‡é¡¯ç¤ºåº§æ¨™ç§»å‹•è½‰æ›ç‚ºå¼•æ“æ ¼å¼ç§»å‹•
         * é¡¯ç¤ºçš„ g3g4ï¼Œæ‡‰è©²è½‰æ›ç‚ºå¼•æ“çš„ g6g5
         * @param {string} displayMove - é¡¯ç¤ºæ ¼å¼çš„ç§»å‹• (ä¾‹å¦‚: "g3g4")
         * @returns {string} å¼•æ“æ ¼å¼çš„ç§»å‹• (ä¾‹å¦‚: "g6g5")
         */
        convertDisplayToEngineMove(displayMove) {
            if (!displayMove || displayMove.length < 4) {
                console.warn(`âš ï¸ ç„¡æ•ˆçš„é¡¯ç¤ºç§»å‹•æ ¼å¼: ${displayMove}`);
                return displayMove;
            }

            try {
                // è§£æé¡¯ç¤ºç§»å‹• (ä¾‹å¦‚: "g3g4")
                const fromCol = displayMove[0]; // 'g'
                const fromRow = parseInt(displayMove[1]); // 3
                const toCol = displayMove[2]; // 'g'
                const toRow = parseInt(displayMove[3]); // 4

                // ç¿»è½‰è¡Œåº§æ¨™ï¼šé¡¯ç¤º3 -> å¼•æ“6, é¡¯ç¤º4 -> å¼•æ“5
                const engineFromRow = this.flipCoordinate(fromRow); // 9-3=6
                const engineToRow = this.flipCoordinate(toRow); // 9-4=5

                // çµ„åˆå¼•æ“æ ¼å¼ç§»å‹•
                const engineMove = `${fromCol}${engineFromRow}${toCol}${engineToRow}`;

                console.log(`ğŸ”„ é¡¯ç¤º->å¼•æ“è½‰æ›: ${displayMove} -> ${engineMove}`);
                return engineMove;

            } catch (error) {
                console.error(`âŒ è½‰æ›ç§»å‹•æ™‚å‡ºéŒ¯: ${displayMove}`, error);
                return displayMove;
            }
        }



        /**
         * ğŸ”¥ æ–°å¢ï¼šåº§æ¨™è½‰æ›å·¥å…·æ–¹æ³•
         */
        getCoordinateInfo(row, col) {
            return {
                engineRow: row,
                displayRow: this.flipCoordinate(row),
                col: col,
                colLetter: this.colLetters[col] || '?',
                territory: row <= 4 ? 'é»‘æ–¹é ˜åœ°' : 'ç´…æ–¹é ˜åœ°',
                engineNotation: `${this.colLetters[col] || '?'}${row}`,
                displayNotation: `${this.colLetters[col] || '?'}${this.flipCoordinate(row)}`
            };
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šé©—è­‰ç§»å‹•æ ¼å¼
         */
        isValidMoveFormat(move) {
            if (!move || typeof move !== 'string' || move.length < 4) {
                return false;
            }

            const fromCol = move[0];
            const fromRow = parseInt(move[1]);
            const toCol = move[2];
            const toRow = parseInt(move[3]);

            // æª¢æŸ¥åˆ—æ˜¯å¦æœ‰æ•ˆ (a-i)
            if (!this.colLetters.includes(fromCol) || !this.colLetters.includes(toCol)) {
                return false;
            }

            // æª¢æŸ¥è¡Œæ˜¯å¦æœ‰æ•ˆ (0-9)
            if (isNaN(fromRow) || isNaN(toRow) ||
                fromRow < 0 || fromRow > 9 ||
                toRow < 0 || toRow > 9) {
                return false;
            }

            return true;
        }


        /**
         * æ£‹ç›¤ç‹€æ…‹åˆ†ææ–¹æ³• - æƒææ‰€æœ‰æ£‹å­ä½ç½®
         */
        analyzeBoardState(board) {
            console.log('ğŸ” é–‹å§‹æƒææ£‹ç›¤ä¸Šæ‰€æœ‰æ£‹å­ä½ç½®...');

            if (!board || !Array.isArray(board)) {
                console.warn('âŒ ç„¡æ•ˆæ£‹ç›¤ï¼Œç„¡æ³•åˆ†æ');
                return null;
            }

            const analysis = {
                boardSize: {
                    height: board.length,
                    width: 0,
                    isStandard: false
                },
                pieceCount: {
                    total: 0,
                    red: 0,
                    black: 0,
                    byType: new Map()
                },
                // ğŸ”¥ é—œéµï¼šè¨˜éŒ„æ¯å€‹æ£‹å­çš„ç¢ºåˆ‡ä½ç½®å’Œé¡å‹
                piecePositions: [],  // æ‰€æœ‰æ£‹å­çš„ä½ç½®æ•¸çµ„
                boardMatrix: [],     // æ£‹ç›¤çŸ©é™£è¡¨ç¤º
                distribution: {
                    red: { positions: [], types: new Map() },
                    black: { positions: [], types: new Map() }
                },
                gamePhase: 'unknown',
                advantage: 'neutral'
            };

            // æª¢æ¸¬æ£‹ç›¤å°ºå¯¸
            if (board[0] && Array.isArray(board[0])) {
                analysis.boardSize.width = board[0].length;
                analysis.boardSize.isStandard = (analysis.boardSize.height === 10 && analysis.boardSize.width === 9);
            }

            console.log(`ğŸ“ æ£‹ç›¤å°ºå¯¸: ${analysis.boardSize.height}x${analysis.boardSize.width} ${analysis.boardSize.isStandard ? '(æ¨™æº–)' : '(éæ¨™æº–)'}`);

            // ğŸ”¥ åˆå§‹åŒ–æ£‹ç›¤çŸ©é™£ - ç”¨æ–¼ FEN ç”Ÿæˆ
            for (let row = 0; row < analysis.boardSize.height; row++) {
                analysis.boardMatrix[row] = new Array(analysis.boardSize.width).fill(null);
            }

            // ğŸ”¥ éæ­·æ£‹ç›¤ï¼Œæƒææ‰€æœ‰æ£‹å­ä½ç½®
            for (let row = 0; row < board.length; row++) {
                if (!board[row] || !Array.isArray(board[row])) continue;

                for (let col = 0; col < board[row].length; col++) {
                    const piece = board[row][col];
                    if (!piece || !piece.type || !piece.color) continue;

                    const { color, type } = piece;

                    // ğŸ”¥ æ·»åŠ åº§æ¨™ä¿¡æ¯
                    const coordInfo = this.getCoordinateInfo(row, col);

                    // è¨˜éŒ„æ£‹å­ä½ç½®
                    const pieceInfo = {
                        row: row,
                        col: col,
                        color: color,
                        type: type,
                        fenChar: this.pieceToFEN[type] || '?',
                        // ğŸ”¥ æ–°å¢åº§æ¨™ä¿¡æ¯
                        engineNotation: coordInfo.engineNotation,
                        displayNotation: coordInfo.displayNotation,
                        territory: coordInfo.territory
                    };

                    analysis.piecePositions.push(pieceInfo);
                    analysis.boardMatrix[row][col] = pieceInfo;

                    // çµ±è¨ˆæ•¸æ“š
                    analysis.pieceCount.total++;
                    analysis.pieceCount[color]++;

                    // æŒ‰é¡å‹çµ±è¨ˆ
                    const typeKey = `${color}_${type}`;
                    analysis.pieceCount.byType.set(typeKey, (analysis.pieceCount.byType.get(typeKey) || 0) + 1);

                    // ä½ç½®è¨˜éŒ„
                    analysis.distribution[color].positions.push({ row, col, type });
                    analysis.distribution[color].types.set(type, (analysis.distribution[color].types.get(type) || 0) + 1);

                    console.log(`ğŸ“ æ£‹å­æƒæ: ${coordInfo.displayNotation} (å¼•æ“:${coordInfo.engineNotation}) ${color} ${type} -> FEN:'${pieceInfo.fenChar}' [${coordInfo.territory}]`);
                }
            }

            // åˆ†æéŠæˆ²éšæ®µ
            if (analysis.pieceCount.total > 20) {
                analysis.gamePhase = 'opening';
            } else if (analysis.pieceCount.total > 10) {
                analysis.gamePhase = 'middle';
            } else {
                analysis.gamePhase = 'endgame';
            }

            // åˆ†æå„ªåŠ£å‹¢
            const redCount = analysis.pieceCount.red;
            const blackCount = analysis.pieceCount.black;

            if (redCount > blackCount + 2) {
                analysis.advantage = 'red';
            } else if (blackCount > redCount + 2) {
                analysis.advantage = 'black';
            } else {
                analysis.advantage = 'balanced';
            }

            // è¼¸å‡ºæƒæçµæœ
            this.logBoardAnalysis(analysis);

            console.log(`âœ… æ£‹ç›¤æƒæå®Œæˆï¼Œç™¼ç¾ ${analysis.pieceCount.total} å€‹æ£‹å­`);
            return analysis;
        }

        /**
         * ğŸ”¥ ä¿®å¾©ç‰ˆï¼šå¾DOMä¸­æå–ç•¶å‰çœŸå¯¦æ£‹ç›¤ç‹€æ…‹
         * å„ªå…ˆç´šèª¿æ•´ï¼šå…ˆå˜—è©¦ç²å–çœŸå¯¦ç•¶å‰ç‹€æ…‹ï¼Œæœ€å¾Œæ‰ä½¿ç”¨å‚³å…¥çš„inputBoard
         */
        getCurrentEffectiveBoard(inputBoard = null) {
            console.log(`\nğŸ¯ ç²å–çœŸæ­£çš„ç•¶å‰æ£‹ç›¤ç‹€æ…‹...`);

            let effectiveBoard = null;
            let dataSource = null;

            // 1. ğŸ”¥ å„ªå…ˆï¼šç›´æ¥å¾DOMæå–ç•¶å‰æ£‹ç›¤ç‹€æ…‹ï¼ˆæœ€çœŸå¯¦çš„ç‹€æ…‹ï¼‰
            console.log('ğŸ” å„ªå…ˆå˜—è©¦å¾DOMæå–ç•¶å‰æ£‹ç›¤ç‹€æ…‹...');
            effectiveBoard = this.extractBoardFromDOM();
            if (effectiveBoard) {
                dataSource = 'dom_extraction';
                console.log('âœ… æˆåŠŸå¾DOMæå–æ£‹ç›¤ç‹€æ…‹');
            }

            // 2. å¦‚æœæœ‰è™›æ“¬æ£‹ç›¤ç³»çµ±ï¼Œå˜—è©¦ç²å–å…¶ç‹€æ…‹
            if (!effectiveBoard && typeof this !== 'undefined' && this.getCurrentBoardArray) {
                try {
                    const virtualBoard = this.getCurrentBoardArray();
                    if (virtualBoard && Array.isArray(virtualBoard)) {
                        effectiveBoard = virtualBoard;
                        dataSource = 'virtual_board';
                        console.log('âœ… ä½¿ç”¨è™›æ“¬æ£‹ç›¤ç³»çµ±çš„ç•¶å‰ç‹€æ…‹');
                    }
                } catch (error) {
                    console.log('âš ï¸ ç„¡æ³•ç²å–è™›æ“¬æ£‹ç›¤ç‹€æ…‹ï¼Œå˜—è©¦å…¶ä»–æ–¹å¼');
                }
            }

            // 3. å˜—è©¦å¾å…¨åŸŸè®Šæ•¸ç²å–ç•¶å‰ç‹€æ…‹
            if (!effectiveBoard) {
                // æŒ‰å„ªå…ˆç´šå˜—è©¦ä¸åŒçš„å…¨åŸŸè®Šæ•¸
                if (typeof current_board !== 'undefined' && Array.isArray(current_board)) {
                    effectiveBoard = current_board;
                    dataSource = 'current_board';
                    console.log('âœ… ä½¿ç”¨ current_board å…¨åŸŸè®Šæ•¸');
                } else if (typeof gameState !== 'undefined' && gameState.board && Array.isArray(gameState.board)) {
                    effectiveBoard = gameState.board;
                    dataSource = 'gameState_board';
                    console.log('âœ… ä½¿ç”¨ gameState.board');
                }
            }

            // 4. å‚™ç”¨ï¼šä½¿ç”¨gameHistoryä¸­çš„ç•¶å‰ç‹€æ…‹
            if (!effectiveBoard && typeof gameHistory !== 'undefined' && gameHistory && gameHistory.currentBoard) {
                effectiveBoard = gameHistory.currentBoard;
                dataSource = 'gameHistory_current';
                console.log('âœ… ä½¿ç”¨gameHistoryä¸­çš„ç•¶å‰æ£‹ç›¤');
            }

            // 5. æœ€å¾Œæ‰ä½¿ç”¨å‚³å…¥çš„æ£‹ç›¤ç‹€æ…‹ï¼ˆå¯èƒ½ä¸æ˜¯æœ€æ–°çš„ï¼‰
            if (!effectiveBoard && inputBoard) {
                effectiveBoard = inputBoard;
                dataSource = 'input_board_fallback';
                console.log('âš ï¸ ä½¿ç”¨å‚³å…¥çš„æ£‹ç›¤ç‹€æ…‹ï¼ˆå¯èƒ½ä¸æ˜¯æœ€æ–°ç‹€æ…‹ï¼‰');
            }

            // 6. æœ€å¾Œå‚™ç”¨ï¼šä½¿ç”¨gameHistoryä¸­çš„åˆå§‹æ£‹ç›¤
            if (!effectiveBoard && typeof gameHistory !== 'undefined' && gameHistory && gameHistory.initialBoard) {
                effectiveBoard = gameHistory.initialBoard;
                dataSource = 'initial_board';
                console.log('âš ï¸ ä½¿ç”¨gameHistoryä¸­çš„åˆå§‹æ£‹ç›¤');
            }

            // 7. æ‰¾ä¸åˆ°ä»»ä½•ç‹€æ…‹
            if (!effectiveBoard) {
                console.warn('âŒ æ‰¾ä¸åˆ°ä»»ä½•æ£‹ç›¤ç‹€æ…‹');
                return null;
            }

            console.log(`ğŸ“‹ æ•¸æ“šæº: ${dataSource}`);

            // å¿«é€Ÿæª¢æŸ¥æ£‹ç›¤ç‹€æ…‹
            let pieceCount = 0;
            if (effectiveBoard && Array.isArray(effectiveBoard)) {
                for (let row = 0; row < effectiveBoard.length; row++) {
                    if (effectiveBoard[row] && Array.isArray(effectiveBoard[row])) {
                        for (let col = 0; col < effectiveBoard[row].length; col++) {
                            const piece = effectiveBoard[row][col];
                            if (piece && piece.type && piece.color) {
                                pieceCount++;
                            }
                        }
                    }
                }
            }

            console.log(`ğŸ“Š æ£‹ç›¤ç‹€æ…‹æª¢æŸ¥: ç™¼ç¾ ${pieceCount} å€‹æ£‹å­`);

            // ğŸ”¥ å¦‚æœæ£‹å­æ•¸é‡ä¸åˆç†ï¼Œè­¦å‘Šç”¨æˆ¶
            if (pieceCount === 0) {
                console.warn('âš ï¸ æ£‹ç›¤ç‚ºç©ºï¼Œé€™å¯èƒ½ä¸æ­£ç¢º');
            } else if (pieceCount > 32) {
                console.warn('âš ï¸ æ£‹å­æ•¸é‡è¶…é32å€‹ï¼Œé€™å¯èƒ½ä¸æ­£ç¢º');
            } else if (pieceCount < 5 && dataSource !== 'dom_extraction') {
                console.warn('âš ï¸ æ£‹å­æ•¸é‡å¾ˆå°‘ï¼Œå¯èƒ½æ˜¯æ®˜å±€æˆ–æœ‰å•é¡Œçš„æ£‹ç›¤ç‹€æ…‹');
            }

            return {
                board: effectiveBoard,
                source: dataSource,
                pieceCount: pieceCount
            };
        }
// åœ¨ XiangqiTranslator é¡ä¸­æ·»åŠ é€™å€‹ç¼ºå°‘çš„æ–¹æ³•
        logMoveParseResult(parseResult) {
            console.log('ğŸ“‹ ç§»å‹•è§£æçµæœ:');
            console.log(`  åŸå§‹ç§»å‹•: ${parseResult.originalMove} (${parseResult.originalFormat})`);
            console.log(`  å¼•æ“æ ¼å¼: ${parseResult.engineMove}`);
            console.log(`  é¡¯ç¤ºæ ¼å¼: ${parseResult.displayMove}`);
            console.log(`  èµ·å§‹ä½ç½®: ${parseResult.from.displayNotation} (å¼•æ“:${parseResult.from.engineNotation})`);
            console.log(`  ç›®æ¨™ä½ç½®: ${parseResult.to.displayNotation} (å¼•æ“:${parseResult.to.engineNotation})`);
            console.log(`  ç§»å‹•åˆ†æ: ${parseResult.analysis.direction}, è·é›¢:${parseResult.analysis.distance.total}`);
        }
        /**
         * ğŸ”¥ æ–°å¢ï¼šå¾DOMä¸­æå–æ£‹ç›¤ç‹€æ…‹çš„æ–¹æ³•
         */
        extractBoardFromDOM() {
            console.log("ğŸ” é–‹å§‹å¾DOMæå–æ£‹ç›¤ç‹€æ…‹...");

            try {
                // ç²å–æ‰€æœ‰tile
                const tiles = document.querySelectorAll('.tile');

                if (tiles.length === 0) {
                    console.warn('âŒ æ‰¾ä¸åˆ°ä»»ä½• .tile å…ƒç´ ');
                    return null;
                }

                console.log(`ğŸ“‹ æ‰¾åˆ° ${tiles.length} å€‹tile`);

                // å‰µå»º10x9çš„æ£‹ç›¤ç‹€æ…‹é™£åˆ—
                const board = Array(10).fill().map(() => Array(9).fill(null));

                // æ£‹å­åç¨±æ˜ å°„
                const pieceMapping = {
                    // ç´…æ–¹æ£‹å­
                    'ä¿¥': { type: 'ä¿¥', color: 'red' },
                    'å‚Œ': { type: 'å‚Œ', color: 'red' },
                    'ç›¸': { type: 'ç›¸', color: 'red' },
                    'ä»•': { type: 'ä»•', color: 'red' },
                    'å¸¥': { type: 'å¸¥', color: 'red' },
                    'ç‚®': { type: 'ç‚®', color: 'red' },
                    'å…µ': { type: 'å…µ', color: 'red' },

                    // é»‘æ–¹æ£‹å­
                    'è»Š': { type: 'è»Š', color: 'black' },
                    'é¦¬': { type: 'é¦¬', color: 'black' },
                    'è±¡': { type: 'è±¡', color: 'black' },
                    'å£«': { type: 'å£«', color: 'black' },
                    'å°‡': { type: 'å°‡', color: 'black' },
                    'åŒ…': { type: 'åŒ…', color: 'black' },
                    'ç ²': { type: 'åŒ…', color: 'black' }, // ä¹Ÿæ”¯æ´ç ²å­—
                    'å’': { type: 'å’', color: 'black' }
                };

                let extractedPieces = 0;

                // éæ­·æ‰€æœ‰tileä¸¦æå–æ£‹å­ä¿¡æ¯
                tiles.forEach((tile, index) => {
                    const row = parseInt(tile.dataset.row);
                    const col = parseInt(tile.dataset.col);

                    // é©—è­‰rowå’Œcolæ˜¯å¦æœ‰æ•ˆ
                    if (isNaN(row) || isNaN(col) || row < 0 || row >= 10 || col < 0 || col >= 9) {
                        console.warn(`âš ï¸ ç„¡æ•ˆä½ç½®: tile ${index}, row=${tile.dataset.row}, col=${tile.dataset.col}`);
                        return;
                    }

                    // æª¢æŸ¥é€™å€‹tileæ˜¯å¦æœ‰æ£‹å­
                    const piece = tile.querySelector('.chess-piece');

                    if (piece) {
                        const alt = piece.alt; // å¾altå±¬æ€§ç²å–æ£‹å­åç¨±

                        if (pieceMapping[alt]) {
                            board[row][col] = pieceMapping[alt];
                            extractedPieces++;

                            // ğŸ”¥ é¡¯ç¤ºåº§æ¨™ä¿¡æ¯
                            const coordInfo = this.getCoordinateInfo(row, col);
                            console.log(`ğŸ“ æå–æ£‹å­: ${coordInfo.displayNotation} (å¼•æ“:${coordInfo.engineNotation}) ${pieceMapping[alt].color} ${pieceMapping[alt].type} [${coordInfo.territory}]`);
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°æ˜ å°„ï¼Œå˜—è©¦å¾srcæ¨æ–·
                            const src = piece.src || '';
                            let color = 'unknown';

                            if (src.includes('_red')) {
                                color = 'red';
                            } else if (src.includes('_black')) {
                                color = 'black';
                            }

                            board[row][col] = {
                                type: alt,
                                color: color,
                                unknown: true
                            };
                            extractedPieces++;
                            console.warn(`âš ï¸ æœªçŸ¥æ£‹å­: (${row},${col}) ${alt}, æ¨æ¸¬é¡è‰²: ${color}`);
                        }
                    }
                });

                console.log(`âœ… DOMæå–å®Œæˆ: æ‰¾åˆ° ${extractedPieces} å€‹æ£‹å­`);

                // é©—è­‰æå–çµæœ
                if (extractedPieces === 0) {
                    console.warn('âš ï¸ æ²’æœ‰æå–åˆ°ä»»ä½•æ£‹å­ï¼Œå¯èƒ½æ£‹ç›¤ç‚ºç©ºæˆ–çµæ§‹æœ‰è®Š');
                }

                return board;

            } catch (error) {
                console.error('âŒ DOMæå–éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤:', error);
                return null;
            }
        }


        /**
         * è¼¸å‡ºæ£‹ç›¤åˆ†æçµæœ
         */
        logBoardAnalysis(analysis) {
            console.log('\nğŸ“Š æ£‹ç›¤åˆ†æçµæœ:');
            console.log(`ğŸ“ æ£‹ç›¤å°ºå¯¸: ${analysis.boardSize.height}x${analysis.boardSize.width}`);
            console.log(`ğŸ¯ éŠæˆ²éšæ®µ: ${analysis.gamePhase}`);
            console.log(`âš–ï¸ å„ªåŠ£å‹¢: ${analysis.advantage}`);
            console.log(`ğŸ”´ ç´…æ–¹æ£‹å­: ${analysis.pieceCount.red}å€‹`);
            console.log(`âš« é»‘æ–¹æ£‹å­: ${analysis.pieceCount.black}å€‹`);
            console.log(`ğŸ“Š ç¸½æ£‹å­æ•¸: ${analysis.pieceCount.total}å€‹`);
        }


        /**
         * ğŸ”¥ ä¿®å¾©ï¼šFEN ç•¶å‰ç©å®¶åˆ¤æ–· - æ­£ç¢ºè™•ç†åº§æ¨™åå‘å’Œè¼ªæ¬¡åˆ¤æ–·
         */

// 1. ğŸ”¥ æ–°å¢ï¼šç²å–ç•¶å‰è¼ªåˆ°èª°ä¸‹æ£‹çš„æ–¹æ³•
        getCurrentPlayer() {
            console.log('ğŸ¯ åˆ¤æ–·ç•¶å‰è¼ªåˆ°èª°ä¸‹æ£‹...');

            let currentPlayer = 'red'; // é»˜èªç´…æ–¹å…ˆèµ°

            // æ–¹æ³•1: å¾å…¨åŸŸè®Šæ•¸ç²å–
            if (typeof gameState !== 'undefined' && gameState.currentTurn) {
                currentPlayer = gameState.currentTurn;
                console.log(`âœ… å¾ gameState ç²å–ç•¶å‰ç©å®¶: ${currentPlayer}`);
            }
            // æ–¹æ³•2: å¾éŠæˆ²æ­·å²ç²å–
            else if (typeof gameHistory !== 'undefined' && gameHistory.moves) {
                // æ ¹æ“šç§»å‹•æ¬¡æ•¸åˆ¤æ–·ï¼šå¶æ•¸æ¬¡=ç´…æ–¹ï¼Œå¥‡æ•¸æ¬¡=é»‘æ–¹
                const moveCount = gameHistory.moves.length;
                currentPlayer = (moveCount % 2 === 0) ? 'red' : 'black';
                console.log(`âœ… å¾ç§»å‹•æ­·å²æ¨æ–·ç•¶å‰ç©å®¶: ${currentPlayer} (ç§»å‹•${moveCount}æ¬¡)`);
            }
            // æ–¹æ³•3: å¾DOM UI ç²å–
            else {
                const currentPlayerElement = document.querySelector('.current-player');
                if (currentPlayerElement) {
                    const text = currentPlayerElement.textContent.toLowerCase();
                    if (text.includes('é»‘') || text.includes('black')) {
                        currentPlayer = 'black';
                    } else if (text.includes('ç´…') || text.includes('red')) {
                        currentPlayer = 'red';
                    }
                    console.log(`âœ… å¾UIå…ƒç´ ç²å–ç•¶å‰ç©å®¶: ${currentPlayer}`);
                } else {
                    console.log(`âš ï¸ ç„¡æ³•ç¢ºå®šç•¶å‰ç©å®¶ï¼Œä½¿ç”¨é»˜èªå€¼: ${currentPlayer}`);
                }
            }

            return currentPlayer;
        }

        /**
         * ğŸ”¥ åœ¨ XiangqiTranslator é¡ä¸­æ›¿æ›åŸæœ‰çš„ boardToFEN æ–¹æ³•
         */
        boardToFEN(inputBoard = null, manualCurrentPlayer = null) {
            console.log('\nğŸ“ === ä¿®å¾©ç‰ˆ FEN ç”Ÿæˆé–‹å§‹ ===');

            // ğŸ¯ æ­¥é©Ÿ1: ç²å–çœŸæ­£çš„ç•¶å‰æ£‹ç›¤ç‹€æ…‹
            const boardInfo = this.getCurrentEffectiveBoard(inputBoard);

            if (!boardInfo || !boardInfo.board) {
                console.error('âŒ ç„¡æ³•ç²å–æœ‰æ•ˆçš„æ£‹ç›¤ç‹€æ…‹');
                return null;
            }

            let { board, source, pieceCount } = boardInfo;
            console.log(`ğŸ¯ ä½¿ç”¨æ£‹ç›¤ä¾†æº: ${source}ï¼ŒåŒ…å« ${pieceCount} å€‹æ£‹å­`);

            // ğŸ”¥ é—œéµä¿®æ­£ï¼šæª¢æŸ¥è¦–è§’æ˜¯å¦ç¿»è½‰
            const isFlipped = this.checkBoardFlipState();
            console.log(`ğŸ”„ æ£‹ç›¤è¦–è§’ç‹€æ…‹: ${isFlipped ? 'å·²ç¿»è½‰(é»‘æ–¹åœ¨ä¸‹)' : 'æ­£å¸¸(ç´…æ–¹åœ¨ä¸‹)'}`);

            // ğŸ”¥ å¦‚æœè¦–è§’ç¿»è½‰äº†ï¼Œéœ€è¦å°‡æ£‹ç›¤æ•¸æ“šç¿»è½‰å›æ¨™æº–åº§æ¨™
            if (isFlipped && source === 'dom_extraction') {
                console.log('âš ï¸ æª¢æ¸¬åˆ°è¦–è§’ç¿»è½‰ï¼Œæ­£åœ¨è½‰æ›DOMåº§æ¨™åˆ°æ¨™æº–åº§æ¨™...');
                board = this.flipBoardCoordinates(board);
                console.log('âœ… åº§æ¨™è½‰æ›å®Œæˆ');
            }

            // ğŸ¯ æ­¥é©Ÿ2: ç²å–ç•¶å‰è¼ªåˆ°èª°ä¸‹æ£‹
            let currentPlayer = manualCurrentPlayer || this.getCurrentPlayer();
            console.log(`ğŸ® ç•¶å‰è¼ªåˆ°: ${currentPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}`);

            // ğŸ¯ æ­¥é©Ÿ3: åˆ†ææ£‹ç›¤ç‹€æ…‹
            console.log('ğŸ” é–‹å§‹åˆ†ææ£‹ç›¤ç‹€æ…‹...');
            const analysis = this.analyzeBoardState(board);

            if (!analysis) {
                console.error('âŒ æ£‹ç›¤åˆ†æå¤±æ•—');
                return null;
            }

            console.log(`ğŸ“Š åˆ†æçµæœ: ${analysis.pieceCount.total} å€‹æ£‹å­ (ç´…${analysis.pieceCount.red}, é»‘${analysis.pieceCount.black})`);
            console.log(`ğŸ® éŠæˆ²éšæ®µ: ${this.getGamePhaseDescription(analysis.gamePhase)}`);

            // ğŸ¯ æ­¥é©Ÿ4: ç”Ÿæˆæ£‹ç›¤ FEN
            const { boardMatrix, boardSize } = analysis;
            let fenRows = [];

            for (let row = 0; row < boardSize.height; row++) {
                let rowStr = '';
                let emptyCount = 0;

                for (let col = 0; col < boardSize.width; col++) {
                    const piece = boardMatrix[row][col];

                    if (!piece) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            rowStr += emptyCount.toString();
                            emptyCount = 0;
                        }
                        if (piece.fenChar && piece.fenChar !== '?') {
                            rowStr += piece.fenChar;
                            console.log(`ğŸ¯ FEN è½‰æ›: ${piece.displayNotation} (å¼•æ“:${piece.engineNotation}) ${piece.color} ${piece.type} -> '${piece.fenChar}' [${piece.territory}]`);
                        } else {
                            console.warn(`âš ï¸ ç„¡æ³•è½‰æ›æ£‹å­: (${row},${col}) ${piece.type}`);
                            emptyCount++;
                        }
                    }
                }

                if (emptyCount > 0) {
                    rowStr += emptyCount.toString();
                }
                if (rowStr === '') {
                    rowStr = boardSize.width.toString();
                }

                fenRows.push(rowStr);
                console.log(`ğŸ“„ ç¬¬ ${row} è¡Œ FEN: "${rowStr}"`);
            }

            // ğŸ¯ æ­¥é©Ÿ5: çµ„è£å®Œæ•´ FEN
            const boardFEN = fenRows.join('/');
            const activeColor = currentPlayer === 'red' ? 'w' : 'b';
            const fen = `${boardFEN} ${activeColor} - - 0 1`;

            console.log(`âœ… ç”Ÿæˆçš„ FEN (åŸºæ–¼ ${source}${isFlipped ? ', å·²è™•ç†ç¿»è½‰' : ''}):`, fen);
            console.log(`ğŸ“Š FEN åŒ…å« ${analysis.pieceCount.total} å€‹æ£‹å­ï¼Œç•¶å‰è¼ªåˆ°${currentPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}`);

            // ğŸ¯ æ­¥é©Ÿ6: é¡å¤–ä¿¡æ¯è¨˜éŒ„
            const fenInfo = {
                fen: fen,
                boardSource: source,
                currentPlayer: currentPlayer,
                engineActiveColor: activeColor,
                pieceCount: analysis.pieceCount.total,
                gamePhase: analysis.gamePhase,
                wasFlipped: isFlipped,
                explanation: isFlipped
                    ? `è¦–è§’å·²ç¿»è½‰ï¼Œå·²å°‡DOMåº§æ¨™è½‰æ›ç‚ºæ¨™æº–åº§æ¨™å¾Œç”ŸæˆFEN`
                    : `è¦–è§’æ­£å¸¸ï¼Œç›´æ¥ç”ŸæˆFEN`
            };

            // é©—è­‰ FEN
            if (this.validateGeneratedFEN && typeof this.validateGeneratedFEN === 'function') {
                const isValid = this.validateGeneratedFEN(fen, board);
                if (!isValid) {
                    console.error('âŒ FEN é©—è­‰å¤±æ•—ï¼');
                    return null;
                }
                console.log('âœ… FEN é©—è­‰é€šé');
            }

            console.log('ğŸ“ === ä¿®å¾©ç‰ˆ FEN ç”Ÿæˆå®Œæˆ ===\n');

            // å­˜å„²å®Œæ•´ä¿¡æ¯
            if (typeof window !== 'undefined') {
                window.lastFenInfo = fenInfo;
            } else if (typeof global !== 'undefined') {
                global.lastFenInfo = fenInfo;
            }

            return fen;
        }

// ==================== æ–¹æ¡ˆ2: æ–°å¢è¼”åŠ©æ–¹æ³• ====================

        /**
         * ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ£‹ç›¤æ˜¯å¦ç¿»è½‰
         */
        checkBoardFlipState() {
            // æ–¹æ³•1: å¾ gameState ç²å–
            if (typeof gameState !== 'undefined' && gameState.isFlipped !== undefined) {
                return gameState.isFlipped;
            }

            // æ–¹æ³•2: å¾ currentSettings ç²å–
            if (typeof currentSettings !== 'undefined' && currentSettings.boardFlipped !== undefined) {
                return currentSettings.boardFlipped;
            }

            // æ–¹æ³•3: å¾ localStorage ç²å–
            try {
                const saved = localStorage.getItem('chessGameSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.boardFlipped !== undefined) {
                        return settings.boardFlipped;
                    }
                }
            } catch (e) {
                console.warn('ç„¡æ³•å¾ localStorage è®€å–ç¿»è½‰ç‹€æ…‹');
            }

            // æ–¹æ³•4: å¾ DOM æª¢æŸ¥ç¿»è½‰æŒ‡ç¤ºå™¨
            const flipIndicator = document.getElementById('flip-indicator');
            if (flipIndicator) {
                return true;
            }

            // é»˜èªï¼šæœªç¿»è½‰
            return false;
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šç¿»è½‰æ£‹ç›¤åº§æ¨™
         * å°‡DOMæå–çš„ç¿»è½‰è¦–è§’åº§æ¨™è½‰æ›ç‚ºæ¨™æº–åº§æ¨™(ç´…æ–¹åœ¨ä¸‹)
         */
        flipBoardCoordinates(board) {
            if (!board || !Array.isArray(board)) {
                console.error('âŒ ç„¡æ•ˆçš„æ£‹ç›¤æ•¸æ“š');
                return board;
            }

            const height = board.length;
            const width = board[0] ? board[0].length : 0;

            console.log(`ğŸ”„ é–‹å§‹ç¿»è½‰æ£‹ç›¤åº§æ¨™ (${height}x${width})`);

            // å‰µå»ºæ–°çš„æ£‹ç›¤æ•¸çµ„
            const flippedBoard = Array(height).fill().map(() => Array(width).fill(null));

            // ä¸Šä¸‹ç¿»è½‰
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const newRow = height - 1 - row; // ç¿»è½‰è¡Œ
                    flippedBoard[newRow][col] = board[row][col];

                    if (board[row][col]) {
                        console.log(`  ç¿»è½‰: (${row},${col}) -> (${newRow},${col}) ${board[row][col].type}`);
                    }
                }
            }

            console.log('âœ… æ£‹ç›¤åº§æ¨™ç¿»è½‰å®Œæˆ');
            return flippedBoard;
        }


        /**
         * ğŸ”¥ è¼”åŠ©æ–¹æ³•ï¼šç²å–éŠæˆ²éšæ®µæè¿°
         */
        getGamePhaseDescription(phase) {
            switch (phase) {
                case 'opening':
                    return 'é–‹å±€éšæ®µ';
                case 'middle':
                    return 'ä¸­å±€éšæ®µ';
                case 'endgame':
                    return 'æ®˜å±€éšæ®µ';
                default:
                    return 'æœªçŸ¥éšæ®µ';
            }
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šFENé©—è­‰æ–¹æ³•
         */
        validateGeneratedFEN(fen, originalBoard) {
            console.log('ğŸ” é©—è­‰ç”Ÿæˆçš„FEN...');

            if (!fen || typeof fen !== 'string') {
                console.error('âŒ FENæ ¼å¼ç„¡æ•ˆ');
                return false;
            }

            const parts = fen.split(' ');
            if (parts.length !== 6) {
                console.error('âŒ FENéƒ¨ä»¶æ•¸é‡ä¸æ­£ç¢º');
                return false;
            }

            const [boardPart, activeColor, castling, enPassant, halfmove, fullmove] = parts;

            // æª¢æŸ¥æ£‹ç›¤éƒ¨åˆ†
            const rows = boardPart.split('/');
            if (rows.length !== 10) {
                console.error('âŒ FENæ£‹ç›¤è¡Œæ•¸ä¸æ­£ç¢º');
                return false;
            }

            // æª¢æŸ¥æ¯è¡Œçš„é•·åº¦
            for (let i = 0; i < rows.length; i++) {
                let colCount = 0;
                for (const char of rows[i]) {
                    if (isNaN(char)) {
                        colCount += 1; // æ£‹å­
                    } else {
                        colCount += parseInt(char); // ç©ºæ ¼æ•¸
                    }
                }
                if (colCount !== 9) {
                    console.error(`âŒ ç¬¬${i}è¡Œåˆ—æ•¸ä¸æ­£ç¢º: ${colCount}`);
                    return false;
                }
            }

            // æª¢æŸ¥é¡è‰²æ¨™è¨˜
            if (activeColor !== 'w' && activeColor !== 'b') {
                console.error('âŒ ç•¶å‰ç©å®¶é¡è‰²æ¨™è¨˜ç„¡æ•ˆ');
                return false;
            }

            console.log('âœ… FENé©—è­‰é€šé');
            return true;
        }



        /**
         * ğŸ”¥ ä¿®æ­£ï¼šè§£æç§»å‹•å­—ç¬¦ä¸² - æ­£ç¢ºè™•ç†å¼•æ“æ ¼å¼è­˜åˆ¥
         * @param {string} move - ç§»å‹•å­—ç¬¦ä¸² (ä¾‹å¦‚: "g6g5" å¼•æ“æ ¼å¼ æˆ– "g3g4" é¡¯ç¤ºæ ¼å¼)
         * @param {boolean} isEngineFormat - æ˜¯å¦ç‚ºå¼•æ“æ ¼å¼ (é»˜èªfalseï¼Œå³é¡¯ç¤ºæ ¼å¼)
         * @returns {object} è§£æçµæœ
         */
        parseMove(move, isEngineFormat = false) {
            console.log(`ğŸ” è§£æç§»å‹•: ${move} (${isEngineFormat ? 'å¼•æ“æ ¼å¼' : 'é¡¯ç¤ºæ ¼å¼'})`);

            if (!this.isValidMoveFormat(move)) {
                console.error(`âŒ ç„¡æ•ˆçš„ç§»å‹•æ ¼å¼: ${move}`);
                return null;
            }

            try {
                // è§£æç§»å‹•çµ„ä»¶
                const fromCol = move[0];
                const fromRow = parseInt(move[1]);
                const toCol = move[2];
                const toRow = parseInt(move[3]);

                // ç²å–åˆ—ç´¢å¼•
                const fromColIndex = this.colLetters.indexOf(fromCol);
                const toColIndex = this.colLetters.indexOf(toCol);

                if (fromColIndex === -1 || toColIndex === -1) {
                    console.error(`âŒ ç„¡æ•ˆçš„åˆ—æ¨™è¨˜: ${fromCol} æˆ– ${toCol}`);
                    return null;
                }

                // æ ¹æ“šæ ¼å¼ç²å–æ­£ç¢ºçš„åº§æ¨™ä¿¡æ¯
                let fromCoordInfo, toCoordInfo;
                let displayMove, engineMove;

                if (isEngineFormat) {
                    // è¼¸å…¥æ˜¯å¼•æ“æ ¼å¼ (å¦‚ g6g5)
                    engineMove = move;
                    displayMove = this.convertEngineToDisplayMove(move);

                    // å¼•æ“æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨åŸå§‹è¡Œè™Ÿ
                    fromCoordInfo = this.getCoordinateInfo(fromRow, fromColIndex);
                    toCoordInfo = this.getCoordinateInfo(toRow, toColIndex);

                } else {
                    // è¼¸å…¥æ˜¯é¡¯ç¤ºæ ¼å¼ (å¦‚ g3g4)
                    displayMove = move;
                    engineMove = this.convertDisplayToEngineMove(move);

                    // é¡¯ç¤ºæ ¼å¼ï¼šéœ€è¦ç¿»è½‰è¡Œè™Ÿä¾†ç²å–å¼•æ“åº§æ¨™ä¿¡æ¯
                    const engineFromRow = this.flipCoordinate(fromRow);
                    const engineToRow = this.flipCoordinate(toRow);
                    fromCoordInfo = this.getCoordinateInfo(engineFromRow, fromColIndex);
                    toCoordInfo = this.getCoordinateInfo(engineToRow, toColIndex);
                }

                const parseResult = {
                    // åŸå§‹ä¿¡æ¯
                    originalMove: move,
                    originalFormat: isEngineFormat ? 'engine' : 'display',

                    // é›™æ ¼å¼ç§»å‹•
                    engineMove: engineMove,
                    displayMove: displayMove,

                    // èµ·å§‹ä½ç½® (çµ±ä¸€ä½¿ç”¨å¼•æ“è¡Œè™Ÿä½œç‚ºåŸºæº–)
                    from: {
                        col: fromCol,
                        colIndex: fromColIndex,
                        engineRow: isEngineFormat ? fromRow : this.flipCoordinate(fromRow),
                        displayRow: isEngineFormat ? this.flipCoordinate(fromRow) : fromRow,
                        engineNotation: fromCoordInfo.engineNotation,
                        displayNotation: fromCoordInfo.displayNotation,
                        territory: fromCoordInfo.territory
                    },

                    // ç›®æ¨™ä½ç½® (çµ±ä¸€ä½¿ç”¨å¼•æ“è¡Œè™Ÿä½œç‚ºåŸºæº–)
                    to: {
                        col: toCol,
                        colIndex: toColIndex,
                        engineRow: isEngineFormat ? toRow : this.flipCoordinate(toRow),
                        displayRow: isEngineFormat ? this.flipCoordinate(toRow) : toRow,
                        engineNotation: toCoordInfo.engineNotation,
                        displayNotation: toCoordInfo.displayNotation,
                        territory: toCoordInfo.territory
                    },

                    // ç§»å‹•åˆ†æ (åŸºæ–¼å¼•æ“åº§æ¨™)
                    analysis: {
                        isHorizontal: (isEngineFormat ? fromRow : this.flipCoordinate(fromRow)) === (isEngineFormat ? toRow : this.flipCoordinate(toRow)),
                        isVertical: fromCol === toCol,
                        isDiagonal: Math.abs(fromColIndex - toColIndex) === Math.abs((isEngineFormat ? fromRow : this.flipCoordinate(fromRow)) - (isEngineFormat ? toRow : this.flipCoordinate(toRow))),
                        distance: {
                            horizontal: Math.abs(toColIndex - fromColIndex),
                            vertical: Math.abs((isEngineFormat ? toRow : this.flipCoordinate(toRow)) - (isEngineFormat ? fromRow : this.flipCoordinate(fromRow))),
                            total: Math.abs(toColIndex - fromColIndex) + Math.abs((isEngineFormat ? toRow : this.flipCoordinate(toRow)) - (isEngineFormat ? fromRow : this.flipCoordinate(fromRow)))
                        },
                        crossTerritory: fromCoordInfo.territory !== toCoordInfo.territory,
                        direction: this.getMoveDirection(
                            fromColIndex,
                            isEngineFormat ? fromRow : this.flipCoordinate(fromRow),
                            toColIndex,
                            isEngineFormat ? toRow : this.flipCoordinate(toRow)
                        )
                    }
                };

                this.logMoveParseResult(parseResult);
                return parseResult;

            } catch (error) {
                console.error(`âŒ è§£æç§»å‹•æ™‚ç™¼ç”ŸéŒ¯èª¤: ${move}`, error);
                return null;
            }
        }
        getMoveDirection(fromCol, fromRow, toCol, toRow) {
            const deltaCol = toCol - fromCol;
            const deltaRow = toRow - fromRow;

            if (deltaCol === 0 && deltaRow === 0) return 'stay';
            if (deltaCol === 0) return deltaRow > 0 ? 'down' : 'up';
            if (deltaRow === 0) return deltaCol > 0 ? 'right' : 'left';

            // å¯¹è§’çº¿ç§»åŠ¨
            const horizontal = deltaCol > 0 ? 'right' : 'left';
            const vertical = deltaRow > 0 ? 'down' : 'up';
            return `${vertical}-${horizontal}`;
        }
    }



    // ============================================
    // ğŸ”§ XiangqiGameAI é¡åˆ¥ - åŠ å…¥ç›£æ§æ•´åˆ
    // ============================================
    /**
     * ğŸ”¥ æ•´åˆåˆ°ä½ çš„è±¡æ£‹éŠæˆ²çš„ç°¡å–®ä»‹é¢ - åŠ å…¥ç›£æ§ç‰ˆ
     */
    class XiangqiGameAI {
        constructor(yourBoardArray) {
            this.board = yourBoardArray;
            this.ai = new CompleteXiangqiAI();

            // ğŸ”¥ æ–°å¢ï¼šè¨­å®šå…¨å±€å¼•ç”¨æŒ‡å‘å…§éƒ¨çš„ CompleteXiangqiAI
            if (typeof window !== 'undefined') {
                window.xiangqiAI = this.ai;  // æŒ‡å‘å…§éƒ¨çš„ CompleteXiangqiAI
                console.log('âœ… window.xiangqiAI å·²è¨­ç‚º CompleteXiangqiAI å¯¦ä¾‹');
            }

            this.isAIMode = false;

            // æ–°å¢ï¼šéŠæˆ²æ¨¡å¼å±¬æ€§
            this.gameMode = null;

            // **é—œéµä¿®æ­£ï¼šæ·»åŠ ç¼ºå¤±çš„å±¬æ€§**
            this.analysisMode = 'analysis';  // é»˜èªåˆ†ææ¨¡å¼
            this.difficulty = 'medium';      // é»˜èªé›£åº¦

            console.log('ğŸ”§ XiangqiGameAI åˆå§‹åŒ– - æ¨¡å¼:', this.analysisMode, 'é›£åº¦:', this.difficulty);
        }

        /**
         * åˆå§‹åŒ– AIï¼ˆåœ¨ä½ çš„éŠæˆ²é–‹å§‹æ™‚å‘¼å«ä¸€æ¬¡ï¼‰ - åŠ å…¥ç›£æ§
         */
        async initializeAI() {
            try {
                console.log('ğŸ¤– æ­£åœ¨åˆå§‹åŒ– AI å¼•æ“...');

                // ğŸ”§ é–‹å§‹ç›£æ§
                if (typeof aiMonitor !== 'undefined') {
                    aiMonitor.startMonitoring();
                }

                const success = await this.ai.initialize();

                if (success) {
                    console.log('ğŸ‰ AI å·²æº–å‚™å°±ç·’ï¼');

                    // ğŸ”§ æ¨™è¨˜ AI å®Œå…¨å°±ç·’
                    if (typeof aiMonitor !== 'undefined') {
                        aiMonitor.markCheckpoint('aiReady');
                    }

                    console.log('ğŸ“Š ç•¶å‰è¨­å®š - æ¨¡å¼:', this.analysisMode, 'é›£åº¦:', this.difficulty);
                    return true;
                } else {
                    console.error('âŒ AI åˆå§‹åŒ–å¤±æ•—');

                    // ğŸ”§ åˆå§‹åŒ–å¤±æ•—æ™‚é¡¯ç¤ºè­¦å‘Š
                    if (typeof aiMonitor !== 'undefined') {
                        aiMonitor.showAIWarning('error');
                    }

                    return false;
                }
            } catch (error) {
                console.error('âŒ AI åˆå§‹åŒ–éŒ¯èª¤:', error);

                // ğŸ”§ éŒ¯èª¤æ™‚é¡¯ç¤ºè­¦å‘Š
                if (typeof aiMonitor !== 'undefined') {
                    aiMonitor.showAIWarning('error');
                }

                return false;
            }
        }

        /**
         * æ–°å¢ï¼šè¨­å®šç•¶å‰éŠæˆ²æ¨¡å¼ï¼ˆä»£ç†åˆ°å…§éƒ¨ AIï¼‰
         */
        setCurrentMode(mode) {
            this.gameMode = mode;

            // ä»£ç†åˆ°å…§éƒ¨çš„ CompleteXiangqiAI
            if (this.ai && typeof this.ai.setCurrentMode === 'function') {
                this.ai.setCurrentMode(mode);
            } else if (this.ai) {
                // å¦‚æœæ²’æœ‰æ–¹æ³•ï¼Œç›´æ¥è¨­å®šå±¬æ€§
                this.ai.gameMode = mode;
            }

            console.log(`ğŸ”§ [MODE] XiangqiGameAI è¨­å®šéŠæˆ²æ¨¡å¼:`, mode);
        }

        /**
         * ğŸ”¥ ç²å¾— AI å»ºè­°ï¼ˆä½ åœ¨æŒ‰éˆ•é»æ“Šæ™‚å‘¼å«é€™å€‹ï¼‰
         */
        async getAISuggestion() {
            console.log('ğŸ” èª¿ç”¨æ™‚æ©Ÿ:', new Date().toLocaleTimeString());
            console.log('ğŸ” èª¿ç”¨å †æ£§:', new Error().stack.split('\n')[2]); // çœ‹æ˜¯èª°èª¿ç”¨çš„
            console.log('ğŸ” å¼•æ“ç‹€æ…‹:', {
                analysisMode: this.analysisMode,
                difficulty: this.difficulty,
                isReady: this.ai?.isReady,
                isThinking: this.ai?.isThinking,
                hasEngine: this.ai?.hasEngine
            });

            try {
                const suggestion = await this.ai.getAISuggestion(this.board);
                console.log('ğŸ¤– AI å»ºè­°:', suggestion);
                return suggestion;
            } catch (error) {
                console.error('âŒ ç²å– AI å»ºè­°å¤±æ•—:', error);

                // ğŸ”§ å¦‚æœ AI åŠŸèƒ½å¤±æ•—ï¼Œå¯èƒ½æ˜¯å¼•æ“æ›æ‰äº†
                if (typeof aiMonitor !== 'undefined' && !aiMonitor.warningShown) {
                    aiMonitor.showAIWarning('not_working');
                }

                return null;
            }
        }

        /**
         * ğŸ”¥ è®“ AI ä¸‹ä¸€æ­¥ï¼ˆAI å°æˆ°æ¨¡å¼ï¼‰
         */
        async makeAIMove() {
            try {
                const suggestion = await this.getAISuggestion();
                if (suggestion) {
                    const success = this.ai.executeAIMove(this.board, suggestion);
                    if (success) {
                        console.log('âœ… AI å·²ä¸‹æ£‹:', suggestion.description);
                        return suggestion;
                    }
                }
                return null;
            } catch (error) {
                console.error('âŒ AI ä¸‹æ£‹å¤±æ•—:', error);

                // ğŸ”§ å¦‚æœ AI åŠŸèƒ½å¤±æ•—ï¼Œå¯èƒ½æ˜¯å¼•æ“æ›æ‰äº†
                if (typeof aiMonitor !== 'undefined' && !aiMonitor.warningShown) {
                    aiMonitor.showAIWarning('not_working');
                }

                return null;
            }
        }

        /**
         * è¨­å®š AI é›£åº¦ - **ä¿®æ­£ç‰ˆ**
         */
        setDifficulty(level) {
            this.difficulty = level;
            this.ai.setDifficulty(level);
            console.log(`ğŸ® é›£åº¦è¨­å®šç‚º: ${level}`);
        }

        /**
         * è¨­å®šåˆ†ææ¨¡å¼ - **æ–°å¢æ–¹æ³•**
         */
        setAnalysisMode(mode) {
            this.analysisMode = mode;
            console.log(`ğŸ”§ åˆ†ææ¨¡å¼è¨­å®šç‚º: ${mode}`);
        }

        /**
         * åˆ‡æ› AI å°æˆ°æ¨¡å¼
         */
        toggleAIMode() {
            this.isAIMode = !this.isAIMode;
            console.log('ğŸ¯ AI å°æˆ°æ¨¡å¼:', this.isAIMode ? 'é–‹å•Ÿ' : 'é—œé–‰');
            return this.isAIMode;
        }

        /**
         * **æ–°å¢ï¼šä»£ç†åˆ°å…§éƒ¨ AI çš„æ–¹æ³•**
         */
        getDifficultyDepth() {
            if (this.ai && this.ai.getDifficultyDepth) {
                return this.ai.getDifficultyDepth();
            }
            // å‚™ç”¨é‚è¼¯
            switch (this.difficulty) {
                case 'easy': return 3;
                case 'medium': return 5;
                case 'hard': return 7;
                default: return 5;
            }
        }

        /**
         * åœ¨ XiangqiGameAI ç±»ä¸­æ·»åŠ è¿™ä¸ªæ–¹æ³•ï¼Œä½œä¸º CompleteXiangqiAI.getAISuggestionWithBattleMode çš„ä»£ç†
         */
        async getAISuggestionWithBattleMode(boardArray, battleDifficulty) {
            console.log(`ğŸ”§ [PROXY] XiangqiGameAI ä»£ç†è°ƒç”¨ getAISuggestionWithBattleModeï¼Œéš¾åº¦: ${battleDifficulty}`);

            try {
                // ä»£ç†åˆ°å†…éƒ¨çš„ CompleteXiangqiAI å®ä¾‹
                if (this.ai && typeof this.ai.getAISuggestionWithBattleMode === 'function') {
                    console.log(`âš”ï¸ [PROXY] è°ƒç”¨å†…éƒ¨ AI çš„å¯¹æˆ˜æ–¹æ³•`);
                    const suggestion = await this.ai.getAISuggestionWithBattleMode(boardArray, battleDifficulty);
                    console.log(`âœ… [PROXY] å†…éƒ¨ AI å¯¹æˆ˜æ–¹æ³•å®Œæˆï¼Œæ·±åº¦: ${suggestion?.usedDepth}`);
                    return suggestion;
                } else {
                    console.error(`âŒ [PROXY] å†…éƒ¨ AI æ²¡æœ‰ getAISuggestionWithBattleMode æ–¹æ³•`);
                    console.error(`âŒ [PROXY] this.ai ç±»å‹: ${this.ai?.constructor?.name}`);
                    throw new Error('å†…éƒ¨ AI å¼•æ“ç¼ºå°‘ getAISuggestionWithBattleMode æ–¹æ³•');
                }
            } catch (error) {
                console.error('âŒ [PROXY] ä»£ç†è°ƒç”¨å¤±è´¥:', error);

                // ğŸ”§ å¦‚æœä»£ç†èª¿ç”¨å¤±æ•—ï¼Œå¯èƒ½æ˜¯å¼•æ“å•é¡Œ
                if (typeof aiMonitor !== 'undefined' && !aiMonitor.warningShown) {
                    aiMonitor.showAIWarning('not_working');
                }

                throw error;
            }
        }

        /**
         * **æ–°å¢ï¼šç²å–å°æˆ°ç§»å‹•å»ºè­°**
         */
        async getBattleMoveSuggestion(boardArray) {
            // è‡¨æ™‚åˆ‡æ›åˆ°å°æˆ°æ¨¡å¼
            const originalMode = this.analysisMode;
            this.analysisMode = 'battle';

            try {
                const suggestion = await this.getAISuggestion(boardArray);
                if (suggestion) {
                    suggestion.isBattleMove = true;
                    suggestion.battleDepth = this.getDifficultyDepth();
                    suggestion.difficulty = this.difficulty;
                }
                return suggestion;
            } catch (error) {
                console.error('âŒ ç²å–å°æˆ°å»ºè­°å¤±æ•—:', error);

                // ğŸ”§ å¦‚æœå¤±æ•—ï¼Œå¯èƒ½æ˜¯å¼•æ“å•é¡Œ
                if (typeof aiMonitor !== 'undefined' && !aiMonitor.warningShown) {
                    aiMonitor.showAIWarning('not_working');
                }

                throw error;
            } finally {
                this.analysisMode = originalMode;
            }
        }
    }

    /**
     * ğŸ¯ AI åˆ†æç®¡ç†å™¨ - ä¿®æ­£ç‰ˆ
     */
    class AIAnalysisManager {
        constructor() {
            this.isAnalyzing = false;
            this.currentSuggestion = null;
            this.arrowElements = [];  // ğŸ”¥ æ”¹ç‚ºé™£åˆ—ï¼Œæ”¯æ´å¤šå€‹ç®­é ­
            // åˆå§‹åŒ– translator
            this.translator = new XiangqiTranslator();

            this.latestCpScore = null;
            this.cpScoreHistory = [];
        }

        /**
         * ğŸ”¥ ä¿®æ”¹: analyzePosition - è™•ç†æ–°çš„åˆ†æçµæœæ ¼å¼
         */
        async analyzePosition() {
            if (this.isAnalyzing) {
                console.log('âš ï¸ AI æ­£åœ¨åˆ†æä¸­ï¼Œè«‹ç¨å€™...');
                return;
            }

            if (!gameAI || !gameAI.ai.isAIReady()) {
                showAINotReady();
                return;
            }

            try {
                this.isAnalyzing = true;
                this.showAnalyzingStatus(true);

                console.log('ğŸ¤– é–‹å§‹ AI åˆ†æç•¶å‰å±€é¢...');

                const suggestion = await gameAI.getAISuggestion();

                console.log('âœ… AI åˆ†æå®Œæˆ:', suggestion);

                // ğŸ”¥ æª¢æŸ¥æ˜¯å¦å°‡æ­»
                if (suggestion && suggestion.isCheckmate) {
                    console.log('ğŸ å±€é¢å·²å°‡æ­»ï¼');
                    const winner = gameState.currentTurn === 'red' ? 'é»‘æ–¹' : 'ç´…æ–¹';
                    const loser = gameState.currentTurn === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
                    this.displayCheckmateMessage(winner, loser);
                    return;
                }

                // ğŸ”¥ æª¢æŸ¥æ˜¯å¦ç‚ºé€£çºŒå°å¼ˆæ¨¡å¼
                if (suggestion && suggestion.isSequence) {
                    console.log('ğŸ”„ é¡¯ç¤ºé€£çºŒå°å¼ˆçµæœ');
                    this.displaySequenceResult(suggestion);
                    return;
                }

                // ğŸ”¥ æª¢æŸ¥æ˜¯å¦ç‚º MultiPV çµæœ
                if (suggestion && suggestion.moves && suggestion.moves.length > 0) {
                    console.log(`ğŸ“Š é¡¯ç¤º ${suggestion.moves.length} å€‹åˆ†æçµæœ`);
                    this.displayMultiPVResults(suggestion);
                    return;
                }

                // å–®ä¸€çµæœ (èˆŠæ ¼å¼ç›¸å®¹)
                this.currentSuggestion = suggestion;
                this.displaySuggestion(suggestion);

            } catch (error) {
                console.error('âŒ AI åˆ†æå¤±æ•—:', error);
                alert('AI åˆ†æå¤±æ•—: ' + error.message);
            } finally {
                this.isAnalyzing = false;
                this.showAnalyzingStatus(false);
            }
        }

        /**
         * ğŸ”¥ æ–°å¢: é¡¯ç¤º MultiPV çµæœ (å‰2é¸/å‰3é¸)
         */
        displayMultiPVResults(suggestion) {
            console.log('ğŸ¨ é¡¯ç¤º MultiPV çµæœ:', suggestion.moves.length, 'å€‹èµ°æ³•');

            this.clearHighlight();

            const isFlipped = this.checkBoardFlipState();
            const currentPlayer = this.getCurrentPlayer();

            // ç‚ºæ¯å€‹èµ°æ³•ç¹ªè£½ç®­é ­
            suggestion.moves.forEach((move, index) => {
                let fromCoord, toCoord;

                if (isFlipped) {
                    fromCoord = this.convertAICoordFlipped(move.from);
                    toCoord = this.convertAICoordFlipped(move.to);
                } else {
                    fromCoord = this.normalizeCoordinate(move.from);
                    toCoord = this.normalizeCoordinate(move.to);
                }

                if (fromCoord && toCoord) {
                    this.drawArrowWithLabel(fromCoord, toCoord, index + 1, move.cpScore);
                }
            });

            // é¡¯ç¤ºæ–‡å­—èªªæ˜
            this.showMultiPVText(suggestion, isFlipped);

            // 10ç§’å¾Œè‡ªå‹•æ¸…é™¤
            setTimeout(() => {
                this.clearHighlight();
            }, 25000);
        }

        /**
         * ğŸ”¥ æ–°å¢: é¡¯ç¤ºé€£çºŒå°å¼ˆçµæœ (5æ­¥é›™æ–¹å°å¼ˆ)
         */
        displaySequenceResult(suggestion) {
            console.log('ğŸ”„ é¡¯ç¤ºé€£çºŒå°å¼ˆçµæœ:', suggestion.sequence.length, 'æ­¥');

            this.clearHighlight();

            const isFlipped = this.checkBoardFlipState();

            // ç‚ºæ¯ä¸€æ­¥ç¹ªè£½ç®­é ­
            suggestion.sequence.forEach((move, index) => {
                let fromCoord, toCoord;

                if (isFlipped) {
                    fromCoord = this.convertAICoordFlipped(move.from);
                    toCoord = this.convertAICoordFlipped(move.to);
                } else {
                    fromCoord = this.normalizeCoordinate(move.from);
                    toCoord = this.normalizeCoordinate(move.to);
                }

                if (fromCoord && toCoord) {
                    // ä½¿ç”¨ä¸åŒé¡è‰²å€åˆ†ç´…é»‘
                    const color = move.player === 'red' ? '#ff4444' : '#444444';
                    this.drawArrowWithLabel(fromCoord, toCoord, index + 1, null, color);
                }
            });

            // é¡¯ç¤ºæ–‡å­—èªªæ˜
            this.showSequenceText(suggestion, isFlipped);

            // 15ç§’å¾Œè‡ªå‹•æ¸…é™¤
            setTimeout(() => {
                this.clearHighlight();
            }, 20000);
        }

        /**
         * ğŸ”¥ æ–°å¢: ç¹ªè£½å¸¶æœ‰ç·¨è™Ÿæ¨™è¨˜çš„ç®­é ­
         * @param {Object} from - èµ·å§‹åº§æ¨™ {row, col}
         * @param {Object} to - ç›®æ¨™åº§æ¨™ {row, col}
         * @param {number} label - ç®­é ­ç·¨è™Ÿ (1, 2, 3...)
         * @param {number|null} score - CP åˆ†æ•¸ (å¯é¸)
         * @param {string} color - ç®­é ­é¡è‰² (å¯é¸ï¼Œé è¨­ç¶ è‰²)
         */
        drawArrowWithLabel(from, to, label, score = null, color = '#00ff88') {
            try {
                console.log(`ğŸ¨ ç¹ªè£½ç®­é ­ #${label}:`, from, '->', to);

                const fromCell = this.findCell(from.row, from.col);
                const toCell = this.findCell(to.row, to.col);

                if (!fromCell || !toCell) {
                    console.warn(`âš ï¸ ç„¡æ³•æ‰¾åˆ°æ ¼å­`);
                    return;
                }

                const board = this.findChessboard();
                if (!board) {
                    console.warn('âš ï¸ ç„¡æ³•æ‰¾åˆ°æ£‹ç›¤å®¹å™¨');
                    return;
                }

                const fromRect = fromCell.getBoundingClientRect();
                const toRect = toCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();

                const fromX = fromRect.left + fromRect.width / 2 - boardRect.left;
                const fromY = fromRect.top + fromRect.height / 2 - boardRect.top;
                const toX = toRect.left + toRect.width / 2 - boardRect.left;
                const toY = toRect.top + toRect.height / 2 - boardRect.top;

                const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                const cellSize = Math.min(fromRect.width, fromRect.height);

                const strokeWidth = Math.max(2, Math.min(4, cellSize * 0.08));
                const arrowSize = Math.max(6, Math.min(10, cellSize * 0.2));

                // å‰µå»º SVG å®¹å™¨
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'ai-suggestion-arrow');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '1000';

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

                // å‹•ç•«æ¨£å¼
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
                @keyframes dash {
                    to { stroke-dashoffset: -15; }
                }
                .ai-arrow-glow {
                    filter: drop-shadow(0 0 3px ${color}aa);
                }
            `;
                defs.appendChild(style);

                // ç®­é ­æ¨™è¨˜
                const markerId = `ai-arrowhead-${label}`;
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', arrowSize.toString());
                marker.setAttribute('markerHeight', (arrowSize * 0.8).toString());
                marker.setAttribute('refX', (arrowSize - 1).toString());
                marker.setAttribute('refY', (arrowSize * 0.4).toString());
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');

                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = `0 0, ${arrowSize} ${arrowSize * 0.4}, 0 ${arrowSize * 0.8}`;
                polygon.setAttribute('points', points);
                polygon.setAttribute('fill', color);
                polygon.setAttribute('stroke', color);
                polygon.setAttribute('stroke-width', '0.5');

                marker.appendChild(polygon);
                defs.appendChild(marker);

                // èƒŒæ™¯ç™¼å…‰ç·šæ¢
                const glowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                glowLine.setAttribute('x1', fromX);
                glowLine.setAttribute('y1', fromY);
                glowLine.setAttribute('x2', toX);
                glowLine.setAttribute('y2', toY);
                glowLine.setAttribute('stroke', color);
                glowLine.setAttribute('stroke-width', (strokeWidth + 2).toString());
                glowLine.setAttribute('opacity', '0.3');
                glowLine.setAttribute('stroke-linecap', 'round');

                // ä¸»ç®­é ­ç·šæ¢
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromX);
                line.setAttribute('y1', fromY);
                line.setAttribute('x2', toX);
                line.setAttribute('y2', toY);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', strokeWidth.toString());
                line.setAttribute('marker-end', `url(#${markerId})`);
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('class', 'ai-arrow-glow');

                const dashArray = Math.max(8, cellSize * 0.15);
                const dashGap = dashArray * 0.6;
                line.style.strokeDasharray = `${dashArray},${dashGap}`;
                line.style.animation = 'dash 1.2s linear infinite';

                // ğŸ”¥ æ–°å¢: ç·¨è™Ÿæ¨™è¨˜ (åœ“åœˆ + æ•¸å­—)
                const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                // æ¨™è¨˜ä½ç½®ï¼šç®­é ­ä¸­é»åå‘èµ·é»
                const labelX = fromX + (toX - fromX) * 0.35;
                const labelY = fromY + (toY - fromY) * 0.35;
                const labelRadius = Math.max(12, cellSize * 0.15);

                // åœ“åœˆèƒŒæ™¯
                const labelCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                labelCircle.setAttribute('cx', labelX);
                labelCircle.setAttribute('cy', labelY);
                labelCircle.setAttribute('r', labelRadius);
                labelCircle.setAttribute('fill', color);
                labelCircle.setAttribute('stroke', 'white');
                labelCircle.setAttribute('stroke-width', '2');
                labelCircle.setAttribute('opacity', '0.95');

                // æ•¸å­—æ–‡å­—
                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', labelX);
                labelText.setAttribute('y', labelY);
                labelText.setAttribute('text-anchor', 'middle');
                labelText.setAttribute('dominant-baseline', 'central');
                labelText.setAttribute('fill', 'white');
                labelText.setAttribute('font-size', (labelRadius * 1.2).toString());
                labelText.setAttribute('font-weight', 'bold');
                labelText.setAttribute('font-family', 'Arial, sans-serif');
                labelText.textContent = label.toString();

                labelGroup.appendChild(labelCircle);
                labelGroup.appendChild(labelText);

                // ğŸ”¥ æ–°å¢: åˆ†æ•¸æ¨™è¨˜ (å¦‚æœæœ‰)
                if (score !== null && score !== undefined) {
                    const scoreX = toX + (toX - fromX) * 0.1;
                    const scoreY = toY + (toY - fromY) * 0.1;

                    const scoreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    scoreText.setAttribute('x', scoreX);
                    scoreText.setAttribute('y', scoreY - labelRadius - 5);
                    scoreText.setAttribute('text-anchor', 'middle');
                    scoreText.setAttribute('fill', color);
                    scoreText.setAttribute('font-size', (labelRadius * 0.8).toString());
                    scoreText.setAttribute('font-weight', 'bold');
                    scoreText.setAttribute('stroke', 'white');
                    scoreText.setAttribute('stroke-width', '1');
                    scoreText.setAttribute('paint-order', 'stroke');
                    scoreText.textContent = score > 0 ? `+${score}` : score.toString();

                    labelGroup.appendChild(scoreText);
                }

                // çµ„è£ SVG
                svg.appendChild(defs);
                svg.appendChild(glowLine);
                svg.appendChild(line);
                svg.appendChild(labelGroup);

                board.style.position = 'relative';
                board.appendChild(svg);

                // ğŸ”¥ å„²å­˜ç®­é ­å…ƒç´ 
                this.arrowElements.push(svg);

                console.log(`âœ… ç®­é ­ #${label} å·²ç¹ªè£½`);

            } catch (error) {
                console.error(`âŒ ç¹ªè£½ç®­é ­ #${label} å¤±æ•—:`, error);
            }
        }

        /**
         * ğŸ”¥ æ˜¾ç¤º MultiPV æ–‡å­—è¯´æ˜ (ä¿®æ”¹ç‰ˆ - æ·»åŠ å°†æ­»æè¿°)
         */
        showMultiPVText(suggestion, isFlipped) {
            const oldText = document.getElementById('ai-suggestion-text');
            if (oldText) oldText.remove();

            const textDiv = document.createElement('div');
            textDiv.id = 'ai-suggestion-text';
            textDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        font-size: 16px;
        z-index: 1001;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        max-width: 350px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        animation: slideIn 0.3s ease-out;
    `;

            // ç”Ÿæˆæ¯å€‹èµ°æ³•çš„èªªæ˜
            const movesHtml = suggestion.moves.map((move, index) => {
                const notation = isFlipped
                    ? this.convertToNotationFlipped(this.normalizeCoordinate(move.from), this.normalizeCoordinate(move.to), move)
                    : this.convertMoveToNotation(move.moveString);

                // ğŸ”¥ å¤„ç†åˆ†æ•°æ˜¾ç¤º - æ·»åŠ å°†æ­»æè¿°
                let scoreText = '';
                if (move.cpScore !== null && move.cpScore !== undefined) {
                    const score = move.cpScore;
                    const absScore = Math.abs(score);
                    const color = score > 0 ? '#00ff88' : '#ff4444';

                    if (absScore >= 9900) {
                        // æ˜¾ç¤ºå°†æ­»ä¿¡æ¯
                        const steps = 9999 - absScore;
                        let mateDesc = '';
                        if (score > 0) {
                            mateDesc = steps === 0 ? 'é»‘æ–¹å·²è¢«å°†æ­»' : `${steps}æ­¥å°†æ­»é»‘æ–¹`;
                        } else {
                            mateDesc = steps === 0 ? 'çº¢æ–¹å·²è¢«å°†æ­»' : `${steps}æ­¥è¢«é»‘æ–¹å°†æ­»`;
                        }
                        scoreText = `<span style="color: ${color};">(${score > 0 ? '+' : ''}${score}) ${mateDesc}</span>`;
                    } else {
                        // æ˜¾ç¤ºæ™®é€šåˆ†æ•°
                        scoreText = `<span style="color: ${color};">(${score > 0 ? '+' : ''}${score})</span>`;
                    }
                }

                return `
            <div style="
                padding: 10px;
                margin-bottom: 8px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                border-left: 4px solid #00ff88;
            ">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="
                        width: 28px;
                        height: 28px;
                        background: #00ff88;
                        color: black;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 14px;
                    ">${index + 1}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 20px; font-weight: bold; letter-spacing: 2px;">
                            ${notation}
                        </div>
                        <div style="font-size: 12px; opacity: 0.8; margin-top: 4px;">
                            ${move.description} ${scoreText}
                        </div>
                    </div>
                </div>
            </div>
        `;
            }).join('');

            textDiv.innerHTML = `
        <style>
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            #ai-suggestion-text button:hover {
                background: #00dd77 !important;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            }
        </style>
        <div style="font-weight: bold; color: #00ff88; margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
            <span>ğŸ¤– AI åˆ†æ - å‰ ${suggestion.moves.length} é¸</span>
        </div>

        ${movesHtml}

        ${isFlipped ? `
            <div style="font-size: 11px; color: rgba(255, 136, 0, 0.8); margin-top: 10px; text-align: center; background: rgba(255, 136, 0, 0.1); padding: 5px; border-radius: 4px;">
                ğŸ”„ è¦–è§’å·²ç¿»è½‰ (é»‘æ–¹åœ¨ä¸‹)
            </div>
        ` : ''}

        <button onclick="aiAnalysisManager.clearHighlight()"
                style="width: 100%; padding: 10px; background: #00ff88; color: black; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.2s; margin-top: 15px;">
            æ¸…é™¤å»ºè­°
        </button>
    `;

            document.body.appendChild(textDiv);
        }


        /**
         * ğŸ”¥ æ–°å¢: é¡¯ç¤ºé€£çºŒå°å¼ˆæ–‡å­—èªªæ˜
         */
        showSequenceText(suggestion, isFlipped) {
            const oldText = document.getElementById('ai-suggestion-text');
            if (oldText) oldText.remove();

            const textDiv = document.createElement('div');
            textDiv.id = 'ai-suggestion-text';
            textDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            font-size: 16px;
            z-index: 1001;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideIn 0.3s ease-out;
        `;

            // ç”Ÿæˆæ¯ä¸€æ­¥çš„èªªæ˜
            const stepsHtml = suggestion.sequence.map((move, index) => {
                const playerColor = move.player === 'red' ? '#ff4444' : '#444444';
                const playerName = move.player === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';

                const notation = isFlipped
                    ? this.convertToNotationFlipped(this.normalizeCoordinate(move.from), this.normalizeCoordinate(move.to), move)
                    : this.convertMoveToNotation(move.moveString);

                return `
                <div style="
                    padding: 8px 12px;
                    margin-bottom: 6px;
                    background: rgba(0, 0, 0, 0.2);
                    border-radius: 6px;
                    border-left: 4px solid ${playerColor};
                    display: flex;
                    align-items: center;
                    gap: 10px;
                ">
                    <div style="
                        width: 26px;
                        height: 26px;
                        background: ${playerColor};
                        color: white;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 13px;
                    ">${index + 1}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: ${playerColor}; margin-bottom: 2px;">
                            ${playerName}
                        </div>
                        <div style="font-size: 18px; font-weight: bold; letter-spacing: 2px;">
                            ${notation}
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            textDiv.innerHTML = `
            <style>
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                #ai-suggestion-text button:hover {
                    background: #00dd77 !important;
                    transform: translateY(-2px);
                    box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
                }
            </style>
            <div style="font-weight: bold; color: #00ff88; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
                <span>ğŸ”„ é›™æ–¹å°å¼ˆ ${suggestion.steps} æ­¥</span>
            </div>

            ${stepsHtml}

            ${isFlipped ? `
                <div style="font-size: 11px; color: rgba(255, 136, 0, 0.8); margin-top: 10px; text-align: center; background: rgba(255, 136, 0, 0.1); padding: 5px; border-radius: 4px;">
                    ğŸ”„ è¦–è§’å·²ç¿»è½‰ (é»‘æ–¹åœ¨ä¸‹)
                </div>
            ` : ''}

            <button onclick="aiAnalysisManager.clearHighlight()"
                    style="width: 100%; padding: 10px; background: #00ff88; color: black; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: all 0.2s; margin-top: 15px;">
                æ¸…é™¤å»ºè­°
            </button>
        `;

            document.body.appendChild(textDiv);
        }



        /**
         * ğŸ é¡¯ç¤ºå°‡æ­»è¨Šæ¯ UIï¼ˆç°¡æ½”ç‰ˆï¼‰
         */
        displayCheckmateMessage(winner, loser) {
            // ç§»é™¤èˆŠçš„è¨Šæ¯
            const oldText = document.getElementById('ai-suggestion-text');
            if (oldText) oldText.remove();

            // åˆ¤æ–·è´å®¶é¡è‰²
            const winnerColor = winner === 'ç´…æ–¹' ? '#ff4444' : '#333333';
            const winnerBg = winner === 'ç´…æ–¹' ? 'rgba(255, 68, 68, 0.15)' : 'rgba(51, 51, 51, 0.15)';

            const textDiv = document.createElement('div');
            textDiv.id = 'ai-suggestion-text';
            textDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        font-size: 16px;
        z-index: 1001;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        max-width: 300px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        animation: slideIn 0.3s ease-out;
    `;

            textDiv.innerHTML = `
        <style>
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            #ai-suggestion-text button:hover {
                background: #00dd77 !important;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            }
        </style>

        <!-- æ¨™é¡Œ -->
        <div style="font-weight: bold; color: #00ff88; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
            <span style="font-size: 20px;">ğŸ éŠæˆ²çµæŸ</span>
        </div>

        <!-- ç²å‹è€…å€å¡Š -->
        <div style="
            background: ${winnerBg};
            border: 2px solid ${winnerColor};
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        ">
            <div style="font-size: 32px; margin-bottom: 8px;">ğŸ‘‘</div>
            <div style="
                font-size: 20px;
                font-weight: bold;
                color: ${winnerColor};
                margin-bottom: 5px;
            ">
                ${winner}
            </div>
            <div style="font-size: 16px; color: #00ff88; font-weight: bold;">
                ç²å‹ï¼
            </div>
        </div>

        <!-- å°‡æ­»èªªæ˜ -->
        <div style="
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            margin-bottom: 15px;
        ">
            ${loser} å·²è¢«å°‡æ­»
        </div>

        <!-- é—œé–‰æŒ‰éˆ• -->
        <button onclick="document.getElementById('ai-suggestion-text').remove(); if(typeof aiAnalysisManager !== 'undefined') aiAnalysisManager.clearHighlight();"
                style="
                    width: 100%;
                    padding: 10px;
                    background: #00ff88;
                    color: black;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: bold;
                    transition: all 0.2s;
                ">
            ç¢ºèª
        </button>
    `;

            document.body.appendChild(textDiv);
        }


        /**
         * ğŸ”¥ ä¿®æ­£ displaySuggestion - æ ¹æ“šç¿»è½‰ç‹€æ…‹é¸æ“‡è½‰æ›é‚è¼¯
         */
        displaySuggestion(suggestion) {
            console.log('ğŸ¨ é–‹å§‹é¡¯ç¤º AI å»ºè­°:', suggestion);

            if (!suggestion || !suggestion.from || !suggestion.to) {
                console.error('âŒ ç„¡æ•ˆçš„å»ºè­°:', suggestion);
                return;
            }

            this.clearHighlight();

            // ğŸ”¥ æª¢æŸ¥ç¿»è½‰ç‹€æ…‹
            const isFlipped = this.checkBoardFlipState();
            console.log(`ğŸ”„ æ£‹ç›¤è¦–è§’: ${isFlipped ? 'å·²ç¿»è½‰(é»‘æ–¹åœ¨ä¸‹)' : 'æ­£å¸¸(ç´…æ–¹åœ¨ä¸‹)'}`);

            // ğŸ”¥ æ ¹æ“šç¿»è½‰ç‹€æ…‹é¸æ“‡å°æ‡‰çš„è½‰æ›é‚è¼¯
            let fromCoord, toCoord;

            if (isFlipped) {
                // === ç¿»è½‰è¦–è§’ï¼šä½¿ç”¨æ–°é‚è¼¯ ===
                console.log('ğŸ“‹ ä½¿ç”¨ç¿»è½‰è¦–è§’è½‰æ›é‚è¼¯');
                fromCoord = this.convertAICoordFlipped(suggestion.from);
                toCoord = this.convertAICoordFlipped(suggestion.to);
            } else {
                // === æ­£å¸¸è¦–è§’ï¼šä½¿ç”¨èˆŠé‚è¼¯ ===
                console.log('ğŸ“‹ ä½¿ç”¨æ­£å¸¸è¦–è§’è½‰æ›é‚è¼¯');
                fromCoord = this.normalizeCoordinate(suggestion.from);
                toCoord = this.normalizeCoordinate(suggestion.to);
            }

            if (!fromCoord || !toCoord) {
                console.error('âŒ åº§æ¨™è½‰æ›å¤±æ•—');
                return;
            }

            // é©—è­‰åº§æ¨™
            const fromValid = this.isValidCoordinate(fromCoord);
            const toValid = this.isValidCoordinate(toCoord);

            if (!fromValid || !toValid) {
                console.error('âŒ åº§æ¨™é©—è­‰å¤±æ•—');
                return;
            }

            console.log('âœ… æœ€çµ‚é¡¯ç¤ºåº§æ¨™:', {
                from: `(${fromCoord.row}, ${fromCoord.col})`,
                to: `(${toCoord.row}, ${toCoord.col})`
            });

            // ç¹ªè£½ç®­é ­
            try {
                this.drawArrow(fromCoord, toCoord);
                console.log('âœ… ç®­é ­å·²ç¹ªè£½');
            } catch (error) {
                console.error('âŒ ç¹ªè£½ç®­é ­å¤±æ•—:', error);
            }

            // é¡¯ç¤ºå»ºè­°æ–‡å­—
            try {
                this.showSuggestionText(suggestion, fromCoord, toCoord, isFlipped);
            } catch (error) {
                console.error('âŒ é¡¯ç¤ºå»ºè­°æ–‡å­—å¤±æ•—:', error);
            }

            // 10ç§’å¾Œè‡ªå‹•æ¸…é™¤
            setTimeout(() => {
                this.clearHighlight();
            }, 15000);
        }

        // ==================== åœ¨ AIAnalysisManager é¡ä¸­æ·»åŠ é€™äº›æ–¹æ³• ====================

        /**
         * ğŸ”¥ æª¢æŸ¥æ£‹ç›¤ç¿»è½‰ç‹€æ…‹
         */
        checkBoardFlipState() {
            // å„ªå…ˆç´š1: gameState
            if (typeof gameState !== 'undefined' && gameState.isFlipped !== undefined) {
                return gameState.isFlipped;
            }

            // å„ªå…ˆç´š2: currentSettings
            if (typeof currentSettings !== 'undefined' && currentSettings.boardFlipped !== undefined) {
                return currentSettings.boardFlipped;
            }

            // å„ªå…ˆç´š3: localStorage
            try {
                const saved = localStorage.getItem('chessGameSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.boardFlipped !== undefined) {
                        return settings.boardFlipped;
                    }
                }
            } catch (e) {
                console.warn('ç„¡æ³•å¾ localStorage è®€å–ç¿»è½‰ç‹€æ…‹');
            }

            // å„ªå…ˆç´š4: DOM æŒ‡ç¤ºå™¨
            const flipIndicator = document.getElementById('flip-indicator');
            if (flipIndicator) {
                return true;
            }

            return false; // é»˜èªæœªç¿»è½‰
        }


        /**
         * ğŸ” é©—è­‰åº§æ¨™æ˜¯å¦æœ‰æ•ˆ - å…§å»ºç¿»è­¯å™¨ç‰ˆæœ¬
         * æ”¯æŒï¼šæ•¸å­—åˆ—ç´¢å¼•(0-8) å’Œ è‹±æ–‡åˆ—æ¨™è¨˜(A-I)
         * æ£‹ç›¤ï¼š10è¡ŒÃ—9åˆ— (è¡Œ:0-9, åˆ—:A-I æˆ– 0-8)
         */
        isValidCoordinate(coord) {
            console.log('ğŸ” é©—è­‰åº§æ¨™:', coord);

            if (!coord) {
                console.error('âŒ åº§æ¨™ç‚ºç©º');
                return false;
            }

            // å…§å»ºç¿»è­¯å™¨ï¼šå°‡å„ç¨®æ ¼å¼çµ±ä¸€è½‰æ›ç‚ºæ•¸å­—
            let rowNum, colNum;

            // è™•ç† row (è¡Œ)
            if (typeof coord.row === 'number') {
                rowNum = coord.row;
            } else if (typeof coord.row === 'string') {
                rowNum = parseInt(coord.row);
                if (isNaN(rowNum)) {
                    console.error('âŒ ç„¡æ•ˆçš„è¡Œåº§æ¨™:', coord.row);
                    return false;
                }
            } else {
                console.error('âŒ è¡Œåº§æ¨™æ ¼å¼éŒ¯èª¤:', coord.row);
                return false;
            }

            // è™•ç† col (åˆ—) - æ”¯æŒæ•¸å­—(0-8)å’Œå­—æ¯(A-I)
            if (typeof coord.col === 'number') {
                colNum = coord.col;
            } else if (typeof coord.col === 'string') {
                const upperCol = coord.col.toUpperCase();

                // æª¢æŸ¥æ˜¯å¦ç‚ºå­—æ¯ A-I
                if (upperCol >= 'A' && upperCol <= 'I') {
                    colNum = upperCol.charCodeAt(0) - 'A'.charCodeAt(0); // A->0, B->1, ..., I->8
                    console.log(`ğŸ“ å­—æ¯è½‰æ›: ${coord.col} -> ${colNum}`);
                }
                // æª¢æŸ¥æ˜¯å¦ç‚ºå­—ç¬¦ä¸²æ•¸å­—
                else {
                    colNum = parseInt(coord.col);
                    if (isNaN(colNum)) {
                        console.error('âŒ ç„¡æ•ˆçš„åˆ—åº§æ¨™:', coord.col);
                        return false;
                    }
                }
            } else {
                console.error('âŒ åˆ—åº§æ¨™æ ¼å¼éŒ¯èª¤:', coord.col);
                return false;
            }

            // é©—è­‰ç¯„åœ
            const rowValid = rowNum >= 0 && rowNum <= 9;  // 10è¡Œ (0-9)
            const colValid = colNum >= 0 && colNum <= 8;  // 9åˆ— (0-8, å°æ‡‰A-I)

            console.log('ğŸ“Š åº§æ¨™é©—è­‰çµæœ:', {
                åŸå§‹: coord,
                è½‰æ›å¾Œ: {row: rowNum, col: colNum},
                è¡Œé©—è­‰: `${rowNum} in [0,9] = ${rowValid}`,
                åˆ—é©—è­‰: `${colNum} in [0,8] = ${colValid}`,
                æ•´é«”çµæœ: rowValid && colValid
            });

            if (!rowValid) {
                console.error('âŒ è¡Œåº§æ¨™è¶…å‡ºç¯„åœ:', {
                    value: rowNum,
                    validRange: '[0-9]'
                });
            }

            if (!colValid) {
                console.error('âŒ åˆ—åº§æ¨™è¶…å‡ºç¯„åœ:', {
                    value: colNum,
                    validRange: '[0-8] æˆ– [A-I]'
                });
            }

            return rowValid && colValid;
        }



        /**
         * ğŸ”„ æ¨™æº–åŒ–åº§æ¨™æ ¼å¼ - çµ±ä¸€è½‰ç‚ºæ•¸å­—
         */
        normalizeCoordinate(coord) {
            let rowNum, colNum;

            // è™•ç† row
            if (typeof coord.row === 'number') {
                rowNum = coord.row;
            } else {
                rowNum = parseInt(coord.row);
            }

            // è™•ç† col - æ”¯æŒå­—æ¯å’Œæ•¸å­—
            if (typeof coord.col === 'number') {
                colNum = coord.col;
            } else if (typeof coord.col === 'string') {
                const upperCol = coord.col.toUpperCase();
                if (upperCol >= 'A' && upperCol <= 'I') {
                    colNum = upperCol.charCodeAt(0) - 'A'.charCodeAt(0);
                } else {
                    colNum = parseInt(coord.col);
                }
            }

            return { row: rowNum, col: colNum };
        }

        /**
         * ğŸ”¥ æ–°é‚è¼¯ï¼šç¿»è½‰è¦–è§’çš„åº§æ¨™è½‰æ›
         * AIè¿”å›çš„æ˜¯å¼•æ“åº§æ¨™(ç´…æ–¹åœ¨ä¸‹)ï¼Œéœ€è¦è½‰æ›ç‚ºç¿»è½‰å¾Œçš„é¡¯ç¤ºåº§æ¨™(é»‘æ–¹åœ¨ä¸‹)
         */
        convertAICoordFlipped(coord) {
            console.log('ğŸ”„ [ç¿»è½‰é‚è¼¯] è¼¸å…¥åº§æ¨™:', coord);

            if (!coord) return null;

            // æ­¥é©Ÿ1: è§£æAIåº§æ¨™ï¼ˆå¼•æ“æ ¼å¼ï¼‰
            let engineRow, engineCol;

            // è§£æ row
            if (typeof coord.row === 'number') {
                engineRow = coord.row;
            } else if (typeof coord.row === 'string') {
                engineRow = parseInt(coord.row);
                if (isNaN(engineRow)) {
                    console.error('âŒ ç„¡æ•ˆçš„è¡Œåº§æ¨™:', coord.row);
                    return null;
                }
            } else {
                console.error('âŒ è¡Œåº§æ¨™æ ¼å¼éŒ¯èª¤:', coord.row);
                return null;
            }

            // è§£æ col
            if (typeof coord.col === 'number') {
                engineCol = coord.col;
            } else if (typeof coord.col === 'string') {
                const upperCol = coord.col.toUpperCase();
                if (upperCol >= 'A' && upperCol <= 'I') {
                    engineCol = upperCol.charCodeAt(0) - 'A'.charCodeAt(0);
                } else {
                    engineCol = parseInt(coord.col);
                    if (isNaN(engineCol)) {
                        console.error('âŒ ç„¡æ•ˆçš„åˆ—åº§æ¨™:', coord.col);
                        return null;
                    }
                }
            } else {
                console.error('âŒ åˆ—åº§æ¨™æ ¼å¼éŒ¯èª¤:', coord.col);
                return null;
            }

            console.log(`   å¼•æ“åº§æ¨™: (${engineRow}, ${engineCol})`);

            // æ­¥é©Ÿ2: ç¿»è½‰è½‰æ› - é¡¯ç¤ºè¡Œ = 9 - å¼•æ“è¡Œ
            const displayRow = 9 - engineRow;
            const displayCol = engineCol; // åˆ—ä¸è®Š

            console.log(`   ç¿»è½‰å¾Œé¡¯ç¤ºåº§æ¨™: (${displayRow}, ${displayCol})`);

            // é©—è­‰ç¯„åœ
            if (displayRow < 0 || displayRow > 9 || displayCol < 0 || displayCol > 8) {
                console.error('âŒ åº§æ¨™è¶…å‡ºç¯„åœ:', { displayRow, displayCol });
                return null;
            }

            return { row: displayRow, col: displayCol };
        }

        /**
         * â¡ï¸ ç¹ªè£½ç§»å‹•ç®­é ­ - å„ªåŒ–å¤§å°ç‰ˆæœ¬
         */
        drawArrow(from, to) {
            try {
                console.log('ğŸ¨ ç¹ªè£½ç®­é ­:', from, '->', to);

                // ç§»é™¤èˆŠç®­é ­
                this.clearMoveArrow();

                // å¤šç¨®æ–¹å¼å°‹æ‰¾æ ¼å­
                const fromCell = this.findCell(from.row, from.col);
                const toCell = this.findCell(to.row, to.col);

                if (!fromCell) {
                    console.warn(`âš ï¸ ç„¡æ³•æ‰¾åˆ°èµ·å§‹æ ¼å­ (${from.row}, ${from.col})`);
                    return;
                }

                if (!toCell) {
                    console.warn(`âš ï¸ ç„¡æ³•æ‰¾åˆ°ç›®æ¨™æ ¼å­ (${to.row}, ${to.col})`);
                    return;
                }

                // å°‹æ‰¾æ£‹ç›¤å®¹å™¨ - ä½¿ç”¨æ”¹é€²ç‰ˆæœ¬
                const board = this.findChessboard();
                if (!board) {
                    console.warn('âš ï¸ ç„¡æ³•æ‰¾åˆ°æ£‹ç›¤å®¹å™¨');
                    return;
                }

                // è¨ˆç®—ä½ç½®
                const fromRect = fromCell.getBoundingClientRect();
                const toRect = toCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();

                // è¨ˆç®—ç›¸å°ä½ç½®
                const fromX = fromRect.left + fromRect.width / 2 - boardRect.left;
                const fromY = fromRect.top + fromRect.height / 2 - boardRect.top;
                const toX = toRect.left + toRect.width / 2 - boardRect.left;
                const toY = toRect.top + toRect.height / 2 - boardRect.top;

                // è¨ˆç®—ç®­é ­é•·åº¦ï¼Œç”¨æ–¼èª¿æ•´å¤§å°
                const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                const cellSize = Math.min(fromRect.width, fromRect.height);

                // æ ¹æ“šæ ¼å­å¤§å°å’Œç®­é ­é•·åº¦èª¿æ•´åƒæ•¸
                const strokeWidth = Math.max(2, Math.min(4, cellSize * 0.08)); // ç·šæ¢å¯¬åº¦ï¼šæ ¼å­çš„8%
                const arrowSize = Math.max(6, Math.min(10, cellSize * 0.2));   // ç®­é ­å¤§å°ï¼šæ ¼å­çš„20%

                // å‰µå»º SVG ç®­é ­
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'ai-suggestion-arrow');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '1000';

                // ç®­é ­æ¨™è¨˜å®šç¾©
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');

                // æ·»åŠ å‹•ç•«æ¨£å¼
                const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
                style.textContent = `
            @keyframes dash {
                to { stroke-dashoffset: -15; }
            }
            .ai-arrow-glow {
                filter: drop-shadow(0 0 3px #00ff88aa);
            }
        `;
                defs.appendChild(style);

                // å‰µå»ºé©ä¸­å¤§å°çš„ç®­é ­æ¨™è¨˜
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'ai-arrowhead-medium');
                marker.setAttribute('markerWidth', arrowSize.toString());
                marker.setAttribute('markerHeight', (arrowSize * 0.8).toString());
                marker.setAttribute('refX', (arrowSize - 1).toString());
                marker.setAttribute('refY', (arrowSize * 0.4).toString());
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');

                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = `0 0, ${arrowSize} ${arrowSize * 0.4}, 0 ${arrowSize * 0.8}`;
                polygon.setAttribute('points', points);
                polygon.setAttribute('fill', '#00ff88');
                polygon.setAttribute('stroke', '#00ff88');
                polygon.setAttribute('stroke-width', '0.5');

                marker.appendChild(polygon);
                defs.appendChild(marker);

                // èƒŒæ™¯ç™¼å…‰ç·šæ¢ï¼ˆå¯é¸ï¼‰
                const glowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                glowLine.setAttribute('x1', fromX);
                glowLine.setAttribute('y1', fromY);
                glowLine.setAttribute('x2', toX);
                glowLine.setAttribute('y2', toY);
                glowLine.setAttribute('stroke', '#00ff88');
                glowLine.setAttribute('stroke-width', (strokeWidth + 2).toString());
                glowLine.setAttribute('opacity', '0.3');
                glowLine.setAttribute('stroke-linecap', 'round');

                // ä¸»ç®­é ­ç·šæ¢ - é©ä¸­å¤§å°
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromX);
                line.setAttribute('y1', fromY);
                line.setAttribute('x2', toX);
                line.setAttribute('y2', toY);
                line.setAttribute('stroke', '#00ff88');
                line.setAttribute('stroke-width', strokeWidth.toString());
                line.setAttribute('marker-end', 'url(#ai-arrowhead-medium)');
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('class', 'ai-arrow-glow');

                // æ·»åŠ é©ä¸­çš„å‹•ç•«æ•ˆæœ
                const dashArray = Math.max(8, cellSize * 0.15);
                const dashGap = dashArray * 0.6;
                line.style.strokeDasharray = `${dashArray},${dashGap}`;
                line.style.animation = 'dash 1.2s linear infinite';

                // çµ„è£ SVG
                svg.appendChild(defs);
                svg.appendChild(glowLine); // ç™¼å…‰èƒŒæ™¯
                svg.appendChild(line);     // ä¸»ç·šæ¢

                // åŠ åˆ°æ£‹ç›¤ä¸Š
                board.style.position = 'relative';
                board.appendChild(svg);
                this.arrowElement = svg;

                console.log('âœ… AIå»ºè­°ç®­é ­å·²ç¹ªè£½ (é©ä¸­å¤§å°):', {
                    fromX, fromY, toX, toY,
                    strokeWidth, arrowSize, cellSize, length
                });

            } catch (error) {
                console.error('âŒ ç¹ªè£½ç®­é ­æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }
        }

        /**
         * ğŸ” å°‹æ‰¾æ ¼å­å…ƒç´  - æ”¯æŒå¤šç¨®é¸æ“‡å™¨
         */
        findCell(row, col) {
            const selectors = [
                `[data-row="${row}"][data-col="${col}"]`,
                `.cell-${row}-${col}`,
                `#cell-${row}-${col}`,
                `.row-${row} .col-${col}`,
                `tr:nth-child(${row + 1}) td:nth-child(${col + 1})`,
                `.chess-cell[data-position="${row}-${col}"]`
            ];

            for (const selector of selectors) {
                const cell = document.querySelector(selector);
                if (cell) {
                    console.log(`âœ… æ‰¾åˆ°æ ¼å­ (${row}, ${col}) ä½¿ç”¨: ${selector}`);
                    return cell;
                }
            }

            console.warn(`âŒ ç„¡æ³•æ‰¾åˆ°æ ¼å­ (${row}, ${col})`);
            return null;
        }

        /**
         * ğŸ” ä¿®å¤ç‰ˆæœ¬çš„æ£‹ç›˜æŸ¥æ‰¾å‡½æ•°
         */
        findChessboard() {
            console.log('ğŸ” å¯»æ‰¾æ£‹ç›˜å®¹å™¨...');

            // æ–¹æ³•1: ç›´æ¥é€šè¿‡IDæŸ¥æ‰¾ï¼ˆæ ¹æ®æ‚¨çš„æ£€æµ‹ç»“æœï¼‰
            let board = document.getElementById('chess-board');
            if (board) {
                console.log('âœ… é€šè¿‡IDæ‰¾åˆ°æ£‹ç›˜: #chess-board');
                return board;
            }

            // æ–¹æ³•2: é€šè¿‡ç°æœ‰çš„æ ¼å­åå‘æŸ¥æ‰¾æ£‹ç›˜å®¹å™¨
            const cellsWithData = document.querySelectorAll('[data-row][data-col]');
            if (cellsWithData.length > 0) {
                console.log(`âœ… æ‰¾åˆ° ${cellsWithData.length} ä¸ªæ ¼å­ï¼Œå¯»æ‰¾å…±åŒçˆ¶å®¹å™¨...`);

                // æ‰¾åˆ°æ‰€æœ‰æ ¼å­çš„æœ€è¿‘å…¬å…±çˆ¶å…ƒç´ 
                let commonParent = cellsWithData[0];
                for (let i = 1; i < Math.min(10, cellsWithData.length); i++) {
                    commonParent = this.findCommonParent(commonParent, cellsWithData[i]);
                    if (commonParent === document.body) break;
                }

                if (commonParent && commonParent !== document.body) {
                    console.log('âœ… é€šè¿‡æ ¼å­æ‰¾åˆ°æ£‹ç›˜å®¹å™¨:', commonParent);
                    return commonParent;
                }
            }

            // æ–¹æ³•3: åŸæœ‰çš„é€‰æ‹©å™¨åˆ—è¡¨
            const selectors = [
                '#chessboard', '.chessboard',
                '#board', '.board',
                '#game-board', '.game-board',
                'table', '.chess-table',
                '.board-container',
                '#chess', '.chess'
            ];

            for (const selector of selectors) {
                board = document.querySelector(selector);
                if (board) {
                    console.log(`âœ… æ‰¾åˆ°æ£‹ç›˜å®¹å™¨: ${selector}`);
                    return board;
                }
            }

            // æ–¹æ³•4: æ™ºèƒ½æ£€æµ‹ï¼ˆæ ¹æ®å°ºå¯¸å’Œå­å…ƒç´ æ•°é‡ï¼‰
            const candidates = [];
            document.querySelectorAll('*').forEach(el => {
                if (el.children.length > 50) { // æ£‹ç›˜é€šå¸¸æœ‰å¾ˆå¤šå­å…ƒç´ 
                    const rect = el.getBoundingClientRect();
                    if (rect.width > 300 && rect.height > 300) {
                        candidates.push({
                            element: el,
                            score: el.children.length + (rect.width * rect.height) / 10000
                        });
                    }
                }
            });

            if (candidates.length > 0) {
                candidates.sort((a, b) => b.score - a.score);
                console.log('âœ… æ™ºèƒ½æ£€æµ‹æ‰¾åˆ°æ£‹ç›˜å®¹å™¨:', candidates[0].element);
                return candidates[0].element;
            }

            console.warn('âŒ æ— æ³•æ‰¾åˆ°æ£‹ç›˜å®¹å™¨');
            return null;
        }

        /**
         * ğŸ”§ è¾…åŠ©å‡½æ•°ï¼šæ‰¾åˆ°ä¸¤ä¸ªå…ƒç´ çš„æœ€è¿‘å…¬å…±çˆ¶å…ƒç´ 
         */
        findCommonParent(el1, el2) {
            const parents1 = [];
            let current = el1;
            while (current && current !== document.body) {
                parents1.push(current);
                current = current.parentElement;
            }

            current = el2;
            while (current && current !== document.body) {
                if (parents1.includes(current)) {
                    return current;
                }
                current = current.parentElement;
            }
            return document.body;
        }
        /**
         * ğŸ¯ å°‡ AI å»ºè­°çš„ç§»å‹•è½‰æ›ç‚ºä¸­åœ‹è±¡æ£‹è¨˜è­œæ³•
         * ä½¿ç”¨ XiangqiTranslator çš„å®Œæ•´åŠŸèƒ½
         */
        convertMoveToNotation(moveString) {
            console.log(`ğŸ” é–‹å§‹è½‰æ›ç§»å‹•: ${moveString}`);

            // ç¢ºä¿æœ‰ translator å¯¦ä¾‹
            if (!this.translator) {
                console.warn('âš ï¸ XiangqiTranslator æœªåˆå§‹åŒ–');
                return moveString;
            }

            try {
                // æ­¥é©Ÿ1: åˆ¤æ–·ç§»å‹•æ ¼å¼ï¼ˆ"g6 åˆ° g5" æˆ– "g6g5"ï¼‰
                let engineMove;

                if (moveString.includes('åˆ°')) {
                    // è™•ç† "g6 åˆ° g5" æ ¼å¼
                    const parts = moveString.split('åˆ°').map(s => s.trim());
                    engineMove = parts[0] + parts[1]; // "g6g5"
                } else {
                    engineMove = moveString; // å·²ç¶“æ˜¯ "g6g5" æ ¼å¼
                }

                console.log(`ğŸ“‹ å¼•æ“ç§»å‹•æ ¼å¼: ${engineMove}`);

                // æ­¥é©Ÿ2: ä½¿ç”¨ translator è§£æç§»å‹•ï¼ˆå¼•æ“æ ¼å¼ï¼‰
                const parseResult = this.translator.parseMove(engineMove, true);

                if (!parseResult) {
                    console.error('âŒ ç§»å‹•è§£æå¤±æ•—');
                    return moveString;
                }

                // æ­¥é©Ÿ3: ç²å–æ£‹ç›¤ç‹€æ…‹
                const boardInfo = this.translator.getCurrentEffectiveBoard(this.board);

                if (!boardInfo || !boardInfo.board) {
                    console.error('âŒ ç„¡æ³•ç²å–æ£‹ç›¤ç‹€æ…‹');
                    return moveString;
                }

                const board = boardInfo.board;

                // æ­¥é©Ÿ4: å¾å¼•æ“åº§æ¨™ç²å–æ£‹å­
                const fromRow = parseResult.from.engineRow;
                const fromCol = parseResult.from.colIndex;

                const piece = board[fromRow]?.[fromCol];

                if (!piece || !piece.type) {
                    console.error(`âŒ ä½ç½® ${parseResult.from.engineNotation} æ²’æœ‰æ£‹å­`);
                    return moveString;
                }

                console.log(`âœ… æ‰¾åˆ°æ£‹å­: ${piece.color} ${piece.type} åœ¨ ${parseResult.from.displayNotation}`);

                // æ­¥é©Ÿ5: è½‰æ›ç‚ºè¨˜è­œæ³•
                const notation = this.convertToChineseNotation(
                    fromRow,
                    fromCol,
                    parseResult.to.engineRow,
                    parseResult.to.colIndex,
                    piece,
                    board
                );

                console.log(`ğŸ‰ æœ€çµ‚è¨˜è­œ: ${notation}`);
                return notation;

            } catch (error) {
                console.error('âŒ è½‰æ›éç¨‹ç™¼ç”ŸéŒ¯èª¤:', error);
                return moveString;
            }
        }

        /**
         * ğŸ“ å®Œæ•´çš„ä¸­åœ‹è±¡æ£‹è¨˜è­œè½‰æ›
         */
        convertToChineseNotation(fromRow, fromCol, toRow, toCol, piece, board) {
            const isRed = piece.color === 'red';

            // æ£‹å­åç¨±
            const pieceNames = {
                'red': { 'å¸¥': 'å¸¥', 'ä»•': 'ä»•', 'ç›¸': 'ç›¸', 'å‚Œ': 'å‚Œ', 'ä¿¥': 'ä¿¥', 'ç‚®': 'ç‚®', 'å…µ': 'å…µ' },
                'black': { 'å°‡': 'å°‡', 'å£«': 'å£«', 'è±¡': 'è±¡', 'é¦¬': 'é¦¬', 'è»Š': 'è»Š', 'åŒ…': 'åŒ…', 'å’': 'å’' }
            };

            // åˆ—æ•¸è½‰æ›
            const colNamesRed = ['ä¹', 'å…«', 'ä¸ƒ', 'å…­', 'äº”', 'å››', 'ä¸‰', 'äºŒ', 'ä¸€'];
            const colNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            const getColName = (col) => isRed ? colNamesRed[col] : colNamesBlack[col];

            // è·é›¢æ•¸å­—è½‰æ›
            const distanceNamesRed = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
            const distanceNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            const getDistanceName = (dist) => {
                if (dist >= 1 && dist <= 9) {
                    return isRed ? distanceNamesRed[dist - 1] : distanceNamesBlack[dist - 1];
                }
                return dist.toString();
            };

            const pieceName = pieceNames[piece.color]?.[piece.type] || piece.type;
            const fromColName = getColName(fromCol);
            const toColName = getColName(toCol);

            // æª¢æ¸¬åŒåˆ—ç›¸åŒæ£‹å­
            const samePiecesInColumn = [];
            for (let row = 0; row < 10; row++) {
                if (!board[row]) continue;
                const currentPiece = board[row][fromCol];
                if (currentPiece?.color === piece.color && currentPiece?.type === piece.type) {
                    samePiecesInColumn.push({ row, piece: currentPiece });
                }
            }

            let piecePrefix = pieceName;
            let colPrefix = fromColName;

            // è™•ç†åŒåˆ—å¤šå€‹ç›¸åŒæ£‹å­
            if (samePiecesInColumn.length > 1) {
                samePiecesInColumn.sort((a, b) => isRed ? (a.row - b.row) : (b.row - a.row));
                const currentIndex = samePiecesInColumn.findIndex(p => p.row === fromRow);

                // ğŸ”¥ ä¿®å¤ï¼šç‰¹æ®Šå¤„ç†å…µ/å’ - ä½¿ç”¨å®é™…æ£‹å­åç§°
                if (piece.type === 'å…µ' || piece.type === 'å’') {
                    const pawnName = piece.type; // å…³é”®ï¼šä½¿ç”¨å®é™…ç±»å‹

                    if (samePiecesInColumn.length === 2) {
                        piecePrefix = (currentIndex === 0) ? 'å‰' + pawnName : 'å¾Œ' + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 3) {
                        piecePrefix = ['å‰', 'ä¸­', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 4) {
                        piecePrefix = ['å‰', 'äºŒ', 'ä¸‰', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 5) {
                        piecePrefix = ['å‰', 'äºŒ', 'ä¸‰', 'å››', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    }
                }

                // å…¶ä»–æ£‹å­ï¼ˆé™¤å£«ç›¸å¤–ï¼‰
                else if (piece.type !== 'ä»•' && piece.type !== 'å£«' &&
                    piece.type !== 'ç›¸' && piece.type !== 'è±¡') {
                    if (samePiecesInColumn.length === 2) {
                        piecePrefix = (currentIndex === 0) ? 'å‰' : 'å¾Œ';
                        colPrefix = pieceName;
                    } else {
                        piecePrefix = currentIndex === 0 ? 'å‰' :
                            currentIndex === samePiecesInColumn.length - 1 ? 'å¾Œ' : 'ä¸­';
                        colPrefix = pieceName;
                    }
                }
            }

            // åˆ¤æ–·ç§»å‹•é¡å‹
            let finalNotation;
            if (fromCol === toCol) {
                // å‚ç›´ç§»å‹•
                const distance = Math.abs(toRow - fromRow);
                const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
                finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${getDistanceName(distance)}`;
            } else if (fromRow === toRow) {
                // æ°´å¹³ç§»å‹•
                finalNotation = `${piecePrefix}${colPrefix}å¹³${toColName}`;
            } else {
                // æ–œå‘ç§»å‹•
                const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
                finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${toColName}`;
            }

            return finalNotation;
        }

        /**
         * ğŸ”¥ ä¿®å¤: ç¿»è½¬è§†è§’ä¸‹çš„è®°è­œå‡½æ•°
         * è§£å†³é»‘æ–¹åœ¨ä¸‹æ—¶çš„æ£‹å­è¯†åˆ«é—®é¢˜
         */

        /**
         * ğŸ”¥ å®Œæ•´ä¿®å¤: convertToNotationFlipped - è°ƒç”¨æ–°çš„ç¿»è½¬è®°è­œå‡½æ•°
         */
        convertToNotationFlipped(fromDisplay, toDisplay, suggestion) {
            console.log('ğŸ“ [ç¿»è½¬è®°è­œ] å¼€å§‹è½¬æ¢');
            console.log('   æ˜¾ç¤ºåº§æ ‡ from:', fromDisplay, 'to:', toDisplay);

            try {
                // æ­¥éª¤1: å°†æ˜¾ç¤ºåº§æ ‡è½¬æ¢å›å¼•æ“åº§æ ‡
                const fromEngine = {
                    row: 9 - fromDisplay.row,
                    col: fromDisplay.col
                };
                const toEngine = {
                    row: 9 - toDisplay.row,
                    col: toDisplay.col
                };

                console.log('   å¼•æ“åº§æ ‡ from:', fromEngine, 'to:', toEngine);

                // æ­¥éª¤2: è·å–æ£‹ç›˜çŠ¶æ€
                const boardInfo = this.translator.getCurrentEffectiveBoard();
                if (!boardInfo?.board) {
                    console.error('âŒ æ— æ³•è·å–æ£‹ç›˜çŠ¶æ€');
                    return suggestion.moveString || 'ç§»åŠ¨';
                }

                const board = boardInfo.board;

                // æ­¥éª¤3: è·å–æ£‹å­
                const piece = this.getPieceFromFlippedBoard(board, fromEngine, fromDisplay);
                if (!piece?.type) {
                    console.error('âŒ æ— æ³•æ‰¾åˆ°æ£‹å­');
                    return suggestion.moveString || 'ç§»åŠ¨';
                }

                console.log(`âœ… æ‰¾åˆ°æ£‹å­: ${piece.color} ${piece.type}`);

                // æ­¥éª¤4: ğŸ”¥ è°ƒç”¨ç¿»è½¬ç‰ˆæœ¬çš„è®°è­œå‡½æ•°
                const notation = this.convertToChineseNotationFlipped(
                    fromEngine.row,
                    fromEngine.col,
                    toEngine.row,
                    toEngine.col,
                    piece,
                    board,
                    true  // isFlipped = true
                );

                console.log(`ğŸ‰ ç¿»è½¬è®°è­œå®Œæˆ: ${notation}`);
                return notation;

            } catch (error) {
                console.error('âŒ ç¿»è½¬è®°è­œè½¬æ¢å¤±è´¥:', error);
                return suggestion.moveString || 'ç§»åŠ¨';
            }
        }

        /**
         * ğŸ”¥ æ–°å¢: ä»ç¿»è½¬æ£‹ç›˜ä¸­è·å–æ£‹å­ (åŒé‡éªŒè¯)
         * @param {Array} board - æ ‡å‡†åº§æ ‡çš„æ£‹ç›˜ (çº¢æ–¹åœ¨ä¸‹)
         * @param {Object} engineCoord - å¼•æ“åº§æ ‡ {row, col}
         * @param {Object} displayCoord - æ˜¾ç¤ºåº§æ ‡ {row, col}
         * @returns {Object|null} æ£‹å­å¯¹è±¡
         */
        getPieceFromFlippedBoard(board, engineCoord, displayCoord) {
            console.log('ğŸ” è·å–æ£‹å­ (ç¿»è½¬æ£‹ç›˜ç‰ˆæœ¬)');
            console.log('   å¼•æ“åº§æ ‡:', engineCoord, 'æ˜¾ç¤ºåº§æ ‡:', displayCoord);

            // æ–¹æ³•1: ä»å¼•æ“åº§æ ‡ç›´æ¥è·å–
            const enginePiece = board[engineCoord.row]?.[engineCoord.col];

            // æ–¹æ³•2: éªŒè¯æ˜¾ç¤ºåº§æ ‡çš„æ£‹å­æ˜¯å¦ä¸å¼•æ“åº§æ ‡å¯¹åº”
            // è¿™æ˜¯å…³é”®: displayRow = 9 - engineRow
            const expectedEngineRow = 9 - displayCoord.row;
            const expectedEngineCol = displayCoord.col;

            console.log('   æ–¹æ³•1 - å¼•æ“åº§æ ‡:', {
                piece: enginePiece?.type ? `${enginePiece.color} ${enginePiece.type}` : 'æ— ',
                at: `(${engineCoord.row}, ${engineCoord.col})`
            });

            console.log('   æ–¹æ³•2 - åå‘éªŒè¯:', {
                expectedEngineCoord: `(${expectedEngineRow}, ${expectedEngineCol})`,
                match: (expectedEngineRow === engineCoord.row && expectedEngineCol === engineCoord.col)
            });

            // å¦‚æœä¸¤ç§æ–¹æ³•éƒ½æŒ‡å‘åŒä¸€ä¸ªä½ç½®ï¼Œè¿”å›æ£‹å­
            if (expectedEngineRow === engineCoord.row && expectedEngineCol === engineCoord.col) {
                if (enginePiece && enginePiece.type) {
                    console.log(`âœ… æ£‹å­éªŒè¯æˆåŠŸ: ${enginePiece.color} ${enginePiece.type}`);
                    return enginePiece;
                }
            }

            console.warn('âš ï¸ æ£‹å­éªŒè¯å¤±è´¥ï¼Œå°è¯•ä»æ˜¾ç¤ºåº§æ ‡åå‘æŸ¥æ‰¾...');

            // é™çº§æ–¹æ¡ˆ: å¦‚æœç›´æ¥æ–¹æ³•å¤±è´¥ï¼Œä½¿ç”¨åå‘è½¬æ¢
            const fallbackRow = 9 - displayCoord.row;
            const fallbackCol = displayCoord.col;
            const fallbackPiece = board[fallbackRow]?.[fallbackCol];

            if (fallbackPiece && fallbackPiece.type) {
                console.log(`âš ï¸ ä½¿ç”¨é™çº§æ–¹æ¡ˆæ‰¾åˆ°æ£‹å­: ${fallbackPiece.color} ${fallbackPiece.type}`);
                return fallbackPiece;
            }

            console.error('âŒ æ— æ³•æ‰¾åˆ°æ£‹å­');
            return null;
        }

        getSamePiecesInColumnFlipped(board, fromEngineRow, fromCol, piece, isFlipped) {
            console.log('ğŸ” ç²å–åŒåˆ—æ£‹å­ (ç¿»è½‰ç‰ˆæœ¬)');

            const samePiecesInColumn = [];

            for (let row = 0; row < 10; row++) {
                if (!board[row]) continue;

                const currentPiece = board[row][fromCol];
                if (currentPiece?.color === piece.color && currentPiece?.type === piece.type) {
                    samePiecesInColumn.push({
                        row: row,  // å¼•æ“åº§æ¨™
                        displayRow: isFlipped ? 9 - row : row,
                        piece: currentPiece
                    });
                }
            }

            console.log(`   æ‰¾åˆ° ${samePiecesInColumn.length} å€‹åŒé¡æ£‹å­`);

            if (samePiecesInColumn.length > 1) {
                const isRed = piece.color === 'red';

                // ğŸ”¥ ä¿®æ­£ï¼šä½¿ç”¨ rowï¼ˆå¼•æ“åº§æ¨™ï¼‰æ’åºï¼Œå’Œå³é‚Šç¨‹å¼ä¸€è‡´
                samePiecesInColumn.sort((a, b) => {
                    if (isFlipped) {
                        // å·²ç¿»è½‰ï¼šç´…æ–¹è¡Œè™Ÿå¤§=å‰ï¼Œé»‘æ–¹è¡Œè™Ÿå°=å‰
                        return isRed ? (b.row - a.row) : (a.row - b.row);
                    } else {
                        // æœªç¿»è½‰ï¼šç´…æ–¹è¡Œè™Ÿå°=å‰ï¼Œé»‘æ–¹è¡Œè™Ÿå¤§=å‰
                        return isRed ? (a.row - b.row) : (b.row - a.row);
                    }
                });

                console.log(`   ğŸ”„ æ’åºé‚è¼¯: ${isRed ? 'ç´…æ–¹' : 'é»‘æ–¹'}, æ£‹ç›¤${isFlipped ? 'å·²ç¿»è½‰' : 'æœªç¿»è½‰'}`);
                console.log('   æ’åºå¾Œ (å¾"å‰"åˆ°"å¾Œ"):');
                samePiecesInColumn.forEach((p, i) => {
                    console.log(`     ${i + 1}. å¼•æ“è¡Œ${p.row} â†’ é¡¯ç¤ºè¡Œ${p.displayRow}`);
                });
            }

            return samePiecesInColumn;
        }

        /**
         * ğŸ”¥ æ”¹è¿›: convertToChineseNotationFlipped - æ­£ç¡®å¤„ç†è¿›é€€æ–¹å‘
         * å…³é”®ï¼šå½“æ£‹ç›˜ç¿»è½¬æ—¶ï¼Œå¼•æ“åº§æ ‡çš„è¡Œå·åè½¬ï¼Œä½†è¿›é€€åˆ¤æ–­ä¹Ÿè¦åè½¬
         */
        convertToChineseNotationFlipped(fromRow, fromCol, toRow, toCol, piece, board, isFlipped) {
            console.log('ğŸ“ [ç¿»è½¬è®°è­œ v3.0] å¼€å§‹ç”Ÿæˆè®°è­œ');
            console.log(`   æ£‹å­: ${piece.color} ${piece.type}`);
            console.log(`   ä» (${fromRow},${fromCol}) åˆ° (${toRow},${toCol})`);
            console.log(`   ç¿»è½¬çŠ¶æ€: ${isFlipped}`);

            const isRed = piece.color === 'red';

            // æ£‹å­åç§°
            const pieceNames = {
                'red': { 'å¸¥': 'å¸¥', 'ä»•': 'ä»•', 'ç›¸': 'ç›¸', 'å‚Œ': 'å‚Œ', 'ä¿¥': 'ä¿¥', 'ç‚®': 'ç‚®', 'å…µ': 'å…µ' },
                'black': { 'å°‡': 'å°‡', 'å£«': 'å£«', 'è±¡': 'è±¡', 'é¦¬': 'é¦¬', 'è»Š': 'è»Š', 'åŒ…': 'åŒ…', 'å’': 'å’' }
            };

            // åˆ—æ•°è½¬æ¢ï¼ˆå¼•æ“åº§æ ‡ï¼‰
            const colNamesRed = ['ä¹', 'å…«', 'ä¸ƒ', 'å…­', 'äº”', 'å››', 'ä¸‰', 'äºŒ', 'ä¸€'];
            const colNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            const getColName = (col) => isRed ? colNamesRed[col] : colNamesBlack[col];

            // è·ç¦»æ•°å­—è½¬æ¢
            const distanceNamesRed = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
            const distanceNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            const getDistanceName = (dist) => {
                if (dist >= 1 && dist <= 9) {
                    return isRed ? distanceNamesRed[dist - 1] : distanceNamesBlack[dist - 1];
                }
                return dist.toString();
            };

            const pieceName = pieceNames[piece.color]?.[piece.type] || piece.type;
            const fromColName = getColName(fromCol);
            const toColName = getColName(toCol);

            // è·å–åŒåˆ—æ£‹å­ï¼ˆç”¨äºæ¶ˆæ­§ä¹‰ï¼‰
            const samePiecesInColumn = this.getSamePiecesInColumnFlipped(
                board, fromRow, fromCol, piece, isFlipped
            );

            let piecePrefix = pieceName;
            let colPrefix = fromColName;

            // å¤„ç†åŒåˆ—å¤šä¸ªç›¸åŒæ£‹å­çš„æ¶ˆæ­§ä¹‰
            if (samePiecesInColumn.length > 1) {
                const currentIndex = samePiecesInColumn.findIndex(p => p.row === fromRow);

                // ğŸ”¥ ä¿®å¤ï¼šç‰¹æ®Šå¤„ç†å…µ/å’ - ä½¿ç”¨å®é™…æ£‹å­åç§°
                if (piece.type === 'å…µ' || piece.type === 'å’') {
                    const pawnName = piece.type; // å…³é”®ï¼šä½¿ç”¨å®é™…ç±»å‹

                    if (samePiecesInColumn.length === 2) {
                        piecePrefix = (currentIndex === 0) ? 'å‰' + pawnName : 'å¾Œ' + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 3) {
                        piecePrefix = ['å‰', 'ä¸­', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 4) {
                        piecePrefix = ['å‰', 'äºŒ', 'ä¸‰', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    } else if (samePiecesInColumn.length === 5) {
                        piecePrefix = ['å‰', 'äºŒ', 'ä¸‰', 'å››', 'å¾Œ'][currentIndex] + pawnName;
                        colPrefix = '';
                    }
                }

                // å…¶ä»–æ£‹å­
                else if (piece.type !== 'ä»•' && piece.type !== 'å£«' &&
                    piece.type !== 'ç›¸' && piece.type !== 'è±¡') {
                    if (samePiecesInColumn.length === 2) {
                        piecePrefix = (currentIndex === 0) ? 'å‰' : 'å¾Œ';
                        colPrefix = pieceName;
                    } else {
                        piecePrefix = currentIndex === 0 ? 'å‰' :
                            currentIndex === samePiecesInColumn.length - 1 ? 'å¾Œ' : 'ä¸­';
                        colPrefix = pieceName;
                    }
                }
            }

            // åˆ¤æ–­ç§»åŠ¨ç±»å‹å’Œæ–¹å‘
            let finalNotation;

            if (fromCol === toCol) {
                // å‚ç›´ç§»åŠ¨ï¼ˆè¡Œç›¸åŒï¼Œåˆ—ä¸åŒï¼‰
                const distance = Math.abs(toRow - fromRow);

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šè¿›é€€æ–¹å‘è¦æ ¹æ®æ£‹ç›˜ç¿»è½¬çŠ¶æ€è°ƒæ•´
                // å¼•æ“åº§æ ‡æ ‡å‡†: çº¢æ–¹åœ¨ä¸‹ï¼ˆè¡Œ0åœ¨åº•éƒ¨ï¼‰ï¼Œæ‰€ä»¥è¡Œå·å° = æ›´é ä¸‹ = çº¢æ–¹çš„"è¿›"
                // ä½†å¦‚æœæ£‹ç›˜ç¿»è½¬æ˜¾ç¤ºï¼Œåˆ™è¦åè½¬è¿™ä¸ªé€»è¾‘

                let isAdvancing;

                if (isFlipped) {
                    // ç¿»è½¬è§†è§’ï¼šé»‘æ–¹åœ¨ä¸‹ï¼Œæ‰€ä»¥è¦åè½¬è¿›é€€åˆ¤æ–­
                    // å¯¹çº¢æ–¹ï¼šè¡Œå·å¢å¤§ï¼ˆè§†è§‰ä¸Šå‘ä¸‹ï¼‰= "è¿›"
                    // å¯¹é»‘æ–¹ï¼šè¡Œå·å‡å°ï¼ˆè§†è§‰ä¸Šå‘ä¸‹ï¼‰= "è¿›"
                    console.log(`   ğŸ”„ ç¿»è½¬è§†è§’ä¸‹çš„è¿›é€€åˆ¤æ–­`);

                    if (isRed) {
                        // çº¢æ–¹ï¼šåœ¨ç¿»è½¬è§†è§’ä¸‹ï¼Œè¡Œå·å¢å¤§ = å‘çº¢æ–¹ä½ç½®ç§»åŠ¨ = "è¿›"
                        isAdvancing = toRow > fromRow;
                    } else {
                        // é»‘æ–¹ï¼šåœ¨ç¿»è½¬è§†è§’ä¸‹ï¼Œè¡Œå·å‡å° = å‘é»‘æ–¹ä½ç½®ç§»åŠ¨ = "è¿›"
                        isAdvancing = toRow < fromRow;
                    }
                } else {
                    // æ­£å¸¸è§†è§’ï¼šçº¢æ–¹åœ¨ä¸‹ï¼ˆè¡Œå·å°ï¼‰ï¼Œé»‘æ–¹åœ¨ä¸Šï¼ˆè¡Œå·å¤§ï¼‰
                    console.log(`   â¡ï¸ æ­£å¸¸è§†è§’ä¸‹çš„è¿›é€€åˆ¤æ–­`);

                    if (isRed) {
                        // çº¢æ–¹ï¼šè¡Œå·å‡å° = "è¿›"ï¼ˆå‘ä¸‹ç§»åŠ¨ï¼‰
                        isAdvancing = toRow < fromRow;
                    } else {
                        // é»‘æ–¹ï¼šè¡Œå·å¢å¤§ = "è¿›"ï¼ˆå‘ä¸‹ç§»åŠ¨ï¼‰
                        isAdvancing = toRow > fromRow;
                    }
                }

                console.log(`   è¿›é€€æ–¹å‘: ${isAdvancing ? 'è¿›' : 'é€€'} (fromRow=${fromRow}, toRow=${toRow})`);

                finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${getDistanceName(distance)}`;

            } else if (fromRow === toRow) {
                // æ°´å¹³ç§»åŠ¨ï¼ˆè¡Œä¸åŒï¼Œåˆ—ç›¸åŒï¼‰
                console.log(`   æ°´å¹³ç§»åŠ¨`);
                finalNotation = `${piecePrefix}${colPrefix}å¹³${toColName}`;

            } else {
                // æ–œå‘ç§»åŠ¨ï¼ˆè¡Œåˆ—éƒ½ä¸åŒï¼Œè±¡/ç›¸çš„ç‰¹æ®Šç§»åŠ¨ï¼‰
                console.log(`   æ–œå‘ç§»åŠ¨`);

                // ğŸ”¥ åŒæ ·éœ€è¦å¤„ç†è¿›é€€æ–¹å‘
                let isAdvancing;

                if (isFlipped) {
                    if (isRed) {
                        isAdvancing = toRow > fromRow;
                    } else {
                        isAdvancing = toRow < fromRow;
                    }
                } else {
                    if (isRed) {
                        isAdvancing = toRow < fromRow;
                    } else {
                        isAdvancing = toRow > fromRow;
                    }
                }

                console.log(`   è¿›é€€æ–¹å‘: ${isAdvancing ? 'è¿›' : 'é€€'} (fromRow=${fromRow}, toRow=${toRow})`);

                finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${toColName}`;
            }

            console.log(`âœ… è®°è­œç”Ÿæˆå®Œæˆ: ${finalNotation}`);
            return finalNotation;
        }

        /**
         * ğŸ”¥ è¼”åŠ©æ–¹æ³•ï¼šå°‡ç¿»è½‰çš„æ£‹ç›¤ç¿»è½‰å›æ¨™æº–åº§æ¨™
         */
        flipBoardBack(board) {
            if (!board || !Array.isArray(board)) {
                return board;
            }

            const height = board.length;
            const width = board[0] ? board[0].length : 0;

            console.log(`ğŸ”„ ç¿»è½‰æ£‹ç›¤å›æ¨™æº–åº§æ¨™ (${height}x${width})`);

            const flippedBoard = Array(height).fill().map(() => Array(width).fill(null));

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const newRow = height - 1 - row;
                    flippedBoard[newRow][col] = board[row][col];
                }
            }

            return flippedBoard;
        }

        /**
         * åˆ›å»ºå°†æ­»è¯„ä¼°çš„ HTML
         */
        createMateEvaluationHtml(cpScore) {
            const absScore = Math.abs(cpScore);

            // åªæœ‰åˆ†æ•°ç»å¯¹å€¼ >= 9900 æ‰æ˜¾ç¤ºå°†æ­»ä¿¡æ¯
            if (absScore < 9900) {
                // æ˜¾ç¤ºæ™®é€šåˆ†æ•°
                const evaluation = this.calculateEvaluation(cpScore, 'red');
                return evaluation && evaluation.html ? evaluation.html : '';
            }

            let mateText = '';
            let bgColor = '';
            let textColor = '';
            let icon = '';

            if (cpScore >= 9900) {
                // æ­£åˆ†æ•°: çº¢æ–¹å¯ä»¥å°†æ­»é»‘æ–¹
                const steps = 9999 - cpScore;
                if (steps === 0) {
                    mateText = 'é»‘æ–¹å·²è¢«å°†æ­»';
                } else {
                    mateText = `${steps}æ­¥å°†æ­»é»‘æ–¹`;
                }
                bgColor = 'rgba(0, 200, 100, 0.2)';
                textColor = '#00ff88';
                icon = 'âš”ï¸';
            } else {
                // è´Ÿåˆ†æ•°: çº¢æ–¹å°†è¢«é»‘æ–¹å°†æ­»
                const steps = 9999 + cpScore;
                if (steps === 0) {
                    mateText = 'çº¢æ–¹å·²è¢«å°†æ­»';
                } else {
                    mateText = `${steps}æ­¥è¢«é»‘æ–¹å°†æ­»`;
                }
                bgColor = 'rgba(255, 80, 80, 0.2)';
                textColor = '#ff5050';
                icon = 'âš ï¸';
            }

            return `
        <div style="
            background: ${bgColor};
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border-left: 4px solid ${textColor};
        ">
            <div style="
                font-size: 18px;
                font-weight: bold;
                color: ${textColor};
                text-align: center;
                letter-spacing: 1px;
            ">
                ${icon} ${mateText}
            </div>
        </div>
    `;
        }

        /**
         * ğŸ“ å®Œæ•´ä¿®å¤ç‰ˆ: showSuggestionText - æ ¹æ®ç¿»è½¬çŠ¶æ€é€‰æ‹©è®°è­œè½¬æ¢
         */
        showSuggestionText(suggestion, fromCoord, toCoord, isFlipped) {
            console.log('ğŸ¨ æ˜¾ç¤º AI å»ºè®®æ–‡å­—');
            console.log('   ç¿»è½¬çŠ¶æ€:', isFlipped);
            console.log('   åº§æ ‡:', fromCoord, '->', toCoord);
            console.log('   ğŸ“¦ å®Œæ•´ suggestion å¯¹è±¡:', JSON.stringify(suggestion, null, 2));
            console.log('   ğŸ“Š cpScore å€¼:', suggestion.cpScore);
            console.log('   ğŸ“Š isMate å€¼:', suggestion.isMate);
            console.log('   ğŸ“Š mateSteps å€¼:', suggestion.mateSteps);
            console.log('   suggestion å¯¹è±¡:', suggestion);
            console.log('   cpScore:', suggestion.cpScore, 'isMate:', suggestion.isMate, 'mateSteps:', suggestion.mateSteps);

            // ç§»é™¤æ—§çš„å»ºè®®æ–‡å­—
            const oldText = document.getElementById('ai-suggestion-text');
            if (oldText) oldText.remove();

            // ğŸ”¥ æ ¹æ®ç¿»è½¬çŠ¶æ€é€‰æ‹©è®°è­œè½¬æ¢é€»è¾‘
            let notation;
            let conversionMethod = '';

            try {
                if (isFlipped) {
                    // === ç¿»è½¬è§†è§’ï¼šä½¿ç”¨æ–°è®°è­œé€»è¾‘ ===
                    console.log('ğŸ“ ä½¿ç”¨ç¿»è½¬è§†è§’è®°è­œè½¬æ¢');
                    conversionMethod = 'ç¿»è½¬è§†è§’';
                    notation = this.convertToNotationFlipped(fromCoord, toCoord, suggestion);
                } else {
                    // === æ­£å¸¸è§†è§’ï¼šä½¿ç”¨æ—§è®°è­œé€»è¾‘ ===
                    console.log('ğŸ“ ä½¿ç”¨æ­£å¸¸è§†è§’è®°è­œè½¬æ¢');
                    conversionMethod = 'æ­£å¸¸è§†è§’';
                    notation = this.convertMoveToNotation(suggestion.moveString);
                }

                console.log(`âœ… è®°è­œè½¬æ¢å®Œæˆ (${conversionMethod}): ${notation}`);
            } catch (error) {
                console.error('âŒ è®°è­œè½¬æ¢å¤±è´¥:', error);
                notation = suggestion.moveString || 'ç§»åŠ¨';
            }

            // è·å–å±€åŠ¿è¯„ä¼°
            let evaluationHtml = '';
            try {
                if (suggestion.cpScore !== undefined && suggestion.cpScore !== null) {
                    console.log('ğŸ“Š å¤„ç†åˆ†æ•°:', suggestion.cpScore);
                    const absScore = Math.abs(suggestion.cpScore);

                    if (absScore >= 9900) {
                        // æ˜¾ç¤ºå°†æ­»ä¿¡æ¯
                        console.log('âœ“ æ£€æµ‹åˆ°å°†æ­»åˆ†æ•°,æ˜¾ç¤ºå°†æ­»ä¿¡æ¯');
                        evaluationHtml = this.createMateEvaluationHtml(suggestion.cpScore);
                    } else {
                        // æ˜¾ç¤ºæ™®é€šåˆ†æ•°
                        console.log('âœ“ æ˜¾ç¤ºæ™®é€šåˆ†æ•°');
                        const evaluation = this.calculateEvaluation(suggestion.cpScore, 'red');
                        if (evaluation && evaluation.html) {
                            evaluationHtml = evaluation.html;
                        }
                    }
                }
            } catch (error) {
                console.warn('âš ï¸ æ— æ³•è·å–å±€åŠ¿è¯„ä¼°:', error);
            }

            // åˆ›å»ºå»ºè®®æ–‡å­—å®¹å™¨
            const textDiv = document.createElement('div');
            textDiv.id = 'ai-suggestion-text';
            textDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        font-size: 16px;
        z-index: 1001;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        max-width: 300px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        animation: slideIn 0.3s ease-out;
    `;

            // åŠ¨ç”»æ ·å¼
            const styleContent = `
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        #ai-suggestion-text button:hover {
            background: #00dd77 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }
        #ai-suggestion-text .flip-indicator {
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
    `;

            // è·å–æè¿°æ–‡æœ¬
            const description = suggestion.description || 'æ¨èç§»åŠ¨';

            // æ„å»º HTML å†…å®¹
            const coordinateInfo = `
        <div style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px; text-align: center;">
            æ˜¾ç¤ºåº§æ ‡: (${fromCoord.row},${fromCoord.col}) â†’ (${toCoord.row},${toCoord.col})
        </div>
    `;

            // ç¿»è½¬è§†è§’æç¤º
            const flipIndicator = isFlipped ? `
        <div class="flip-indicator" style="
            font-size: 11px;
            color: rgba(255, 136, 0, 0.9);
            margin-bottom: 12px;
            text-align: center;
            background: rgba(255, 136, 0, 0.15);
            padding: 6px;
            border-radius: 4px;
            border-left: 3px solid #ff8800;
        ">
            ğŸ”„ è§†è§’å·²ç¿»è½¬ (é»‘æ–¹åœ¨ä¸‹)
        </div>
    ` : '';

            // å®Œæ•´çš„ HTML å†…å®¹
            textDiv.innerHTML = `
        <style>
            ${styleContent}
        </style>

        <!-- æ ‡é¢˜ -->
        <div style="font-weight: bold; color: #00ff88; margin-bottom: 12px; display: flex; align-items: center;">
            ğŸ¤– <span style="margin-left: 8px;">AI å»ºè®®</span>
        </div>

        <!-- å±€åŠ¿è¯„ä¼° -->
        ${evaluationHtml}

        <!-- å»ºè®®æè¿° -->
        <div style="
            margin-bottom: 12px;
            line-height: 1.5;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
        ">
            ${description}
        </div>

        <!-- è®°è­œæ˜¾ç¤º -->
        <div style="
            font-size: 24px;
            color: #00ff88;
            margin-bottom: 12px;
            text-align: center;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.2);
            padding: 14px;
            border-radius: 8px;
            letter-spacing: 4px;
            border: 2px solid rgba(0, 255, 136, 0.3);
        ">
            ${notation}
        </div>

        <!-- åº§æ ‡ä¿¡æ¯ -->
        ${coordinateInfo}

        <!-- ç¿»è½¬æç¤º -->
        ${flipIndicator}

        <!-- æ¸…é™¤æŒ‰é’® -->
        <button onclick="aiAnalysisManager.clearHighlight()"
                style="
                    width: 100%;
                    padding: 10px;
                    background: #00ff88;
                    color: black;
                    border: none;
                    border-radius: 6px;
                    cursor: pointer;
                    font-weight: bold;
                    transition: all 0.2s;
                    font-size: 14px;
                    margin-top: 12px;
                ">
            æ¸…é™¤å»ºè®®
        </button>

        <!-- è°ƒè¯•ä¿¡æ¯ (å¯é€‰) -->
        <div style="
            font-size: 10px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 8px;
            text-align: center;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        ">
            ${conversionMethod} | Score: ${suggestion.cpScore !== undefined ? suggestion.cpScore : 'æ— '}
        </div>
    `;

            // æ·»åŠ åˆ°é¡µé¢
            document.body.appendChild(textDiv);

            console.log('âœ… å»ºè®®æ–‡å­—æ˜¾ç¤ºå®Œæˆ');
        }

        /**
         * ğŸ¯ è¨ˆç®—å±€å‹¢è©•ä¼°ï¼ˆé¡¯ç¤º CP åŸå§‹åˆ†æ•¸ï¼Œæ›´ç›´è§€ï¼‰
         * @param {number} cpScore - CP åˆ†æ•¸ï¼ˆå¾å¼•æ“è¦–è§’ï¼‰
         * @param {string} perspective - 'red' æˆ– 'black'ï¼Œè¡¨ç¤ºé€™å€‹åˆ†æ•¸æ˜¯å¾èª°çš„è¦–è§’
         */
        calculateEvaluation(cpScore, perspective = 'red') {
            if (cpScore === null || cpScore === undefined) {
                return {
                    html: '',
                    advantage: 'unknown',
                    score: 0
                };
            }

            console.log(`ğŸ¯ è¨ˆç®—è©•ä¼°: cpScore=${cpScore}, perspective=${perspective}`);

            // ğŸ”¥ æª¢æŸ¥å°‡æ­»æ¨™è¨˜
            if (cpScore === 'CHECKMATE') {
                const html = `
            <div style="
                background: rgba(255, 68, 68, 0.15);
                border: 2px solid #ff4444;
                border-radius: 8px;
                padding: 12px;
                margin-bottom: 15px;
                text-align: center;
            ">
                <div style="font-size: 18px; margin-bottom: 5px;">ğŸ†</div>
                <div style="font-size: 16px; font-weight: bold; color: #ff4444;">
                    ${perspective === 'red' ? 'ç´…æ–¹å‹åˆ©' : 'é»‘æ–¹å‹åˆ©'}
                </div>
            </div>
        `;

                return {
                    html: html,
                    advantage: perspective,
                    score: Infinity,
                    rawScore: 10000
                };
            }

            // è½‰æ›ç‚ºæ•¸å€¼
            const score = this.parseScoreValue(cpScore);

            // ğŸ”¥ è½‰æ›ç‚ºç´…æ–¹è¦–è§’ï¼ˆçµ±ä¸€æ¨™æº–ï¼šæ­£æ•¸=ç´…å„ªï¼Œè² æ•¸=é»‘å„ªï¼‰
            let redViewScore;
            if (perspective === 'red') {
                redViewScore = score;
            } else {
                redViewScore = -score;
            }

            console.log(`   åŸå§‹åˆ†æ•¸: ${score}, ç´…æ–¹è¦–è§’åˆ†æ•¸: ${redViewScore}`);

            let advantageText, advantageColor, advantageIcon, bgColor;

            // ğŸ”¥ åˆ¤æ–·æ˜¯å¦ç‚ºå°‡æ­»å±€é¢
            const isCheckmate = this.isCheckmateSituation(score);
            const isMateSequence = Math.abs(score) >= 9000 && Math.abs(score) < 10000;

            if (isCheckmate) {
                // mate 0ï¼šç•¶å‰å±€é¢å·²å°‡æ­»
                if (redViewScore > 0) {
                    advantageText = 'ç´…æ–¹å‹åˆ©';
                    advantageColor = '#ff4444';
                    advantageIcon = 'ğŸ†';
                    bgColor = 'rgba(255, 68, 68, 0.15)';
                } else {
                    advantageText = 'é»‘æ–¹å‹åˆ©';
                    advantageColor = '#00ff00';
                    advantageIcon = 'ğŸ†';
                    bgColor = 'rgba(51, 51, 51, 0.15)';
                }
            } else if (isMateSequence) {
                // mate xï¼šå³å°‡å°‡æ­»ï¼ˆ9000 ~ 9999ï¼‰
                const steps = 9999 - Math.abs(score);
                if (redViewScore > 0) {
                    advantageText = `ç´…æ–¹ ${steps} æ­¥å…§å°‡æ­»`;
                    advantageColor = '#ff4444';
                    advantageIcon = 'âš”ï¸';
                    bgColor = 'rgba(255, 68, 68, 0.15)';
                } else {
                    advantageText = `é»‘æ–¹ ${steps} æ­¥å…§å°‡æ­»`;
                    advantageColor = '#00ff00';
                    advantageIcon = 'âš”ï¸';
                    bgColor = 'rgba(51, 51, 51, 0.15)';
                }
            } else if (Math.abs(redViewScore) < 50) {
                // å‡å‹¢ï¼ˆÂ±50 CP ä»¥å…§ï¼‰
                advantageText = 'å‡å‹¢';
                advantageColor = '#888888';
                advantageIcon = 'âš–ï¸';
                bgColor = 'rgba(136, 136, 136, 0.15)';
            } else if (redViewScore > 0) {
                // ğŸ”¥ ç´…æ–¹å„ªå‹¢ - ç›´æ¥é¡¯ç¤ºåˆ†æ•¸
                advantageText = `ç´…å„ª ${Math.abs(redViewScore)} åˆ†`;
                advantageColor = '#ff4444';
                advantageIcon = 'ğŸ”´';
                bgColor = 'rgba(255, 68, 68, 0.15)';
            } else {
                // ğŸ”¥ é»‘æ–¹å„ªå‹¢ - ç›´æ¥é¡¯ç¤ºåˆ†æ•¸
                advantageText = `é»‘å„ª ${Math.abs(redViewScore)} åˆ†`;
                advantageColor = '#00ff00';
                advantageIcon = 'âš«';
                bgColor = 'rgba(51, 51, 51, 0.15)';
            }

            const html = `
        <div style="
            background: ${bgColor};
            border: 2px solid ${advantageColor};
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            text-align: center;
        ">
            <div style="font-size: 18px; margin-bottom: 5px;">${advantageIcon}</div>
            <div style="
                font-size: 16px;
                font-weight: bold;
                color: ${advantageColor};
            ">${advantageText}</div>
            ${!isCheckmate && !isMateSequence ? `
                <div style="
                    font-size: 11px;
                    color: rgba(255, 255, 255, 0.5);
                    margin-top: 4px;
                ">${redViewScore > 0 ? '+' : ''}${redViewScore}</div>
            ` : ''}
        </div>
    `;

            console.log(`   çµæœ: ${advantageText}`);

            return {
                html: html,
                advantage: redViewScore > 50 ? 'red' : redViewScore < -50 ? 'black' : 'equal',
                score: Math.abs(redViewScore),
                rawScore: redViewScore
            };
        }

        /**
         * ç²å–ç•¶å‰ç©å®¶ - ä½¿ç”¨ä½ ç¾æœ‰çš„é‚è¼¯
         */
        getCurrentPlayer() {
            if (typeof gameState !== 'undefined' && gameState.currentTurn) {
                return gameState.currentTurn;
            }

            // å¾ç§»å‹•æ­·å²æ¨æ–·
            if (typeof gameHistory !== 'undefined' && gameHistory.moves) {
                return gameHistory.moves.length % 2 === 0 ? 'red' : 'black';
            }

            return 'red'; // é»˜èªç´…æ–¹å…ˆæ‰‹
        }


        /**
         * ğŸ”¥ è§£æåˆ†æ•¸å€¼ï¼ˆè™•ç†æ•¸å€¼å’Œå­—ä¸²ï¼‰
         */
        parseScoreValue(score) {
            if (typeof score === 'number') {
                return score;
            }
            if (typeof score === 'string') {
                // è™•ç† "mate X" æ ¼å¼
                const mateMatch = score.match(/mate\s+(-?\d+)/);
                if (mateMatch) {
                    const steps = parseInt(mateMatch[1]);
                    if (steps === 0) {
                        return 10000;
                    } else if (steps > 0) {
                        return 9999 - steps;
                    } else {
                        return -9999 + Math.abs(steps);
                    }
                }
                return parseInt(score) || 0;
            }
            return 0;
        }

        /**
         * ğŸ”¥ æª¢æŸ¥æ˜¯å¦ç‚ºå°‡æ­»å±€é¢
         */
        isCheckmateSituation(score) {
            const numScore = this.parseScoreValue(score);
            return Math.abs(numScore) === 10000;
        }

        /**
         * ğŸ”„ æ¸…é™¤ç§»å‹•ç®­é ­
         */
        clearMoveArrow() {
            const arrows = document.querySelectorAll('.ai-suggestion-arrow');
            arrows.forEach(arrow => arrow.remove());
        }

        /**
         * ğŸ”¥ ä¿®æ”¹: clearHighlight - æ¸…é™¤æ‰€æœ‰ç®­é ­
         */
        clearHighlight() {
            console.log('ğŸ§¹ æ¸…é™¤æ‰€æœ‰ AI å»ºè­°é¡¯ç¤º');

            // æ¸…é™¤æ‰€æœ‰ç®­é ­
            this.arrowElements.forEach(arrow => {
                if (arrow && arrow.parentElement) {
                    arrow.remove();
                }
            });
            this.arrowElements = [];

            // æ¸…é™¤å»ºè­°æ–‡å­—
            const suggestionText = document.getElementById('ai-suggestion-text');
            if (suggestionText) {
                suggestionText.remove();
            }

            // èˆŠçš„å–®ä¸€ç®­é ­
            const oldArrows = document.querySelectorAll('.ai-suggestion-arrow');
            oldArrows.forEach(arrow => arrow.remove());
        }


        /**
         * â³ é¡¯ç¤ºåˆ†æç‹€æ…‹
         */
        showAnalyzingStatus(isAnalyzing) {
            const button = document.getElementById('ai-analyze-btn');
            if (button) {
                if (isAnalyzing) {
                    button.textContent = 'ğŸ¤– åˆ†æä¸­...';
                    button.disabled = true;
                    button.style.background = '#ccc';
                } else {

                    button.textContent = 'ğŸ¤– AI åˆ†æ';
                    button.disabled = false;
                    button.style.background = '#4CAF50';
                }
            }
        }
    }


    // ğŸ”¥ å‰µå»ºå…¨åŸŸ AI åˆ†æç®¡ç†å™¨
    let aiAnalysisManager = null;



    function showAINotReady() {
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨é€šçŸ¥ï¼Œé¿å…é‡è¤‡å‰µå»º
        if (document.getElementById('ai-notification-style')) {
            return;
        }
        // å‰µå»ºæ¨£å¼
        const style = document.createElement('style');
        style.id = 'ai-notification-style';
        style.textContent = `
        .ai-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            padding: 30px 40px;
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(220, 38, 38, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10000;
        }
        .ai-notification-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 9999;
        }
        .ai-notification-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .ai-notification-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .ai-notification-content {
            position: relative;
        }
        .ai-notification-icon {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        .ai-notification-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }
        .ai-notification-message {
            font-size: 16px;
            opacity: 0.9;
            text-align: center;
            margin: 0;
        }
    `;
        document.head.appendChild(style);

        // é—œé–‰å‡½æ•¸
        const closeNotification = () => {
            const notif = document.getElementById('ai-notification');
            const back = document.getElementById('ai-notification-backdrop');
            const sty = document.getElementById('ai-notification-style');

            if (notif) document.body.removeChild(notif);
            if (back) document.body.removeChild(back);
            if (sty) document.head.removeChild(sty);
        };

        // å‰µå»ºèƒŒæ™¯é®ç½©
        const backdrop = document.createElement('div');
        backdrop.className = 'ai-notification-backdrop';
        backdrop.id = 'ai-notification-backdrop';
        backdrop.addEventListener('click', closeNotification);

        // å‰µå»ºé€šçŸ¥å…ƒç´ 
        const notification = document.createElement('div');
        notification.className = 'ai-notification';
        notification.id = 'ai-notification';
        notification.innerHTML = `
        <div class="ai-notification-content">
            <button class="ai-notification-close" aria-label="é—œé–‰">âœ•</button>
            <div class="ai-notification-icon">âš ï¸</div>
            <h3 class="ai-notification-title">AI å¼•æ“å°šæœªå°±ç·’</h3>
            <p class="ai-notification-message">ç³»çµ±æ­£åœ¨åˆå§‹åŒ–ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦</p>
        </div>
    `;

        // æ·»åŠ åˆ°é é¢
        document.body.appendChild(backdrop);
        document.body.appendChild(notification);

        // ç¶å®šé—œé–‰æŒ‰éˆ•äº‹ä»¶
        const closeBtn = notification.querySelector('.ai-notification-close');
        closeBtn.addEventListener('click', closeNotification);

        // 3ç§’å¾Œè‡ªå‹•ç§»é™¤
        setTimeout(closeNotification, 3000);
    }

    /**
     * ğŸ¨ å‰µå»º AI åˆ†ææŒ‰éˆ•ï¼ˆå›ºå®šåº•éƒ¨ï¼Œç¬¦åˆåŸæœ‰é¢¨æ ¼ï¼‰
     */
    function createAIAnalysisButton() {
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (document.getElementById('ai-analyze-btn')) {
            return;
        }

        // ğŸ”¥ æª¢æ¸¬æ˜¯å¦ç‚ºç§»å‹•è¨­å‚™
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 768;

        if (isMobile) {
            // === ç§»å‹•è¨­å‚™ï¼šå›ºå®šåœ¨åº•éƒ¨ ===
            const container = document.createElement('div');
            container.id = 'ai-analyze-container';
            container.style.cssText = `
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: transparent;
        z-index: 9999;
        padding: 0;                    /* âœ… æ”¹æˆ 0 */
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

            const button = document.createElement('button');
            button.id = 'ai-analyze-btn';
            button.textContent = 'ğŸ¤– AI åˆ†æ';
            button.style.cssText = `
        padding: 12px 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin: 10px 16px;              /* âœ… æ”¹æˆèˆ‡ä¸Šæ–¹æŒ‰éˆ•ä¸€è‡´ */
        width: calc(100% - 32px);       /* âœ… æ¸›å»å·¦å³ margin */
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: background-color 0.3s ease;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    `;
            // hover/active æ•ˆæœ
            button.addEventListener('mouseenter', () => {
                if (!button.disabled) button.style.backgroundColor = '#45a049';
            });

            button.addEventListener('mouseleave', () => {
                if (!button.disabled) button.style.backgroundColor = '#4CAF50';
            });

            // è§¸æ§åé¥‹
            button.addEventListener('touchstart', () => {
                if (!button.disabled) button.style.backgroundColor = '#45a049';
            }, { passive: true });

            button.addEventListener('touchend', () => {
                if (!button.disabled) {
                    setTimeout(() => {
                        button.style.backgroundColor = '#4CAF50';
                    }, 150);
                }
            }, { passive: true });

            // é»æ“Šäº‹ä»¶
            button.onclick = () => {
                if (aiAnalysisManager) {
                    aiAnalysisManager.analyzePosition();
                }
            };

            container.appendChild(button);
            document.body.appendChild(container);

            console.log('âœ… AI åˆ†ææŒ‰éˆ•å·²å‰µå»ºï¼ˆç§»å‹•è¨­å‚™å›ºå®šåº•éƒ¨ï¼‰');

        } else {
            // === æ¡Œé¢è¨­å‚™ï¼šåŠ åˆ°æ§åˆ¶é¢æ¿ ===
            const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
                btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
            );

            let buttonContainer = regretButton ? regretButton.parentElement :
                document.getElementById('controls') ||
                document.body;

            const button = document.createElement('button');
            button.id = 'ai-analyze-btn';
            button.textContent = 'ğŸ¤– AI åˆ†æ';

            // ğŸ”¥ è¤‡è£½å…¶ä»–æŒ‰éˆ•çš„æ¨£å¼
            if (regretButton) {
                button.className = regretButton.className;
                button.style.cssText = regretButton.style.cssText;
            } else {
                button.style.cssText = `
                padding: 12px 20px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                margin: 5px;
            `;
            }

            // hover æ•ˆæœ
            button.addEventListener('mouseenter', () => {
                if (!button.disabled) button.style.backgroundColor = '#45a049';
            });

            button.addEventListener('mouseleave', () => {
                if (!button.disabled) button.style.backgroundColor = '#4CAF50';
            });

            // é»æ“Šäº‹ä»¶
            button.onclick = () => {
                if (aiAnalysisManager) {
                    aiAnalysisManager.analyzePosition();
                }
            };

            buttonContainer.appendChild(button);

            console.log('âœ… AI åˆ†ææŒ‰éˆ•å·²å‰µå»ºï¼ˆæ¡Œé¢è¨­å‚™å´é‚Šï¼‰');
        }
    }

    /**
     * ğŸ¨ åŠ å…¥ CSS æ¨£å¼
     */
    function addAIAnalysisStyles() {
        const style = document.createElement('style');
        style.textContent = `
        .ai-suggestion-from {
            background-color: rgba(76, 175, 80, 0.6) !important;
            box-shadow: 0 0 10px #4CAF50 !important;
            animation: pulse-green 1s infinite;
        }

        .ai-suggestion-to {
            background-color: rgba(33, 150, 243, 0.6) !important;
            box-shadow: 0 0 10px #2196F3 !important;
            animation: pulse-blue 1s infinite;
        }

        @keyframes pulse-green {
            0% { box-shadow: 0 0 5px #4CAF50; }
            50% { box-shadow: 0 0 15px #4CAF50; }
            100% { box-shadow: 0 0 5px #4CAF50; }
        }

        @keyframes pulse-blue {
            0% { box-shadow: 0 0 5px #2196F3; }
            50% { box-shadow: 0 0 15px #2196F3; }
            100% { box-shadow: 0 0 5px #2196F3; }
        }
    `;
        document.head.appendChild(style);
    }

    // ğŸ”¥ ä¿®å¤ç‰ˆï¼šæ£‹å­é¢œè‰²è¯†åˆ«é€»è¾‘
    function getBoardState() {
        const board = Array(10).fill(null).map(() => Array(9).fill(null));

        try {
            const pieces = document.querySelectorAll('img.chess-piece');
            let validPieceCount = 0;

            console.log(`ğŸ” å¼€å§‹æ£€æµ‹æ£‹ç›˜ï¼Œæ‰¾åˆ° ${pieces.length} ä¸ªæ£‹å­å…ƒç´ `);

            pieces.forEach((pieceElement, index) => {
                try {
                    let row, col, pieceType, pieceColor;

                    // ğŸ”¥ æ­¥éª¤1: è·å–æ£‹å­ç±»å‹ï¼ˆä» alt å±æ€§ï¼‰
                    pieceType = pieceElement.alt;

                    // ğŸ”¥ æ­¥éª¤2: ä»å›¾ç‰‡è·¯å¾„è¯†åˆ«é¢œè‰²ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
                    const src = pieceElement.src.toLowerCase();

                    if (src.includes('_black') || src.includes('black_')) {
                        pieceColor = 'black';
                    } else if (src.includes('_red') || src.includes('red_')) {
                        pieceColor = 'red';
                    } else {
                        // ğŸ”¥ æ­¥éª¤3: æ ¹æ®æ£‹å­ç±»å‹åˆ¤æ–­é¢œè‰²ï¼ˆä½œä¸ºåå¤‡æ–¹æ¡ˆï¼‰
                        const redPieces = ['å¸¥', 'ä»•', 'ç›¸', 'å‚Œ', 'ä¿¥', 'ç‚®', 'å…µ'];
                        const blackPieces = ['å°‡', 'å£«', 'è±¡', 'é¦¬', 'è»Š', 'åŒ…', 'å’'];

                        if (redPieces.includes(pieceType)) {
                            pieceColor = 'red';
                            console.log(`  âš ï¸ è­¦å‘Š: ${pieceType} ä»ç±»å‹æ¨æ–­ä¸ºçº¢è‰² (src=${src})`);
                        } else if (blackPieces.includes(pieceType)) {
                            pieceColor = 'black';
                            console.log(`  âš ï¸ è­¦å‘Š: ${pieceType} ä»ç±»å‹æ¨æ–­ä¸ºé»‘è‰² (src=${src})`);
                        } else {
                            console.warn(`  âŒ æ— æ³•è¯†åˆ«æ£‹å­ç±»å‹: ${pieceType} (src=${src})`);
                            return; // è·³è¿‡è¿™ä¸ªæ£‹å­
                        }
                    }

                    // ğŸ”¥ æ­¥éª¤4: è·å–æ£‹å­ä½ç½®
                    let parent = pieceElement.parentElement;
                    if (parent && parent.classList.contains('tile')) {
                        // æ–¹æ³•A: ä»çˆ¶å…ƒç´ çš„ data å±æ€§è·å–
                        if (parent.hasAttribute('data-row') && parent.hasAttribute('data-col')) {
                            row = parseInt(parent.getAttribute('data-row'));
                            col = parseInt(parent.getAttribute('data-col'));
                        } else {
                            // æ–¹æ³•B: ä» DOM ç»“æ„é¡ºåºæ¨æ–­ï¼ˆ10è¡Œ9åˆ—å¸ƒå±€ï¼‰
                            const allTiles = document.querySelectorAll('.tile');
                            const currentTileIndex = Array.from(allTiles).indexOf(parent);
                            if (currentTileIndex !== -1) {
                                row = Math.floor(currentTileIndex / 9);
                                col = currentTileIndex % 9;
                            }
                        }
                    }

                    // ğŸ”¥ æ­¥éª¤5: éªŒè¯å¹¶æ·»åŠ åˆ°æ£‹ç›˜
                    if (typeof row === 'number' && typeof col === 'number' &&
                        row >= 0 && row < 10 && col >= 0 && col < 9 &&
                        pieceType && pieceColor) {

                        board[row][col] = {
                            type: pieceType,
                            color: pieceColor
                        };
                        validPieceCount++;

                        console.log(`  âœ… [${index}] ${pieceColor} ${pieceType} åœ¨ (${row}, ${col})`);
                    } else {
                        console.warn(`  âš ï¸ [${index}] æ£‹å­æ•°æ®ä¸å®Œæ•´:`, {
                            row, col, pieceType, pieceColor
                        });
                    }

                } catch (error) {
                    console.warn(`  âŒ å¤„ç†æ£‹å­å…ƒç´ æ—¶å‡ºé”™:`, error);
                }
            });

            console.log(`âœ… æˆåŠŸæ£€æµ‹åˆ° ${validPieceCount} ä¸ªæœ‰æ•ˆæ£‹å­`);

            // ğŸ”¥ æ–°å¢: æ‰“å°æ£‹ç›˜å¸ƒå±€ï¼ˆä¾¿äºè°ƒè¯•ï¼‰
            if (validPieceCount > 0) {
                console.log('ğŸ“‹ å½“å‰æ£‹ç›˜å¸ƒå±€:');
                for (let r = 0; r < 10; r++) {
                    let rowStr = `è¡Œ${r}: `;
                    for (let c = 0; c < 9; c++) {
                        if (board[r][c]) {
                            const p = board[r][c];
                            const colorSymbol = p.color === 'red' ? 'ğŸ”´' : 'âš«';
                            rowStr += `${colorSymbol}${p.type} `;
                        } else {
                            rowStr += '__ ';
                        }
                    }
                    console.log(rowStr);
                }
            }

            return validPieceCount > 0 ? board : null;

        } catch (error) {
            console.error('âŒ è·å–æ£‹ç›˜çŠ¶æ€å¤±è´¥:', error);
            return null;
        }
    }

    // åº§æ¨™è½‰æ›ç‚ºè±¡æ£‹è¨˜æ³•
    function convertToNotation(fromRow, fromCol, toRow, toCol, piece) {
        // è·å–å½“å‰æ£‹ç›˜çŠ¶æ€
        const board = getBoardState();

        const isBoardFlipped = gameState && gameState.isFlipped;
        console.log(`ğŸ”„ æ£‹ç›¤ç¿»è½‰ç‹€æ…‹: ${isBoardFlipped}, æ£‹å­é¡è‰²: ${piece.color}`);


        // ğŸ”¥ æ–°å¢ï¼šå°‡è¦–è¦ºåº§æ¨™è½‰æ›ç‚ºé‚è¼¯åº§æ¨™
        const logicalFromRow = isBoardFlipped ? (9 - fromRow) : fromRow;
        const logicalToRow = isBoardFlipped ? (9 - toRow) : toRow;
        console.log(`ğŸ“ åº§æ¨™è½‰æ›: è¦–è¦º(${fromRow}) -> é‚è¼¯(${logicalFromRow})`);

        if (!board) {
            console.warn('æ— æ³•è·å–æ£‹ç›˜çŠ¶æ€ï¼Œä½¿ç”¨ç®€åŒ–è®°è°±');
            return convertToNotationSimple(fromRow, fromCol, toRow, toCol, piece);
        }

        const isRed = piece.color === 'red';

        // æ£‹å­åç¨±å°ç…§
        const pieceNames = {
            'red': {
                'å¸¥': 'å¸¥', 'ä»•': 'ä»•', 'ç›¸': 'ç›¸', 'å‚Œ': 'å‚Œ',
                'ä¿¥': 'ä¿¥', 'ç‚®': 'ç‚®', 'å…µ': 'å…µ'
            },
            'black': {
                'å°‡': 'å°‡', 'å£«': 'å£«', 'è±¡': 'è±¡', 'é¦¬': 'é¦¬',
                'è»Š': 'è»Š', 'åŒ…': 'åŒ…', 'å’': 'å’'
            }
        };

        // åˆ—æ•¸è½‰æ›
        const colNamesRed = ['ä¹', 'å…«', 'ä¸ƒ', 'å…­', 'äº”', 'å››', 'ä¸‰', 'äºŒ', 'ä¸€'];
        const colNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const getColName = (col) => isRed ? colNamesRed[col] : colNamesBlack[col];

        // è·é›¢æ•¸å­—è½‰æ›
        const distanceNamesRed = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
        const distanceNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const getDistanceName = (distance) => {
            if (distance >= 1 && distance <= 9) {
                return isRed ? distanceNamesRed[distance - 1] : distanceNamesBlack[distance - 1];
            }
            return distance.toString();
        };

        const pieceName = pieceNames[piece.color][piece.type];
        const fromColName = getColName(fromCol);
        const toColName = getColName(toCol);

        // **æ£€æµ‹åŒä¸€åˆ—çš„ç›¸åŒæ£‹å­**
        console.log(`ğŸ” æ£€æµ‹åŒåˆ—æ£‹å­: ${piece.color} ${piece.type} åœ¨ç¬¬${fromCol}åˆ—`);

        const samePiecesInColumn = [];
        for (let row = 0; row < 10; row++) {
            const currentPiece = board[row][fromCol];
            if (currentPiece &&
                currentPiece.color === piece.color &&
                currentPiece.type === piece.type) {
                samePiecesInColumn.push({
                    row: row,
                    piece: currentPiece
                });
                console.log(`  æ‰¾åˆ°åŒç±»æ£‹å­åœ¨ç¬¬${row}è¡Œç¬¬${fromCol}åˆ—`);
            }
        }

        console.log(`ğŸ“Š ç¬¬${fromCol}åˆ—å…±æœ‰${samePiecesInColumn.length}ä¸ª${piece.color} ${piece.type}`);

        // å¤„ç†åŒä¸€ç«–çº¿å¤šä¸ªåŒç±»æ£‹å­çš„æƒ…å†µ
        let piecePrefix = pieceName;
        let colPrefix = fromColName;

        if (samePiecesInColumn.length > 1) {
            // ğŸ”¥ æ ¹æ“šæ£‹ç›¤ç¿»è½‰ç‹€æ…‹åˆ¤å®šå‰å¾Œ
            // æœªç¿»è½‰: ç´…æ–¹åº•ç·šrow=9ï¼Œé»‘æ–¹åº•ç·šrow=0
            // å·²ç¿»è½‰: ç´…æ–¹åº•ç·šrow=0ï¼Œé»‘æ–¹åº•ç·šrow=9

            samePiecesInColumn.sort((a, b) => {
                if (!isBoardFlipped) {
                    // æœªç¿»è½‰ï¼šç´…æ–¹è¡Œè™Ÿå°=å‰ï¼Œé»‘æ–¹è¡Œè™Ÿå¤§=å‰
                    return isRed ? (a.row - b.row) : (b.row - a.row);
                } else {
                    // å·²ç¿»è½‰ï¼šç´…æ–¹è¡Œè™Ÿå¤§=å‰ï¼Œé»‘æ–¹è¡Œè™Ÿå°=å‰
                    return isRed ? (b.row - a.row) : (a.row - b.row);
                }
            });

            console.log(`ğŸ”„ æ’åºé‚è¼¯: ${isRed ? 'ç´…æ–¹' : 'é»‘æ–¹'}, æ£‹ç›¤${isBoardFlipped ? 'å·²ç¿»è½‰' : 'æœªç¿»è½‰'}`);

            const currentIndex = samePiecesInColumn.findIndex(p => p.row === (isBoardFlipped ? (9 - fromRow) : fromRow));
            console.log(`ğŸ¯ å½“å‰ç§»åŠ¨æ£‹å­åœ¨æ’åºåçš„ç¬¬${currentIndex}ä½ï¼ˆå…±${samePiecesInColumn.length}ä¸ªï¼‰`);



            // ç‰¹æ®Šå¤„ç†å…µå’
            if (piece.type === 'å…µ' || piece.type === 'å’') {
                const pawnName = piece.type; // å…³é”®ï¼šä½¿ç”¨å®é™…ç±»å‹ 'å…µ' æˆ– 'å’'

                if (samePiecesInColumn.length === 3) {
                    // ä¸‰ä¸ªå…µçš„æƒ…å†µ
                    if (currentIndex === 1) {
                        piecePrefix = 'ä¸­å…µ';
                        colPrefix = '';
                    } else {
                        piecePrefix = (currentIndex === 0) ? 'å‰å…µ' : 'å¾Œå…µ';
                        colPrefix = '';
                    }
                    console.log(`âœ… ä¸‰å…µæƒ…å†µï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}`);
                } else if (samePiecesInColumn.length === 4) {
                    // å››ä¸ªå…µçš„æƒ…å†µ
                    const positions = ['å‰', 'äºŒ', 'ä¸‰', 'å¾Œ'];
                    piecePrefix = positions[currentIndex] + 'å…µ';
                    colPrefix = '';
                    console.log(`âœ… å››å…µæƒ…å†µï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}`);
                } else if (samePiecesInColumn.length === 5) {
                    // äº”ä¸ªå…µçš„æƒ…å†µ
                    const positions = ['å‰', 'äºŒ', 'ä¸‰', 'å››', 'å¾Œ'];
                    piecePrefix = positions[currentIndex] + 'å…µ';
                    colPrefix = '';
                    console.log(`âœ… äº”å…µæƒ…å†µï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}`);
                } else if (samePiecesInColumn.length === 2) {
                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¤šæ¡ç«–çº¿éƒ½æœ‰å¤šä¸ªå…µçš„æƒ…å†µ
                    let multiColumnPawns = false;
                    for (let col = 0; col < 9; col++) {
                        if (col === fromCol) continue;
                        let pawnCount = 0;
                        for (let row = 0; row < 10; row++) {
                            const p = board[row][col];
                            if (p && p.color === piece.color && (p.type === 'å…µ' || p.type === 'å’')) {
                                pawnCount++;
                            }
                        }
                        if (pawnCount >= 2) {
                            multiColumnPawns = true;
                            break;
                        }
                    }

                    if (multiColumnPawns) {
                        // å­˜åœ¨å¤šæ¡ç«–çº¿éƒ½æœ‰â‰¥2ä¸ªå…µ/å’çš„æƒ…å†µï¼Œä½¿ç”¨å‰/å+åˆ—å·
                        piecePrefix = (currentIndex === 0) ? 'å‰' : 'å¾Œ';
                        colPrefix = fromColName;
                        console.log(`âœ… å¤šåˆ—${pawnName}æƒ…å†µï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}${colPrefix}`);
                    } else {
                        // ä¸¤ä¸ªå…µ/å’çš„æƒ…å†µ
                        piecePrefix = (currentIndex === 0) ? 'å‰' + pawnName : 'å¾Œ' + pawnName;
                        colPrefix = '';
                        console.log(`âœ… ä¸¤${pawnName}æƒ…å†µï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}`);
                    }
                }
            } else {
                // éå…µå’æ£‹å­çš„å¤„ç†ï¼ˆå£«å’Œç›¸é™¤å¤–ï¼‰
                if (piece.type !== 'ä»•' && piece.type !== 'å£«' && piece.type !== 'ç›¸' && piece.type !== 'è±¡') {
                    if (samePiecesInColumn.length === 2) {
                        // ä¸¤ä¸ªç›¸åŒæ£‹å­çš„æƒ…å†µ
                        piecePrefix = (currentIndex === 0) ? 'å‰' : 'å¾Œ';
                        colPrefix = pieceName;  // ç¬¬äºŒä¸ªå­—æ˜¯æ£‹å­åç§°
                        console.log(`âœ… ä¸¤ä¸ª${pieceName}ï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}${colPrefix}`);
                    } else if (samePiecesInColumn.length > 2) {
                        // å¤šäºä¸¤ä¸ªçš„æƒ…å†µ
                        if (currentIndex === 0) {
                            piecePrefix = 'å‰';
                        } else if (currentIndex === samePiecesInColumn.length - 1) {
                            piecePrefix = 'å¾Œ';
                        } else {
                            piecePrefix = 'ä¸­';  // ä¸­é—´çš„æ£‹å­
                        }
                        colPrefix = pieceName;
                        console.log(`âœ… å¤šä¸ª${pieceName}ï¼Œå½“å‰æ£‹å­è®°ä¸º: ${piecePrefix}${colPrefix}`);
                    }
                } else {
                    console.log(`â„¹ï¸ ${pieceName}æ˜¯å£«æˆ–ç›¸ï¼Œä¸ä½¿ç”¨å‰ååŒºåˆ†`);
                }
            }
        } else {
            console.log(`â„¹ï¸ ç¬¬${fromCol}åˆ—åªæœ‰1ä¸ª${piece.color} ${piece.type}ï¼Œä½¿ç”¨å¸¸è§„è®°è°±`);
        }

        // åˆ¤æ–·ç§»å‹•é¡å‹å¹¶ç”Ÿæˆæœ€ç»ˆè®°è°±
        let finalNotation;
        if (fromCol === toCol) {
            // å‚ç›´ç§»å‹•
            const distance = Math.abs(toRow - fromRow);
            const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
            finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${getDistanceName(distance)}`;
        } else if (fromRow === toRow) {
            // æ°´å¹³ç§»å‹•
            finalNotation = `${piecePrefix}${colPrefix}å¹³${toColName}`;
        } else {
            // æ–œå‘ç§»å‹•
            const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
            finalNotation = `${piecePrefix}${colPrefix}${isAdvancing ? 'é€²' : 'é€€'}${toColName}`;
        }

        console.log(`ğŸ‰ æœ€ç»ˆè®°è°±: ${finalNotation}`);
        return finalNotation;
    }

    // ç®€åŒ–è®°è°±ï¼ˆåå¤‡æ–¹æ¡ˆï¼‰
    function convertToNotationSimple(fromRow, fromCol, toRow, toCol, piece) {
        const isRed = piece.color === 'red';

        const pieceNames = {
            'red': { 'å¸¥': 'å¸¥', 'ä»•': 'ä»•', 'ç›¸': 'ç›¸', 'å‚Œ': 'é¦¬', 'ä¿¥': 'è»Š', 'ç‚®': 'ç‚®', 'å…µ': 'å…µ' },
            'black': { 'å°‡': 'å°‡', 'å£«': 'å£«', 'è±¡': 'è±¡', 'é¦¬': 'é¦¬', 'è»Š': 'è»Š', 'åŒ…': 'ç‚®', 'å’': 'å’' }
        };

        const colNamesRed = ['ä¹', 'å…«', 'ä¸ƒ', 'å…­', 'äº”', 'å››', 'ä¸‰', 'äºŒ', 'ä¸€'];
        const colNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const getColName = (col) => isRed ? colNamesRed[col] : colNamesBlack[col];

        const distanceNamesRed = ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹'];
        const distanceNamesBlack = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
        const getDistanceName = (distance) => {
            if (distance >= 1 && distance <= 9) {
                return isRed ? distanceNamesRed[distance - 1] : distanceNamesBlack[distance - 1];
            }
            return distance.toString();
        };

        const pieceName = pieceNames[piece.color][piece.type];
        const fromColName = getColName(fromCol);
        const toColName = getColName(toCol);

        if (fromCol === toCol) {
            const distance = Math.abs(toRow - fromRow);
            const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
            return `${pieceName}${fromColName}${isAdvancing ? 'é€²' : 'é€€'}${getDistanceName(distance)}`;
        } else if (fromRow === toRow) {
            return `${pieceName}${fromColName}å¹³${toColName}`;
        } else {
            const isAdvancing = isRed ? (toRow < fromRow) : (toRow > fromRow);
            return `${pieceName}${fromColName}${isAdvancing ? 'é€²' : 'é€€'}${toColName}`;
        }
    }


    // ========================================
    // âœ… è£œå……ï¼šç¢ºä¿ recordMove è¿”å›æ£‹è­œ
    // ========================================
    function recordMove(fromRow, fromCol, toRow, toCol, boardStateHistory = null) {
        const piece = gameState.board[toRow][toCol];
        const notation = convertToNotation(fromRow, fromCol, toRow, toCol, piece);

        // âœ… é—œéµï¼šå…ˆä¿å­˜æœ€æ–°æ£‹è­œ
        const latestNotation = notation;
        console.log(`ğŸ¯ recordMove ç”Ÿæˆæ£‹è­œ: ${latestNotation}`);

        // è¨˜éŒ„ç§»å‹•åˆ°æ£‹è­œ
        if (gameState.currentTurn === 'red') {
            gameState.gameRecord.push({
                red: notation,
                black: null
            });
        } else {
            if (gameState.gameRecord.length > 0) {
                const lastMove = gameState.gameRecord[gameState.gameRecord.length - 1];
                if (!lastMove.black) {
                    lastMove.black = notation;
                } else {
                    console.error('âŒ æ£‹è­œè¨˜éŒ„éŒ¯èª¤ï¼šé»‘æ–¹é‡è¤‡è¨˜éŒ„');
                }
            } else {
                console.error('âŒ æ£‹è­œè¨˜éŒ„éŒ¯èª¤ï¼šé»‘æ–¹å…ˆæ‰‹');
                gameState.gameRecord.push({
                    red: null,
                    black: notation
                });
            }
        }

        // è¨˜éŒ„æ­·å²ç‹€æ…‹
        const stateToSave = {
            board: JSON.parse(JSON.stringify(gameState.board)),
            currentTurn: gameState.currentTurn,
            gameRecord: JSON.parse(JSON.stringify(gameState.gameRecord)),
            totalMoves: gameState.totalMoves,
            noCaptureCount: gameState.noCaptureCount
        };

        if (historyManager) {
            if (historyManager.canRedo()) {
                historyManager.history = historyManager.history.slice(0, historyManager.currentIndex + 1);
            }
            historyManager.addState(stateToSave);
        }

        console.log(`ğŸ” ç•¶å‰æ£‹è­œé•·åº¦: ${gameState.gameRecord.length}`);

        // ä¿®æ­£ï¼šåªæœ‰ç•¶æ£‹è­œé•·åº¦è¶³å¤ æ™‚æ‰é–‹å§‹æª¢æ¸¬
        if (gameState.gameRecord.length >= 2) {

            // ğŸ¥‡ å„ªå…ˆç´š1ï¼šæª¢æ¸¬é•·å°‡
            const perpetualCheckResult = cycleDetector.detectPerpetualCheck(
                gameState.gameRecord,
                Math.max(0, gameState.gameRecord.length - 6),
                gameState.gameRecord.length
            );

            if (perpetualCheckResult && perpetualCheckResult.isPerpetualCheck) {
                console.log(`ğŸ” æª¢æ¸¬åˆ°é•·å°‡ï¼Œå¾ªç’°æ¬¡æ•¸: ${perpetualCheckResult.cycleCount}`);

                const lossThreshold = 3;
                const warningThreshold = 2;

                if (perpetualCheckResult.cycleCount >= lossThreshold) {
                    console.log(`ğŸš¨ é•·å°‡åˆ¤è² ï¼š${perpetualCheckResult.perpetualCheckPlayer}æ–¹é•·å°‡${perpetualCheckResult.cycleCount}å›åˆ`);
                    handlePerpetualCheckLoss(perpetualCheckResult);
                    return latestNotation; // âœ… ç¢ºä¿è¿”å›
                }

                if (perpetualCheckResult.cycleCount >= warningThreshold) {
                    console.log(`âš ï¸ é•·å°‡è­¦å‘Šï¼š${perpetualCheckResult.perpetualCheckPlayer}æ–¹é•·å°‡${perpetualCheckResult.cycleCount}å›åˆ`);
                    handlePerpetualCheckWarning(perpetualCheckResult);
                }

                updateMoveDisplay();
                return latestNotation; // âœ… ç¢ºä¿è¿”å›
            }

            // ğŸ¥ˆ å„ªå…ˆç´š2ï¼šæª¢æ¸¬é•·æ‰
            const longCaptureResult = cycleDetector.detectLongCaptureWithParams(
                gameState.gameRecord,
                Math.max(0, gameState.gameRecord.length - 6),
                gameState.gameRecord.length,
                2, 2
            );

            if (longCaptureResult && longCaptureResult.isLongCapture) {
                console.log(`ğŸ” æª¢æ¸¬åˆ°é•·æ‰çµæœ:`, longCaptureResult);

                const cycleCount = longCaptureResult.internalCycleCount || longCaptureResult.cycleCount || 0;

                const lossThreshold = 3;
                const warningThreshold = 2;

                console.log(`ğŸ” é•·æ‰å¾ªç’°æ¬¡æ•¸: ${cycleCount}, åˆ¤è² é–¾å€¼: ${lossThreshold}, è­¦å‘Šé–¾å€¼: ${warningThreshold}`);

                if (cycleCount >= lossThreshold) {
                    console.log(`ğŸš¨ é•·æ‰åˆ¤è² ï¼š${longCaptureResult.longCapturePlayer}æ–¹é•·æ‰${cycleCount}å›åˆ`);
                    longCaptureResult.shouldEndGame = true;
                    longCaptureResult.warningLevel = 'loss';
                    handleLongCaptureLoss(longCaptureResult);
                    return latestNotation; // âœ… ç¢ºä¿è¿”å›
                }

                if (cycleCount >= warningThreshold) {
                    console.log(`âš ï¸ é•·æ‰è­¦å‘Šï¼š${longCaptureResult.longCapturePlayer}æ–¹é•·æ‰${cycleCount}å›åˆ`);
                    longCaptureResult.shouldEndGame = false;
                    longCaptureResult.warningLevel = 'warning';
                    handleLongCaptureWarning(longCaptureResult);
                }

                updateMoveDisplay();
                return latestNotation; // âœ… ç¢ºä¿è¿”å›
            }

            // ğŸ¥‰ å„ªå…ˆç´š3ï¼šæ™®é€šå¾ªç’°æª¢æ¸¬
            const cycleResult = cycleDetector.detectCycle(gameState.gameRecord, boardStateHistory);

            if (cycleResult && cycleResult.type === 'draw') {
                console.log(`ğŸ”„ æª¢æ¸¬åˆ°å¾ªç’°å’Œæ£‹ï¼š${cycleResult.cycleCount}æ¬¡å¾ªç’°`);
                handleCycleDraw(cycleResult);
                return latestNotation; // âœ… ç¢ºä¿è¿”å›
            }

            if (cycleResult && cycleResult.type === 'warning') {
                console.log(`âš ï¸ å¾ªç’°è­¦å‘Šï¼š${cycleResult.cycleCount}æ¬¡å¾ªç’°`);
                handleCycleWarning(cycleResult);
            }
        }

        updateMoveDisplay();
        return latestNotation; // âœ… æœ€çµ‚ç¢ºä¿è¿”å›
    }



    // æ£‹é˜æ ¸å¿ƒé‚è¼¯å‡½æ•¸
    function createChessClock() {
        let enabled = false;
        let gameStarted = false;
        let isRunning = false;
        let currentPlayer = 'red';
        let totalMinutes = 10;
        let incrementSeconds = 0;

        let redTimeLeft = totalMinutes * 60; // ç§’
        let blackTimeLeft = totalMinutes * 60; // ç§’

        let timer = null;
        let callbacks = {};

        const warningTime = 60; // 60ç§’è­¦å‘Š

        return {
            setEnabled(value) {
                enabled = value;
            },

            setTotalMinutes(minutes) {
                totalMinutes = minutes;
                if (!gameStarted) {
                    redTimeLeft = minutes * 60;
                    blackTimeLeft = minutes * 60;
                }
            },

            setIncrementSeconds(seconds) {
                incrementSeconds = seconds;
            },

            startGame() {
                gameStarted = true;
                isRunning = true;
                currentPlayer = 'red';
                redTimeLeft = totalMinutes * 60;
                blackTimeLeft = totalMinutes * 60;
                this.startClock();
            },

            startClock() {
                if (!gameStarted) return;

                isRunning = true;
                timer = setInterval(() => {
                    if (currentPlayer === 'red') {
                        redTimeLeft--;
                        if (redTimeLeft <= 0) {
                            this.stopClock();
                            callbacks.onTimeUp && callbacks.onTimeUp('red');
                            return;
                        }
                        // æª¢æŸ¥è­¦å‘Šç‹€æ…‹
                        if (redTimeLeft === warningTime && callbacks.onWarning) {
                            callbacks.onWarning('red', true);
                        }
                    } else {
                        blackTimeLeft--;
                        if (blackTimeLeft <= 0) {
                            this.stopClock();
                            callbacks.onTimeUp && callbacks.onTimeUp('black');
                            return;
                        }
                        // æª¢æŸ¥è­¦å‘Šç‹€æ…‹
                        if (blackTimeLeft === warningTime && callbacks.onWarning) {
                            callbacks.onWarning('black', true);
                        }
                    }

                    callbacks.onTick && callbacks.onTick();
                }, 1000);
            },

            stopClock() {
                isRunning = false;
                gameStarted = false;
                if (timer) {
                    clearInterval(timer);
                    timer = null;
                }
                currentPlayer = 'red';
            },

            switchPlayer() {
                if (!gameStarted || !isRunning) return;

                // åŠ ç§’çµ¦ç•¶å‰ç©å®¶
                if (incrementSeconds > 0) {
                    if (currentPlayer === 'red') {
                        redTimeLeft += incrementSeconds;
                    } else {
                        blackTimeLeft += incrementSeconds;
                    }
                }

                // åˆ‡æ›ç©å®¶
                currentPlayer = currentPlayer === 'red' ? 'black' : 'red';
                callbacks.onPlayerSwitch && callbacks.onPlayerSwitch(currentPlayer);
                callbacks.onTick && callbacks.onTick();
            },

            getTimeDisplay() {
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                };

                return {
                    red: formatTime(Math.max(0, redTimeLeft)),
                    black: formatTime(Math.max(0, blackTimeLeft)),
                    redWarning: redTimeLeft <= warningTime && redTimeLeft > 0,
                    blackWarning: blackTimeLeft <= warningTime && blackTimeLeft > 0,
                    currentPlayer: currentPlayer
                };
            },

            getState() {
                return {
                    enabled,
                    gameStarted,
                    isRunning,
                    currentPlayer,
                    totalMinutes,
                    incrementSeconds
                };
            },

            setCallbacks(callbackObj) {
                callbacks = { ...callbacks, ...callbackObj };
            }
        };
    }

    // ä¿®æ”¹ createSidebarClock() å‡½æ•¸ä¸­çš„ sidebarContainer æ¨£å¼å’ŒåŠŸèƒ½

    function createSidebarClock() {
        const chessClock = createChessClock();

        // å‰µå»ºå´é‚Šæ¬„å®¹å™¨ - ä¿®æ”¹ç‚ºå¯æ‹–å‹•ç‰ˆæœ¬
        const sidebarContainer = document.createElement('div');
        sidebarContainer.id = 'chessClock-sidebar';
        sidebarContainer.style.cssText = `
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        width: min(90vw, 320px);
        z-index: 999;
        font-family: 'Microsoft JhengHei', sans-serif;
        cursor: move;
        touch-action: none;
    `;

        // æ·»åŠ æ‹–å‹•åŠŸèƒ½
        let isDragging = false;
        let currentX;
        let currentY;
        let initialX;
        let initialY;
        let xOffset = 0;
        let yOffset = 0;

        function dragStart(e) {
            const target = e.target;
            const clockDisplay = sidebarContainer.querySelector('#clockDisplay');
            const isGameStarted = clockDisplay && clockDisplay.style.display !== 'none';

            // è¨­å®šç•«é¢æ™‚ï¼šæŒ‰éˆ•ã€è¼¸å…¥æ¡†ã€é¸æ“‡æ¡†ä¸èƒ½æ‹–å‹•
            if (!isGameStarted) {
                if (target.tagName === 'BUTTON' ||
                    target.tagName === 'INPUT' ||
                    target.tagName === 'SELECT' ||
                    target.closest('button') ||
                    target.closest('input') ||
                    target.closest('select')) {
                    return;
                }
            }
            // æ¯”è³½ç•«é¢æ™‚ï¼šåªæœ‰æŒ‰éˆ•ä¸èƒ½æ‹–å‹•ï¼Œæ™‚é–“é¡¯ç¤ºå€åŸŸå¯ä»¥æ‹–å‹•
            else {
                if (target.tagName === 'BUTTON' || target.closest('button')) {
                    return;
                }
            }

            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }

            isDragging = true;
            sidebarContainer.style.transition = 'none';
        }

        function drag(e) {
            if (isDragging) {
                e.preventDefault();

                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }

                xOffset = currentX;
                yOffset = currentY;

                setTranslate(currentX, currentY);
            }
        }

        function dragEnd(e) {
            isDragging = false;
        }

        function setTranslate(xPos, yPos) {
            sidebarContainer.style.transform = `translate(calc(-50% + ${xPos}px), ${yPos}px)`;
        }

        // æ·»åŠ äº‹ä»¶ç›£è½å™¨
        sidebarContainer.addEventListener('mousedown', dragStart);
        sidebarContainer.addEventListener('touchstart', dragStart, { passive: false });
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('touchend', dragEnd);

        sidebarContainer.innerHTML = `
    <style>
        #chessClock-sidebar .chess-timer-container {
            background: rgba(245, 245, 245, 0.98);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            backdrop-filter: blur(5px);
        }
        #chessClock-sidebar h3 {
            text-align: center;
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
            cursor: move;
            padding: 8px;
            background: rgba(33, 150, 243, 0.1);
            border-radius: 6px;
            user-select: none;
        }
        #chessClock-sidebar .drag-hint {
            text-align: center;
            font-size: 11px;
            color: #999;
            margin: -8px 0 12px 0;
            user-select: none;
        }
        #chessClock-sidebar .settings-section {
            margin-bottom: 12px;
        }
        #chessClock-sidebar .setting-item {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 13px;
        }
        #chessClock-sidebar .setting-item select {
            margin-left: 8px;
            padding: 5px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            flex: 1;
        }
        #chessClock-sidebar .setting-item input[type="number"] {
            margin-left: 8px;
            padding: 5px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            width: 60px;
        }
        #chessClock-sidebar .custom-time-input {
            display: none;
            align-items: center;
            margin-left: 8px;
        }
        #chessClock-sidebar .start-btn {
            width: 100%;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
        }
        #chessClock-sidebar .start-btn:hover {
            background: #45a049;
        }
        #chessClock-sidebar .clock-display {
            margin-bottom: 12px;
        }
        #chessClock-sidebar .player-clock {
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid;
            transition: all 0.3s ease;
            cursor: move;
            user-select: none;
        }
        #chessClock-sidebar .red-clock {
            background: #ffebee;
            border-color: #f44336;
        }
        #chessClock-sidebar .black-clock {
            background: #f3e5f5;
            border-color: #9c27b0;
        }
        #chessClock-sidebar .player-name {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        #chessClock-sidebar .time-display {
            font-size: 22px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        #chessClock-sidebar .controls {
            text-align: center;
        }
        #chessClock-sidebar .switch-btn {
            width: 100%;
            padding: 12px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 8px;
        }
        #chessClock-sidebar .switch-btn:hover {
            background: #1976D2;
        }
        #chessClock-sidebar .stop-btn {
            width: 100%;
            padding: 8px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
        }
        #chessClock-sidebar .stop-btn:hover {
            background: #d32f2f;
        }
        @keyframes warning-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); background-color: #ff5722 !important; color: white !important; }
        }
        #chessClock-sidebar .warning {
            animation: warning-pulse 1s infinite;
        }
        #chessClock-sidebar .close-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #999;
            width: 20px;
            height: 20px;
            z-index: 10;
        }
    </style>

    <div class="chess-timer-container">
        <button class="close-btn" id="closeClock">âœ•</button>
        <h3>ğŸ• è±¡æ£‹æ£‹é˜</h3>
        <div class="drag-hint">ğŸ‘† é•·æŒ‰æ‹–å‹•èª¿æ•´ä½ç½®</div>

        <div id="settings" class="settings-section">
            <div class="setting-item">
                <span>ç¸½æ™‚é–“:</span>
                <select id="totalMinutes">
                    <option value="1">1åˆ†é˜</option>
                    <option value="3">3åˆ†é˜</option>
                    <option value="5">5åˆ†é˜</option>
                    <option value="10" selected>10åˆ†é˜</option>
                    <option value="15">15åˆ†é˜</option>
                    <option value="20">20åˆ†é˜</option>
                    <option value="30">30åˆ†é˜</option>
                    <option value="60">60åˆ†é˜</option>
                    <option value="90">90åˆ†é˜</option>
                    <option value="120">120åˆ†é˜</option>
                    <option value="custom">è‡ªå®šç¾©</option>
                </select>
                <div id="customTimeInput" class="custom-time-input">
                    <input type="number" id="customMinutes" min="1" max="120" placeholder="åˆ†é˜">
                </div>
            </div>

            <div class="setting-item">
                <span>åŠ ç§’:</span>
                <select id="incrementSeconds">
                    <option value="0" selected>0ç§’</option>
                    <option value="5">5ç§’</option>
                    <option value="10">10ç§’</option>
                    <option value="20">20ç§’</option>
                    <option value="30">30ç§’</option>
                    <option value="60">60ç§’</option>
                </select>
            </div>

            <button id="startGame" class="start-btn">é–‹å§‹æ¯”è³½</button>
        </div>

        <div id="clockDisplay" style="display: none;">
            <div class="clock-display">
                <div id="redClock" class="player-clock red-clock">
                    <div class="player-name">ç´…æ–¹</div>
                    <div id="redTime" class="time-display">10:00</div>
                </div>
                <div id="blackClock" class="player-clock black-clock">
                    <div class="player-name">é»‘æ–¹</div>
                    <div id="blackTime" class="time-display">10:00</div>
                </div>
            </div>

            <div class="controls">
                <button id="switchBtn" class="switch-btn">èµ°æ£‹å®Œæˆ</button>
                <button id="stopBtn" class="stop-btn">çµæŸéŠæˆ²</button>
            </div>
        </div>
    </div>
`;

        // ç²å–DOMå…ƒç´ 
        const elements = {
            settings: sidebarContainer.querySelector('#settings'),
            clockDisplay: sidebarContainer.querySelector('#clockDisplay'),
            totalMinutes: sidebarContainer.querySelector('#totalMinutes'),
            customTimeInput: sidebarContainer.querySelector('#customTimeInput'),
            customMinutes: sidebarContainer.querySelector('#customMinutes'),
            incrementSeconds: sidebarContainer.querySelector('#incrementSeconds'),
            startGame: sidebarContainer.querySelector('#startGame'),
            switchBtn: sidebarContainer.querySelector('#switchBtn'),
            stopBtn: sidebarContainer.querySelector('#stopBtn'),
            closeBtn: sidebarContainer.querySelector('#closeClock'),
            redTime: sidebarContainer.querySelector('#redTime'),
            blackTime: sidebarContainer.querySelector('#blackTime'),
            redClock: sidebarContainer.querySelector('#redClock'),
            blackClock: sidebarContainer.querySelector('#blackClock')
        };

        // è™•ç†æ™‚é–“é¸æ“‡è®ŠåŒ–
        elements.totalMinutes.addEventListener('change', function() {
            if (this.value === 'custom') {
                elements.customTimeInput.style.display = 'flex';
                elements.customMinutes.focus();
            } else {
                elements.customTimeInput.style.display = 'none';
                chessClock.setTotalMinutes(parseInt(this.value));
                updateTimeDisplay();
            }
        });

        // è™•ç†è‡ªå®šç¾©æ™‚é–“è¼¸å…¥
        elements.customMinutes.addEventListener('input', function() {
            const minutes = parseInt(this.value);
            if (minutes >= 1 && minutes <= 120) {
                chessClock.setTotalMinutes(minutes);
                updateTimeDisplay();
            }
        });

        elements.incrementSeconds.addEventListener('change', function() {
            chessClock.setIncrementSeconds(parseInt(this.value));
        });

        elements.startGame.addEventListener('click', function() {
            let totalMinutes;

            if (elements.totalMinutes.value === 'custom') {
                totalMinutes = parseInt(elements.customMinutes.value);
                if (!totalMinutes || totalMinutes < 1 || totalMinutes > 120) {
                    alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„æ™‚é–“ï¼ˆ1-120åˆ†é˜ï¼‰');
                    return;
                }
            } else {
                totalMinutes = parseInt(elements.totalMinutes.value);
            }

            showGameStartConfirmation(totalMinutes, elements.incrementSeconds.value, function(confirmed) {
                if (confirmed) {
                    chessClock.setTotalMinutes(totalMinutes);
                    chessClock.startGame();
                    elements.settings.style.display = 'none';
                    elements.clockDisplay.style.display = 'block';
                }
            });
        });

        elements.switchBtn.addEventListener('click', function() {
            chessClock.switchPlayer();
        });

        // ä¿®æ”¹å¾Œçš„åœæ­¢æŒ‰éˆ•
        elements.stopBtn.addEventListener('click', function() {
            showChessClockConfirm(
                'ç¢ºå®šçµæŸéŠæˆ²å—ï¼Ÿ',
                'çµæŸå¾Œå°‡è¿”å›è¨­å®šç•«é¢',
                null,
                () => {
                    chessClock.stopClock();
                    elements.settings.style.display = 'block';
                    elements.clockDisplay.style.display = 'none';
                }
            );
        });

// ä¿®æ”¹å¾Œçš„é—œé–‰æŒ‰éˆ•
        elements.closeBtn.addEventListener('click', function() {
            if (chessClock.getState().gameStarted) {
                showChessClockConfirm(
                    'ç¢ºå®šé—œé–‰æ£‹é˜å—ï¼Ÿ',
                    'æ¯”è³½é€²è¡Œä¸­',
                    'é—œé–‰å¾Œæ¯”è³½å°‡çµæŸï¼',
                    () => {
                        chessClock.stopClock();
                        document.body.removeChild(sidebarContainer);
                    }
                );
            } else {
                document.body.removeChild(sidebarContainer);
            }
        });

        // æ›´æ–°æ™‚é–“é¡¯ç¤ºçš„å‡½æ•¸ (ä¿æŒåŸæ¨£)
        function updateTimeDisplay() {
            const timeDisplay = chessClock.getTimeDisplay();
            elements.redTime.textContent = timeDisplay.red;
            elements.blackTime.textContent = timeDisplay.black;

            // è™•ç†è­¦å‘Šç‹€æ…‹
            if (timeDisplay.redWarning) {
                elements.redClock.classList.add('warning');
            } else {
                elements.redClock.classList.remove('warning');
            }

            if (timeDisplay.blackWarning) {
                elements.blackClock.classList.add('warning');
            } else {
                elements.blackClock.classList.remove('warning');
            }

            // é«˜äº®ç•¶å‰ç©å®¶
            if (timeDisplay.currentPlayer === 'red') {
                elements.redClock.style.transform = 'scale(1.05)';
                elements.blackClock.style.transform = 'scale(1)';
            } else {
                elements.redClock.style.transform = 'scale(1)';
                elements.blackClock.style.transform = 'scale(1.05)';
            }
        }

// å‰µå»ºéŠæˆ²çµæŸ UI çš„å‡½æ•¸
        function createGameOverUI(loserPlayer) {
            const winner = loserPlayer === 'red' ? 'é»‘æ–¹' : 'ç´…æ–¹';
            const loser = loserPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';

            // å‰µå»ºåŠé€æ˜é®ç½©
            const overlay = document.createElement('div');
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;

            // å‰µå»ºçµæœå¡ç‰‡
            const resultCard = document.createElement('div');
            resultCard.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 40px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.4s ease-out;
    `;

            // æ·»åŠ å‹•ç•«æ¨£å¼
            const style = document.createElement('style');
            style.textContent = `
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    `;
            document.head.appendChild(style);

            // å‰µå»ºæ¨™é¡Œ
            const title = document.createElement('h1');
            title.textContent = 'éŠæˆ²çµæŸ';
            title.style.cssText = `
        font-size: 32px;
        color: #333;
        margin: 0 0 20px 0;
    `;

            // å‰µå»ºçµæœä¿¡æ¯
            const resultText = document.createElement('div');
            resultText.style.cssText = `
        font-size: 24px;
        margin: 20px 0;
        line-height: 1.8;
    `;
            resultText.innerHTML = `
        <div style="color: #d32f2f; font-weight: bold;">${loser} æ™‚é–“è€—ç›¡ï¼</div>
        <div style="color: #388e3c; font-weight: bold; margin-top: 15px;">${winner} ç²å‹ï¼</div>
    `;

            // å‰µå»ºæŒ‰éˆ•å®¹å™¨
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
        margin-top: 30px;
        display: flex;
        gap: 15px;
        justify-content: center;
    `;

            // è¿”å›æŒ‰éˆ•
            const backButton = document.createElement('button');
            backButton.textContent = 'è¿”å›';
            backButton.style.cssText = `
        padding: 12px 30px;
        font-size: 16px;
        border: none;
        border-radius: 6px;
        background-color: #1976d2;
        color: white;
        cursor: pointer;
        transition: background-color 0.3s;
    `;
            backButton.onmouseover = () => backButton.style.backgroundColor = '#1565c0';
            backButton.onmouseout = () => backButton.style.backgroundColor = '#1976d2';
            backButton.onclick = () => {
                overlay.remove();
                chessClock.stopClock();
                elements.settings.style.display = 'block';
                elements.clockDisplay.style.display = 'none';
            };

            // é‡æ–°é–‹å§‹æŒ‰éˆ•
            const restartButton = document.createElement('button');
            restartButton.textContent = 'é‡æ–°é–‹å§‹';
            restartButton.style.cssText = `
        padding: 12px 30px;
        font-size: 16px;
        border: none;
        border-radius: 6px;
        background-color: #388e3c;
        color: white;
        cursor: pointer;
        transition: background-color 0.3s;
    `;
            restartButton.onmouseover = () => restartButton.style.backgroundColor = '#2e7d32';
            restartButton.onmouseout = () => restartButton.style.backgroundColor = '#388e3c';
            restartButton.onclick = () => {
                overlay.remove();
                location.reload(); // é‡æ–°è¼‰å…¥é é¢
            };

            buttonContainer.appendChild(backButton);
            buttonContainer.appendChild(restartButton);

            resultCard.appendChild(title);
            resultCard.appendChild(resultText);
            resultCard.appendChild(buttonContainer);
            overlay.appendChild(resultCard);

            document.body.appendChild(overlay);
        }

// è¨­å®šå›èª¿å‡½æ•¸
        chessClock.setCallbacks({
            onTimeUp: function(player) {
                chessClock.stopClock();

                const loserName = player === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
                const winnerName = player === 'red' ? 'é»‘æ–¹' : 'ç´…æ–¹';
                const message = `${loserName}æ™‚é–“è€—ç›¡ï¼${winnerName}ç²å‹ï¼`;

                console.log(`â° æ™‚é–“è€—ç›¡: ${message}`);
                createGameNotification('timeout', message, null, 'time_up');
            },
            onTick: updateTimeDisplay,
            onPlayerSwitch: function(newPlayer) {
                console.log(`è¼ªåˆ° ${newPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'} äº†`);
            },
            onWarning: function(player, isWarning) {
                console.log(`${player === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}${isWarning ? 'é€²å…¥' : 'è„«é›¢'}è­¦å‘Šç‹€æ…‹`);
            }
        });

// åˆå§‹åŒ–é¡¯ç¤º
        chessClock.setEnabled(true);
        updateTimeDisplay();

// æ·»åŠ åˆ°é é¢
        document.body.appendChild(sidebarContainer);

        return {
            chessClock,
            container: sidebarContainer,
            switchPlayer: () => chessClock.switchPlayer(),
            getState: () => chessClock.getState(),
            close: () => document.body.removeChild(sidebarContainer)
        };
    }


    // é€šç”¨ç¢ºèªå°è©±æ¡†å‡½æ•¸
    function showChessClockConfirm(title, message, warningText, onConfirm) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
    `;

        const card = document.createElement('div');
        card.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 40px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        max-width: 400px;
    `;

        let warningHtml = '';
        if (warningText) {
            warningHtml = `
            <div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 12px 15px; margin-bottom: 25px; border-radius: 4px; text-align: left; font-size: 14px; color: #856404;">
                âš ï¸ <strong>æ³¨æ„ï¼š</strong>${warningText}
            </div>
        `;
        }

        card.innerHTML = `
        <h2 style="font-size: 24px; color: #333; margin: 0 0 25px 0;">${title}</h2>

        <p style="font-size: 16px; color: #666; margin: 0 0 25px 0; line-height: 1.6;">${message}</p>

        ${warningHtml}

        <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="cancelBtn" style="padding: 12px 30px; font-size: 16px; border: 2px solid #ccc; border-radius: 6px; background-color: white; color: #666; cursor: pointer; transition: all 0.3s;">å–æ¶ˆ</button>
            <button id="confirmBtn" style="padding: 12px 30px; font-size: 16px; border: none; border-radius: 6px; background-color: #dc3545; color: white; cursor: pointer; transition: all 0.3s;">ç¢ºå®š</button>
        </div>
    `;

        overlay.appendChild(card);
        document.body.appendChild(overlay);

        const cancelBtn = card.querySelector('#cancelBtn');
        const confirmBtn = card.querySelector('#confirmBtn');

        cancelBtn.onmouseover = () => {
            cancelBtn.style.borderColor = '#999';
            cancelBtn.style.color = '#333';
        };
        cancelBtn.onmouseout = () => {
            cancelBtn.style.borderColor = '#ccc';
            cancelBtn.style.color = '#666';
        };
        cancelBtn.onclick = () => overlay.remove();

        confirmBtn.onmouseover = () => {
            confirmBtn.style.backgroundColor = '#c82333';
        };
        confirmBtn.onmouseout = () => {
            confirmBtn.style.backgroundColor = '#dc3545';
        };
        confirmBtn.onclick = () => {
            overlay.remove();
            if (onConfirm) onConfirm();
        };

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.remove();
            }
        };
    }

    // å‰µå»ºéŠæˆ²é–‹å§‹ç¢ºèªå½ˆçª—
    function showGameStartConfirmation(totalMinutes, incrementSeconds, callback) {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    `;

        const card = document.createElement('div');
        card.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 40px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.4s ease-out;
        max-width: 400px;
    `;

        const style = document.createElement('style');
        style.textContent = `
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }
    `;
        document.head.appendChild(style);

        card.innerHTML = `
        <h2 style="font-size: 24px; color: #333; margin: 0 0 25px 0;">ç¢ºå®šé–‹å§‹æ¯”è³½å—ï¼Ÿ</h2>

        <div style="background-color: #f5f5f5; border-radius: 8px; padding: 20px; margin-bottom: 25px; text-align: left;">
            <div style="display: flex; justify-content: space-between; margin: 12px 0; font-size: 16px;">
                <span style="color: #666;">ç¸½æ™‚é–“ï¼š</span>
                <span style="color: #1976d2; font-weight: bold;">${totalMinutes}åˆ†é˜</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin: 12px 0; font-size: 16px;">
                <span style="color: #666;">åŠ ç§’ï¼š</span>
                <span style="color: #388e3c; font-weight: bold;">${incrementSeconds}ç§’</span>
            </div>
        </div>

        <div style="background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 12px 15px; margin-bottom: 25px; border-radius: 4px; text-align: left; font-size: 14px; color: #856404;">
            âš ï¸ <strong>æ³¨æ„ï¼š</strong>æ¯”è³½é–‹å§‹å¾Œç„¡æ³•æš«åœï¼
        </div>

        <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="cancelBtn" style="padding: 12px 30px; font-size: 16px; border: 2px solid #ccc; border-radius: 6px; background-color: white; color: #666; cursor: pointer; transition: all 0.3s;">å–æ¶ˆ</button>
            <button id="confirmBtn" style="padding: 12px 30px; font-size: 16px; border: none; border-radius: 6px; background-color: #1976d2; color: white; cursor: pointer; transition: all 0.3s;">ç¢ºå®šé–‹å§‹</button>
        </div>
    `;

        overlay.appendChild(card);
        document.body.appendChild(overlay);

        const cancelBtn = card.querySelector('#cancelBtn');
        const confirmBtn = card.querySelector('#confirmBtn');

        cancelBtn.onmouseover = () => { cancelBtn.style.borderColor = '#999'; cancelBtn.style.color = '#333'; };
        cancelBtn.onmouseout = () => { cancelBtn.style.borderColor = '#ccc'; cancelBtn.style.color = '#666'; };
        cancelBtn.onclick = () => overlay.remove();

        confirmBtn.onmouseover = () => { confirmBtn.style.backgroundColor = '#1565c0'; };
        confirmBtn.onmouseout = () => { confirmBtn.style.backgroundColor = '#1976d2'; };
        confirmBtn.onclick = () => {
            overlay.remove();
            callback(true);
        };
    }

    // ä¿®æ”¹æŒ‰éˆ•å‡½æ•¸
    function addTimerButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const timerButton = document.createElement('button');
        timerButton.textContent = 'æ£‹é˜';

        if (regretButton) {
            timerButton.className = regretButton.className;
            timerButton.style.cssText = regretButton.style.cssText;
        } else {
            timerButton.style.cssText = `
        padding: 12px 20px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        margin: 5px;
    `;
        }

        let clockInstance = null;

        timerButton.addEventListener('click', function() {
            if (!clockInstance) {
                clockInstance = createSidebarClock();
                timerButton.textContent = 'é—œé–‰æ£‹é˜';
                timerButton.style.backgroundColor = '#dc3545';

                // ç›£è½é—œé–‰äº‹ä»¶
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node === clockInstance?.container) {
                                    clockInstance = null;
                                    timerButton.textContent = 'æ£‹é˜';
                                    timerButton.style.backgroundColor = '#28a745';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                clockInstance.close();
            }
        });

        buttonContainer.appendChild(timerButton);

        return {
            button: timerButton,
            getCurrentClock: () => clockInstance
        };
    }
    // æ”¹é€²ç‰ˆè‡ªå®šç¾©æ£‹ç›¤åŠŸèƒ½
    function addCustomBoardButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const customBoardButton = document.createElement('button');
        customBoardButton.textContent = 'è‡ªå®šç¾©æ£‹ç›¤';

        if (regretButton) {
            customBoardButton.className = regretButton.className;
            customBoardButton.style.cssText = regretButton.style.cssText;
        } else {
            customBoardButton.style.cssText = `
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        `;
        }

        let customBoardInstance = null;

        customBoardButton.addEventListener('click', function() {
            if (!customBoardInstance) {
                customBoardInstance = createCustomBoardInterface();
                customBoardButton.textContent = 'é—œé–‰è‡ªå®šç¾©';
                customBoardButton.style.backgroundColor = '#dc3545';

                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node === customBoardInstance?.container) {
                                    customBoardInstance = null;
                                    customBoardButton.textContent = 'è‡ªå®šç¾©æ£‹ç›¤';
                                    customBoardButton.style.backgroundColor = '#007bff';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                customBoardInstance.close();
            }
        });

        buttonContainer.appendChild(customBoardButton);

        return {
            button: customBoardButton,
            getCurrentInstance: () => customBoardInstance
        };
    }

    // æ”¹é€²ç‰ˆè¦å‰‡æª¢æŸ¥å™¨
    class ChessRuleValidator {
        constructor() {
            this.customBoard = this.createEmptyBoard();
            this.currentPlayer = 'red';
        }

        // ğŸ”¥ æ–°å¢ï¼šæ·±æ‹·è²æ£‹ç›¤
        deepCopyBoard(board) {
            const copy = [];
            for (let i = 0; i < 10; i++) {
                copy[i] = [];
                for (let j = 0; j < 9; j++) {
                    copy[i][j] = board[i][j] ? { ...board[i][j] } : null;
                }
            }
            return copy;
        }

        createEmptyBoard() {
            const board = [];
            for (let i = 0; i < 10; i++) {
                board[i] = [];
                for (let j = 0; j < 9; j++) {
                    board[i][j] = null;
                }
            }
            return board;
        }

        isInTerritory(row, col, color) {
            if (color === 'red') {
                return row >= 5;
            } else {
                return row <= 4;
            }
        }

        isInPalace(row, col, color) {
            if (color === 'red') {
                return row >= 7 && row <= 9 && col >= 3 && col <= 5;
            } else {
                return row >= 0 && row <= 2 && col >= 3 && col <= 5;
            }
        }

        isValidAdvisorPosition(row, col, color) {
            const validPositions = color === 'red' ?
                [[7,3], [7,5], [8,4], [9,3], [9,5]] :
                [[0,3], [0,5], [1,4], [2,3], [2,5]];
            return validPositions.some(pos => pos[0] === row && pos[1] === col);
        }

        isValidElephantPosition(row, col, color) {
            const validPositions = color === 'red' ?
                [[5,2], [5,6], [7,0], [7,4], [7,8], [9,2], [9,6]] :
                [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];
            return validPositions.some(pos => pos[0] === row && pos[1] === col);
        }

        isValidSoldierPosition(row, col, color) {
            if (color === 'red') {
                // ç´…å…µï¼šåœ¨å·±æ–¹é ˜åœ°å¯ä»¥åœ¨5-6è¡Œï¼Œéæ²³å¾Œå¯ä»¥åœ¨0-4è¡Œ
                if (row >= 5) {
                    return row === 5 || row === 6; // å¯ä»¥åœ¨ç¬¬5è¡Œæˆ–ç¬¬6è¡Œ
                } else {
                    return row >= 0 && row <= 4; // éæ²³å¾Œ
                }
            } else {
                // é»‘å’ï¼šåœ¨å·±æ–¹é ˜åœ°å¯ä»¥åœ¨3-4è¡Œï¼Œéæ²³å¾Œå¯ä»¥åœ¨5-9è¡Œ
                if (row <= 4) {
                    return row === 3 || row === 4; // å¯ä»¥åœ¨ç¬¬3è¡Œæˆ–ç¬¬4è¡Œ
                } else {
                    return row >= 5 && row <= 9; // éæ²³å¾Œ
                }
            }
        }

        canPlacePiece(row, col, piece) {
            const { type, color } = piece;

            if (row < 0 || row > 9 || col < 0 || col > 8) {
                return { valid: false, reason: 'ä½ç½®è¶…å‡ºæ£‹ç›¤ç¯„åœ' };
            }

            if (type === 'å¸¥' || type === 'å°‡') {
                if (!this.isInPalace(row, col, color)) {
                    return { valid: false, reason: `${type}åªèƒ½æ”¾åœ¨ä¹å®®æ ¼å…§` };
                }
                if (this.hasKing(color)) {
                    return { valid: false, reason: `æ¯æ–¹åªèƒ½æœ‰ä¸€å€‹${type}` };
                }
            }

            if (type === 'å£«' || type === 'ä»•') {
                if (!this.isValidAdvisorPosition(row, col, color)) {
                    return { valid: false, reason: `${type}åªèƒ½æ”¾åœ¨å›ºå®šçš„äº”å€‹ä½ç½®ä¸Š` };
                }
                if (this.countPieces(type, color) >= 2) {
                    return { valid: false, reason: `${type}æœ€å¤šåªèƒ½æœ‰2å€‹` };
                }
            }

            if (type === 'è±¡' || type === 'ç›¸') {
                if (!this.isValidElephantPosition(row, col, color)) {
                    return { valid: false, reason: `${type}åªèƒ½æ”¾åœ¨å›ºå®šä½ç½®ä¸Š` };
                }
                if (this.countPieces(type, color) >= 2) {
                    return { valid: false, reason: `${type}æœ€å¤šåªèƒ½æœ‰2å€‹` };
                }
            }


// ğŸ”¥ ä¿®æ­£ç‰ˆæœ¬ï¼šèª¿æ•´å…µå’æª¢æŸ¥é‚è¼¯
            if (type === 'å…µ' || type === 'å’') {
                // æª¢æŸ¥è‡ªå·±å…µåœ¨è‡ªå·±é ˜åœ°çš„yåº§æ¨™é™åˆ¶ï¼šåªèƒ½åœ¨0,2,4,6,8åˆ—
                const isInOwnTerritory = this.isInTerritory(row, col, color);
                if (isInOwnTerritory) {
                    const validColumns = [0, 2, 4, 6, 8];
                    if (!validColumns.includes(col)) {
                        return {
                            valid: false,
                            reason: `${type}åœ¨è‡ªå·±é ˜åœ°å…§åªèƒ½æ”¾åœ¨ç¬¬1ã€3ã€5ã€7ã€9åˆ—ï¼ˆyåº§æ¨™0,2,4,6,8ï¼‰`
                        };
                    }

                    // ğŸ”¥ é—œéµä¿®æ­£ï¼šåªåœ¨å·±æ–¹é ˜åœ°æ™‚æª¢æŸ¥åŒåˆ—ç–Šå…µ
                    if (this.hasSoldierInOwnTerritory(col, type, color)) {
                        return {
                            valid: false,
                            reason: `åŒä¸€åˆ—åœ¨${color === 'red' ? 'ç´…' : 'é»‘'}æ–¹é ˜åœ°å…§ä¸èƒ½æœ‰å…©å€‹${type}`
                        };
                    }
                }

                // åŸæœ‰çš„ä½ç½®è¦å‰‡æª¢æŸ¥
                if (!this.isValidSoldierPosition(row, col, color)) {
                    return {
                        valid: false,
                        reason: `${type}çš„ä½ç½®ä¸ç¬¦åˆè±¡æ£‹è¦å‰‡`
                    };
                }

                // æ•¸é‡é™åˆ¶
                if (this.countPieces(type, color) >= 5) {
                    return {
                        valid: false,
                        reason: `${type}æœ€å¤šåªèƒ½æœ‰5å€‹`
                    };
                }
            }

            if (['è»Š', 'ä¿¥', 'é¦¬', 'å‚Œ', 'ç‚®', 'åŒ…'].includes(type)) {
                if (this.countPieces(type, color) >= 2) {
                    return { valid: false, reason: `${type}æœ€å¤šåªèƒ½æœ‰2å€‹` };
                }
            }

            return { valid: true };
        }
// ğŸ”¥ æ–°å‡½æ•¸ï¼šå°ˆé–€æª¢æŸ¥å·±æ–¹é ˜åœ°çš„åŒåˆ—ç–Šå…µ
        hasSoldierInOwnTerritory(col, type, color) {
            if (color === 'red') {
                // ç´…æ–¹ï¼šæª¢æŸ¥5-9è¡Œï¼ˆå·±æ–¹é ˜åœ°ï¼‰
                for (let i = 5; i <= 9; i++) {
                    const piece = this.customBoard[i][col];
                    if (piece && piece.type === type && piece.color === color) {
                        return true;
                    }
                }
            } else {
                // é»‘æ–¹ï¼šæª¢æŸ¥0-4è¡Œï¼ˆå·±æ–¹é ˜åœ°ï¼‰
                for (let i = 0; i <= 4; i++) {
                    const piece = this.customBoard[i][col];
                    if (piece && piece.type === type && piece.color === color) {
                        return true;
                    }
                }
            }
            return false;
        }

        countPieces(type, color) {
            let count = 0;
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = this.customBoard[i][j];
                    if (piece && piece.type === type && piece.color === color) {
                        count++;
                    }
                }
            }
            return count;
        }

        hasKing(color) {
            const kingType = color === 'red' ? 'å¸¥' : 'å°‡';
            return this.countPieces(kingType, color) > 0;
        }

        hasPieceInColumn(col, type, color, onlyInTerritory = true) {
            for (let i = 0; i < 10; i++) {
                const piece = this.customBoard[i][col];
                if (piece && piece.type === type && piece.color === color) {
                    if (onlyInTerritory && !this.isInTerritory(i, col, color)) {
                        continue;
                    }
                    return true;
                }
            }
            return false;
        }

        areKingsFacing() {
            let redKingPos = null;
            let blackKingPos = null;

            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = this.customBoard[i][j];
                    if (piece) {
                        if (piece.type === 'å¸¥') {
                            redKingPos = { row: i, col: j };
                        } else if (piece.type === 'å°‡') {
                            blackKingPos = { row: i, col: j };
                        }
                    }
                }
            }

            if (!redKingPos || !blackKingPos) {
                return false;
            }

            if (redKingPos.col !== blackKingPos.col) {
                return false;
            }

            const startRow = Math.min(redKingPos.row, blackKingPos.row) + 1;
            const endRow = Math.max(redKingPos.row, blackKingPos.row) - 1;

            for (let i = startRow; i <= endRow; i++) {
                if (this.customBoard[i][redKingPos.col]) {
                    return false;
                }
            }

            return true;
        }

        // ğŸ”¥ ä¿®æ­£ï¼šfindKingPosition ä¹Ÿè¦æ”¯æŒè‡ªå®šç¾©æ£‹ç›¤
        findKingPosition(color, board = null) {
            const checkBoard = board || this.customBoard;
            const kingType = color === 'red' ? 'å¸¥' : 'å°‡';
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = checkBoard[i][j];
                    if (piece && piece.type === kingType && piece.color === color) {
                        return { row: i, col: j };
                    }
                }
            }
            return null;
        }

// ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦è¢«å°æ–¹æ”»æ“Š
        isPositionUnderAttack(row, col, color, board = this.customBoard) {
            const opponent = color === 'red' ? 'black' : 'red';

            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = board[i][j];
                    if (piece && piece.color === opponent) {
                        if (this.canPieceAttack(i, j, row, col, piece, board)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

// ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ£‹å­æ˜¯å¦èƒ½æ”»æ“Šç›®æ¨™ä½ç½®ï¼ˆç°¡åŒ–ç‰ˆèµ°æ³•è¦å‰‡ï¼‰
        canPieceAttack(fromRow, fromCol, toRow, toCol, piece, board) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch(piece.type) {
                case 'è»Š':
                case 'ä¿¥':
                    if (fromRow === toRow || fromCol === toCol) {
                        return this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                    }
                    return false;

                case 'é¦¬':
                case 'å‚Œ':
                    // é¦¬èµ°æ—¥å­—ï¼š(2,1) æˆ– (1,2)
                    if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {
                        // æª¢æŸ¥é¦¬è…³ä½ç½®
                        let blockRow, blockCol;

                        if (rowDiff === 2) {
                            // å‚ç›´æ–¹å‘èµ°2æ ¼ï¼Œé¦¬è…³åœ¨ä¸­é–“çš„å‚ç›´ä½ç½®
                            blockRow = fromRow + (toRow > fromRow ? 1 : -1);
                            blockCol = fromCol;
                        } else {
                            // æ°´å¹³æ–¹å‘èµ°2æ ¼ï¼Œé¦¬è…³åœ¨ä¸­é–“çš„æ°´å¹³ä½ç½®
                            blockRow = fromRow;
                            blockCol = fromCol + (toCol > fromCol ? 1 : -1);
                        }

                        // é¦¬è…³ä½ç½®å¿…é ˆç‚ºç©º
                        return !board[blockRow][blockCol];
                    }
                    return false;

                case 'ç‚®':
                case 'åŒ…':
                    if (fromRow === toRow || fromCol === toCol) {
                        const between = this.countPiecesBetween(fromRow, fromCol, toRow, toCol, board);
                        return between === 1;
                    }
                    return false;

                case 'å…µ':
                case 'å’':
                    const isRed = piece.color === 'red';
                    const forward = isRed ? -1 : 1;
                    const crossedRiver = isRed ? fromRow <= 4 : fromRow >= 5;

                    if (toRow === fromRow + forward && toCol === fromCol) {
                        return true;
                    }
                    if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) {
                        return true;
                    }
                    return false;

                case 'å°‡':
                case 'å¸¥':
                    // 1. æ­£å¸¸çš„å°‡/å¸¥ç§»å‹•æ”»æ“Šï¼ˆä¹å®®æ ¼å…§ï¼Œèµ°ä¸€æ ¼ï¼‰
                    if (this.isInPalace(toRow, toCol, piece.color)) {
                        if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                            return true;
                        }
                    }

                    // ğŸ”¥ 2. å°‡å¸¥å°è‡‰æ”»æ“Šï¼ˆåŒä¸€åˆ—ï¼Œä¸­é–“ç„¡å­ï¼‰
                    if (fromCol === toCol) {
                        const targetPiece = board[toRow][toCol];
                        // æª¢æŸ¥ç›®æ¨™æ˜¯å¦æ˜¯å°æ–¹çš„å°‡/å¸¥
                        if (targetPiece &&
                            (targetPiece.type === 'å°‡' || targetPiece.type === 'å¸¥') &&
                            targetPiece.color !== piece.color) {
                            // æª¢æŸ¥ä¸­é–“æ˜¯å¦æœ‰æ£‹å­
                            return this.isPathClear(fromRow, fromCol, toRow, toCol, board);
                        }
                    }

                    return false;

                case 'å£«':
                case 'ä»•':
                    return rowDiff === 1 && colDiff === 1 && this.isInPalace(toRow, toCol, piece.color);

                case 'è±¡':
                case 'ç›¸':
                    if (rowDiff === 2 && colDiff === 2) {
                        const midRow = (fromRow + toRow) / 2;
                        const midCol = (fromCol + toCol) / 2;
                        return !board[midRow][midCol] && this.isInTerritory(toRow, toCol, piece.color);
                    }
                    return false;
            }
            return false;
        }

// ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥è·¯å¾‘æ˜¯å¦æš¢é€šï¼ˆè»Šã€ç‚®ä½¿ç”¨ï¼‰
        isPathClear(fromRow, fromCol, toRow, toCol, board) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow || col !== toCol) {
                if (board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            return true;
        }

// ğŸ”¥ æ–°å¢ï¼šè¨ˆç®—è·¯å¾‘é–“çš„æ£‹å­æ•¸ï¼ˆç‚®ä½¿ç”¨ï¼‰
        countPiecesBetween(fromRow, fromCol, toRow, toCol, board) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let count = 0;
            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow || col !== toCol) {
                if (board[row][col]) count++;
                row += rowStep;
                col += colStep;
            }
            return count;
        }

// ğŸ”¥ ä¿®æ­£ï¼šæ”¯æŒè‡ªå®šç¾©æ£‹ç›¤åƒæ•¸
        isCheck(color, board = null) {
            const checkBoard = board || this.customBoard;
            const kingPos = this.findKingPosition(color, checkBoard);
            if (!kingPos) return false;
            return this.isPositionUnderAttack(kingPos.row, kingPos.col, color, checkBoard);
        }

// ğŸ”¥ ä¿®æ­£ï¼šæª¢æŸ¥æ˜¯å¦æœ‰åˆæ³•ç§»å‹•ï¼ˆä½¿ç”¨æ·±æ‹·è²é¿å…æ±¡æŸ“æ£‹ç›¤ï¼‰
        hasLegalMoves(color) {
            for (let fromRow = 0; fromRow < 10; fromRow++) {
                for (let fromCol = 0; fromCol < 9; fromCol++) {
                    const piece = this.customBoard[fromRow][fromCol];
                    if (piece && piece.color === color) {
                        // æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„ç›®æ¨™ä½ç½®
                        for (let toRow = 0; toRow < 10; toRow++) {
                            for (let toCol = 0; toCol < 9; toCol++) {
                                if (fromRow === toRow && fromCol === toCol) continue;

                                const target = this.customBoard[toRow][toCol];
                                if (target && target.color === color) continue;

                                // æª¢æŸ¥æ˜¯å¦å¯ä»¥æ”»æ“Šç›®æ¨™ä½ç½®
                                if (this.canPieceAttack(fromRow, fromCol, toRow, toCol, piece, this.customBoard)) {
                                    // ğŸ”¥ é—œéµï¼šä½¿ç”¨æ·±æ‹·è²æ¨¡æ“¬ç§»å‹•
                                    const boardCopy = this.deepCopyBoard(this.customBoard);
                                    boardCopy[toRow][toCol] = piece;
                                    boardCopy[fromRow][fromCol] = null;

                                    // åœ¨æ‹·è²çš„æ£‹ç›¤ä¸Šæª¢æŸ¥æ˜¯å¦é‚„è¢«å°‡è»
                                    const stillInCheck = this.isCheck(color, boardCopy);

                                    // ğŸ”¥ ä¸éœ€è¦æ¢å¾©ï¼Œå› ç‚ºåŸæ£‹ç›¤æ²’è¢«ä¿®æ”¹

                                    if (!stillInCheck) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }


// ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦è¢«å°‡æ­»
        isCheckmate(color) {
            if (!this.isCheck(color)) return false;
            return !this.hasLegalMoves(color);
        }

// ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ˜¯å¦å›°æ–ƒ
        isStalemate(color) {
            if (this.isCheck(color)) return false;
            return !this.hasLegalMoves(color);
        }


        validateBoard() {
            const errors = [];

            // åŸºæœ¬æª¢æŸ¥
            if (this.areKingsFacing()) {
                errors.push('å°‡å¸¥ä¸èƒ½å°è‡‰');
            }

            if (!this.hasKing('red')) {
                errors.push('ç´…æ–¹å¿…é ˆæœ‰å¸¥');
            }
            if (!this.hasKing('black')) {
                errors.push('é»‘æ–¹å¿…é ˆæœ‰å°‡');
            }

            // ğŸ”¥ é—œéµï¼šæ¯æ¬¡æª¢æ¸¬å‰ç¢ºä¿ä½¿ç”¨åŸå§‹æ£‹ç›¤ç‹€æ…‹
            const redInCheck = this.isCheck('red');
            const blackInCheck = this.isCheck('black');

            // ğŸ”¥ å°‡æ­»æª¢æŸ¥ï¼ˆæœ€é«˜å„ªå…ˆç´šï¼‰
            const redCheckmate = this.isCheckmate('red');
            const blackCheckmate = this.isCheckmate('black');

            if (redCheckmate) {
                errors.push('âŒ ç´…æ–¹å·²è¢«å°‡æ­»ï¼Œä¸èƒ½è®“ä»»ä½•ä¸€æ–¹å…ˆèµ°');
                return errors;
            }
            if (blackCheckmate) {
                errors.push('âŒ é»‘æ–¹å·²è¢«å°‡æ­»ï¼Œä¸èƒ½è®“ä»»ä½•ä¸€æ–¹å…ˆèµ°');
                return errors;
            }

            // ğŸ”¥ å›°æ–ƒæª¢æŸ¥ï¼ˆåœ¨ç¢ºèªä¸æ˜¯å°‡æ­»å¾Œï¼‰
            const redStalemate = this.isStalemate('red');
            const blackStalemate = this.isStalemate('black');

            if (redStalemate && this.currentPlayer === 'red') {
                errors.push('âŒ ç´…æ–¹å·²å›°æ–ƒï¼ˆç„¡å­å¯å‹•ï¼‰ï¼Œä¸èƒ½è®“ç´…æ–¹å…ˆèµ°');
            }
            if (blackStalemate && this.currentPlayer === 'black') {
                errors.push('âŒ é»‘æ–¹å·²å›°æ–ƒï¼ˆç„¡å­å¯å‹•ï¼‰ï¼Œä¸èƒ½è®“é»‘æ–¹å…ˆèµ°');
            }

            // ğŸ”¥ å°‡è»æª¢æŸ¥ï¼ˆæœ€å¾Œæª¢æŸ¥ï¼‰
            if (redInCheck && this.currentPlayer === 'black') {
                errors.push('âš ï¸ ç´…æ–¹æ­£è¢«å°‡è»ï¼Œä¸èƒ½è®“é»‘æ–¹å…ˆèµ°ï¼ˆå°æ–¹å¯ç›´æ¥åƒå¸¥ï¼‰');
            }
            if (blackInCheck && this.currentPlayer === 'red') {
                errors.push('âš ï¸ é»‘æ–¹æ­£è¢«å°‡è»ï¼Œä¸èƒ½è®“ç´…æ–¹å…ˆèµ°ï¼ˆå°æ–¹å¯ç›´æ¥åƒå°‡ï¼‰');
            }

            return errors;
        }

        placePiece(row, col, piece) {
            const validation = this.canPlacePiece(row, col, piece);
            if (validation.valid) {
                this.customBoard[row][col] = piece;
            }
            return validation;
        }

        clearPiece(row, col) {
            this.customBoard[row][col] = null;
        }

        clearBoard() {
            this.customBoard = this.createEmptyBoard();
        }

        resetToInitial() {
            this.customBoard = this.createEmptyBoard();

            // ç´…æ–¹æ£‹å­ (åº•éƒ¨ï¼Œè¡Œæ•¸å¤§)
            this.customBoard[9][0] = { type: 'ä¿¥', color: 'red' };
            this.customBoard[9][1] = { type: 'å‚Œ', color: 'red' };
            this.customBoard[9][2] = { type: 'ç›¸', color: 'red' };
            this.customBoard[9][3] = { type: 'ä»•', color: 'red' };
            this.customBoard[9][4] = { type: 'å¸¥', color: 'red' };
            this.customBoard[9][5] = { type: 'ä»•', color: 'red' };
            this.customBoard[9][6] = { type: 'ç›¸', color: 'red' };
            this.customBoard[9][7] = { type: 'å‚Œ', color: 'red' };
            this.customBoard[9][8] = { type: 'ä¿¥', color: 'red' };
            this.customBoard[7][1] = { type: 'ç‚®', color: 'red' };
            this.customBoard[7][7] = { type: 'ç‚®', color: 'red' };
            this.customBoard[6][0] = { type: 'å…µ', color: 'red' };
            this.customBoard[6][2] = { type: 'å…µ', color: 'red' };
            this.customBoard[6][4] = { type: 'å…µ', color: 'red' };
            this.customBoard[6][6] = { type: 'å…µ', color: 'red' };
            this.customBoard[6][8] = { type: 'å…µ', color: 'red' };

            // é»‘æ–¹æ£‹å­ (é ‚éƒ¨ï¼Œè¡Œæ•¸å°)
            this.customBoard[0][0] = { type: 'è»Š', color: 'black' };
            this.customBoard[0][1] = { type: 'é¦¬', color: 'black' };
            this.customBoard[0][2] = { type: 'è±¡', color: 'black' };
            this.customBoard[0][3] = { type: 'å£«', color: 'black' };
            this.customBoard[0][4] = { type: 'å°‡', color: 'black' };
            this.customBoard[0][5] = { type: 'å£«', color: 'black' };
            this.customBoard[0][6] = { type: 'è±¡', color: 'black' };
            this.customBoard[0][7] = { type: 'é¦¬', color: 'black' };
            this.customBoard[0][8] = { type: 'è»Š', color: 'black' };
            this.customBoard[2][1] = { type: 'åŒ…', color: 'black' };
            this.customBoard[2][7] = { type: 'åŒ…', color: 'black' };
            this.customBoard[3][0] = { type: 'å’', color: 'black' };
            this.customBoard[3][2] = { type: 'å’', color: 'black' };
            this.customBoard[3][4] = { type: 'å’', color: 'black' };
            this.customBoard[3][6] = { type: 'å’', color: 'black' };
            this.customBoard[3][8] = { type: 'å’', color: 'black' };
        }
    }

    // æ£‹ç›¤è½‰ FEN ç¢¼ï¼ˆä¿æŒä¸è®Šï¼‰
    function boardToFEN(board, currentPlayer) {
        const pieceToFEN = {
            // ç´…æ–¹ï¼ˆå¤§å¯«ï¼‰
            'å¸¥': 'K', 'ä»•': 'A', 'ç›¸': 'B', 'å‚Œ': 'N', 'ä¿¥': 'R', 'ç‚®': 'C', 'å…µ': 'P',
            // é»‘æ–¹ï¼ˆå°å¯«ï¼‰
            'å°‡': 'k', 'å£«': 'a', 'è±¡': 'b', 'é¦¬': 'n', 'è»Š': 'r', 'åŒ…': 'c', 'å’': 'p'
        };

        let fen = '';

        // éæ­·æ£‹ç›¤ï¼ˆå¾ç¬¬0è¡Œåˆ°ç¬¬9è¡Œï¼‰
        for (let row = 0; row < 10; row++) {
            let emptyCount = 0;

            for (let col = 0; col < 9; col++) {
                const piece = board[row][col];

                if (piece) {
                    if (emptyCount > 0) {
                        fen += emptyCount;
                        emptyCount = 0;
                    }
                    fen += pieceToFEN[piece.type] || '?';
                } else {
                    emptyCount++;
                }
            }

            if (emptyCount > 0) {
                fen += emptyCount;
            }

            if (row < 9) {
                fen += '/';
            }
        }

        // æ·»åŠ èµ°æ£‹æ–¹
        fen += currentPlayer === 'red' ? ' w' : ' b';

        return fen;
    }

    // ğŸ”¥ æ”¹è¿›ç‰ˆï¼šæ”¯æŒæ‰‹æœºç‰ˆçš„è‡ªå®šä¹‰æ£‹ç›˜ç•Œé¢
    function createCustomBoardInterface() {
        const ruleValidator = new ChessRuleValidator();
        let selectedPiece = null;
        let selectedPosition = null;

        // è½½å…¥å½“å‰å±€é¢
        if (typeof gameState !== 'undefined' && gameState.board) {
            console.log('ğŸ“¥ è½½å…¥å½“å‰å±€é¢...');
            const isFlipped = gameState.isFlipped || false;
            console.log(`å½“å‰æ£‹ç›˜ç¿»è½¬çŠ¶æ€: ${isFlipped ? 'é»‘æ–¹åœ¨ä¸‹' : 'çº¢æ–¹åœ¨ä¸‹'}`);

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        ruleValidator.customBoard[row][col] = {
                            type: piece.type,
                            color: piece.color
                        };
                    }
                }
            }
            ruleValidator.currentPlayer = gameState.currentTurn || 'red';
            console.log('âœ… å½“å‰å±€é¢å·²è½½å…¥');
        } else {
            ruleValidator.resetToInitial();
        }

        // ğŸ”¥ æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
        const isMobile = window.innerWidth <= 768;

        const container = document.createElement('div');
        container.style.cssText = `
        position: fixed;
        top: ${isMobile ? '0' : '50%'};
        left: ${isMobile ? '0' : '50%'};
        transform: ${isMobile ? 'none' : 'translate(-50%, -50%)'};
        background: white;
        border: ${isMobile ? 'none' : '2px solid #333'};
        border-radius: ${isMobile ? '0' : '10px'};
        padding: ${isMobile ? '10px' : '20px'};
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-height: ${isMobile ? '100vh' : '95vh'};
        overflow-y: auto;
        width: ${isMobile ? '100vw' : 'auto'};
        min-width: ${isMobile ? 'auto' : '700px'};
        max-width: ${isMobile ? '100vw' : '90vw'};
        box-sizing: border-box;
    `;

        const title = document.createElement('h3');
        title.textContent = 'è‡ªå®šç¾©æ£‹ç›¤';
        title.style.cssText = `
        margin: 0 0 ${isMobile ? '10px' : '15px'} 0;
        text-align: center;
        color: #333;
        font-size: ${isMobile ? '18px' : '20px'};
    `;

        // ç¿»è½¬çŠ¶æ€æŒ‡ç¤ºå™¨
        const flipIndicator = document.createElement('div');
        flipIndicator.style.cssText = `
        text-align: center;
        padding: ${isMobile ? '8px' : '10px'};
        background: #e7f3ff;
        border-radius: 5px;
        margin-bottom: ${isMobile ? '10px' : '15px'};
        font-size: ${isMobile ? '12px' : '14px'};
        color: #0066cc;
        font-weight: bold;
    `;

        function updateFlipIndicatorText() {
            const isFlipped = (typeof gameState !== 'undefined' && gameState.isFlipped) || false;
            flipIndicator.innerHTML = isFlipped
                ? 'ğŸ”„ <strong>ç•¶å‰è§†è§’ï¼šé»‘æ–¹åœ¨ä¸‹</strong>'
                : 'ğŸ“ <strong>ç•¶å‰è§†è§’ï¼šçº¢æ–¹åœ¨ä¸‹</strong>';
        }
        updateFlipIndicatorText();

        const errorDisplay = document.createElement('div');
        errorDisplay.style.cssText = `
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 5px;
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        display: none;
        font-size: ${isMobile ? '12px' : '14px'};
    `;

        const successDisplay = document.createElement('div');
        successDisplay.style.cssText = `
        margin-bottom: 10px;
        padding: 8px;
        border-radius: 5px;
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
        display: none;
        font-size: ${isMobile ? '12px' : '14px'};
    `;

        function showError(message) {
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 3000);
        }

        function showSuccess(message) {
            successDisplay.textContent = message;
            successDisplay.style.display = 'block';
            setTimeout(() => {
                successDisplay.style.display = 'none';
            }, 2000);
        }

        // ğŸ”¥ æ§åˆ¶é¢æ¿ - æ‰‹æœºç‰ˆä¼˜åŒ–
        const controlPanel = document.createElement('div');
        controlPanel.style.cssText = `
        display: grid;
        grid-template-columns: ${isMobile ? 'repeat(2, 1fr)' : 'repeat(auto-fit, minmax(120px, 1fr))'};
        gap: ${isMobile ? '8px' : '10px'};
        margin-bottom: ${isMobile ? '10px' : '15px'};
        padding: ${isMobile ? '10px' : '15px'};
        background: #f8f9fa;
        border-radius: 8px;
    `;

        function createControlButton(text, onClick, color = '#28a745') {
            const button = document.createElement('button');
            button.textContent = text;
            button.style.cssText = `
        padding: ${isMobile ? '10px 8px' : '8px 16px'};
        background-color: ${color};
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: ${isMobile ? '12px' : '13px'};
        font-weight: bold;
        transition: all 0.2s ease;
        white-space: nowrap;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    `;

            // ğŸ”¥ ä½¿ç”¨touchstartä»£æ›¿mouseenterä»¥æ”¯æŒç§»åŠ¨è®¾å¤‡
            if (isMobile) {
                button.addEventListener('touchstart', () => {
                    button.style.opacity = '0.8';
                });
                button.addEventListener('touchend', () => {
                    button.style.opacity = '1';
                });
            } else {
                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'translateY(-1px)';
                    button.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                });
                button.addEventListener('mouseleave', () => {
                    button.style.transform = 'none';
                    button.style.boxShadow = 'none';
                });
            }

            button.addEventListener('click', onClick);
            return button;
        }

        const clearBoardBtn = createControlButton('æ¸…ç©º', () => {
            ruleValidator.clearBoard();
            updateBoardDisplay();
        }, '#dc3545');

        const resetBoardBtn = createControlButton('é‡ç½®', () => {
            ruleValidator.resetToInitial();
            updateBoardDisplay();
        }, '#6c757d');

        const playerToggle = createControlButton('çº¢æ–¹å…ˆ', () => {
            const errors = ruleValidator.validateBoard();
            if (errors.length > 0) {
                showError(errors.join('ï¼›'));
                return;
            }

            ruleValidator.currentPlayer = ruleValidator.currentPlayer === 'red' ? 'black' : 'red';
            playerToggle.textContent = ruleValidator.currentPlayer === 'red' ? 'çº¢æ–¹å…ˆ' : 'é»‘æ–¹å…ˆ';
            playerToggle.style.backgroundColor = ruleValidator.currentPlayer === 'red' ? '#dc3545' : '#343a40';
        }, '#dc3545');

        const exportFenBtn = createControlButton('å°å‡ºFEN', () => {
            const errors = ruleValidator.validateBoard();
            if (errors.length > 0) {
                showError('æ£‹ç›˜æœ‰é”™è¯¯ï¼š' + errors.join('ï¼›'));
                return;
            }

            const fen = boardToFEN(ruleValidator.customBoard, ruleValidator.currentPlayer);

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(fen).then(() => {
                    showSuccess('FENç å·²è¤‡åˆ¶ï¼');
                    console.log('FENç :', fen);
                }).catch(() => {
                    showError('è¤‡åˆ¶å¤±è´¥ï¼š' + fen);
                });
            } else {
                const tempInput = document.createElement('textarea');
                tempInput.value = fen;
                tempInput.style.position = 'fixed';
                tempInput.style.left = '-9999px';
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy');
                    showSuccess('FENç å·²è¤‡åˆ¶ï¼');
                    console.log('FENç :', fen);
                } catch (err) {
                    showError('è¤‡åˆ¶å¤±è´¥');
                    console.log('FENç :', fen);
                }
                document.body.removeChild(tempInput);
            }
        }, '#17a2b8');

        const applyBtn = createControlButton('æ‡‰ç”¨', () => {
            const errors = ruleValidator.validateBoard();
            if (errors.length > 0) {
                showError(errors.join('ï¼›'));
                return;
            }

            if (!ruleValidator.hasKing('red') || !ruleValidator.hasKing('black')) {
                showError('å¿…é¡»è¦æœ‰çº¢å¸¥å’Œé»‘å°‡ï¼');
                return;
            }

            try {
                const boardContainer = findBoardContainer();
                if (!boardContainer) {
                    throw new Error('æ‰¾ä¸åˆ°æ£‹ç›˜å®¹å™¨');
                }

                const correctBoard = createCorrectBoardFormat(ruleValidator.customBoard);
                validateBoardStructure(correctBoard);

                if (typeof gameState === 'undefined') {
                    window.gameState = {};
                }

                gameState.initialBoard = JSON.parse(JSON.stringify(correctBoard));
                gameState.initialTurn = ruleValidator.currentPlayer;
                gameState.board = JSON.parse(JSON.stringify(correctBoard));
                gameState.currentTurn = ruleValidator.currentPlayer;
                gameState.gameRecord = [];
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.history = gameState.history || [];
                gameState.historyIndex = gameState.historyIndex || -1;
                gameState.gameOver = false;
                gameState.checkStatus = null;

                if (historyManager) {
                    historyManager.clear();
                }

                intelligentRender(boardContainer);

                if (typeof updateMoveDisplay === 'function') {
                    updateMoveDisplay();
                }
                if (typeof saveToHistory === 'function') {
                    saveToHistory();
                }

                showSuccess('æ‡‰ç”¨æˆåŠŸï¼');
                console.log('âœ… åˆå§‹å±€é¢å·²ä¿å­˜');
            } catch (error) {
                console.error('æ‡‰ç”¨å¤±è´¥:', error);
                showError('æ‡‰ç”¨å¤±è´¥ï¼š' + error.message);
            }
        }, '#28a745');

        controlPanel.appendChild(clearBoardBtn);
        controlPanel.appendChild(resetBoardBtn);
        controlPanel.appendChild(playerToggle);
        controlPanel.appendChild(exportFenBtn);
        controlPanel.appendChild(applyBtn);

        // ğŸ”¥ æ£‹å­é€‰æ‹©åŒºåŸŸ - æ‰‹æœºç‰ˆä¼˜åŒ–
        const pieceSelector = document.createElement('div');
        pieceSelector.style.cssText = `
        margin-bottom: ${isMobile ? '10px' : '15px'};
        padding: ${isMobile ? '10px' : '15px'};
        background: #f8f9fa;
        border-radius: 8px;
    `;

        const selectorTitle = document.createElement('div');
        selectorTitle.textContent = 'é¸æ“‡æ£‹å­ï¼š';
        selectorTitle.style.cssText = `
        margin-bottom: ${isMobile ? '8px' : '12px'};
        font-weight: bold;
        color: #333;
        font-size: ${isMobile ? '13px' : '15px'};
    `;

        const redPieces = [
            { type: 'å¸¥', name: 'å¸¥' }, { type: 'ä¿¥', name: 'ä¿¥' }, { type: 'å‚Œ', name: 'å‚Œ' },
            { type: 'ç›¸', name: 'ç›¸' }, { type: 'ä»•', name: 'ä»•' }, { type: 'ç‚®', name: 'ç‚®' }, { type: 'å…µ', name: 'å…µ' }
        ];

        const blackPieces = [
            { type: 'å°‡', name: 'å°‡' }, { type: 'è»Š', name: 'è»Š' }, { type: 'é¦¬', name: 'é¦¬' },
            { type: 'è±¡', name: 'è±¡' }, { type: 'å£«', name: 'å£«' }, { type: 'åŒ…', name: 'åŒ…' }, { type: 'å’', name: 'å’' }
        ];

        // ğŸ”¥ åˆ›å»ºæ£‹å­æŒ‰é’® - æ‰‹æœºç‰ˆä¼˜åŒ–
        function createPieceButton(piece, color) {
            const button = document.createElement('button');
            button.textContent = piece.name;
            button.style.cssText = `
    margin: 3px;
    padding: ${isMobile ? '6px 8px' : '8px 12px'};
    border: 2px solid ${color === 'red' ? '#d32f2f' : '#2e7d32'};
    border-radius: 50%;
    cursor: pointer;
    background: ${color === 'red' ? '#ffebee' : '#e8f5e8'};
    color: ${color === 'red' ? '#d32f2f' : '#2e7d32'};
    font-weight: bold;
    font-size: ${isMobile ? '14px' : '16px'};
    min-width: ${isMobile ? '36px' : '45px'};
    min-height: ${isMobile ? '36px' : '45px'};
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        `;

            if (isMobile) {
                button.addEventListener('touchstart', () => {
                    button.style.transform = 'scale(0.95)';
                });
                button.addEventListener('touchend', () => {
                    button.style.transform = 'scale(1)';
                });
            } else {
                button.addEventListener('mouseenter', () => {
                    button.style.transform = 'translateY(-1px)';
                    button.style.boxShadow = '0 2px 6px rgba(0,0,0,0.1)';
                });
                button.addEventListener('mouseleave', () => {
                    if (!button.classList.contains('selected-piece')) {
                        button.style.transform = 'none';
                        button.style.boxShadow = 'none';
                    }
                });
            }

            button.addEventListener('click', function() {
                document.querySelectorAll('.selected-piece').forEach(btn => {
                    btn.classList.remove('selected-piece');
                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                    btn.style.transform = 'none';
                    btn.style.boxShadow = 'none';
                });

                selectedPiece = { type: piece.type, color: color };
                button.classList.add('selected-piece');
                button.style.border = '3px solid #007bff';
                button.style.transform = isMobile ? 'scale(1.05)' : 'translateY(-2px)';
                button.style.boxShadow = '0 4px 12px rgba(0,123,255,0.4)';
            });

            return button;
        }

        // çº¢æ–¹æ£‹å­åŒºåŸŸ
        const redSection = document.createElement('div');
        redSection.style.cssText = `
        margin-bottom: 8px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 5px;
    `;
        const redTitle = document.createElement('strong');
        redTitle.textContent = isMobile ? 'çº¢ï¼š' : 'çº¢æ–¹ï¼š';
        redTitle.style.cssText = `
        color: #d32f2f;
        margin-right: ${isMobile ? '5px' : '10px'};
        font-size: ${isMobile ? '12px' : '14px'};
        white-space: nowrap;
    `;
        redSection.appendChild(redTitle);

        const redButtonsContainer = document.createElement('div');
        redButtonsContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 3px;';
        redPieces.forEach(piece => {
            redButtonsContainer.appendChild(createPieceButton(piece, 'red'));
        });
        redSection.appendChild(redButtonsContainer);

        // é»‘æ–¹æ£‹å­åŒºåŸŸ
        const blackSection = document.createElement('div');
        blackSection.style.cssText = `
        margin-bottom: 10px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 5px;
    `;
        const blackTitle = document.createElement('strong');
        blackTitle.textContent = isMobile ? 'é»‘ï¼š' : 'é»‘æ–¹ï¼š';
        blackTitle.style.cssText = `
        color: #2e7d32;
        margin-right: ${isMobile ? '5px' : '10px'};
        font-size: ${isMobile ? '12px' : '14px'};
        white-space: nowrap;
    `;
        blackSection.appendChild(blackTitle);

        const blackButtonsContainer = document.createElement('div');
        blackButtonsContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 3px;';
        blackPieces.forEach(piece => {
            blackButtonsContainer.appendChild(createPieceButton(piece, 'black'));
        });
        blackSection.appendChild(blackButtonsContainer);

        // æ¸…é™¤æŒ‰é’®
        const clearButton = document.createElement('button');
        clearButton.textContent = 'æ¸…é™¤';
        clearButton.style.cssText = `
        margin: 3px;
        padding: ${isMobile ? '6px 10px' : '8px 12px'};
        border: 2px solid #856404;
        border-radius: 50%;
        cursor: pointer;
        background: #fff3cd;
        color: #856404;
        font-weight: bold;
        font-size: ${isMobile ? '14px' : '16px'};
        min-width: ${isMobile ? '50px' : '60px'};
        min-height: ${isMobile ? '36px' : '45px'};
        transition: all 0.2s ease;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    `;

        if (isMobile) {
            clearButton.addEventListener('touchstart', () => {
                clearButton.style.transform = 'scale(0.95)';
            });
            clearButton.addEventListener('touchend', () => {
                clearButton.style.transform = 'scale(1)';
            });
        } else {
            clearButton.addEventListener('mouseenter', () => {
                clearButton.style.transform = 'translateY(-1px)';
                clearButton.style.boxShadow = '0 2px 6px rgba(0,0,0,0.1)';
            });
            clearButton.addEventListener('mouseleave', () => {
                if (!clearButton.classList.contains('selected-piece')) {
                    clearButton.style.transform = 'none';
                    clearButton.style.boxShadow = 'none';
                }
            });
        }

        clearButton.addEventListener('click', function() {
            selectedPiece = 'clear';
            document.querySelectorAll('.selected-piece').forEach(btn => {
                btn.classList.remove('selected-piece');
                if (btn === clearButton) {
                    btn.style.border = '2px solid #856404';
                } else {
                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                }
                btn.style.transform = 'none';
                btn.style.boxShadow = 'none';
            });
            clearButton.style.border = '3px solid #007bff';
            clearButton.style.transform = isMobile ? 'scale(1.05)' : 'translateY(-2px)';
            clearButton.style.boxShadow = '0 4px 12px rgba(0,123,255,0.4)';
            clearButton.classList.add('selected-piece');
        });

        const actionSection = document.createElement('div');
        actionSection.style.cssText = `
        margin-top: 8px;
        display: flex;
        align-items: center;
        gap: 5px;
    `;
        const actionTitle = document.createElement('strong');
        actionTitle.textContent = isMobile ? 'æ“ä½œï¼š' : 'æ“ä½œï¼š';
        actionTitle.style.cssText = `
        color: #6c757d;
        margin-right: ${isMobile ? '5px' : '10px'};
        font-size: ${isMobile ? '12px' : '14px'};
    `;
        actionSection.appendChild(actionTitle);
        actionSection.appendChild(clearButton);

        pieceSelector.appendChild(selectorTitle);
        pieceSelector.appendChild(redSection);
        pieceSelector.appendChild(blackSection);
        pieceSelector.appendChild(actionSection);

        // ğŸ”¥ æ£‹ç›˜æ˜¾ç¤ºåŒºåŸŸ - æ‰‹æœºç‰ˆä¼˜åŒ–
        const boardDisplay = document.createElement('div');
        boardDisplay.style.cssText = `
        margin-bottom: ${isMobile ? '15px' : '20px'};
        text-align: center;
    `;

        const boardContainer = document.createElement('div');
        boardContainer.style.cssText = `
        display: inline-block;
        background: #f4d03f;
        padding: ${isMobile ? '10px' : '20px'};
        border: ${isMobile ? '2px' : '3px'} solid #8b4513;
        border-radius: 8px;
        position: relative;
        max-width: 100%;
        overflow-x: auto;
    `;

        function createChessBoard() {
            boardContainer.innerHTML = '';

            // å›ºå®šæ£‹ç›˜å¤§å°
            const cellWidth = 35;
            const cellHeight = 38;
            const startX = cellWidth / 2;
            const startY = cellHeight / 2;

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '315');    // ğŸ‘ˆ 35*9
            svg.setAttribute('height', '380');   // ğŸ‘ˆ 38*10
            svg.style.cssText = `
        background: #f4d03f;
        border: 2px solid #8b4513;
    `;

            const isFlipped = (typeof gameState !== 'undefined' && gameState.isFlipped) || false;

            // ç»˜åˆ¶çºµçº¿
            for (let i = 0; i < 9; i++) {
                const x = startX + i * cellWidth;

                if (i === 0 || i === 8) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', startY);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', startY + 9 * cellHeight);
                    line.setAttribute('stroke', '#8b4513');
                    line.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line);
                } else {
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', x);
                    line1.setAttribute('y1', startY);
                    line1.setAttribute('x2', x);
                    line1.setAttribute('y2', startY + 4 * cellHeight);
                    line1.setAttribute('stroke', '#8b4513');
                    line1.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line1);

                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', x);
                    line2.setAttribute('y1', startY + 5 * cellHeight);
                    line2.setAttribute('x2', x);
                    line2.setAttribute('y2', startY + 9 * cellHeight);
                    line2.setAttribute('stroke', '#8b4513');
                    line2.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line2);
                }
            }

            // ç»˜åˆ¶æ¨ªçº¿
            for (let i = 0; i < 10; i++) {
                const y = startY + i * cellHeight;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', y);
                line.setAttribute('x2', startX + 8 * cellWidth);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#8b4513');
                line.setAttribute('stroke-width', '1.5');
                svg.appendChild(line);
            }

            // ç»˜åˆ¶ä¹å®«æ ¼å¯¹è§’çº¿
            const diagLines = [
                { x1: 3, y1: 0, x2: 5, y2: 2 },
                { x1: 5, y1: 0, x2: 3, y2: 2 },
                { x1: 3, y1: 7, x2: 5, y2: 9 },
                { x1: 5, y1: 7, x2: 3, y2: 9 }
            ];

            diagLines.forEach(({ x1, y1, x2, y2 }) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX + x1 * cellWidth);
                line.setAttribute('y1', startY + y1 * cellHeight);
                line.setAttribute('x2', startX + x2 * cellWidth);
                line.setAttribute('y2', startY + y2 * cellHeight);
                line.setAttribute('stroke', '#8b4513');
                line.setAttribute('stroke-width', '1.5');
                svg.appendChild(line);
            });

            // æ·»åŠ æ¥šæ²³æ±‰ç•Œæ–‡å­—
            const fontSize = isMobile ? 12 : 14;
            const riverText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            riverText.setAttribute('x', startX + 1.2 * cellWidth);
            riverText.setAttribute('y', startY + 4.5 * cellHeight + fontSize/2);
            riverText.setAttribute('fill', '#2c3e50');
            riverText.setAttribute('font-size', fontSize);
            riverText.setAttribute('font-weight', 'bold');
            riverText.textContent = 'æ¥šæ²³';
            svg.appendChild(riverText);

            const boundaryText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            boundaryText.setAttribute('x', startX + 5.8 * cellWidth);
            boundaryText.setAttribute('y', startY + 4.5 * cellHeight + fontSize/2);
            boundaryText.setAttribute('fill', '#2c3e50');
            boundaryText.setAttribute('font-size', fontSize);
            boundaryText.setAttribute('font-weight', 'bold');
            boundaryText.textContent = 'æ¼¢ç•Œ';
            svg.appendChild(boundaryText);

            // ğŸ”¥ åˆ›å»ºäº¤ç‚¹ - æ”¯æŒè§¦æ§
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');

                    const displayRow = isFlipped ? (9 - row) : row;
                    const displayCol = col;

                    const cx = startX + displayCol * cellWidth;
                    const cy = startY + displayRow * cellHeight;

                    const touchRadius = isMobile ? 12 : 8;
                    circle.setAttribute('cx', cx);
                    circle.setAttribute('cy', cy);
                    circle.setAttribute('r', touchRadius);
                    circle.setAttribute('fill', 'transparent');
                    circle.setAttribute('stroke', 'transparent');
                    circle.setAttribute('cursor', 'pointer');
                    circle.setAttribute('data-row', row);
                    circle.setAttribute('data-col', col);

                    // ğŸ”¥ è§¦æ§åé¦ˆ
                    if (isMobile) {
                        let touchStartY = 0;

                        circle.addEventListener('touchstart', (e) => {
                            // ğŸ”¥ è®°å½•è§¦æ§å¼€å§‹ä½ç½®ï¼Œä½†ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆå…è®¸æ»šåŠ¨ï¼‰
                            touchStartY = e.touches[0].clientY;
                            circle.setAttribute('fill', 'rgba(0,123,255,0.3)');
                        }, { passive: true });

                        circle.addEventListener('touchend', (e) => {
                            e.preventDefault(); // ğŸ”¥ åªåœ¨touchendé˜»æ­¢é»˜è®¤è¡Œä¸º
                            circle.setAttribute('fill', 'transparent');

                            // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯æ»‘åŠ¨æ“ä½œï¼ˆå¦‚æœæ»‘åŠ¨è·ç¦»å¤§äº10pxåˆ™ä¸è§¦å‘ç‚¹å‡»ï¼‰
                            const touchEndY = e.changedTouches[0].clientY;
                            if (Math.abs(touchEndY - touchStartY) < 10) {
                                handleCellClick(row, col, circle);
                            }
                        });

                        circle.addEventListener('touchcancel', () => {
                            circle.setAttribute('fill', 'transparent');
                        });
                    } else {

                        circle.addEventListener('mouseenter', () => {
                            circle.setAttribute('fill', 'rgba(0,123,255,0.2)');
                        });

                        circle.addEventListener('mouseleave', () => {
                            circle.setAttribute('fill', 'transparent');
                        });

                        circle.addEventListener('click', () => {
                            handleCellClick(row, col, circle);
                        });
                    }

                    svg.appendChild(circle);
                }
            }

            boardContainer.appendChild(svg);
        }

        // ğŸ”¥ å¤„ç†æ ¼å­ç‚¹å‡»çš„ç»Ÿä¸€å‡½æ•°
        function handleCellClick(row, col, circle) {
            const existingPiece = ruleValidator.customBoard[row][col];

            // é˜²æŠ–
            if (circle.dataset.clicking === 'true') {
                return;
            }
            circle.dataset.clicking = 'true';
            setTimeout(() => {
                circle.dataset.clicking = 'false';
            }, 200);

            // æ¸…é™¤æ¨¡å¼
            if (selectedPiece === 'clear') {
                if (existingPiece) {
                    ruleValidator.clearPiece(row, col);
                    createChessBoard();
                    updateBoardDisplay();
                }
                return;
            }

            // æ”¾ç½®æ¨¡å¼
            if (selectedPiece && selectedPiece !== 'clear') {
                if (existingPiece) {
                    selectedPosition = { row, col, piece: existingPiece };
                    selectedPiece = null;
                    document.querySelectorAll('.selected-piece').forEach(btn => {
                        btn.classList.remove('selected-piece');
                        const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                        btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                    });
                    updateBoardDisplay();
                    return;
                }

                const validation = ruleValidator.placePiece(row, col, selectedPiece);
                if (validation.valid) {
                    selectedPosition = null;
                    updateBoardDisplay();
                } else {
                    showError(validation.reason);
                }
                return;
            }

            // ç§»åŠ¨æ¨¡å¼
            if (selectedPosition && selectedPosition.row !== undefined) {
                const fromRow = selectedPosition.row;
                const fromCol = selectedPosition.col;
                const movingPiece = ruleValidator.customBoard[fromRow][fromCol];

                if (fromRow === row && fromCol === col) {
                    selectedPosition = null;
                    updateBoardDisplay();
                    return;
                }

                if (existingPiece && movingPiece && existingPiece.color === movingPiece.color) {
                    selectedPosition = { row, col, piece: existingPiece };
                    updateBoardDisplay();
                    return;
                }

                if (movingPiece) {
                    const originalPiece = ruleValidator.customBoard[fromRow][fromCol];
                    const targetPiece = ruleValidator.customBoard[row][col];

                    ruleValidator.customBoard[fromRow][fromCol] = null;
                    const validation = ruleValidator.canPlacePiece(row, col, movingPiece);

                    if (validation.valid) {
                        ruleValidator.customBoard[row][col] = originalPiece;
                        selectedPosition = null;
                        updateBoardDisplay();
                    } else {
                        ruleValidator.customBoard[fromRow][fromCol] = originalPiece;
                        ruleValidator.customBoard[row][col] = targetPiece;
                        selectedPosition = null;
                        showError(`ç§»å‹•å¤±æ•—: ${validation.reason}`);
                    }
                } else {
                    selectedPosition = null;
                }
                return;
            }

            // é€‰ä¸­æ£‹ç›˜ä¸Šçš„æ£‹å­
            if (existingPiece) {
                selectedPosition = { row, col, piece: existingPiece };
                selectedPiece = null;
                document.querySelectorAll('.selected-piece').forEach(btn => {
                    btn.classList.remove('selected-piece');
                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                });
                updateBoardDisplay();
            }
        }

        function updateBoardDisplay() {
            createChessBoard();

            const svg = boardContainer.querySelector('svg');
            const svgWidth = parseFloat(svg.getAttribute('width'));
            const cellWidth = svgWidth / 9;
            const cellHeight = cellWidth * 1.1;
            const startX = cellWidth / 2;
            const startY = cellHeight / 2;

            const isFlipped = (typeof gameState !== 'undefined' && gameState.isFlipped) || false;

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = ruleValidator.customBoard[row][col];

                    const displayRow = isFlipped ? (9 - row) : row;
                    const displayCol = col;

                    const cx = startX + displayCol * cellWidth;
                    const cy = startY + displayRow * cellHeight;

                    // é€‰ä¸­çŠ¶æ€çš„è§†è§‰æ•ˆæœ
                    if (selectedPosition && selectedPosition.row === row && selectedPosition.col === col) {
                        const highlightCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        highlightCircle.setAttribute('cx', cx);
                        highlightCircle.setAttribute('cy', cy);
                        highlightCircle.setAttribute('r', cellWidth * 0.45);
                        highlightCircle.setAttribute('fill', 'rgba(255,215,0,0.3)');
                        highlightCircle.setAttribute('stroke', '#ffd700');
                        highlightCircle.setAttribute('stroke-width', '3');
                        highlightCircle.setAttribute('stroke-dasharray', '4,2');
                        highlightCircle.setAttribute('pointer-events', 'none');
                        svg.appendChild(highlightCircle);
                    }

                    if (piece) {
                        const pieceRadius = cellWidth * 0.38;
                        const fontSize = isMobile ? cellWidth * 0.42 : cellWidth * 0.45;

                        // åˆ›å»ºæ£‹å­èƒŒæ™¯åœ†åœˆ
                        const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        bgCircle.setAttribute('cx', cx);
                        bgCircle.setAttribute('cy', cy);
                        bgCircle.setAttribute('r', pieceRadius);
                        bgCircle.setAttribute('fill', piece.color === 'red' ? '#ffebee' : '#e8f5e8');
                        bgCircle.setAttribute('stroke', piece.color === 'red' ? '#d32f2f' : '#2e7d32');
                        bgCircle.setAttribute('stroke-width', '2');
                        bgCircle.setAttribute('pointer-events', 'none');
                        svg.appendChild(bgCircle);

                        // åˆ›å»ºæ£‹å­æ–‡å­—
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', cx);
                        text.setAttribute('y', cy);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('dominant-baseline', 'central');
                        text.setAttribute('fill', piece.color === 'red' ? '#d32f2f' : '#2e7d32');
                        text.setAttribute('font-size', fontSize);
                        text.setAttribute('font-weight', 'bold');
                        text.setAttribute('pointer-events', 'none');
                        text.textContent = piece.type;
                        svg.appendChild(text);
                    }
                }
            }

            updateFlipIndicatorText();
        }

        createChessBoard();
        updateBoardDisplay();

        boardDisplay.appendChild(boardContainer);

        // ğŸ”¥ å…³é—­æŒ‰é’® - æ‰‹æœºç‰ˆä¼˜åŒ–
        const closeButton = document.createElement('button');
        closeButton.textContent = 'é—œé–‰';
        closeButton.style.cssText = `
        padding: ${isMobile ? '12px 20px' : '12px 24px'};
        background-color: #6c757d;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: ${isMobile ? '14px' : '16px'};
        font-weight: bold;
        display: block;
        margin: 0 auto;
        transition: all 0.2s ease;
        width: ${isMobile ? '100%' : 'auto'};
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    `;

        if (isMobile) {
            closeButton.addEventListener('touchstart', () => {
                closeButton.style.opacity = '0.8';
            });
            closeButton.addEventListener('touchend', () => {
                closeButton.style.opacity = '1';
            });
        } else {
            closeButton.addEventListener('mouseenter', () => {
                closeButton.style.backgroundColor = '#5a6268';
                closeButton.style.transform = 'translateY(-1px)';
            });
            closeButton.addEventListener('mouseleave', () => {
                closeButton.style.backgroundColor = '#6c757d';
                closeButton.style.transform = 'none';
            });
        }

        closeButton.addEventListener('click', () => {
            selectedPosition = null;
            document.body.removeChild(container);
        });

        // ç»„è£…ç•Œé¢
        container.appendChild(title);
        container.appendChild(flipIndicator);
        container.appendChild(errorDisplay);
        container.appendChild(successDisplay);
        container.appendChild(controlPanel);
        container.appendChild(pieceSelector);
        container.appendChild(boardDisplay);
        container.appendChild(closeButton);

        document.body.appendChild(container);

        // è¾…åŠ©å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
        function findBoardContainer() {
            const selectors = ['#chess-board', '#gameBoard', '#chessBoard', '#board', '.board', '.chess-board'];
            for (const selector of selectors) {
                const element = document.querySelector(selector);
                if (element) return element;
            }
            return null;
        }

        function createCorrectBoardFormat(customBoard) {
            const board = [];
            for (let i = 0; i < 10; i++) {
                board[i] = [];
                for (let j = 0; j < 9; j++) {
                    board[i][j] = null;
                }
            }
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = customBoard[row][col];
                    if (piece) {
                        board[row][col] = {
                            type: piece.type,
                            color: piece.color
                        };
                    }
                }
            }
            return board;
        }

        function validateBoardStructure(board) {
            return {
                isValid: board.length === 10 && board[0].length === 9
            };
        }

        function intelligentRender(container) {
            if (typeof window.renderBoard === 'function') {
                try {
                    window.renderBoard();
                    return;
                } catch (error) {
                    console.log('renderBoardå¤±è´¥:', error.message);
                }
            }
            if (container && window.gameState?.board) {
                updateExistingBoard(container);
            }
        }

        function updateExistingBoard(container) {
            const cells = container.querySelectorAll('[data-row][data-col]');
            cells.forEach(cell => {
                const pieces = cell.querySelectorAll('.piece, .chess-piece');
                pieces.forEach(piece => piece.remove());
            });

            window.gameState.board.forEach((row, rowIndex) => {
                row.forEach((piece, colIndex) => {
                    if (piece) {
                        const cell = container.querySelector(`[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                        if (cell) {
                            const pieceElement = createPieceElement(piece);
                            cell.appendChild(pieceElement);
                        }
                    }
                });
            });
        }

        function createPieceElement(piece) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece piece';
            pieceElement.textContent = piece.type;
            const isRed = piece.color === 'red';
            pieceElement.style.cssText = `
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: ${isRed ? 'linear-gradient(145deg, #ff4757, #ff3742)' : 'linear-gradient(145deg, #2f3542, #40739e)'};
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            cursor: pointer;
            border: 2px solid white;
        `;
            return pieceElement;
        }

        return {
            container: container,
            close: () => {
                if (document.body.contains(container)) {
                    document.body.removeChild(container);
                }
            },
            getBoard: () => ruleValidator.customBoard,
            getCurrentPlayer: () => ruleValidator.currentPlayer
        };
    }

    console.log('âœ… æ‰‹æœºç‰ˆè‡ªå®šä¹‰æ£‹ç›˜å·²åŠ è½½ï¼æ”¯æŒè§¦æ§æ“ä½œ');



    // ====================================
    // é–‹å±€/æ®˜å±€æ¨æ¼”ç³»çµ±ï¼ˆå« JSON è¼‰å…¥åŠŸèƒ½ï¼‰
    // ====================================

    class ChessPositionTrainer {
        constructor() {
            this.openingsData = [];
            this.endgamesData = [];
            this.endgamesAllData = [];
            this.jianghuEndgamesData = []; // ğŸ†• æ–°å¢
            this.challengingEndgamesData = []; // ğŸ†• æ–°å¢é€™è¡Œ
            this.ancientEndgamesData = []; // ğŸ†• æ–°å¢å¤è­œé¡Œåº«è®Šæ•¸
            this.basicCheckmatesData = []; // ğŸ†• æ–°å¢åŸºæœ¬æ®ºæ³•è®Šæ•¸
            this.openingRepertoireData = []; // ğŸ†• æ–°å¢é–‹å±€é¡Œåº«è®Šæ•¸
            this.customEndgamesData = []; // ğŸ†• æ–°å¢è‡ªè¨‚é¡Œåº«è®Šæ•¸
            this.customOpeningsData = []; // ğŸ†• æ–°å¢è‡ªè¨‚é–‹å±€é¡Œåº«è®Šæ•¸
            this.currentMode = null;
            this.currentEndgameType = null;
            this.currentPosition = null;
            this.ruleValidator = new ChessRuleValidator();

            this.patternFiles = [];

            this.initializeSampleData();
            this.loadEndgamesAll();
            this.loadJianghuEndgames(); // ğŸ†• æ–°å¢
            this.loadChallengingEndgames(); // ğŸ†• æ–°å¢é€™è¡Œ
            this.loadAncientEndgames(); // ğŸ†• æ–°å¢é€™è¡Œ
            this.loadBasicCheckmates(); // ğŸ†• æ–°å¢é€™è¡Œ
            this.loadOpeningRepertoire(); // ğŸ†• æ–°å¢é€™è¡Œ
            this.loadCustomFromStorage(); // ğŸ†• å¾ LocalStorage è¼‰å…¥è‡ªè¨‚é¡Œåº«
        }
// æ–°å¢ï¼šè¼‰å…¥è±¡æ£‹å®šå¼é¡Œåº«
        async loadChessPatternsFromFolder() {
            const patternPath = 'D:\\USER_DATA\\Desktop\\è±¡æ£‹\\è±¡æ£‹åœ–ç‰‡\\untitled\\Chess Patterns';

            try {
                // ç”±æ–¼ç€è¦½å™¨ç„¡æ³•ç›´æ¥è®€å–æœ¬åœ°è³‡æ–™å¤¾ï¼Œéœ€è¦ç”¨æˆ¶ä¸Šå‚³æˆ–é€é API
                // é€™è£¡æä¾›æ–¹æ¡ˆï¼šè®€å–é å…ˆæ•´ç†çš„ patterns_index.json
                const response = await fetch('patterns_index.json');
                if (!response.ok) {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥å®šå¼ç´¢å¼•æª”');
                    return;
                }
                const index = await response.json();
                this.patternFiles = index.files || [];
                console.log(`âœ… æˆåŠŸè¼‰å…¥ ${this.patternFiles.length} å€‹å®šå¼æª”æ¡ˆ`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥å®šå¼å¤±æ•—:', error);
            }
        }

        async loadJianghuEndgames() {
            try {
                const response = await fetch('jianghu-endgames.json'); // âœ… æ”¹é€™è£¡
                if (!response.ok) {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ jianghu-endgames.json');
                    return;
                }
                const data = await response.json();
                this.jianghuEndgamesData = data;
                console.log(`âœ… æˆåŠŸè¼‰å…¥ ${this.jianghuEndgamesData.length} ç­†æ±Ÿæ¹–æ®˜å±€è³‡æ–™`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥æ±Ÿæ¹–æ®˜å±€å¤±æ•—:', error);
            }
        }

        async loadAncientEndgames() {
            try {
                // è¼‰å…¥é©æƒ…é›…è¶£
                const response1 = await fetch('shi-qing-ya-qu.json');
                // è¼‰å…¥å¤¢å…¥ç¥æ©Ÿ
                const response2 = await fetch('meng-ru-shen-ji.json');

                let data = [];

                if (response1.ok) {
                    const data1 = await response1.json();
                    data = data.concat(data1);
                    console.log(`âœ… æˆåŠŸè¼‰å…¥é©æƒ…é›…è¶£ ${data1.length} é¡Œ`);
                } else {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ shi-qing-ya-qu.json');
                }

                if (response2.ok) {
                    const data2 = await response2.json();
                    data = data.concat(data2);
                    console.log(`âœ… æˆåŠŸè¼‰å…¥å¤¢å…¥ç¥æ©Ÿ ${data2.length} é¡Œ`);
                } else {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ meng-ru-shen-ji.json');
                }

                this.ancientEndgamesData = data;
                console.log(`âœ… å¤è­œé¡Œåº«ç¸½è¨ˆè¼‰å…¥ ${this.ancientEndgamesData.length} é¡Œ`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥å¤è­œå¤±æ•—:', error);
            }
        }

        async loadBasicCheckmates() {
            try {
                // è¼‰å…¥åŸºç¤æ®ºæ³•ï¼ˆå…ˆè¼‰å…¥ï¼‰
                const response1 = await fetch('basic-checkmates.json');
                // è¼‰å…¥é€²éšæ®ºæ³•
                const response2 = await fetch('advanced-checkmates.json');

                let data = [];

                if (response1.ok) {
                    const data1 = await response1.json();
                    data = data.concat(data1);
                    console.log(`âœ… æˆåŠŸè¼‰å…¥åŸºç¤æ®ºæ³• ${data1.length} é¡Œ`);
                } else {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ basic-checkmates.json');
                }

                if (response2.ok) {
                    const data2 = await response2.json();
                    data = data.concat(data2);
                    console.log(`âœ… æˆåŠŸè¼‰å…¥é€²éšæ®ºæ³• ${data2.length} é¡Œ`);
                } else {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ advanced-checkmates.json');
                }

                this.basicCheckmatesData = data;
                console.log(`âœ… åŸºæœ¬æ®ºæ³•é¡Œåº«ç¸½è¨ˆè¼‰å…¥ ${this.basicCheckmatesData.length} é¡Œ`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥åŸºæœ¬æ®ºæ³•å¤±æ•—:', error);
            }
        }

        async loadOpeningRepertoire() {
            try {
                const response = await fetch('opening-repertoire.json');

                if (response.ok) {
                    const data = await response.json();
                    this.openingRepertoireData = data;
                    console.log(`âœ… æˆåŠŸè¼‰å…¥é–‹å±€é¡Œåº« ${this.openingRepertoireData.length} é¡Œ`);
                } else {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ opening-repertoire.json');
                }
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥é–‹å±€é¡Œåº«å¤±æ•—:', error);
            }
        }

        async loadChallengingEndgames() {
            try {
                const response = await fetch('extremely-challenging-endgames.json');
                if (!response.ok) {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ extremely-challenging-endgames.json');
                    return;
                }
                const data = await response.json();
                this.challengingEndgamesData = data;
                console.log(`âœ… æˆåŠŸè¼‰å…¥ ${this.challengingEndgamesData.length} ç­†ç–‘é›£é›œç—‡è³‡æ–™`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥ç–‘é›£é›œç—‡å¤±æ•—:', error);
            }
        }

        // ğŸ†• æ ¹æ“šæª”åè¼‰å…¥ç‰¹å®šå®šå¼ï¼ˆé¡¯ç¤ºè©³ç´°éŒ¯èª¤è³‡è¨Šï¼‰
        async loadPatternByFile(filename) {
            try {
                const response = await fetch(`Chess Patterns/${filename}`);
                if (!response.ok) {
                    console.warn(`âš ï¸ ç„¡æ³•è¼‰å…¥æª”æ¡ˆ: ${filename}`);
                    return null;
                }

                const text = await response.text();

                // å˜—è©¦è§£æ JSON
                try {
                    const data = JSON.parse(text);

                    // ğŸ”§ ä¿®æ­£ï¼šæª”æ¡ˆæ˜¯é™£åˆ—æ ¼å¼ï¼Œéš¨æ©Ÿé¸ä¸€å€‹å±€é¢
                    if (Array.isArray(data) && data.length > 0) {
                        const randomPosition = data[Math.floor(Math.random() * data.length)];
                        return randomPosition;
                    }

                    // å¦‚æœä¸æ˜¯é™£åˆ—ï¼Œç›´æ¥è¿”å›
                    return data;
                } catch (jsonError) {
                    // ğŸ†• é¡¯ç¤ºè©³ç´°éŒ¯èª¤è³‡è¨Šï¼ŒåŒ…å«æª”æ¡ˆåç¨±
                    console.error(`âŒ JSON æ ¼å¼éŒ¯èª¤ - æª”æ¡ˆ: ${filename}`);
                    console.error(`   éŒ¯èª¤è¨Šæ¯: ${jsonError.message}`);
                    console.error(`   é€™å€‹æª”æ¡ˆéœ€è¦æ‰‹å‹•ä¿®æ­£ JSON æ ¼å¼`);
                    return null;
                }
            } catch (error) {
                console.warn(`âš ï¸ è¼‰å…¥å¤±æ•— - æª”æ¡ˆ: ${filename}`, error);
                return null;
            }
        }

        async loadEndgamesAll() {
            try {
                const response = await fetch('endgames_all.json');
                if (!response.ok) {
                    console.warn('âš ï¸ ç„¡æ³•è¼‰å…¥ endgames_all.json');
                    return;
                }
                const data = await response.json();
                this.endgamesAllData = data;
                console.log(`âœ… æˆåŠŸè¼‰å…¥ ${this.endgamesAllData.length} ç­†æ®˜å±€è³‡æ–™`);
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥å¤±æ•—:', error);
            }
        }

        // ğŸ†• å¾ LocalStorage è¼‰å…¥è‡ªè¨‚é¡Œåº«
        loadCustomFromStorage() {
            try {
                const saved = localStorage.getItem('chessCustomEndgames');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (Array.isArray(data)) {
                        this.customEndgamesData = data;
                        console.log(`âœ… å¾æœ¬åœ°å„²å­˜è¼‰å…¥ ${this.customEndgamesData.length} é¡Œè‡ªè¨‚é¡Œåº«`);
                    }
                }
            } catch (error) {
                console.warn('âš ï¸ è¼‰å…¥è‡ªè¨‚é¡Œåº«å¤±æ•—:', error);
            }
        }

        // ğŸ†• å„²å­˜è‡ªè¨‚é¡Œåº«åˆ° LocalStorage
        saveCustomToStorage() {
            try {
                localStorage.setItem('chessCustomEndgames', JSON.stringify(this.customEndgamesData));
                console.log(`âœ… å·²å„²å­˜ ${this.customEndgamesData.length} é¡Œåˆ°æœ¬åœ°`);
            } catch (error) {
                console.warn('âš ï¸ å„²å­˜å¤±æ•—:', error);
                alert('å„²å­˜å¤±æ•—ï¼šå¯èƒ½è¶…éç€è¦½å™¨å„²å­˜é™åˆ¶ï¼ˆé€šå¸¸ç‚º 5-10MBï¼‰');
            }
        }

        initializeSampleData() {
            this.openingsData = [
                {
                    id: 1,
                    name: "ä¸­ç‚®å°å±é¢¨é¦¬",
                    fen: "r1bakab1r/9/1cn3nc1/p1p1p1p1p/9/9/P1P1P1P1P/1C2C1N2/9/RNBAKAB1R w - - 0 1",
                    description: "ä¸­ç‚®é–‹å±€ï¼Œå°æ–¹å±é¢¨é¦¬æ‡‰å°",
                    category: "ä¸­ç‚®ç³»çµ±",
                    difficulty: "åˆç´š"
                }
            ];

            this.endgamesData = [
                {
                    id: 1,
                    name: "å–®è»Šå‹é›™å£«",
                    fen: "4k4/4a4/3a5/9/9/4R4/9/9/9/4K4 w - - 0 1",
                    description: "ç´…æ–¹å–®è»Šå°é»‘æ–¹é›™å£«çš„å‹æ³•",
                    category: "åŸºç¤æ®˜å±€",
                    difficulty: "åˆç´š",
                    type: "å®šå¼æ®ºæ³•"
                }
            ];
        }

        validateFEN(fen) {
            if (!fen || typeof fen !== 'string') {
                return { valid: false, error: 'FEN ç¢¼ä¸èƒ½ç‚ºç©º' };
            }

            const parts = fen.trim().split(' ');
            if (parts.length < 2) {
                return { valid: false, error: 'FEN ç¢¼æ ¼å¼ä¸å®Œæ•´' };
            }

            const boardPart = parts[0];
            const activeColor = parts[1];

            if (activeColor !== 'w' && activeColor !== 'b') {
                return { valid: false, error: 'ç•¶å‰ç©å®¶æ¨™è¨˜éŒ¯èª¤' };
            }

            const rows = boardPart.split('/');
            if (rows.length !== 10) {
                return { valid: false, error: `æ£‹ç›¤æ‡‰è©²æœ‰ 10 è¡Œ` };
            }

            const hasRedKing = /K/.test(boardPart);
            const hasBlackKing = /k/.test(boardPart);

            if (!hasRedKing || !hasBlackKing) {
                return { valid: false, error: 'å¿…é ˆåŒ…å«ç´…å¸¥å’Œé»‘å°‡' };
            }

            return { valid: true };
        }

        parseFEN(fen) {
            const validation = this.validateFEN(fen);
            if (!validation.valid) {
                console.error('âŒ FEN é©—è­‰å¤±æ•—:', validation.error);
                return null;
            }

            const parts = fen.split(' ');
            const boardPart = parts[0];
            const currentPlayer = parts[1] === 'w' ? 'red' : 'black';

            const board = Array(10).fill(null).map(() => Array(9).fill(null));
            const rows = boardPart.split('/');

            for (let row = 0; row < 10; row++) {
                let col = 0;
                for (const char of rows[row]) {
                    if (/[1-9]/.test(char)) {
                        col += parseInt(char);
                    } else {
                        const piece = this.fenCharToPiece(char);
                        if (piece && col < 9) {
                            board[row][col] = piece;
                        }
                        col++;
                    }
                }
            }

            return { board, currentPlayer };
        }

        fenCharToPiece(char) {
            const pieceMap = {
                'K': { type: 'å¸¥', color: 'red' },
                'A': { type: 'ä»•', color: 'red' },
                'B': { type: 'ç›¸', color: 'red' },
                'N': { type: 'å‚Œ', color: 'red' },
                'R': { type: 'ä¿¥', color: 'red' },
                'C': { type: 'ç‚®', color: 'red' },
                'P': { type: 'å…µ', color: 'red' },
                'k': { type: 'å°‡', color: 'black' },
                'a': { type: 'å£«', color: 'black' },
                'b': { type: 'è±¡', color: 'black' },
                'n': { type: 'é¦¬', color: 'black' },
                'r': { type: 'è»Š', color: 'black' },
                'c': { type: 'åŒ…', color: 'black' },
                'p': { type: 'å’', color: 'black' }
            };
            return pieceMap[char] || null;
        }

        async searchPositions(keyword, mode) {
            let data;

            if (mode === 'opening') {
                // ğŸ†• é–‹å±€æ¨¡å¼ï¼šæ ¹æ“šé¡å‹é¸æ“‡
                if (this.currentOpeningType === 'é–‹å±€é¡Œåº«') {
                    data = this.openingRepertoireData.map((item, index) => ({
                        id: `opening_${index}`,
                        name: item.name || `é–‹å±€ ${index + 1}`,
                        fen: item.fen,
                        description: item.description || item.name || 'é–‹å±€é¡Œåº«',
                        category: item.category || 'é–‹å±€é¡Œåº«',
                        difficulty: item.difficulty || '-',
                        bestMove: item.bestMove || ''
                    }));
                } else {
                    // é è¨­ï¼šä½¿ç”¨åŸæœ¬çš„ç¯„ä¾‹è³‡æ–™
                    data = this.openingsData;
                }
            } else if (mode === 'endgame') {
                if (this.currentEndgameType === 'è±¡æ£‹å®šå¼') {
                    // ğŸ”§ æ”¹ï¼šåªæœ‰é¸å®šå¼æ™‚ï¼Œè¼‰å…¥æ‰€æœ‰å®šå¼æª”æ¡ˆä¸¦å±•é–‹æ‰€æœ‰é¡Œç›®
                    data = [];
                    for (const filename of this.patternFiles) {
                        const patternData = await this.loadPatternByFile(filename);
                        if (Array.isArray(patternData)) {
                            // å¦‚æœæª”æ¡ˆåŒ…å«å¤šå€‹é¡Œç›®ï¼Œå…¨éƒ¨åŠ å…¥
                            patternData.forEach((item, index) => {
                                data.push({
                                    id: `${filename}_${index}`,
                                    name: `${filename.replace('.json', '')} - ç¬¬ ${index + 1} é¡Œ`,
                                    fen: item.fen,
                                    description: item.typeFull || item.type || 'è±¡æ£‹å®šå¼',
                                    category: 'è±¡æ£‹å®šå¼',
                                    difficulty: '-',
                                    bestMove: item.bestMove || ''
                                });
                            });
                        } else if (patternData && patternData.fen) {
                            // å¦‚æœåªæœ‰ä¸€å€‹é¡Œç›®
                            data.push({
                                id: filename,
                                name: filename.replace('.json', ''),
                                fen: patternData.fen,
                                description: patternData.typeFull || patternData.type || 'è±¡æ£‹å®šå¼',
                                category: 'è±¡æ£‹å®šå¼',
                                difficulty: '-',
                                bestMove: patternData.bestMove || ''
                            });
                        }
                    }
                } else if (this.currentEndgameType === 'æ±Ÿæ¹–æ®˜å±€') {
                    // ğŸ†• æ±Ÿæ¹–æ®˜å±€
                    data = this.jianghuEndgamesData.map((item, index) => ({
                        id: `jianghu_${index}`,
                        name: item.name || `æ±Ÿæ¹–æ®˜å±€ ${index + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'æ±Ÿæ¹–æ®˜å±€',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    }));
                } else if (this.currentEndgameType === 'ç–‘é›£é›œç—‡') {
                    // ğŸ†• ç–‘é›£é›œç—‡
                    data = this.challengingEndgamesData.map((item, index) => ({
                        id: `challenging_${index}`,
                        name: item.name || `ç–‘é›£é›œç—‡ ${index + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'ç–‘é›£é›œç—‡',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    }));
                } else if (this.currentEndgameType === 'åŸºæœ¬æ®ºæ³•') {
                    // ğŸ†• åŸºæœ¬æ®ºæ³•
                    data = this.basicCheckmatesData.map((item, index) => ({
                        id: `checkmate_${index}`,
                        name: item.name || `æ®ºæ³• ${index + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'åŸºæœ¬æ®ºæ³•',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    }));
                } else if (this.currentEndgameType === 'å¤å±€ç·´ç¿’') {
                    // ğŸ†• å¤å±€ç·´ç¿’
                    data = this.ancientEndgamesData.map((item, index) => ({
                        id: `ancient_${index}`,
                        name: item.name || `å¤è­œ ${index + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'å¤å±€ç·´ç¿’',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    }));
                }else if (this.currentEndgameType === 'è‡ªè¨‚é¡Œåº«') {
                        // ğŸ†• è‡ªè¨‚é¡Œåº«
                        data = this.customEndgamesData.map((item, index) => ({
                            id: `custom_${index}`,
                            name: item.name || `è‡ªè¨‚ ${index + 1}`,
                            fen: item.fen,
                            description: item.description || item.name || 'è‡ªè¨‚é¡Œåº«',
                            category: 'è‡ªè¨‚é¡Œåº«',
                            difficulty: item.difficulty || '-',
                            bestMove: item.bestMove || ''
                        }));
                } else {
                    // ğŸ”§ é€™è£¡ä¿æŒåŸæ¨£ï¼š7300 é¡Œçš„é‚è¼¯ä¸è®Š
                    if (this.endgamesAllData.length > 0) {
                        data = this.endgamesAllData.map((item, index) => ({
                            id: index,
                            name: item.type || 'æœªçŸ¥é¡å‹',
                            fen: item.fen,
                            description: `ç´…æ–¹: ${item.materialValue?.redValue || 0}, é»‘æ–¹: ${item.materialValue?.blackValue || 0}`,
                            category: item.type || 'å…¶ä»–',
                            difficulty: '-',
                            bestMove: item.bestMove
                        }));
                    } else {
                        data = this.endgamesData;
                    }
                }
            }

            if (!keyword || keyword.trim() === '') {
                return data.slice(0, 100);
            }

            const lowerKeyword = keyword.toLowerCase();
            return data.filter(pos =>
                pos.name.toLowerCase().includes(lowerKeyword) ||
                (pos.description && pos.description.toLowerCase().includes(lowerKeyword)) ||
                pos.category.toLowerCase().includes(lowerKeyword)
            ).slice(0, 100);
        }


        async getRandomPosition(mode) {
            if (mode === 'opening') {
                // ğŸ†• é–‹å±€æ¨¡å¼ï¼šæ ¹æ“šé¡å‹é¸æ“‡
                if (this.currentOpeningType === 'é–‹å±€é¡Œåº«') {
                    if (this.openingRepertoireData.length === 0) return null;

                    const randomIndex = Math.floor(Math.random() * this.openingRepertoireData.length);
                    const item = this.openingRepertoireData[randomIndex];

                    return {
                        id: `opening_${randomIndex}`,
                        name: item.name || `é–‹å±€ ${randomIndex + 1}`,
                        fen: item.fen,
                        description: item.description || item.name || 'é–‹å±€é¡Œåº«',
                        category: item.category || 'é–‹å±€é¡Œåº«',
                        difficulty: item.difficulty || '-',
                        bestMove: item.bestMove || ''
                    };
                } else {
                    // é è¨­ï¼šä½¿ç”¨åŸæœ¬çš„ç¯„ä¾‹è³‡æ–™
                    const data = this.openingsData;
                    if (data.length === 0) return null;
                    return data[Math.floor(Math.random() * data.length)];
                }
            } else if (mode === 'endgame') {
                // æ ¹æ“šé¡å‹é¸æ“‡
                if (this.currentEndgameType === 'è±¡æ£‹å®šå¼') {
                    // å¾å®šå¼æª”æ¡ˆä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.patternFiles.length === 0) {
                        await this.loadChessPatternsFromFolder();
                    }
                    if (this.patternFiles.length === 0) return null;

                    const randomFile = this.patternFiles[Math.floor(Math.random() * this.patternFiles.length)];
                    const patternData = await this.loadPatternByFile(randomFile);

                    // ğŸ”§ ä¿®æ­£ï¼špatternData å·²ç¶“æ˜¯å–®å€‹å±€é¢ç‰©ä»¶
                    if (patternData && patternData.fen) {
                        return {
                            id: `pattern_${randomFile}`,
                            name: patternData.type || patternData.typeFull || randomFile.replace('.json', ''),
                            fen: patternData.fen,
                            description: patternData.typeFull || patternData.type || 'è±¡æ£‹å®šå¼',
                            category: 'è±¡æ£‹å®šå¼',
                            difficulty: '-',
                            bestMove: patternData.bestMove || ''
                        };
                    }
                    return null;
                } else if (this.currentEndgameType === 'æ±Ÿæ¹–æ®˜å±€') {
                    // ğŸ†• å¾æ±Ÿæ¹–æ®˜å±€ä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.jianghuEndgamesData.length === 0) return null;

                    const randomIndex = Math.floor(Math.random() * this.jianghuEndgamesData.length);
                    const item = this.jianghuEndgamesData[randomIndex];

                    return {
                        id: `jianghu_${randomIndex}`,
                        name: item.name || `æ±Ÿæ¹–æ®˜å±€ ${randomIndex + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'æ±Ÿæ¹–æ®˜å±€',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    };
                } else if (this.currentEndgameType === 'ç–‘é›£é›œç—‡') {
                    // ğŸ†• å¾ç–‘é›£é›œç—‡ä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.challengingEndgamesData.length === 0) return null;

                    const randomIndex = Math.floor(Math.random() * this.challengingEndgamesData.length);
                    const item = this.challengingEndgamesData[randomIndex];

                    return {
                        id: `challenging_${randomIndex}`,
                        name: item.name || `ç–‘é›£é›œç—‡ ${randomIndex + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'ç–‘é›£é›œç—‡',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    };
                } else if (this.currentEndgameType === 'åŸºæœ¬æ®ºæ³•') {
                    // ğŸ†• å¾åŸºæœ¬æ®ºæ³•ä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.basicCheckmatesData.length === 0) return null;

                    const randomIndex = Math.floor(Math.random() * this.basicCheckmatesData.length);
                    const item = this.basicCheckmatesData[randomIndex];

                    return {
                        id: `checkmate_${randomIndex}`,
                        name: item.name || `æ®ºæ³• ${randomIndex + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'åŸºæœ¬æ®ºæ³•',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    };
                } else if (this.currentEndgameType === 'å¤å±€ç·´ç¿’') {
                    // ğŸ†• å¾å¤å±€ç·´ç¿’ä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.ancientEndgamesData.length === 0) return null;

                    const randomIndex = Math.floor(Math.random() * this.ancientEndgamesData.length);
                    const item = this.ancientEndgamesData[randomIndex];

                    return {
                        id: `ancient_${randomIndex}`,
                        name: item.name || `å¤è­œ ${randomIndex + 1}`,
                        fen: item.fen,
                        description: `${item.name}${item.result ? ' | ' + item.result : ''}`,
                        category: 'å¤å±€ç·´ç¿’',
                        difficulty: '-',
                        bestMove: item.bestMove || ''
                    };
                }else if (this.currentEndgameType === 'è‡ªè¨‚é¡Œåº«') {
                    // ğŸ†• å¾è‡ªè¨‚é¡Œåº«ä¸­éš¨æ©Ÿé¸æ“‡
                    if (this.customEndgamesData.length === 0) {
                        // å¦‚æœè‡ªè¨‚é¡Œåº«ç‚ºç©ºï¼Œé¡¯ç¤ºæç¤º
                        showBeautifulAlert('è‡ªè¨‚é¡Œåº«æ˜¯ç©ºçš„', 'è«‹é»æ“Šã€ŒğŸ“‚ ç®¡ç†é¡Œåº«ã€æŒ‰éˆ•ä¾†å°å…¥å±€é¢', 'info');
                        return null;
                    }
                        const randomIndex = Math.floor(Math.random() * this.customEndgamesData.length);
                        const item = this.customEndgamesData[randomIndex];

                        return {
                            id: `custom_${randomIndex}`,
                            name: item.name || `è‡ªè¨‚ ${randomIndex + 1}`,
                            fen: item.fen,
                            description: item.description || item.name || 'è‡ªè¨‚é¡Œåº«',
                            category: 'è‡ªè¨‚é¡Œåº«',
                            difficulty: item.difficulty || '-',
                            bestMove: item.bestMove || ''
                        };
                } else {
                    // å¾æ‰€æœ‰ 7300 é¡Œä¸­éš¨æ©Ÿ
                    if (this.endgamesAllData.length > 0) {
                        const randomIndex = Math.floor(Math.random() * this.endgamesAllData.length);
                        const item = this.endgamesAllData[randomIndex];
                        return {
                            id: randomIndex,
                            name: item.type || 'æœªçŸ¥é¡å‹',
                            fen: item.fen,
                            description: `ç´…æ–¹: ${item.materialValue?.redValue || 0}, é»‘æ–¹: ${item.materialValue?.blackValue || 0}`,
                            category: item.type || 'å…¶ä»–',
                            difficulty: '-',
                            bestMove: item.bestMove
                        };
                    } else {
                        const data = this.endgamesData;
                        if (data.length === 0) return null;
                        return data[Math.floor(Math.random() * data.length)];
                    }
                }
            }
        }


        // ğŸ”§ ä¿®æ”¹ ChessPositionTrainer çš„ applyPositionToBoard æ–¹æ³•
// åœ¨ä½ çš„ ChessPositionTrainer é¡ä¸­æ‰¾åˆ°é€™å€‹æ–¹æ³•ä¸¦ä¿®æ”¹ï¼š

        applyPositionToBoard(position) {
            if (!position || !position.fen) {
                console.error('âŒ ç„¡æ•ˆçš„å±€é¢è³‡æ–™');
                return false;
            }

            try {
                const parsed = this.parseFEN(position.fen);
                if (!parsed) {
                    throw new Error('FEN è§£æå¤±æ•—');
                }

                const boardContainer = this.findBoardContainer();
                if (!boardContainer) {
                    throw new Error('æ‰¾ä¸åˆ°æ£‹ç›¤å®¹å™¨');
                }

                if (typeof gameState === 'undefined') {
                    window.gameState = {};
                }

                // âœ… é—œéµä¿®æ”¹ï¼šä¿å­˜åˆå§‹å±€é¢
                gameState.initialBoard = JSON.parse(JSON.stringify(parsed.board));
                gameState.initialTurn = parsed.currentPlayer;

                gameState.board = JSON.parse(JSON.stringify(parsed.board));
                gameState.currentTurn = parsed.currentPlayer;
                gameState.gameRecord = [];
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.gameOver = false;
                gameState.checkStatus = null;

                // æ¸…ç©º HistoryManager
                if (historyManager) {
                    historyManager.clear();
                }

                this.intelligentRender(boardContainer);

                if (typeof updateMoveDisplay === 'function') {
                    updateMoveDisplay();
                }

                // âœ… ä¿å­˜åˆå§‹ç‹€æ…‹
                if (typeof saveToHistory === 'function') {
                    saveToHistory();
                }

                console.log('âœ… åˆå§‹å±€é¢å·²ä¿å­˜:', gameState.initialBoard);
                return true;
            } catch (error) {
                console.error('âŒ æ‡‰ç”¨å¤±æ•—:', error);
                return false;
            }
        }


        findBoardContainer() {
            const selectors = ['#chess-board', '#gameBoard', '#board', '.board'];
            for (const selector of selectors) {
                const element = document.querySelector(selector);
                if (element) return element;
            }
            return null;
        }

        intelligentRender(container) {
            if (typeof window.renderBoard === 'function') {
                try {
                    window.renderBoard();
                    return;
                } catch (error) {
                    console.log('ä½¿ç”¨å‚™ç”¨æ¸²æŸ“');
                }
            }

            if (container && window.gameState?.board) {
                this.updateExistingBoard(container);
            }
        }

        updateExistingBoard(container) {
            const cells = container.querySelectorAll('[data-row][data-col]');

            cells.forEach(cell => {
                const pieces = cell.querySelectorAll('.piece, .chess-piece');
                pieces.forEach(piece => piece.remove());
            });

            window.gameState.board.forEach((row, rowIndex) => {
                row.forEach((piece, colIndex) => {
                    if (piece) {
                        const cell = container.querySelector(`[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                        if (cell) {
                            cell.appendChild(this.createPieceElement(piece));
                        }
                    }
                });
            });
        }

        createPieceElement(piece) {
            const pieceElement = document.createElement('div');
            pieceElement.className = 'chess-piece piece';
            pieceElement.textContent = piece.type;
            const isRed = piece.color === 'red';
            pieceElement.style.cssText = `
            width: 35px; height: 35px; border-radius: 50%;
            background: ${isRed ? 'linear-gradient(145deg, #ff4757, #ff3742)' : 'linear-gradient(145deg, #2f3542, #40739e)'};
            color: white; display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            cursor: pointer; border: 2px solid white;
        `;
            return pieceElement;
        }
    }

    // ====================================
    // UI ä»‹é¢
    // ====================================

    function createPositionTrainerUI() {
        const trainer = new ChessPositionTrainer();

        // å‰µå»ºä¸»å®¹å™¨
        const container = document.createElement('div');
        container.id = 'position-trainer-dialog';
        container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Microsoft JhengHei', sans-serif;
    `;

        const dialogContent = document.createElement('div');
        dialogContent.style.cssText = `
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        max-width: 900px;
        width: 95%;
        max-height: 90vh;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    `;

        // æ¨™é¡Œå€
        const header = document.createElement('div');
        header.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        border-radius: 12px 12px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    `;

        const title = document.createElement('h2');
        title.textContent = 'â™Ÿï¸ é–‹å±€/æ®˜å±€æ¨æ¼”ç³»çµ±';
        title.style.cssText = `
        margin: 0;
        font-size: 24px;
        font-weight: bold;
    `;

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Ã—';
        closeBtn.style.cssText = `
    background: rgba(255, 255, 255, 0.2);
    border: none;
    color: white;
    font-size: 32px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    margin: 0;
    line-height: 0;
    font-family: Arial, sans-serif;
    flex-shrink: 0;
`;
        closeBtn.onmouseover = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
        closeBtn.onmouseout = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
        closeBtn.onclick = () => document.body.removeChild(container);

        header.appendChild(title);
        header.appendChild(closeBtn);

        // ä¸»å…§å®¹å€
        const mainContent = document.createElement('div');
        mainContent.style.cssText = `
        padding: 30px;
    `;

        // æ¨¡å¼é¸æ“‡å€
        const modeSelection = document.createElement('div');
        modeSelection.style.cssText = `
        display: flex;
        gap: 15px;
        margin-bottom: 25px;
        justify-content: center;
    `;

        function createModeButton(text, mode, icon) {
            const btn = document.createElement('button');
            btn.innerHTML = `${icon} ${text}`;
            btn.style.cssText = `
        flex: 1;
        padding: 18px 30px;
        font-size: 18px;
        font-weight: bold;
        border: 3px solid #e0e0e0;
        border-radius: 10px;
        cursor: pointer;
        background: white;
        color: #666;
        transition: all 0.3s;
        max-width: 250px;
    `;

            btn.onmouseover = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                }
            };

            btn.onmouseout = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = 'none';
                }
            };

            btn.onclick = () => {
                document.querySelectorAll('.mode-button').forEach(b => {
                    b.classList.remove('active');
                    b.style.background = 'white';
                    b.style.color = '#666';
                    b.style.borderColor = '#e0e0e0';
                    b.style.transform = 'none';
                });

                btn.classList.add('active');
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                btn.style.color = 'white';
                btn.style.borderColor = '#667eea';
                btn.style.transform = 'translateY(-2px)';
                btn.style.boxShadow = '0 6px 20px rgba(102, 126, 234, 0.4)';

                trainer.currentMode = mode;

                // ğŸ†• æ ¹æ“šæ¨¡å¼é¡¯ç¤º/éš±è—é¡å‹é¸æ“‡å€
                if (mode === 'endgame') {
                    endgameTypeSelection.style.display = 'flex';
                    openingTypeSelection.style.display = 'none'; // ğŸ†• éš±è—é–‹å±€é¡å‹
                    trainer.currentOpeningType = null; // ğŸ†• æ¸…ç©ºé–‹å±€é¡å‹
                    trainer.loadChessPatternsFromFolder();
                    // æ¸…é™¤é–‹å±€é¡å‹æŒ‰éˆ•é¸æ“‡
                    document.querySelectorAll('.opening-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                    });
                    // æ¸…é™¤æ®˜å±€é¡å‹æŒ‰éˆ•é¸æ“‡
                    document.querySelectorAll('.endgame-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                    });
                } else if (mode === 'opening') {
                    openingTypeSelection.style.display = 'flex'; // ğŸ†• é¡¯ç¤ºé–‹å±€é¡å‹
                    endgameTypeSelection.style.display = 'none';
                    trainer.currentEndgameType = null;
                    // æ¸…é™¤é–‹å±€é¡å‹æŒ‰éˆ•é¸æ“‡
                    document.querySelectorAll('.opening-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                    });
                    // æ¸…é™¤æ®˜å±€é¡å‹æŒ‰éˆ•é¸æ“‡
                    document.querySelectorAll('.endgame-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                    });
                } else {
                    endgameTypeSelection.style.display = 'none';
                    openingTypeSelection.style.display = 'none'; // ğŸ†• éš±è—é–‹å±€é¡å‹
                    trainer.currentEndgameType = null;
                    trainer.currentOpeningType = null; // ğŸ†• æ¸…ç©ºé–‹å±€é¡å‹
                }

                showPositionList(mode);
            };

            btn.classList.add('mode-button');
            return btn;
        }

        const openingBtn = createModeButton('é–‹å±€æ¨æ¼”', 'opening', 'ğŸ¯');
        const endgameBtn = createModeButton('æ®˜å±€ç·´ç¿’', 'endgame', 'ğŸ†');

        modeSelection.appendChild(openingBtn);
        modeSelection.appendChild(endgameBtn);

        // ğŸ†• æ®˜å±€é¡å‹é¸æ“‡å€ï¼ˆåˆå§‹éš±è—ï¼‰
        const endgameTypeSelection = document.createElement('div');
        endgameTypeSelection.id = 'endgame-type-selection';
        endgameTypeSelection.style.cssText = `
        display: none;
        gap: 10px;
        margin-bottom: 20px;
        padding: 15px;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        border-radius: 10px;
        flex-wrap: wrap;
        justify-content: center;
    `;

        const endgameTypeTitle = document.createElement('div');
        endgameTypeTitle.style.cssText = `
        width: 100%;
        text-align: center;
        font-weight: bold;
        color: #333;
        margin-bottom: 10px;
        font-size: 16px;
    `;
        endgameTypeTitle.textContent = 'ğŸ¯ é¸æ“‡æ®˜å±€é¡å‹ï¼ˆå¯é¸ï¼Œä¸é¸å‰‡å¾å…¨éƒ¨ 7300 é¡Œéš¨æ©Ÿï¼‰';

        function createEndgameTypeButton(text, type) {
            const btn = document.createElement('button');
            btn.innerHTML = text;  // â† ç”¨ innerHTML æ”¯æ´ HTML æ¨™ç±¤
            btn.style.cssText = `
        padding: 12px 20px;
        font-size: 14px;
        font-weight: bold;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        background: white;
        color: #666;
        transition: all 0.2s;
        line-height: 1.4;
    `;

            btn.onmouseover = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'translateY(-1px)';
                    btn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                }
            };

            btn.onmouseout = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = 'none';
                }
            };

            btn.onclick = () => {
                // å…è¨±å–æ¶ˆé¸æ“‡
                if (btn.classList.contains('active')) {
                    btn.classList.remove('active');
                    btn.style.background = 'white';
                    btn.style.color = '#666';
                    btn.style.borderColor = '#e0e0e0';
                    btn.style.transform = 'none';
                    trainer.currentEndgameType = null;
                } else {
                    // æ¸…é™¤å…¶ä»–æŒ‰éˆ•
                    document.querySelectorAll('.endgame-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                        b.style.transform = 'none';
                    });

                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                    btn.style.color = 'white';
                    btn.style.borderColor = '#f093fb';
                    btn.style.transform = 'translateY(-1px)';
                    btn.style.boxShadow = '0 4px 12px rgba(240, 147, 251, 0.4)';

                    trainer.currentEndgameType = type;
                }

                // è‡ªå‹•é¡¯ç¤ºçµæœï¼ˆæ”¹æˆ asyncï¼‰
                trainer.searchPositions('', 'endgame').then(results => {
                    displayResults(results);
                });
            };

            btn.classList.add('endgame-type-button');
            return btn;
        }

        // ğŸ†• é–‹å±€é¡å‹é¸æ“‡å€ï¼ˆåˆå§‹éš±è—ï¼‰
        const openingTypeSelection = document.createElement('div');
        openingTypeSelection.id = 'opening-type-selection';
        openingTypeSelection.style.cssText = `
    display: none;
    gap: 10px;
    margin-bottom: 20px;
    padding: 15px;
    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    border-radius: 10px;
    flex-wrap: wrap;
    justify-content: center;
`;

        const openingTypeTitle = document.createElement('div');
        openingTypeTitle.style.cssText = `
    width: 100%;
    text-align: center;
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
    font-size: 16px;
`;
        openingTypeTitle.textContent = 'ğŸ¯ é¸æ“‡é–‹å±€é¡å‹ï¼ˆå¯é¸ï¼‰';

        function createOpeningTypeButton(text, type) {
            const btn = document.createElement('button');
            btn.innerHTML = text;  // â† ç”¨ innerHTML æ”¯æ´ HTML æ¨™ç±¤
            btn.style.cssText = `
        padding: 12px 20px;
        font-size: 14px;
        font-weight: bold;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        background: white;
        color: #666;
        transition: all 0.2s;
        line-height: 1.4;
    `;

            btn.onmouseover = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'translateY(-1px)';
                    btn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                }
            };

            btn.onmouseout = () => {
                if (!btn.classList.contains('active')) {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = 'none';
                }
            };

            btn.onclick = () => {
                // å…è¨±å–æ¶ˆé¸æ“‡
                if (btn.classList.contains('active')) {
                    btn.classList.remove('active');
                    btn.style.background = 'white';
                    btn.style.color = '#666';
                    btn.style.borderColor = '#e0e0e0';
                    btn.style.transform = 'none';
                    trainer.currentOpeningType = null;
                } else {
                    // æ¸…é™¤å…¶ä»–æŒ‰éˆ•
                    document.querySelectorAll('.opening-type-button').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'white';
                        b.style.color = '#666';
                        b.style.borderColor = '#e0e0e0';
                        b.style.transform = 'none';
                    });

                    btn.classList.add('active');
                    btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    btn.style.color = 'white';
                    btn.style.borderColor = '#667eea';
                    btn.style.transform = 'translateY(-1px)';
                    btn.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';

                    trainer.currentOpeningType = type;
                }

                // è‡ªå‹•é¡¯ç¤ºçµæœ
                trainer.searchPositions('', 'opening').then(results => {
                    displayResults(results);
                });
            };

            btn.classList.add('opening-type-button');
            return btn;
        }

        openingTypeSelection.appendChild(openingTypeTitle);
        openingTypeSelection.appendChild(createOpeningTypeButton('ğŸ“š é–‹å±€é¡Œåº«<br><small style="font-size: 11px; opacity: 0.8;">264 é¡Œ</small>', 'é–‹å±€é¡Œåº«'));



        endgameTypeSelection.appendChild(endgameTypeTitle);
        endgameTypeSelection.appendChild(createEndgameTypeButton('ğŸ“š è±¡æ£‹å®šå¼<br><small style="font-size: 11px; opacity: 0.8;">199 é¡Œ</small>', 'è±¡æ£‹å®šå¼'));
        endgameTypeSelection.appendChild(createEndgameTypeButton('ğŸ­ æ±Ÿæ¹–æ®˜å±€<br><small style="font-size: 11px; opacity: 0.8;">366 é¡Œ</small>', 'æ±Ÿæ¹–æ®˜å±€'));
        endgameTypeSelection.appendChild(createEndgameTypeButton('ğŸ§© ç–‘é›£é›œç—‡<br><small style="font-size: 11px; opacity: 0.8;">183 é¡Œ</small>', 'ç–‘é›£é›œç—‡'));
        endgameTypeSelection.appendChild(createEndgameTypeButton('âš”ï¸ åŸºæœ¬æ®ºæ³•<br><small style="font-size: 11px; opacity: 0.8;">640 é¡Œ</small>', 'åŸºæœ¬æ®ºæ³•'));
        endgameTypeSelection.appendChild(createEndgameTypeButton('ğŸ“œ å¤å±€ç·´ç¿’<br><small style="font-size: 11px; opacity: 0.8;">695 é¡Œ</small>', 'å¤å±€ç·´ç¿’'));
        endgameTypeSelection.appendChild(createEndgameTypeButton('ğŸ“‚ è‡ªè¨‚é¡Œåº«', 'è‡ªè¨‚é¡Œåº«'));


        // åŠŸèƒ½æŒ‰éˆ•å€
        const functionButtons = document.createElement('div');
        functionButtons.style.cssText = `
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    `;

        // æœå°‹æ¬„
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = `
        flex: 1;
        min-width: 250px;
        display: flex;
        gap: 10px;
    `;

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'æœå°‹å±€é¢åç¨±ã€æè¿°æˆ–åˆ†é¡...';
        searchInput.style.cssText = `
        flex: 1;
        padding: 12px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.2s;
    `;
        searchInput.onfocus = () => searchInput.style.borderColor = '#667eea';
        searchInput.onblur = () => searchInput.style.borderColor = '#e0e0e0';

        const searchBtn = document.createElement('button');
        searchBtn.textContent = 'ğŸ” æœå°‹';
        searchBtn.style.cssText = `
    padding: 12px 20px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
`;
        searchBtn.onmouseover = () => {
            searchBtn.style.background = '#5568d3';
            searchBtn.style.transform = 'translateY(-1px)';
        };
        searchBtn.onmouseout = () => {
            searchBtn.style.background = '#667eea';
            searchBtn.style.transform = 'none';
        };
        searchBtn.onclick = async () => {
            if (trainer.currentMode) {
                const results = await trainer.searchPositions(searchInput.value, trainer.currentMode);
                displayResults(results);
            }
        };

        searchInput.onkeypress = (e) => {
            if (e.key === 'Enter') searchBtn.click();
        };


        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(searchBtn);

        // éš¨æ©ŸæŒ‰éˆ•
        const randomBtn = document.createElement('button');
        randomBtn.textContent = 'ğŸ² éš¨æ©Ÿå±€é¢';
        randomBtn.style.cssText = `
        padding: 12px 20px;
        background: #f093fb;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.2s;
    `;
        randomBtn.onmouseover = () => {
            randomBtn.style.background = '#e082ea';
            randomBtn.style.transform = 'translateY(-1px)';
        };
        randomBtn.onmouseout = () => {
            randomBtn.style.background = '#f093fb';
            randomBtn.style.transform = 'none';
        };
        randomBtn.onclick = async () => {
            if (trainer.currentMode) {
                const position = await trainer.getRandomPosition(trainer.currentMode);
                if (position) {
                    displayResults([position]);
                }
            }
        };

        functionButtons.appendChild(searchContainer);
        functionButtons.appendChild(randomBtn);

        // ğŸ†• ç®¡ç†è‡ªè¨‚é¡Œåº«æŒ‰éˆ•ï¼ˆç¨ç«‹æ–¼é¡å‹é¸æ“‡ï¼‰
        const manageCustomBtn = document.createElement('button');
        manageCustomBtn.textContent = 'ğŸ“‚ ç®¡ç†é¡Œåº«';
        manageCustomBtn.style.cssText = `
    padding: 12px 20px;
    background: #11998e;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
`;
        manageCustomBtn.onmouseover = () => {
            manageCustomBtn.style.background = '#0d7f72';
            manageCustomBtn.style.transform = 'translateY(-1px)';
        };
        manageCustomBtn.onmouseout = () => {
            manageCustomBtn.style.background = '#11998e';
            manageCustomBtn.style.transform = 'none';
        };
        manageCustomBtn.onclick = () => {
            showUploadDialogForCustom();
        };

        functionButtons.appendChild(manageCustomBtn); // ğŸ†• æ–°å¢é€™è¡Œ

// ğŸ†• èªªæ˜æŒ‰éˆ•
        const helpBtn = document.createElement('button');
        helpBtn.textContent = 'ğŸ“– ä½¿ç”¨èªªæ˜';
        helpBtn.style.cssText = `
    padding: 12px 20px;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s;
`;
        helpBtn.onmouseover = () => {
            helpBtn.style.background = 'linear-gradient(135deg, #e082ea 0%, #e4465b 100%)';
            helpBtn.style.transform = 'translateY(-1px)';
        };
        helpBtn.onmouseout = () => {
            helpBtn.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
            helpBtn.style.transform = 'none';
        };
        helpBtn.onclick = () => {
            showHelpDialog();
        };

        functionButtons.appendChild(helpBtn);

        // ğŸ†• è‡ªè¨‚ FEN è¼¸å…¥å€
        const customFENSection = document.createElement('div');
        customFENSection.style.cssText = `
        margin: 20px 0;
        padding: 20px;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        border-radius: 10px;
        border: 2px solid #667eea;
    `;

        const fenTitle = document.createElement('div');
        fenTitle.style.cssText = `
        font-weight: bold;
        color: #333;
        margin-bottom: 12px;
        font-size: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    `;
        fenTitle.innerHTML = 'ğŸ¯ è‡ªè¨‚ FEN ç¢¼';

        const fenDescription = document.createElement('div');
        fenDescription.style.cssText = `
        font-size: 13px;
        color: #666;
        margin-bottom: 12px;
        line-height: 1.6;
    `;
        fenDescription.innerHTML = `
        è¼¸å…¥å®Œæ•´çš„ FEN ç¢¼ä¾†è¼‰å…¥è‡ªè¨‚å±€é¢<br>
        <span style="color: #999;">æ ¼å¼ç¯„ä¾‹: rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1</span>
    `;

        // ğŸ”¥ æ–°å¢ï¼šCtrl+V æç¤º
        const fenPasteHint = document.createElement('div');
        fenPasteHint.style.cssText = `
    background: white;
    border: 2px dashed #667eea;
    border-radius: 6px;
    padding: 10px 14px;
    margin-bottom: 12px;
    text-align: center;
`;
        fenPasteHint.innerHTML = `
    <span style="font-size: 14px; color: #667eea; font-weight: bold;">
        âŒ¨ï¸ æŒ‰ Ctrl+V è²¼ä¸Š FEN ç¢¼
    </span>
`;

        const fenInputContainer = document.createElement('div');
        fenInputContainer.style.cssText = `
        display: flex;
        gap: 10px;
        align-items: stretch;
    `;

        const fenInput = document.createElement('textarea');
        fenInput.placeholder = 'è«‹è¼¸å…¥ FEN ç¢¼... (è‡³å°‘éœ€è¦åŒ…å«æ£‹ç›¤å’Œç•¶å‰ç©å®¶ï¼Œå¦‚: ... w æˆ– ... b)';
        fenInput.rows = 3;
        fenInput.style.cssText = `
        flex: 1;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 13px;
        font-family: 'Courier New', monospace;
        resize: vertical;
        transition: all 0.2s;
    `;
        fenInput.onfocus = () => {
            fenInput.style.borderColor = '#667eea';
            fenInput.style.background = '#fff';
        };
        fenInput.onblur = () => {
            fenInput.style.borderColor = '#e0e0e0';
            fenInput.style.background = '#f8f9fa';
        };

        const fenApplyBtn = document.createElement('button');
        fenApplyBtn.innerHTML = 'âœ…<br>æ‡‰ç”¨<br>åˆ°æ£‹ç›¤';
        fenApplyBtn.style.cssText = `
        padding: 12px 20px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        font-size: 13px;
        line-height: 1.4;
        transition: all 0.2s;
        min-width: 80px;
        box-shadow: 0 2px 8px rgba(17, 153, 142, 0.3);
    `;
        fenApplyBtn.onmouseover = () => {
            fenApplyBtn.style.background = 'linear-gradient(135deg, #0d7f72 0%, #2dd165 100%)';
            fenApplyBtn.style.transform = 'translateY(-2px)';
            fenApplyBtn.style.boxShadow = '0 4px 12px rgba(17, 153, 142, 0.4)';
        };
        fenApplyBtn.onmouseout = () => {
            fenApplyBtn.style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
            fenApplyBtn.style.transform = 'none';
            fenApplyBtn.style.boxShadow = '0 2px 8px rgba(17, 153, 142, 0.3)';
        };

        fenApplyBtn.onclick = () => {
            const fenCode = fenInput.value.trim();

            if (!fenCode) {
                showErrorDialog('è«‹è¼¸å…¥ FEN ç¢¼');
                return;
            }

            // é©—è­‰ FEN
            const validation = trainer.validateFEN(fenCode);
            if (!validation.valid) {
                showErrorDialog(`FEN ç¢¼éŒ¯èª¤ï¼š${validation.error}`);
                return;
            }

            // ğŸ”¥ è§£æ FEN ç¢¼çš„æ£‹ç›¤éƒ¨åˆ†
            const fenParts = fenCode.split(' ');
            const boardPart = fenParts[0];
            const rows = boardPart.split('/');

            // ğŸ”¥ æª¢æŸ¥å° k (é»‘å°‡) åœ¨ç¬¬å¹¾åˆ—
            const topHalf = rows.slice(0, 5).join('');
            const bottomHalf = rows.slice(5, 10).join('');

            const blackKingInTop = /k/.test(topHalf);    // å°kåœ¨ä¸Š = é»‘ä¸Šç´…ä¸‹
            const blackKingInBottom = /k/.test(bottomHalf); // å°kåœ¨ä¸‹ = ç´…ä¸Šé»‘ä¸‹

            if (!blackKingInTop && !blackKingInBottom) {
                showErrorDialog('FEN ç¢¼ä¸­æ‰¾ä¸åˆ°é»‘å°‡ (k)');
                return;
            }

            console.log('ğŸ” FEN ç¢¼é»‘å°‡ä½ç½®:', blackKingInTop ? 'ä¸ŠåŠéƒ¨(1-5åˆ—)' : 'ä¸‹åŠéƒ¨(6-10åˆ—)');

            // ğŸ”¥ æª¢æŸ¥ä¸»æ£‹ç›¤ç•¶å‰è¦–è§’
            const currentFlipState = (typeof gameState !== 'undefined' && gameState.isFlipped) || false;
            const mainBoardIsBlackTop = !currentFlipState; // isFlipped=false ä»£è¡¨é»‘ä¸Šç´…ä¸‹

            console.log('ğŸ” ä¸»æ£‹ç›¤ç•¶å‰è¦–è§’:', mainBoardIsBlackTop ? 'é»‘ä¸Šç´…ä¸‹' : 'ç´…ä¸Šé»‘ä¸‹');

            // ğŸ”¥ åˆ¤æ–·æ˜¯å¦éœ€è¦è©¢å•
            const fenIsBlackTop = blackKingInTop;
            const needAsk = (fenIsBlackTop !== mainBoardIsBlackTop);

            console.log('ğŸ¤” FEN è¦–è§’:', fenIsBlackTop ? 'é»‘ä¸Šç´…ä¸‹' : 'ç´…ä¸Šé»‘ä¸‹');
            console.log('ğŸ¤” æ˜¯å¦éœ€è¦è©¢å•:', needAsk);

            // å‰µå»ºè‡¨æ™‚å±€é¢ç‰©ä»¶
            const customPosition = {
                name: 'è‡ªè¨‚å±€é¢',
                fen: fenCode,
                description: 'ç”¨æˆ¶è‡ªè¨‚çš„ FEN å±€é¢',
                category: 'è‡ªè¨‚',
                difficulty: '-'
            };

            if (!needAsk) {
                // âœ… è¦–è§’ä¸€è‡´ï¼Œç›´æ¥å°å…¥
                console.log('âœ… è¦–è§’ä¸€è‡´ï¼Œç›´æ¥å°å…¥');

                const success = applyFENToMainBoard(
                    fenCode,
                    fenIsBlackTop,
                    mainBoardIsBlackTop
                );

                if (success) {
                    showSuccessMessage('âœ… è‡ªè¨‚ FEN ç¢¼å·²æˆåŠŸæ‡‰ç”¨åˆ°æ£‹ç›¤ï¼è¦–è§’èˆ‡åŸæ£‹ç›¤ä¸€è‡´');
                    fenInput.value = '';
                } else {
                    showErrorDialog('æ‡‰ç”¨å¤±æ•—ï¼Œè«‹ç¢ºèªæ£‹ç›¤å·²æ­£ç¢ºè¼‰å…¥');
                }

            } else {
                // â“ è¦–è§’ä¸ä¸€è‡´ï¼Œè©¢å•ç”¨æˆ¶
                showFENOrientationChoice(customPosition, fenIsBlackTop, mainBoardIsBlackTop, fenInput);
            }
        };

// ğŸ”¥ é¡¯ç¤º FEN è¦–è§’é¸æ“‡å°è©±æ¡†
        function showFENOrientationChoice(customPosition, fenIsBlackTop, mainBoardIsBlackTop, fenInput) {
            const dialog = document.createElement('div');
            dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10001;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 12px;
        max-width: 500px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

            // æ ¹æ“š FEN æ±ºå®šæ–‡å­—æè¿°
            const fenOrientation = fenIsBlackTop ? 'é»‘å°‡åœ¨ä¸Šæ–¹' : 'ç´…å¸¥åœ¨ä¸Šæ–¹';
            const boardOrientation = mainBoardIsBlackTop ? 'é»‘å°‡åœ¨ä¸Šæ–¹' : 'ç´…å¸¥åœ¨ä¸Šæ–¹';

            dialogContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ¯</div>
            <h3 style="margin: 0 0 10px 0; color: #333;">æª¢æ¸¬åˆ°è¦–è§’ä¸ä¸€è‡´</h3>
            <p style="color: #666; font-size: 14px; line-height: 1.6;">
                FEN ç¢¼èˆ‡ç›®å‰æ£‹ç›¤è¦–è§’ä¸åŒï¼Œè«‹é¸æ“‡æ‚¨åå¥½çš„è¦–è§’
            </p>
        </div>

        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button id="use-fen-orientation-btn" style="
                padding: 15px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102,126,234,0.4);
            ">
                ğŸ“‹ ä½¿ç”¨ FEN ç¢¼çš„è¦–è§’
                <div style="font-size: 11px; opacity: 0.9; margin-top: 5px;">
                   (${fenOrientation})
                </div>
            </button>

            <button id="keep-board-orientation-btn" style="
                padding: 15px;
                background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(245,87,108,0.4);
            ">
                ğŸ® ä¿æŒç›®å‰æ£‹ç›¤è¦–è§’
                <div style="font-size: 11px; opacity: 0.9; margin-top: 5px;">
                   (${boardOrientation})
                </div>
            </button>
        </div>
    `;

            dialog.appendChild(dialogContent);
            document.body.appendChild(dialog);

            const useFenBtn = dialog.querySelector('#use-fen-orientation-btn');
            const keepBoardBtn = dialog.querySelector('#keep-board-orientation-btn');

            // ğŸ“‹ é¸æ“‡ï¼šä½¿ç”¨ FEN è¦–è§’
            useFenBtn.addEventListener('click', () => {
                dialog.remove();

                // ä½¿ç”¨ FEN çš„è¦–è§’
                const success = applyFENToMainBoard(
                    customPosition.fen,
                    fenIsBlackTop,      // FEN çš„è¦–è§’
                    fenIsBlackTop       // ç›®æ¨™è¦–è§’ = FEN è¦–è§’
                );

                if (success) {
                    showSuccessMessage(`âœ… å°å…¥æˆåŠŸï¼å·²ä½¿ç”¨ FEN è¦–è§’ï¼š<strong>${fenOrientation}</strong>`);
                    fenInput.value = '';
                } else {
                    showErrorDialog('æ‡‰ç”¨å¤±æ•—ï¼Œè«‹ç¢ºèªæ£‹ç›¤å·²æ­£ç¢ºè¼‰å…¥');
                }
            });

// ğŸ® é¸æ“‡ï¼šä¿æŒæ£‹ç›¤è¦–è§’
            keepBoardBtn.addEventListener('click', () => {
                dialog.remove();

                // ä¿æŒä¸»æ£‹ç›¤ç•¶å‰è¦–è§’
                const success = applyFENToMainBoard(
                    customPosition.fen,
                    fenIsBlackTop,      // FEN çš„è¦–è§’
                    mainBoardIsBlackTop // ç›®æ¨™è¦–è§’ = ä¸»æ£‹ç›¤è¦–è§’
                );

                if (success) {
                    showSuccessMessage(`âœ… å°å…¥æˆåŠŸï¼å·²ä¿æŒæ£‹ç›¤è¦–è§’ï¼š<strong>${boardOrientation}</strong>`);
                    fenInput.value = '';
                } else {
                    showErrorDialog('æ‡‰ç”¨å¤±æ•—ï¼Œè«‹ç¢ºèªæ£‹ç›¤å·²æ­£ç¢ºè¼‰å…¥');
                }
            });

            // æ»‘é¼ æ‡¸åœæ•ˆæœ
            [useFenBtn, keepBoardBtn].forEach(btn => {
                btn.addEventListener('mouseenter', () => {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.3)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = btn.id === 'use-fen-orientation-btn'
                        ? '0 4px 15px rgba(102,126,234,0.4)'
                        : '0 4px 15px rgba(245,87,108,0.4)';
                });
            });
        }

        // ğŸ”¥ ç¿»è½‰æ£‹ç›¤æ•¸æ“šï¼ˆä¸Šä¸‹ç¿»è½‰ï¼‰
        function flipBoardDataForFEN(board) {
            const flipped = [];
            for (let row = 0; row < 10; row++) {
                flipped[row] = [];
                for (let col = 0; col < 9; col++) {
                    // âœ… åªç¿»è½‰ rowï¼ˆä¸Šä¸‹ï¼‰ï¼Œcol ä¿æŒä¸è®Šï¼ˆå·¦å³ä¸è®Šï¼‰
                    const piece = board[9 - row][col];
                    if (piece) {
                        flipped[row][col] = {
                            type: piece.type,
                            color: piece.color
                        };
                    } else {
                        flipped[row][col] = null;
                    }
                }
            }
            return flipped;
        }

// ğŸ”¥ FEN è½‰æ£‹ç›¤æ•¸æ“š
        function fenToBoard(fen) {
            const pieceMap = {
                'K': 'å¸¥', 'A': 'ä»•', 'B': 'ç›¸', 'N': 'å‚Œ', 'R': 'ä¿¥', 'C': 'ç‚®', 'P': 'å…µ',
                'k': 'å°‡', 'a': 'å£«', 'b': 'è±¡', 'n': 'é¦¬', 'r': 'è»Š', 'c': 'åŒ…', 'p': 'å’'
            };

            const parts = fen.split(' ');
            const rows = parts[0].split('/');
            const board = [];

            for (let i = 0; i < 10; i++) {
                board[i] = [];
                let col = 0;
                for (let char of rows[i]) {
                    if (/\d/.test(char)) {
                        // æ•¸å­—ä»£è¡¨ç©ºæ ¼
                        const emptyCount = parseInt(char);
                        for (let j = 0; j < emptyCount; j++) {
                            board[i][col++] = null;
                        }
                    } else {
                        // æ£‹å­
                        const type = pieceMap[char];
                        const color = /[A-Z]/.test(char) ? 'red' : 'black';
                        board[i][col++] = { type, color };
                    }
                }
            }

            return board;
        }

// ğŸ”¥ æ‡‰ç”¨æ£‹ç›¤åˆ°ä¸»éŠæˆ²ï¼ˆä¿®æ­£ç‰ˆï¼‰
        function applyFENToMainBoard(fen, fenIsBlackTop, targetIsBlackTop) {
            try {
                // å…ˆè§£æ FEN ç‚ºæ£‹ç›¤æ•¸æ“š
                let board = fenToBoard(fen);

                // ğŸ”¥ é—œéµï¼šå…ˆæ¨™æº–åŒ–ç‚ºé»‘ä¸Šç´…ä¸‹
                if (!fenIsBlackTop) {
                    console.log('ğŸ”„ FEN æ˜¯ç´…ä¸Šé»‘ä¸‹ï¼Œå…ˆç¿»è½‰ç‚ºæ¨™æº–é»‘ä¸Šç´…ä¸‹');
                    board = flipBoardDataForFEN(board);
                }

                // ç²å–ç•¶å‰ç©å®¶
                const parts = fen.split(' ');
                const currentPlayer = parts[1] === 'w' ? 'red' : 'black';

                const boardContainer = document.querySelector('#chess-board') ||
                    document.querySelector('#gameBoard') ||
                    document.querySelector('.board');

                if (!boardContainer) {
                    throw new Error('æ‰¾ä¸åˆ°ä¸»æ£‹ç›¤å®¹å™¨');
                }

                // æ·±æ‹·è²æ£‹ç›¤
                const correctBoard = [];
                for (let i = 0; i < 10; i++) {
                    correctBoard[i] = [];
                    for (let j = 0; j < 9; j++) {
                        const piece = board[i][j];
                        correctBoard[i][j] = piece ? { type: piece.type, color: piece.color } : null;
                    }
                }

                if (typeof gameState === 'undefined') {
                    window.gameState = {};
                }

                // è¨­å®šéŠæˆ²ç‹€æ…‹ï¼ˆæ£‹ç›¤æ•¸æ“šç¾åœ¨å·²ç¶“æ˜¯æ¨™æº–é»‘ä¸Šç´…ä¸‹ï¼‰
                gameState.initialBoard = JSON.parse(JSON.stringify(correctBoard));
                gameState.initialTurn = currentPlayer;
                gameState.board = JSON.parse(JSON.stringify(correctBoard));
                gameState.currentTurn = currentPlayer;
                gameState.gameRecord = [];
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.gameOver = false;
                gameState.checkStatus = null;

                // ğŸ”¥ é—œéµï¼šè¨­å®šç›®æ¨™è¦–è§’
                // ç¾åœ¨æ£‹ç›¤æ•¸æ“šæ˜¯æ¨™æº–é»‘ä¸Šç´…ä¸‹ï¼Œæ ¹æ“šç›®æ¨™è¦–è§’æ±ºå®šæ˜¯å¦ç¿»è½‰é¡¯ç¤º
                if (!targetIsBlackTop) {
                    // ç›®æ¨™æ˜¯ç´…ä¸Šé»‘ä¸‹ï¼Œéœ€è¦ç¿»è½‰é¡¯ç¤º
                    if (typeof applyBoardFlip === 'function') {
                        applyBoardFlip(true);
                    } else {
                        gameState.isFlipped = true;
                    }
                } else {
                    // ç›®æ¨™æ˜¯é»‘ä¸Šç´…ä¸‹ï¼Œä¸ç¿»è½‰
                    if (typeof applyBoardFlip === 'function') {
                        applyBoardFlip(false);
                    } else {
                        gameState.isFlipped = false;
                    }
                }

                if (typeof window.renderBoard === 'function') {
                    window.renderBoard();
                }

                console.log('âœ… FEN å·²å°å…¥åˆ°ä¸»æ£‹ç›¤, isFlipped =', gameState.isFlipped);
                return true;

            } catch (error) {
                console.error('æ‡‰ç”¨å¤±æ•—:', error);
                return false;
            }
        }

// ğŸ”¥ æˆåŠŸè¨Šæ¯è¼”åŠ©å‡½æ•¸
        function showSuccessMessage(message) {
            const successMsg = document.createElement('div');
            successMsg.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: #4caf50;
        color: white;
        padding: 15px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 10001;
        font-weight: bold;
    `;
            successMsg.innerHTML = message;
            document.body.appendChild(successMsg);

            setTimeout(() => {
                successMsg.style.transition = 'opacity 0.3s';
                successMsg.style.opacity = '0';
                setTimeout(() => document.body.removeChild(successMsg), 300);
            }, 2000);
        }

        // éŒ¯èª¤å°è©±æ¡†å‡½æ•¸
        function showErrorDialog(message) {
            const errorDialog = document.createElement('div');
            errorDialog.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
        `;

            const errorContent = document.createElement('div');
            errorContent.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        `;

            errorContent.innerHTML = `
            <div style="font-size: 48px; margin-bottom: 15px;">âš ï¸</div>
            <h3 style="margin: 0 0 15px 0; color: #d32f2f; font-size: 20px;">FEN ç¢¼éŒ¯èª¤</h3>
            <p style="color: #666; margin: 0 0 20px 0; line-height: 1.6; font-size: 15px;">${message}</p>
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107; text-align: left;">
                <p style="margin: 0 0 8px 0; font-weight: bold; color: #856404;">ğŸ’¡ æç¤ºï¼š</p>
                <ul style="margin: 0; padding-left: 20px; color: #856404; font-size: 13px; line-height: 1.8;">
                    <li>FEN ç¢¼è‡³å°‘éœ€è¦å…©å€‹éƒ¨åˆ†ï¼šæ£‹ç›¤ + ç•¶å‰ç©å®¶</li>
                    <li>æ£‹ç›¤éƒ¨åˆ†æ‡‰æœ‰ 10 è¡Œï¼Œç”¨ "/" åˆ†éš”</li>
                    <li>æ¯è¡Œæ‡‰æœ‰ 9 åˆ—ï¼ˆæ£‹å­æˆ–æ•¸å­—è¡¨ç¤ºç©ºæ ¼ï¼‰</li>
                    <li>ç•¶å‰ç©å®¶ç”¨ "w" (ç´…æ–¹) æˆ– "b" (é»‘æ–¹)</li>
                    <li>å¿…é ˆåŒ…å«ç´…å¸¥ (K) å’Œé»‘å°‡ (k)</li>
                </ul>
            </div>
            <button id="error-ok-btn" style="
                padding: 12px 30px;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: all 0.2s;
            ">æˆ‘çŸ¥é“äº†</button>
        `;

            const okBtn = errorContent.querySelector('#error-ok-btn');
            okBtn.onmouseover = () => {
                okBtn.style.background = '#5568d3';
                okBtn.style.transform = 'translateY(-1px)';
            };
            okBtn.onmouseout = () => {
                okBtn.style.background = '#667eea';
                okBtn.style.transform = 'none';
            };
            okBtn.onclick = () => {
                document.body.removeChild(errorDialog);
                fenInput.focus();
            };

            errorDialog.appendChild(errorContent);
            document.body.appendChild(errorDialog);

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            errorDialog.onclick = (e) => {
                if (e.target === errorDialog) {
                    document.body.removeChild(errorDialog);
                }
            };
        }

        fenInputContainer.appendChild(fenInput);
        fenInputContainer.appendChild(fenApplyBtn);

        customFENSection.appendChild(fenTitle);
        customFENSection.appendChild(fenDescription);
        customFENSection.appendChild(fenPasteHint);  // ğŸ”¥ æ–°å¢é€™è¡Œ
        customFENSection.appendChild(fenInputContainer);

        // çµæœé¡¯ç¤ºå€
        const resultsContainer = document.createElement('div');
        resultsContainer.id = 'results-container';
        resultsContainer.style.cssText = `
        min-height: 300px;
        max-height: 400px;
        overflow-y: auto;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 10px;
        border: 2px solid #e0e0e0;
    `;

        // é¡¯ç¤ºå±€é¢åˆ—è¡¨
        function showPositionList(mode) {
            const data = mode === 'opening' ? trainer.openingsData : trainer.endgamesData;
            displayResults(data);
        }

        // ğŸ†• è‡ªè¨‚é¡Œåº«ä¸Šå‚³å°è©±æ¡†
        function showUploadDialogForCustom() {
            const uploadDialog = document.createElement('div'); // æ”¹æˆ uploadDialog
            uploadDialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
    `;
            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
        background: white;
        padding: 35px;
        border-radius: 15px;
        max-width: 700px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    `;

            dialogContent.innerHTML = `
        <h2 style="margin: 0 0 20px 0; color: #333; display: flex; align-items: center; gap: 10px;">
            ğŸ“‚ è‡ªè¨‚é¡Œåº«ç®¡ç†
        </h2>

        <div style="background: linear-gradient(135deg, #e8f4f8 0%, #d4e8ed 100%); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #17a2b8;">
            <p style="margin: 0 0 12px 0; font-weight: bold; color: #0c5460;">ğŸ“Œ æª”æ¡ˆæ ¼å¼è¦æ±‚ï¼š</p>
            <ul style="margin: 0; padding-left: 20px; color: #0c5460; font-size: 14px; line-height: 1.8;">
                <li>å¿…é ˆæ˜¯ <strong>JSON æ ¼å¼</strong>ï¼ˆå‰¯æª”å .jsonï¼‰</li>
                <li>æ¯å€‹å±€é¢å¿…é ˆåŒ…å« <strong>"fen"</strong> å’Œ <strong>"name"</strong> æ¬„ä½</li>
                <li>FEN ç¢¼æ ¼å¼ï¼š<code style="background: white; padding: 2px 6px; border-radius: 3px;">æ£‹ç›¤éƒ¨åˆ† w/b - - 0 1</code></li>
                <li>æª”æ¡ˆå¯ä»¥æ”¾åœ¨ <strong>ä»»ä½•ä½ç½®</strong>ï¼Œä¸é™è³‡æ–™å¤¾</li>
            </ul>
        </div>

        <div style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
            <p style="margin: 0 0 8px 0; font-weight: bold; color: #856404;">ğŸ’¡ æ¨™æº–æ ¼å¼ç¯„ä¾‹ï¼š</p>
            <pre style="margin: 0; font-size: 12px; color: #856404; overflow-x: auto; background: white; padding: 10px; border-radius: 5px; max-height: 150px;">[
  {
    "fen": "9/3CkC3/3R1R3/9/9/9/4p4/3p1p3/3p1p3/4K4 w - - 0 1",
    "name": "å››å°‡æ“’ç‹",
    "description": "ç¶“å…¸æ®ºæ³•",
    "result": "ç´…å‹",
    "bestMove": "",
    "difficulty": "ä¸­ç´š"
  },
  {
    "fen": "3k2r2/4PP3/9/8C/9/7cR/9/4B4/3pn4/5K3 b - - 0 1",
    "name": "é»‘æ–¹æ®˜å±€",
    "description": "ç·´ç¿’é¡Œ",
    "result": "é»‘å‹",
    "bestMove": ""
  }
]</pre>
        </div>

        <div style="background: #d4edda; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #28a745;">
            <p style="margin: 0; font-weight: bold; color: #155724;">
                ğŸ“Š ç›®å‰è‡ªè¨‚é¡Œåº«ï¼š<span id="current-count">${trainer.customEndgamesData.length}</span> é¡Œ
            </p>
        </div>

     <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 20px;">
    <input type="file" id="json-file-input" accept=".json" style="display: none;">
    <button id="select-file-btn" style="
        padding: 15px 20px;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 15px;
        font-weight: bold;
        transition: all 0.2s;
        box-shadow: 0 4px 15px rgba(17, 153, 142, 0.3);
    ">
        ğŸ“ é¸æ“‡æª”æ¡ˆ
    </button>
    <button id="open-converter-btn" style="
        padding: 15px 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 15px;
        font-weight: bold;
        transition: all 0.2s;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    ">
        ğŸ”„ FENè½‰æ›å™¨
    </button>
    <button id="clear-custom-btn" style="
        padding: 15px 20px;
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 15px;
        font-weight: bold;
        transition: all 0.2s;
        box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
    ">
        ğŸ—‘ï¸ æ¸…ç©ºé¡Œåº«
    </button>
    </div>
        <div id="upload-status" style="text-align: center; min-height: 30px; font-weight: bold; margin-bottom: 15px;"></div>

        <div style="display: flex; gap: 10px;">
            <button id="upload-close-btn" style="
                flex: 1;
                padding: 12px 25px;
                background: #6c757d;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: all 0.2s;
            ">é—œé–‰</button>
        </div>
    `;

            const fileInput = dialogContent.querySelector('#json-file-input');
            const selectFileBtn = dialogContent.querySelector('#select-file-btn');
            const clearCustomBtn = dialogContent.querySelector('#clear-custom-btn');
            const uploadStatus = dialogContent.querySelector('#upload-status');
            const closeBtn = dialogContent.querySelector('#upload-close-btn');
            const currentCount = dialogContent.querySelector('#current-count');


            // é¸æ“‡æª”æ¡ˆæŒ‰éˆ•
            selectFileBtn.onclick = () => {
                fileInput.click();
            };

            selectFileBtn.onmouseover = () => {
                selectFileBtn.style.transform = 'translateY(-2px)';
                selectFileBtn.style.boxShadow = '0 6px 20px rgba(17, 153, 142, 0.4)';
            };

            selectFileBtn.onmouseout = () => {
                selectFileBtn.style.transform = 'none';
                selectFileBtn.style.boxShadow = '0 4px 15px rgba(17, 153, 142, 0.3)';
            };

            // ğŸ†• FEN è½‰æ›å™¨æŒ‰éˆ•
            const openConverterBtn = dialogContent.querySelector('#open-converter-btn');

            openConverterBtn.onclick = () => {
                openFENConverter();
            };

            openConverterBtn.onmouseover = () => {
                openConverterBtn.style.transform = 'translateY(-2px)';
                openConverterBtn.style.boxShadow = '0 6px 20px rgba(102, 126, 234, 0.4)';
            };

            openConverterBtn.onmouseout = () => {
                openConverterBtn.style.transform = 'none';
                openConverterBtn.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.3)';
            };

            // æ¸…ç©ºé¡Œåº«æŒ‰éˆ•
            clearCustomBtn.onclick = () => {
                if (trainer.customEndgamesData.length === 0) {
                    showNotification('é¡Œåº«å·²ç¶“æ˜¯ç©ºçš„', 'warning');
                    return;
                }

                // ä½¿ç”¨ç¯„ä¾‹
                const count = trainer.customEndgamesData.length;
                showConfirmDialog(
                    `ç¢ºå®šè¦æ¸…ç©ºå…¨éƒ¨ ${count} é¡Œè‡ªè¨‚é¡Œåº«å—?`,
                    () => {
                        // ç¢ºå®šå¾ŒåŸ·è¡Œçš„å‹•ä½œ
                        trainer.customEndgamesData = [];
                        currentCount.textContent = '0';
                        trainer.saveCustomToStorage();
                        showNotification(`å·²æ¸…ç©º ${count} é¡Œ`, 'success');
                    }
                );
            }

            clearCustomBtn.onmouseover = () => {
                clearCustomBtn.style.transform = 'translateY(-2px)';
                clearCustomBtn.style.boxShadow = '0 6px 20px rgba(240, 147, 251, 0.4)';
            };

            clearCustomBtn.onmouseout = () => {
                clearCustomBtn.style.transform = 'none';
                clearCustomBtn.style.boxShadow = '0 4px 15px rgba(240, 147, 251, 0.3)';
            };

            // æª”æ¡ˆé¸æ“‡è™•ç†
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                uploadStatus.innerHTML = `<span style="color: #667eea;">â³ æ­£åœ¨è®€å–æª”æ¡ˆ...</span>`;

                try {
                    const content = await readFileAsText(file);
                    const jsonData = JSON.parse(content);

                    // é©—è­‰æ ¼å¼
                    if (!Array.isArray(jsonData)) {
                        throw new Error('JSON å¿…é ˆæ˜¯é™£åˆ—æ ¼å¼ [...]');
                    }

                    if (jsonData.length === 0) {
                        throw new Error('JSON é™£åˆ—ä¸èƒ½ç‚ºç©º');
                    }

                    let validCount = 0;
                    let invalidCount = 0;
                    const validData = [];

                    for (const item of jsonData) {
                        if (!item.fen || !item.name) {
                            invalidCount++;
                            console.warn('è·³éç¼ºå°‘å¿…è¦æ¬„ä½çš„é …ç›®:', item);
                            continue;
                        }

                        // é©—è­‰ FEN ç¢¼
                        const fenValidation = trainer.validateFEN(item.fen);
                        if (!fenValidation.valid) {
                            invalidCount++;
                            console.warn('è·³éç„¡æ•ˆ FEN ç¢¼:', item.fen, fenValidation.error);
                            continue;
                        }

                        validData.push(item);
                        validCount++;
                    }

                    if (validCount === 0) {
                        throw new Error('æ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å±€é¢è³‡æ–™ï¼Œè«‹æª¢æŸ¥æ ¼å¼');
                    }

                    // åœ¨ä½ çš„ fileInput.onchange å‡½æ•¸ä¸­,æ‰¾åˆ°é€™æ®µ:

// è¿½åŠ åˆ°è‡ªè¨‚é¡Œåº«ï¼ˆä¸è¦†è“‹ï¼‰
                    trainer.customEndgamesData = trainer.customEndgamesData.concat(validData);

// ğŸ†• ç«‹å³æ›´æ–°å°è©±æ¡†å…§çš„é¡Œæ•¸é¡¯ç¤º
                    currentCount.textContent = trainer.customEndgamesData.length;

// ğŸ†• å„²å­˜åˆ° LocalStorage
                    trainer.saveCustomToStorage();

// âŒ ç§»é™¤é€™è¡Œé‡è¤‡çš„æ›´æ–°
// currentCount.textContent = trainer.customEndgamesData.length;

// é¡¯ç¤ºé€šçŸ¥
                    if (invalidCount > 0) {
                        showNotification(`æˆåŠŸæ–°å¢ ${validCount} é¡Œï¼Œè·³é ${invalidCount} é¡Œæ ¼å¼éŒ¯èª¤`, 'warning');
                    } else {
                        showNotification(`æˆåŠŸæ–°å¢ ${validCount} é¡Œï¼`, 'success');
                    }

// è‡ªå‹•åˆ·æ–°çµæœåˆ—è¡¨
                    setTimeout(async () => {
                        const results = await trainer.searchPositions('', 'endgame');
                        displayResults(results);
                    }, 500);

// ğŸ†• å°å…¥æˆåŠŸå¾Œè‡ªå‹•é—œé–‰å°è©±æ¡†ï¼ˆè®“ç”¨æˆ¶å…ˆçœ‹åˆ°æ›´æ–°çš„é¡Œæ•¸å’Œé€šçŸ¥ï¼‰
                    setTimeout(() => {
                        document.body.removeChild(uploadDialog);
                    }, 1000); // å»¶é² 1 ç§’

// æ¸…ç©ºæª”æ¡ˆé¸æ“‡ï¼ˆå…è¨±é‡è¤‡é¸åŒä¸€æª”æ¡ˆï¼‰
                    fileInput.value = '';


                    setTimeout(() => {
                        const dialog = document.getElementById('custom-upload-dialog');
                        if (dialog) {
                            document.body.removeChild(dialog);
                            console.log('å·²é—œé–‰è‡ªè¨‚é¡Œåº«ç®¡ç†å°è©±æ¡†');
                        } else {
                            console.log('æ‰¾ä¸åˆ°å°è©±æ¡†');
                        }
                    }, 1000);

                } catch (error) {
                    uploadStatus.innerHTML = `<span style="color: #dc3545;">âŒ éŒ¯èª¤ï¼š${error.message}</span>`;
                    console.error('ä¸Šå‚³éŒ¯èª¤:', error);
                }
            };

            // é—œé–‰æŒ‰éˆ•
            closeBtn.onclick = () => {
                document.body.removeChild(uploadDialog);
            };

            closeBtn.onmouseover = () => {
                closeBtn.style.background = '#5a6268';
            };

            closeBtn.onmouseout = () => {
                closeBtn.style.background = '#6c757d';
            };

            uploadDialog.appendChild(dialogContent);
            document.body.appendChild(uploadDialog);

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            uploadDialog.onclick = (e) => {
                if (e.target === uploadDialog) {
                    document.body.removeChild(uploadDialog);
                }
            };
        }

// ğŸ†• è®€å–æª”æ¡ˆç‚ºæ–‡å­—
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('æª”æ¡ˆè®€å–å¤±æ•—'));
                reader.readAsText(file, 'UTF-8');
            });
        }

        // ç¢ºèªå°è©±æ¡†å‡½æ•¸
        function showConfirmDialog(message, onConfirm) {
            // å‰µå»ºé®ç½©å±¤
            const overlay = document.createElement('div');
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10003;
    `;

            // å‰µå»ºå°è©±æ¡†å®¹å™¨
            const dialog = document.createElement('div');
            dialog.style.cssText = `
        background: white;
        padding: 32px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        max-width: 400px;
        width: 90%;
    `;

            // å‰µå»ºè¨Šæ¯æ–‡å­—
            const messageEl = document.createElement('div');
            messageEl.textContent = message;
            messageEl.style.cssText = `
        font-size: 18px;
        color: #333;
        margin-bottom: 24px;
        text-align: center;
        line-height: 1.5;
    `;

            // å‰µå»ºæŒ‰éˆ•å®¹å™¨
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
        display: flex;
        gap: 12px;
        justify-content: center;
    `;

            // å–æ¶ˆæŒ‰éˆ•
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'å–æ¶ˆ';
            cancelBtn.style.cssText = `
        padding: 12px 32px;
        font-size: 16px;
        border: 2px solid #ddd;
        background: white;
        color: #666;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
    `;

            cancelBtn.onmouseover = () => {
                cancelBtn.style.background = '#f5f5f5';
                cancelBtn.style.borderColor = '#ccc';
            };

            cancelBtn.onmouseout = () => {
                cancelBtn.style.background = 'white';
                cancelBtn.style.borderColor = '#ddd';
            };

            cancelBtn.onclick = () => {
                overlay.remove();
            };

            // ç¢ºå®šæŒ‰éˆ•
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'ç¢ºå®š';
            confirmBtn.style.cssText = `
        padding: 12px 32px;
        font-size: 16px;
        border: none;
        background: #ef4444;
        color: white;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
    `;

            confirmBtn.onmouseover = () => {
                confirmBtn.style.background = '#dc2626';
            };

            confirmBtn.onmouseout = () => {
                confirmBtn.style.background = '#ef4444';
            };

            confirmBtn.onclick = () => {
                overlay.remove();
                if (onConfirm) onConfirm();
            };

            // çµ„è£å…ƒç´ 
            buttonContainer.appendChild(cancelBtn);
            buttonContainer.appendChild(confirmBtn);
            dialog.appendChild(messageEl);
            dialog.appendChild(buttonContainer);
            overlay.appendChild(dialog);

            // æ·»åŠ åˆ°é é¢
            document.body.appendChild(overlay);

            // é»æ“Šé®ç½©å±¤é—œé–‰
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            };
        }


        // ğŸ†• çµ±ä¸€çš„ç¾è§€æç¤ºæ¡†
        function showBeautifulAlert(title, message, type = 'success') {
            const alertBox = document.createElement('div');
            alertBox.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 35px 40px;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        z-index: 10003;
        min-width: 400px;
        max-width: 500px;
        text-align: center;
        animation: slideIn 0.3s ease-out;
    `;

            // å‹•ç•«
            const style = document.createElement('style');
            style.textContent = `
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
    `;
            document.head.appendChild(style);

            const icons = {
                success: 'âœ…',
                error: 'âŒ',
                warning: 'âš ï¸',
                info: 'â„¹ï¸'
            };

            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#17a2b8'
            };

            alertBox.innerHTML = `
        <div style="font-size: 64px; margin-bottom: 20px;">${icons[type]}</div>
        <h3 style="margin: 0 0 15px 0; color: ${colors[type]}; font-size: 24px;">${title}</h3>
        <p style="color: #666; margin: 0 0 25px 0; font-size: 16px; line-height: 1.6;">${message}</p>
        <button id="alert-ok-btn" style="
            padding: 12px 40px;
            background: ${colors[type]};
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        ">ç¢ºå®š</button>
    `;

            const okBtn = alertBox.querySelector('#alert-ok-btn');
            okBtn.onmouseover = () => {
                okBtn.style.transform = 'translateY(-2px)';
                okBtn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.2)';
            };
            okBtn.onmouseout = () => {
                okBtn.style.transform = 'none';
                okBtn.style.boxShadow = 'none';
            };
            okBtn.onclick = () => {
                document.body.removeChild(alertBox);
            };

            document.body.appendChild(alertBox);

            // 3 ç§’å¾Œè‡ªå‹•é—œé–‰ï¼ˆåƒ…é™ success é¡å‹ï¼‰
            if (type === 'success') {
                setTimeout(() => {
                    if (document.body.contains(alertBox)) {
                        document.body.removeChild(alertBox);
                    }
                }, 3000);
            }
        }

// ğŸ†• ç°¡æ˜“é€šçŸ¥ï¼ˆå³ä¸Šè§’ï¼‰
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');

            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#17a2b8'
            };

            notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${colors[type]};
        color: white;
        padding: 18px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10003;
        font-weight: bold;
        font-size: 15px;
        animation: slideInRight 0.3s ease-out;
        max-width: 400px;
    `;

            const style = document.createElement('style');
            style.textContent = `
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    `;
            document.head.appendChild(style);

            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transition = 'opacity 0.3s';
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // ğŸ†• æ‰“é–‹ FEN è½‰æ›å™¨
        function openFENConverter() {
            const converterWindow = document.createElement('div');
            converterWindow.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10002;
        padding: 20px;
    `;

            const converterContent = document.createElement('div');
            converterContent.style.cssText = `
        background: white;
        border-radius: 20px;
        width: 100%;
        max-width: 1200px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    `;

            converterContent.innerHTML = `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px 30px; border-radius: 20px 20px 0 0; display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1 style="margin: 0 0 8px 0; font-size: 28px;">ğŸ¯ FEN ç¢¼è½‰æ›å™¨</h1>
                <p style="margin: 0; opacity: 0.9; font-size: 14px;">å°‡è±¡æ£‹ FEN ç¢¼è½‰æ›ç‚ºæ¨™æº– JSON æ ¼å¼ï¼ˆæ”¯æ´ç´…æ–¹/é»‘æ–¹å…ˆèµ°ï¼‰</p>
            </div>
            <button id="close-converter-btn" style="
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: white;
                font-size: 32px;
                width: 45px;
                height: 45px;
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.2s;
                line-height: 1;
                display: flex;
                align-items: center;
                justify-content: center;
            ">Ã—</button>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; padding: 30px;">
            <div style="display: flex; flex-direction: column;">
                <h2 style="color: #667eea; margin: 0 0 15px 0; font-size: 20px;">ğŸ“ è¼¸å…¥å€ (æ¯è¡Œæ ¼å¼: FENç¢¼ w/b åç¨±)</h2>
                <textarea id="converter-input" placeholder="ç¯„ä¾‹ï¼š&#10;9/3CkC3/3R1R3/9/9/9/4p4/3p1p3/3p1p3/4K4 w å››å°‡æ“’ç‹ (ç´…æ–¹å…ˆèµ°)&#10;3k2r2/4PP3/9/8C/9/7cR/9/4B4/3pn4/5K3 b é»‘æ–¹æ®˜å±€ (é»‘æ–¹å…ˆèµ°)" style="
                    flex: 1;
                    min-height: 400px;
                    padding: 15px;
                    border: 2px solid #e0e0e0;
                    border-radius: 10px;
                    font-family: 'Consolas', 'Courier New', monospace;
                    font-size: 13px;
                    resize: vertical;
                    transition: border-color 0.3s;
                "></textarea>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="convert-btn" style="
                        flex: 1;
                        padding: 15px 30px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">ğŸ”„ è½‰æ›</button>
                    <button id="clear-input-btn" style="
                        flex: 1;
                        padding: 15px 30px;
                        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                        color: white;
                        border: none;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">ğŸ—‘ï¸ æ¸…ç©ºè¼¸å…¥</button>
                </div>
            </div>

            <div style="display: flex; flex-direction: column;">
                <h2 style="color: #667eea; margin: 0 0 15px 0; font-size: 20px;">ğŸ“¤ è¼¸å‡ºå€ (JSON æ ¼å¼)</h2>
                <textarea id="converter-output" readonly placeholder="è½‰æ›çµæœå°‡é¡¯ç¤ºåœ¨é€™è£¡..." style="
                    flex: 1;
                    min-height: 400px;
                    padding: 15px;
                    border: 2px solid #e0e0e0;
                    border-radius: 10px;
                    font-family: 'Consolas', 'Courier New', monospace;
                    font-size: 13px;
                    resize: vertical;
                    background: #f8f9fa;
                "></textarea>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="copy-output-btn" style="
                        flex: 1;
                        padding: 15px 30px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">ğŸ“‹ è¤‡è£½çµæœ</button>
                    <button id="import-to-custom-btn" style="
                        flex: 1;
                        padding: 15px 30px;
                        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                        color: white;
                        border: none;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">âœ… ç›´æ¥å°å…¥</button>
                </div>
            </div>

            <div id="converter-stats" style="grid-column: 1 / -1; background: #e8f4f8; padding: 15px; border-radius: 10px; text-align: center; color: #333; font-weight: bold; display: none;"></div>

            <div style="grid-column: 1 / -1; background: #f8f9fa; padding: 20px; border-radius: 10px; font-size: 14px; color: #666; line-height: 1.8;">
                <strong style="color: #667eea;">ä½¿ç”¨èªªæ˜ï¼š</strong><br>
                1. åœ¨å·¦å´è¼¸å…¥å€è²¼ä¸Šæˆ–è¼¸å…¥ FEN ç¢¼ï¼Œæ¯è¡Œæ ¼å¼ç‚º: <code>FENç¢¼ w/b åç¨±</code><br>
                2. <strong>w</strong> è¡¨ç¤ºç´…æ–¹å…ˆèµ°ï¼Œ<strong>b</strong> è¡¨ç¤ºé»‘æ–¹å…ˆèµ°<br>
                3. é»æ“Šã€Œè½‰æ›ã€æŒ‰éˆ•ï¼Œå³å´æœƒé¡¯ç¤º JSON æ ¼å¼<br>
                4. é»æ“Šã€Œâœ… ç›´æ¥å°å…¥ã€å¯ç«‹å³åŠ å…¥è‡ªè¨‚é¡Œåº«<br>
                <strong style="color: #667eea;">æ³¨æ„ï¼š</strong>ç³»çµ±æœƒè‡ªå‹•ç‚ºæ¯å€‹æ£‹å±€æ·»åŠ æ™‚é–“æˆ³è¨˜
            </div>
        </div>
    `;

            const closeBtn = converterContent.querySelector('#close-converter-btn');
            const inputArea = converterContent.querySelector('#converter-input');
            const outputArea = converterContent.querySelector('#converter-output');
            const convertBtn = converterContent.querySelector('#convert-btn');
            const clearInputBtn = converterContent.querySelector('#clear-input-btn');
            const copyOutputBtn = converterContent.querySelector('#copy-output-btn');
            const importToCustomBtn = converterContent.querySelector('#import-to-custom-btn');
            const statsDiv = converterContent.querySelector('#converter-stats');

            // é—œé–‰æŒ‰éˆ•
            closeBtn.onclick = () => {
                document.body.removeChild(converterWindow);
            };

            closeBtn.onmouseover = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
            };

            closeBtn.onmouseout = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            };

            // è½‰æ›æŒ‰éˆ•
            convertBtn.onclick = () => {
                const input = inputArea.value;
                if (!input.trim()) {
                    // åŸæœ¬çš„ alert('è«‹å…ˆè¼¸å…¥ FEN ç¢¼ï¼');
                    showBeautifulAlert('æç¤º', 'è«‹å…ˆè¼¸å…¥ FEN ç¢¼ï¼', 'warning');
                    return;
                }

                // æ¸…é™¤ç„¡é—œæ–‡å­—
                let cleanedInput = input
                    .replace(/ä½ å‚³é€äº†/g, '')
                    .replace(/å·²ç·¨è¼¯/g, '')
                    .replace(/é€±[ä¸€äºŒä¸‰å››äº”å…­æ—¥]\s+[ä¸Šä¸‹]åˆ\d{1,2}:\d{2}/g, '')
                    .replace(/[ä¸Šä¸‹]åˆ\d{1,2}:\d{2}/g, '');

                const lines = cleanedInput.trim().split('\n');
                const result = [];
                const baseDate = new Date();
                baseDate.setHours(0, 0, 0, 0);
                let validIndex = 0;
                let redCount = 0;
                let blackCount = 0;

                let pendingFen = null;
                let pendingSide = null;

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    if (!line) continue;

                    const isFenOnly = /^[a-zA-Z0-9\/]+\s+[wb]\s*$/.test(line);

                    if (isFenOnly) {
                        const match = line.match(/^([a-zA-Z0-9\/]+)\s+([wb])\s*$/);
                        if (match) {
                            pendingFen = match[1].trim();
                            pendingSide = match[2];
                        }
                        continue;
                    }

                    const isNameOnly = !/[a-zA-Z0-9\/]+\s+[wb]/.test(line);

                    if (isNameOnly && pendingFen && pendingSide) {
                        const name = line.trim();
                        const timestamp = new Date(baseDate.getTime() + validIndex * 1000);
                        result.push({
                            fen: pendingFen + ' ' + pendingSide + ' - - 0 1',
                            name: name,
                            result: 'egtb:',
                            bestMove: '',
                            timestamp: timestamp.toISOString()
                        });
                        validIndex++;
                        if (pendingSide === 'w') {
                            redCount++;
                        } else {
                            blackCount++;
                        }
                        pendingFen = null;
                        pendingSide = null;
                        continue;
                    }

                    const pattern1 = /^([a-zA-Z0-9\/]+)\s+([wb])\s+(.+)$/;
                    const match1 = line.match(pattern1);

                    if (match1) {
                        const fen = match1[1].trim();
                        const side = match1[2];
                        const name = match1[3].trim();

                        if (fen && name) {
                            const timestamp = new Date(baseDate.getTime() + validIndex * 1000);
                            result.push({
                                fen: fen + ' ' + side + ' - - 0 1',
                                name: name,
                                result: 'egtb:',
                                bestMove: '',
                                timestamp: timestamp.toISOString()
                            });
                            validIndex++;
                            if (side === 'w') {
                                redCount++;
                            } else {
                                blackCount++;
                            }
                        }
                        continue;
                    }

                    const pattern2 = /^([a-zA-Z0-9\/]+)\s+([wb])([^\s].+)$/;
                    const match2 = line.match(pattern2);

                    if (match2) {
                        const fen = match2[1].trim();
                        const side = match2[2];
                        const name = match2[3].trim();

                        if (fen && name) {
                            const timestamp = new Date(baseDate.getTime() + validIndex * 1000);
                            result.push({
                                fen: fen + ' ' + side + ' - - 0 1',
                                name: name,
                                result: 'egtb:',
                                bestMove: '',
                                timestamp: timestamp.toISOString()
                            });
                            validIndex++;
                            if (side === 'w') {
                                redCount++;
                            } else {
                                blackCount++;
                            }
                        }
                    }
                }

                if (result.length === 0) {
                    showBeautifulAlert('æ ¼å¼éŒ¯èª¤', 'æ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ FEN ç¢¼ï¼Œè«‹æª¢æŸ¥æ ¼å¼ï¼', 'error');
                    statsDiv.style.display = 'none';
                    return;
                }

                outputArea.value = JSON.stringify(result, null, 2);
                statsDiv.style.display = 'block';
                statsDiv.innerHTML = `âœ… è½‰æ›æˆåŠŸï¼å…± ${result.length} å€‹æ£‹å±€ | ğŸ”´ ç´…æ–¹å…ˆèµ°: ${redCount} å€‹ | âš« é»‘æ–¹å…ˆèµ°: ${blackCount} å€‹`;
            };

            // æ¸…ç©ºè¼¸å…¥
            clearInputBtn.onclick = () => {
                inputArea.value = '';
            };

            // è¤‡è£½çµæœ
            copyOutputBtn.onclick = () => {
                if (!outputArea.value) {
                    showBeautifulAlert('æç¤º', 'æ²’æœ‰å¯è¤‡è£½çš„å…§å®¹ï¼', 'info');
                    return;
                }
                outputArea.select();
                document.execCommand('copy');
                showNotification('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', 'success');
            };

            // ğŸ†• ç›´æ¥å°å…¥åˆ°è‡ªè¨‚é¡Œåº«
            importToCustomBtn.onclick = () => {
                if (!outputArea.value.trim()) {
                    showBeautifulAlert('æç¤º', 'è«‹å…ˆè½‰æ› FEN ç¢¼ï¼', 'warning');
                    return;
                }

                try {
                    const jsonData = JSON.parse(outputArea.value);

                    if (!Array.isArray(jsonData) || jsonData.length === 0) {
                        showBeautifulAlert('æ ¼å¼éŒ¯èª¤', 'JSON æ ¼å¼éŒ¯èª¤æˆ–ç‚ºç©ºï¼', 'error');
                        return;
                    }

                    let validCount = 0;
                    const validData = [];

                    for (const item of jsonData) {
                        if (item.fen && item.name) {
                            const fenValidation = trainer.validateFEN(item.fen);
                            if (fenValidation.valid) {
                                validData.push(item);
                                validCount++;
                            }
                        }
                    }

                    if (validCount === 0) {
                        showBeautifulAlert('éŒ¯èª¤', 'æ²’æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„å±€é¢è³‡æ–™ï¼', 'error');
                        return;
                    }

                    // è¿½åŠ åˆ°è‡ªè¨‚é¡Œåº«
                    trainer.customEndgamesData = trainer.customEndgamesData.concat(validData);

                    // å„²å­˜åˆ° LocalStorage
                    trainer.saveCustomToStorage();

                    // ğŸ†• æ›´æ–°æª”æ¡ˆç®¡ç†å°è©±æ¡†çš„é¡Œæ•¸é¡¯ç¤º
                    const currentCountInDialog = document.getElementById('current-count');
                    if (currentCountInDialog) {
                        currentCountInDialog.textContent = trainer.customEndgamesData.length;
                    }

                    showBeautifulAlert(
                        'å°å…¥æˆåŠŸ',
                        `å·²æˆåŠŸå°å…¥ ${validCount} é¡Œåˆ°è‡ªè¨‚é¡Œåº«ï¼`,
                        'success'
                    );

                    // å»¶é²é—œé–‰è½‰æ›å™¨
                    setTimeout(() => {
                        if (document.body.contains(converterWindow)) {
                            document.body.removeChild(converterWindow);
                        }
                    }, 1500);

                    // åˆ·æ–°çµæœåˆ—è¡¨
                    trainer.searchPositions('', 'endgame').then(results => {
                        displayResults(results);
                    });

                } catch (error) {
                    showBeautifulAlert('å°å…¥å¤±æ•—', error.message, 'error');
                }
            };

            // æŒ‰éˆ• hover æ•ˆæœ
            [convertBtn, clearInputBtn, copyOutputBtn, importToCustomBtn].forEach(btn => {
                btn.onmouseover = () => {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 5px 20px rgba(0,0,0,0.2)';
                };
                btn.onmouseout = () => {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = 'none';
                };
            });

            // input focus æ•ˆæœ
            inputArea.onfocus = () => {
                inputArea.style.borderColor = '#667eea';
            };
            inputArea.onblur = () => {
                inputArea.style.borderColor = '#e0e0e0';
            };

            converterWindow.appendChild(converterContent);
            document.body.appendChild(converterWindow);

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            converterWindow.onclick = (e) => {
                if (e.target === converterWindow) {
                    document.body.removeChild(converterWindow);
                }
            };
        }


        // é¡¯ç¤ºçµæœ
        function displayResults(positions) {
            resultsContainer.innerHTML = '';

            if (!trainer.currentMode) {
                resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 60px 20px; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 15px;">ğŸ¯</div>
                    <p style="font-size: 18px; margin: 0;">è«‹å…ˆé¸æ“‡é–‹å±€æˆ–æ®˜å±€æ¨¡å¼</p>
                </div>
            `;
                return;
            }

            if (positions.length === 0) {
                resultsContainer.innerHTML = `
                <div style="text-align: center; padding: 60px 20px; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 15px;">ğŸ”</div>
                    <p style="font-size: 18px; margin: 0;">æ²’æœ‰æ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„å±€é¢</p>
                </div>
            `;
                return;
            }

            positions.forEach(pos => {
                const card = document.createElement('div');
                card.style.cssText = `
                background: white;
                padding: 20px;
                margin-bottom: 15px;
                border-radius: 10px;
                border: 2px solid #e0e0e0;
                cursor: pointer;
                transition: all 0.2s;
            `;

                card.onmouseover = () => {
                    card.style.borderColor = '#667eea';
                    card.style.transform = 'translateY(-2px)';
                    card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
                };

                card.onmouseout = () => {
                    card.style.borderColor = '#e0e0e0';
                    card.style.transform = 'none';
                    card.style.boxShadow = 'none';
                };

                card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                    <h3 style="margin: 0; color: #333; font-size: 18px;">${pos.name}</h3>
                    <span style="background: #667eea; color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px; white-space: nowrap;">
                        ${pos.difficulty}
                    </span>
                </div>
                <p style="color: #666; margin: 8px 0; font-size: 14px;">${pos.description || ''}</p>
                <div style="display: flex; gap: 10px; margin-top: 12px;">
                    <span style="background: #f0f0f0; padding: 4px 10px; border-radius: 6px; font-size: 13px; color: #555;">
                        ğŸ“ ${pos.category}
                    </span>
                    <span style="background: #e8f5e9; padding: 4px 10px; border-radius: 6px; font-size: 13px; color: #2e7d32;">
                        ğŸ¯ é»æ“Šé è¦½/æ‡‰ç”¨
                    </span>
                </div>
            `;

                card.onclick = () => showPositionDetail(pos);
                resultsContainer.appendChild(card);
            });
        }

        // é¡¯ç¤ºå±€é¢è©³æƒ…
        function showPositionDetail(position) {
            const detailDialog = document.createElement('div');
            detailDialog.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;

            const detailContent = document.createElement('div');
            detailContent.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;

            detailContent.innerHTML = `
            <h2 style="margin: 0 0 20px 0; color: #333;">${position.name}</h2>
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <p style="margin: 0 0 10px 0;"><strong>åˆ†é¡ï¼š</strong>${position.category}</p>
                <p style="margin: 0 0 10px 0;"><strong>é›£åº¦ï¼š</strong>${position.difficulty}</p>
                <p style="margin: 0;"><strong>èªªæ˜ï¼š</strong>${position.description}</p>
            </div>
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                <p style="margin: 0; color: #856404;"><strong>FENï¼š</strong></p>
                <code style="display: block; margin-top: 8px; word-break: break-all; font-size: 12px; color: #856404;">${position.fen}</code>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="apply-btn" style="
                    flex: 1;
                    padding: 15px 25px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    transition: all 0.2s;
                ">âœ… æ‡‰ç”¨åˆ°æ£‹ç›¤</button>
                <button id="close-detail-btn" style="
                    padding: 15px 25px;
                    background: #6c757d;
                    color: white;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    transition: all 0.2s;
                ">å–æ¶ˆ</button>
            </div>
        `;

            const applyBtn = detailContent.querySelector('#apply-btn');
            const closeDetailBtn = detailContent.querySelector('#close-detail-btn');

            applyBtn.onmouseover = () => {
                applyBtn.style.transform = 'translateY(-2px)';
                applyBtn.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.4)';
            };
            applyBtn.onmouseout = () => {
                applyBtn.style.transform = 'none';
                applyBtn.style.boxShadow = 'none';
            };

            applyBtn.onclick = () => {
                const success = trainer.applyPositionToBoard(position);
                if (success) {
                    // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #4caf50;
                    color: white;
                    padding: 15px 30px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 10001;
                    font-weight: bold;
                `;
                    successMsg.textContent = `âœ… å·²æˆåŠŸæ‡‰ç”¨ã€Œ${position.name}ã€åˆ°æ£‹ç›¤ï¼`;
                    document.body.appendChild(successMsg);

                    setTimeout(() => {
                        successMsg.style.transition = 'opacity 0.3s';
                        successMsg.style.opacity = '0';
                        setTimeout(() => document.body.removeChild(successMsg), 300);
                    }, 2000);

                    // é—œé–‰æ‰€æœ‰å°è©±æ¡†
                    document.body.removeChild(detailDialog);
                    document.body.removeChild(container);
                } else {
                    alert('âŒ æ‡‰ç”¨å¤±æ•—ï¼Œè«‹ç¢ºèªæ£‹ç›¤å·²æ­£ç¢ºè¼‰å…¥');
                }
            };

            closeDetailBtn.onmouseover = () => {
                closeDetailBtn.style.background = '#5a6268';
                closeDetailBtn.style.transform = 'translateY(-1px)';
            };
            closeDetailBtn.onmouseout = () => {
                closeDetailBtn.style.background = '#6c757d';
                closeDetailBtn.style.transform = 'none';
            };

            closeDetailBtn.onclick = () => {
                document.body.removeChild(detailDialog);
            };

            detailDialog.appendChild(detailContent);
            document.body.appendChild(detailDialog);

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            detailDialog.onclick = (e) => {
                if (e.target === detailDialog) {
                    document.body.removeChild(detailDialog);
                }
            };
        }

        // ğŸ†• é¡¯ç¤ºèªªæ˜å°è©±æ¡†
        function showHelpDialog() {
            const helpDialog = document.createElement('div');
            helpDialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        padding: 20px;
        overflow: auto;
    `;

            const helpContent = document.createElement('div');
            helpContent.style.cssText = `
        background: white;
        border-radius: 20px;
        width: 100%;
        max-width: 1000px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    `;

            helpContent.innerHTML = `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px 30px; border-radius: 20px 20px 0 0; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 1;">
            <div>
                <h1 style="margin: 0 0 8px 0; font-size: 28px;">ğŸ“š é–‹å±€/æ®˜å±€æ¨æ¼”ç³»çµ± - ä½¿ç”¨èªªæ˜</h1>
                <p style="margin: 0; opacity: 0.9; font-size: 14px;">å®Œæ•´åŠŸèƒ½ä»‹ç´¹èˆ‡ä½¿ç”¨æŒ‡å—</p>
            </div>
            <button id="close-help-btn" style="
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: white;
                font-size: 32px;
                width: 45px;
                height: 45px;
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.2s;
                line-height: 1;
                display: flex;
                align-items: center;
                justify-content: center;
            ">Ã—</button>
        </div>

        <div style="padding: 30px; line-height: 1.8; color: #333;">
            <!-- ç³»çµ±æ¦‚è¿° -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸ¯ ç³»çµ±æ¦‚è¿°</h2>
                <p style="font-size: 16px;">é€™æ˜¯ä¸€å€‹å°ˆç‚ºè±¡æ£‹æ„›å¥½è€…è¨­è¨ˆçš„å…¨æ–¹ä½è¨“ç·´ç³»çµ±ï¼Œæ•´åˆäº†é–‹å±€æ¨æ¼”ã€æ®˜å±€ç·´ç¿’ã€å¤è­œç ”ç©¶ç­‰å¤šç¨®åŠŸèƒ½ï¼Œæ“æœ‰è¶…é <strong>7300+ é¡Œåº«è³‡æº</strong>ï¼Œæ”¯æ´è‡ªè¨‚é¡Œåº«ç®¡ç†ï¼Œä¸¦æä¾›æ™ºèƒ½ FEN ç¢¼è½‰æ›å·¥å…·ã€‚</p>
            </section>

            <!-- é¡Œåº«ç¸½è¦½ -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸ“Š é¡Œåº«ç¸½è¦½</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">ğŸ“š è±¡æ£‹å®šå¼</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">ç´„ 200 é¡Œ</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">ç¶“å…¸å®šå¼ç³»çµ±åŒ–å­¸ç¿’</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">ğŸ­ æ±Ÿæ¹–æ®˜å±€</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">366 é¡Œ</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">æ¯æ—¥ä¸€é¡Œï¼Œä¸€å¹´å®Œæˆ</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">ğŸ§© ç–‘é›£é›œç—‡</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">183 é¡Œ</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">æ¯2æ—¥ä¸€é¡Œï¼Œä¸€å¹´å®Œæˆ</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">âš”ï¸ åŸºæœ¬æ®ºæ³•</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">åŸºç¤+é€²éš</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">ç³»çµ±åŒ–æ®ºæ³•è¨“ç·´</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">ğŸ“œ å¤å±€ç·´ç¿’</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">é›™è­œåˆé›†</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.9; font-size: 14px;">é©æƒ…é›…è¶£+å¤¢å…¥ç¥æ©Ÿ</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 10px 0;">ğŸ“‚ å…¨å±€é¡Œåº«</h3>
                        <p style="margin: 0; font-size: 24px; font-weight: bold;">7300+ é¡Œ</p>
                        <p style="margin: 10px 0 0 0; opacity: 0.8; font-size: 14px;">æµ·é‡æ®˜å±€ç·´ç¿’</p>
                    </div>
                </div>
            </section>

            <!-- AI ä½¿ç”¨èªªæ˜ -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸ¤– AI å°æˆ°èˆ‡å­¸ç¿’</h2>

                <div style="background: #e8f5e9; padding: 20px; border-radius: 12px; margin-bottom: 20px; border-left: 4px solid #4caf50;">
                    <h3 style="margin: 0 0 15px 0; color: #2e7d32;">âœ… å¯å®Œç¾è§£ç­”çš„é¡Œåº«ï¼ˆæ¨è–¦ä½¿ç”¨æœ€é«˜é›£åº¦ AIï¼‰</h3>
                    <ul style="margin: 0; padding-left: 25px;">
                        <li><strong>è±¡æ£‹å®šå¼ã€æ±Ÿæ¹–æ®˜å±€ã€åŸºæœ¬æ®ºæ³•ã€å¤å±€ç·´ç¿’ã€é–‹å±€é¡Œåº«ã€å…¨å±€é¡Œåº«</strong></li>
                        <li>AI å¯æ­£ç¢ºè§£ç­”ï¼Œé©åˆé©—è­‰å­¸ç¿’æˆæœ</li>
                        <li>å¯ä½¿ç”¨ AI åˆ†æåŠŸèƒ½å­¸ç¿’æœ€ä½³è‘—æ³•</li>
                        <li>å»ºè­°èˆ‡ AI å°å¼ˆï¼Œé›™æ–¹è‘—æ³•éƒ½å¯åƒè€ƒ</li>
                    </ul>
                </div>

                <div style="background: #fff3e0; padding: 20px; border-radius: 12px; border-left: 4px solid #ff9800;">
                    <h3 style="margin: 0 0 15px 0; color: #e65100;">âš ï¸ ç–‘é›£é›œç—‡çš„ç‰¹æ®Šä½¿ç”¨æ–¹å¼</h3>
                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <p style="margin: 0 0 10px 0;"><strong>ğŸ’¡ AI èƒ½åŠ›ç‰¹æ€§ï¼š</strong></p>
                        <ul style="margin: 0; padding-left: 25px;">
                            <li>âœ… <strong>é˜²å®ˆèƒ½åŠ›å„ªç§€</strong>ï¼šAI æœƒä»¥æœ€ä½³è§£é€²è¡Œé˜²å®ˆ</li>
                            <li>âš ï¸ <strong>é€²æ”»èƒ½åŠ›å—é™</strong>ï¼šAI åˆ†æå¯èƒ½ä¸çŸ¥é“å¦‚ä½•é€²æ”»</li>
                            <li>âš ï¸ <strong>åˆ¤å®šå¯èƒ½éŒ¯èª¤</strong>ï¼šAI å¯èƒ½åˆ¤å®šç‚ºå’Œæ£‹ï¼Œä½†å¯¦éš›ç´…æ–¹èƒ½å‹</li>
                        </ul>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px;">
                        <p style="margin: 0 0 10px 0;"><strong>ğŸ¯ æ­£ç¢ºä½¿ç”¨æ–¹å¼ï¼š</strong></p>
                        <p style="margin: 0 0 8px 0; padding: 10px; background: #e8f5e9; border-radius: 6px;">
                            âœ… <strong>æ¨è–¦</strong>ï¼šæ‚¨é€²æ”»ï¼ˆç´…æ–¹ï¼‰+ AI é˜²å®ˆï¼ˆé»‘æ–¹ï¼‰<br>
                            â€¢ AI æœƒçµ¦å‡ºæœ€å¼·é˜²å®ˆï¼Œå¹«æ‚¨é©—è­‰ç ´å±€ä¹‹é“<br>
                            â€¢ åœ¨ AI çš„åš´å¯†é˜²å®ˆä¸­æ‰¾åˆ°çªç ´å£
                        </p>
                        <p style="margin: 0; padding: 10px; background: #ffebee; border-radius: 6px;">
                            âš ï¸ <strong>ä¸æ¨è–¦</strong>ï¼šä½¿ç”¨ AI åˆ†æé€²æ”»è·¯ç·š<br>
                            â€¢ AI å¯èƒ½æ‰¾ä¸åˆ°äººé¡çš„å¦™æ‰‹<br>
                            â€¢ é€²æ”»çš„å‰µæ„éœ€è¦æ‚¨è‡ªå·±ç™¼æ˜
                        </p>
                    </div>
                </div>
            </section>

            <!-- å¿«é€Ÿä¸Šæ‰‹ -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸš€ å¿«é€Ÿä¸Šæ‰‹</h2>
                <div style="background: #f5f7fa; padding: 20px; border-radius: 12px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">åŸºæœ¬æ“ä½œæµç¨‹ï¼š</h3>
                    <ol style="margin: 0; padding-left: 25px; line-height: 2;">
                        <li><strong>é¸æ“‡æ¨¡å¼</strong>ï¼šé»æ“Šã€Œé–‹å±€æ¨æ¼”ã€æˆ–ã€Œæ®˜å±€ç·´ç¿’ã€</li>
                        <li><strong>é¸æ“‡é¡å‹</strong>ï¼ˆå¯é¸ï¼‰ï¼šå¦‚ã€Œæ±Ÿæ¹–æ®˜å±€ã€ã€ã€Œç–‘é›£é›œç—‡ã€ç­‰</li>
                        <li><strong>æœå°‹æˆ–éš¨æ©Ÿ</strong>ï¼šè¼¸å…¥é—œéµå­—æœå°‹ï¼Œæˆ–é»ã€ŒğŸ² éš¨æ©Ÿå±€é¢ã€</li>
                        <li><strong>æŸ¥çœ‹è©³æƒ…</strong>ï¼šé»æ“Šä»»ä½•å±€é¢å¡ç‰‡æŸ¥çœ‹è©³ç´°è³‡è¨Š</li>
                        <li><strong>æ‡‰ç”¨åˆ°æ£‹ç›¤</strong>ï¼šé»ã€Œâœ… æ‡‰ç”¨åˆ°æ£‹ç›¤ã€é–‹å§‹ç·´ç¿’</li>
                        <li><strong>AI å°æˆ°</strong>ï¼šé¸æ“‡æœ€é«˜é›£åº¦ AIï¼Œé–‹å§‹å°å¼ˆå­¸ç¿’</li>
                    </ol>
                </div>
            </section>

            <!-- è‡ªè¨‚é¡Œåº« -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸ“‚ è‡ªè¨‚é¡Œåº«ç®¡ç†</h2>
                <div style="background: #e3f2fd; padding: 20px; border-radius: 12px; margin-bottom: 15px;">
                    <h3 style="margin: 0 0 15px 0; color: #1565c0;">å…©ç¨®å°å…¥æ–¹å¼ï¼š</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <p style="margin: 0 0 10px 0; font-weight: bold;">ğŸ“ æ–¹å¼ä¸€ï¼šä¸Šå‚³ JSON æª”æ¡ˆ</p>
                            <p style="margin: 0; font-size: 14px; color: #666;">é»ã€ŒğŸ“‚ ç®¡ç†é¡Œåº«ã€â†’ã€ŒğŸ“ é¸æ“‡æª”æ¡ˆã€â†’ é¸æ“‡ JSON æª”æ¡ˆ</p>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <p style="margin: 0 0 10px 0; font-weight: bold;">ğŸ”„ æ–¹å¼äºŒï¼šFEN è½‰æ›å™¨</p>
                            <p style="margin: 0; font-size: 14px; color: #666;">é»ã€ŒğŸ“‚ ç®¡ç†é¡Œåº«ã€â†’ã€ŒğŸ”„ FENè½‰æ›å™¨ã€â†’ è²¼ä¸Š FEN ç¢¼è½‰æ›</p>
                        </div>
                    </div>
                </div>
                <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; color: #856404;"><strong>ğŸ’¡ æç¤ºï¼š</strong>è³‡æ–™ä¿å­˜åœ¨ç€è¦½å™¨æœ¬åœ°ï¼Œå»ºè­°å®šæœŸå‚™ä»½ JSON æª”æ¡ˆ</p>
                </div>
            </section>

            <!-- å­¸ç¿’å»ºè­° -->
            <section style="margin-bottom: 40px;">
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">ğŸ“… æ¨è–¦å­¸ç¿’è¨ˆåŠƒ</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 15px 0;">ğŸŒ æ¯æ—¥æŒ‘æˆ°</h3>
                        <ul style="margin: 0; padding-left: 20px; font-size: 14px; line-height: 1.8;">
                            <li>æ±Ÿæ¹–æ®˜å±€ 1 é¡Œï¼ˆ366å¤©ï¼‰</li>
                            <li>åŸºæœ¬æ®ºæ³• 2-3 é¡Œ</li>
                            <li>å®šå¼ç·´ç¿’è‹¥å¹²</li>
                        </ul>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 15px 0;">ğŸ¯ é€²éšæŒ‘æˆ°</h3>
                        <ul style="margin: 0; padding-left: 20px; font-size: 14px; line-height: 1.8;">
                            <li>ç–‘é›£é›œç—‡æ¯2æ—¥1é¡Œï¼ˆ366å¤©ï¼‰</li>
                            <li>èˆ‡ AI å°å¼ˆé©—è­‰</li>
                            <li>å¤å±€å°ˆé¡Œç ”ç©¶</li>
                        </ul>
                    </div>
                    <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 12px;">
                        <h3 style="margin: 0 0 15px 0;">ğŸš€ å¿«é€Ÿæå‡</h3>
                        <ul style="margin: 0; padding-left: 20px; font-size: 14px; line-height: 1.8;">
                            <li>é¸å®šå¼±é …é›†ä¸­ç‰¹è¨“</li>
                            <li>2é€±å®Œæˆ20-30é¡Œ</li>
                            <li>åšç­†è¨˜è¨˜éŒ„å¿ƒå¾—</li>
                        </ul>
                    </div>
                </div>
            </section>

           <!-- æ³¨æ„äº‹é … -->
            <section>
                <h2 style="color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-bottom: 20px;">âš ï¸ é‡è¦æé†’</h2>
                <div style="background: #ffebee; padding: 20px; border-radius: 12px; border-left: 4px solid #f44336;">
                    <ul style="margin: 0; padding-left: 25px; line-height: 2;">
                        <li><strong>ç–‘é›£é›œç—‡</strong>è«‹è®“ AI é˜²å®ˆï¼Œæ‚¨è² è²¬é€²æ”»</li>
                        <li><strong>ä¸è¦å®Œå…¨ä¾è³´ AI</strong>ï¼ŒåŸ¹é¤Šç¨ç«‹æ€è€ƒèƒ½åŠ›</li>
                        <li><strong>å»ºè­°ä½¿ç”¨æœ€é«˜é›£åº¦ AI</strong>ç²å¾—æœ€ä½³å­¸ç¿’æ•ˆæœ</li>
                        <li><strong>å®šæœŸå‚™ä»½</strong>è‡ªè¨‚é¡Œåº«çš„ JSON æª”æ¡ˆ</li>
                        <li><strong>æŒä¹‹ä»¥æ†</strong>æ¯”ä¸€æ™‚å¤§é‡ç·´ç¿’æ›´é‡è¦</li>
                        <li><strong>é¡Œåº«éŒ¯èª¤è™•ç†</strong>ï¼šè‹¥é‡åˆ°éŒ¯èª¤å±€é¢è«‹å¿½ç•¥æˆ–è·³éï¼Œæˆ–å¡«å¯« <a href="https://docs.google.com/forms/d/e/1FAIpQLSfkDBDErVFK1tkGesY6ZiNG7_-MknwwyiHtONGrqoYlNrbKyA/viewform" target="_blank" style="color: #1976d2; text-decoration: underline;">å•é¡Œå›å ±è¡¨å–®</a></li>
                        <li><strong>å±€åéŒ¯èª¤è™•ç†</strong>ï¼šå¦‚é‡å±€åéŒ¯èª¤ç­‰æƒ…æ³ï¼Œè«‹å¿½ç•¥è·³éæˆ–ä½¿ç”¨å•é¡Œå›å ±è¡¨å–®åé¥‹</li>
                    </ul>
                </div>
            </section>
        </div>

        <div style="background: #f5f7fa; padding: 20px; text-align: center; border-radius: 0 0 20px 20px; border-top: 2px solid #e0e0e0;">
            <p style="margin: 0; color: #666;">ç¥æ‚¨æ£‹è—ç²¾é€²ï¼Œäº«å—è±¡æ£‹çš„æ¨‚è¶£ï¼ğŸ‰</p>
        </div>
    `;

            const closeBtn = helpContent.querySelector('#close-help-btn');
            closeBtn.onmouseover = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
            };
            closeBtn.onmouseout = () => {
                closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            };
            closeBtn.onclick = () => {
                document.body.removeChild(helpDialog);
            };

            helpDialog.appendChild(helpContent);
            document.body.appendChild(helpDialog);

            // é»æ“ŠèƒŒæ™¯é—œé–‰
            helpDialog.onclick = (e) => {
                if (e.target === helpDialog) {
                    document.body.removeChild(helpDialog);
                }
            };
        }

        // çµ„è£ UI
        mainContent.appendChild(modeSelection);
        mainContent.appendChild(functionButtons);
        mainContent.appendChild(endgameTypeSelection);  // ğŸ†• æ·»åŠ æ®˜å±€é¡å‹é¸æ“‡å€
        mainContent.appendChild(openingTypeSelection);  // ğŸ†• é–‹å±€é¡å‹é¸æ“‡å€
        mainContent.appendChild(customFENSection);
        mainContent.appendChild(resultsContainer);

        dialogContent.appendChild(header);
        dialogContent.appendChild(mainContent);
        container.appendChild(dialogContent);

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        container.onclick = (e) => {
            if (e.target === container) {
                document.body.removeChild(container);
            }
        };

        document.body.appendChild(container);

        return {
            container: container,
            trainer: trainer,
            close: () => {
                if (document.body.contains(container)) {
                    document.body.removeChild(container);
                }
            }
        };
    }


    // ====================================
    // æ·»åŠ æŒ‰éˆ•åˆ°é é¢
    // ====================================

    function addPositionTrainerButton() {
        // å°‹æ‰¾åˆé©çš„æŒ‰éˆ•å®¹å™¨
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('å•é¡Œå›å ±')
        );

        const buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const trainerButton = document.createElement('button');
        trainerButton.textContent = 'ğŸ“š é–‹å±€/æ®˜å±€';

        if (regretButton) {
            trainerButton.className = regretButton.className;
            trainerButton.style.cssText = regretButton.style.cssText;
        } else {
            trainerButton.style.cssText = `
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        `;
        }

        trainerButton.addEventListener('mouseenter', () => {
            trainerButton.style.transform = 'translateY(-2px)';
            trainerButton.style.boxShadow = '0 4px 15px rgba(102, 126, 234, 0.5)';
        });

        trainerButton.addEventListener('mouseleave', () => {
            trainerButton.style.transform = 'none';
            trainerButton.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
        });

        trainerButton.addEventListener('click', () => {
            createPositionTrainerUI();
        });

        buttonContainer.appendChild(trainerButton);

        return trainerButton;
    }

    // ====================================
    // åˆå§‹åŒ–
    // ====================================

    function initPositionTrainerSystem() {
        console.log('ğŸ¯ é–‹å±€/æ®˜å±€æ¨æ¼”ç³»çµ±è¼‰å…¥ä¸­...');

        // æ·»åŠ æŒ‰éˆ•
        const button = addPositionTrainerButton();

        console.log('âœ… é–‹å±€/æ®˜å±€æ¨æ¼”ç³»çµ±å·²å°±ç·’ï¼');

        return {
            button: button,
            openUI: createPositionTrainerUI
        };
    }

    // è‡ªå‹•åˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPositionTrainerSystem);
    } else {
        initPositionTrainerSystem();
    }

    // å°å‡ºä¾›å¤–éƒ¨ä½¿ç”¨
    if (typeof window !== 'undefined') {
        window.ChessPositionTrainer = ChessPositionTrainer;
        window.createPositionTrainerUI = createPositionTrainerUI;
        window.initPositionTrainerSystem = initPositionTrainerSystem;
    }


    function showErrorNotification(message) {
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨é€šçŸ¥ï¼Œé¿å…é‡è¤‡å‰µå»º
        if (document.getElementById('error-notification-style')) {
            return;
        }

        const style = document.createElement('style');
        style.id = 'error-notification-style';
        style.textContent = `
        .error-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            padding: 30px 40px;
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(220, 38, 38, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10000;
            min-width: 300px;
            max-width: 500px;
        }
        .error-notification-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 9999;
        }
        .error-notification-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .error-notification-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .error-notification-content {
            position: relative;
            width: 100%;
        }
        .error-notification-icon {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }
        .error-notification-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0;
        }
        .error-notification-message {
            font-size: 16px;
            opacity: 0.9;
            text-align: center;
            margin: 0;
            line-height: 1.5;
        }
    `;
        document.head.appendChild(style);

        const closeNotification = () => {
            const notif = document.getElementById('error-notification');
            const back = document.getElementById('error-notification-backdrop');
            const sty = document.getElementById('error-notification-style');

            if (notif) document.body.removeChild(notif);
            if (back) document.body.removeChild(back);
            if (sty) document.head.removeChild(sty);
        };

        const backdrop = document.createElement('div');
        backdrop.className = 'error-notification-backdrop';
        backdrop.id = 'error-notification-backdrop';
        backdrop.addEventListener('click', closeNotification);

        const notification = document.createElement('div');
        notification.className = 'error-notification';
        notification.id = 'error-notification';
        notification.innerHTML = `
        <div class="error-notification-content">
            <button class="error-notification-close" aria-label="é—œé–‰">âœ•</button>
            <div class="error-notification-icon">âŒ</div>
            <h3 class="error-notification-title">AI æ€è€ƒå¤±æ•—</h3>
            <p class="error-notification-message">${message}</p>
        </div>
    `;

        document.body.appendChild(backdrop);
        document.body.appendChild(notification);

        const closeBtn = notification.querySelector('.error-notification-close');
        closeBtn.addEventListener('click', closeNotification);

        // 5ç§’å¾Œè‡ªå‹•ç§»é™¤ï¼ˆéŒ¯èª¤è¨Šæ¯å¯èƒ½éœ€è¦æ›´é•·æ™‚é–“é–±è®€ï¼‰
        setTimeout(closeNotification, 5000);
    }




    // ========== ä¿®å¾©å¾Œçš„ ONNX æ¨¡å‹æ¨ç†æ¨¡å¡Š ==========
    class ChessRecognitionModel {
        constructor() {
            this.session = null;
            this.inputSize = 640;  // YOLOv8 è¼¸å…¥å°ºå¯¸
            this.outputNames = null;  // æ–°å¢ï¼šå„²å­˜è¼¸å‡ºåç¨±

            // ğŸ”¥ ä¸€å®šè¦åŠ é€™ä¸‰è¡Œ!
            this.lastScale = 1.0;      // é è¨­ä¸ç¸®æ”¾
            this.lastOffsetX = 0;      // é è¨­ç„¡åç§»
            this.lastOffsetY = 0;

            // ğŸ”¥ ä¿®å¾©ï¼šæ­£ç¢ºå®šç¾©é¡åˆ¥åç¨±
            this.classNames = [
                'å¸¥',  // 0 - red king
                'ä»•',  // 1 - red advisor
                'ç›¸',  // 2 - red bishop
                'å‚Œ',  // 3 - red knight
                'ç‚®',  // 4 - red cannon
                'ä¿¥',  // 5 - red rook
                'å…µ',  // 6 - red pawn
                'å°‡',  // 7 - black king
                'å£«',  // 8 - black advisor
                'è±¡',  // 9 - black bishop
                'é¦¬',  // 10 - black horse
                'è»Š',  // 11 - black rook
                'ç ²',  // 12 - black cannon
                'å’',  // 13 - black pawn
            ];

            // ğŸ”¥ æ–°å¢ï¼šä¸­æ–‡åˆ° FEN ç¬¦è™Ÿçš„æ˜ å°„
            this.pieceToFEN = {
                'å¸¥': 'K', 'ä»•': 'A', 'ç›¸': 'B', 'å‚Œ': 'N', 'ç‚®': 'C', 'ä¿¥': 'R', 'å…µ': 'P',
                'å°‡': 'k', 'å£«': 'a', 'è±¡': 'b', 'é¦¬': 'n', 'è»Š': 'r', 'ç ²': 'c', 'å’': 'p'
            };
        }

        async loadModel(modelPath = 'Entity_chess_recognition_model.onnx') {
            try {
                console.log('ğŸ”„ è¼‰å…¥ ONNX æ¨¡å‹: ' + modelPath);
                this.session = await ort.InferenceSession.create(modelPath, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                // ğŸ”¥ é‡è¦ï¼šç²å–æ¨¡å‹çš„è¼¸å…¥è¼¸å‡ºåç¨±
                console.log('ğŸ“‹ æ¨¡å‹è¼¸å…¥:', this.session.inputNames);
                console.log('ğŸ“‹ æ¨¡å‹è¼¸å‡º:', this.session.outputNames);

                this.outputNames = this.session.outputNames;

                console.log('âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ');
                return true;
            } catch (error) {
                console.error('âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
                return false;
            }
        }

        preprocessImage(canvas) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.inputSize;
            tempCanvas.height = this.inputSize;
            const ctx = tempCanvas.getContext('2d');

            // ğŸ”¥ 1. æ”¹æˆç°è‰²å¡«å……
            ctx.fillStyle = 'rgb(114, 114, 114)';
            ctx.fillRect(0, 0, this.inputSize, this.inputSize);

            // 2. è¨ˆç®—ç¸®æ”¾ä¸¦å±…ä¸­ç¹ªè£½ (é€™æ®µä¿æŒä¸è®Š)
            const scale = Math.min(
                this.inputSize / canvas.width,
                this.inputSize / canvas.height
            );
            const scaledWidth = canvas.width * scale;
            const scaledHeight = canvas.height * scale;
            const offsetX = (this.inputSize - scaledWidth) / 2;
            const offsetY = (this.inputSize - scaledHeight) / 2;

            ctx.drawImage(
                canvas,
                0, 0, canvas.width, canvas.height,
                offsetX, offsetY, scaledWidth, scaledHeight
            );

            // ä¿å­˜ç¸®æ”¾ä¿¡æ¯
            this.lastScale = scale;
            this.lastOffsetX = offsetX;
            this.lastOffsetY = offsetY;

            // 3. ç²å–åƒç´ æ•¸æ“š
            const imageData = ctx.getImageData(0, 0, this.inputSize, this.inputSize);
            const { data } = imageData;  // RGBA æ ¼å¼: [R, G, B, A, R, G, B, A, ...]

            const input = new Float32Array(1 * 3 * this.inputSize * this.inputSize);
            const size = this.inputSize * this.inputSize;

            // ğŸ”¥ 4. æ”¹æˆ RGB é †åº (èˆ‡ Python ä¸€è‡´!)
            for (let i = 0; i < size; i++) {
                input[i] = data[i * 4] / 255.0;              // R â† ç¬¬0å€‹
                input[size + i] = data[i * 4 + 1] / 255.0;  // G â† ç¬¬1å€‹
                input[size * 2 + i] = data[i * 4 + 2] / 255.0;  // B â† ç¬¬2å€‹
            }

            return input;
        }

        async detect(canvas) {
            if (!this.session) {
                throw new Error('æ¨¡å‹æœªè¼‰å…¥');
            }

            console.log('ğŸ” é–‹å§‹æª¢æ¸¬...');

            try {
                // é è™•ç†åœ–åƒ
                const inputData = this.preprocessImage(canvas);
                const inputTensor = new ort.Tensor('float32', inputData, [1, 3, this.inputSize, this.inputSize]);

                // åŸ·è¡Œæ¨ç†
                const feeds = { images: inputTensor };
                const results = await this.session.run(feeds);

                // ğŸ”¥ ä¿®å¾©ï¼šå‹•æ…‹ç²å–è¼¸å‡ºæ•¸æ“š
                const outputName = this.outputNames[0];  // ä½¿ç”¨ç¬¬ä¸€å€‹è¼¸å‡ºåç¨±
                console.log(`ğŸ“Š ä½¿ç”¨è¼¸å‡ºåç¨±: ${outputName}`);

                if (!results[outputName]) {
                    console.error('âŒ å¯ç”¨çš„è¼¸å‡º:', Object.keys(results));
                    throw new Error(`æ‰¾ä¸åˆ°è¼¸å‡º "${outputName}"`);
                }

                const output = results[outputName];
                console.log('ğŸ“ è¼¸å‡ºå½¢ç‹€:', output.dims);
                console.log('ğŸ“Š è¼¸å‡ºæ•¸æ“šé•·åº¦:', output.data.length);

                // è§£æ YOLOv8 è¼¸å‡º
                const detections = this.parseYoloV8Output(output, canvas.width, canvas.height);

                console.log(`âœ… æª¢æ¸¬åˆ° ${detections.length} å€‹æ£‹å­`);
                return detections;

            } catch (error) {
                console.error('âŒ æª¢æ¸¬å¤±æ•—:', error);
                throw error;
            }
        }

        parseYoloV8Output(output, originalWidth, originalHeight) {
            const detections = [];
            const confThreshold = 0.25;
            const iouThreshold = 0.45;

            const data = output.data;
            const dims = output.dims;

            // YOLOv8 è¼¸å‡ºæ ¼å¼: [1, 18, 8400] æˆ– [1, 8400, 18]
            // 18 = 4(bbox) + 14(classes)

            let numDetections, numClasses, batchSize;

            if (dims.length === 3) {
                if (dims[1] > dims[2]) {
                    // æ ¼å¼: [1, 8400, 18]
                    batchSize = dims[0];
                    numDetections = dims[1];
                    numClasses = dims[2] - 4;
                } else {
                    // æ ¼å¼: [1, 18, 8400]
                    batchSize = dims[0];
                    numClasses = dims[1] - 4;
                    numDetections = dims[2];
                }
            }

            console.log(`ğŸ“Š æ‰¹æ¬¡: ${batchSize}, æª¢æ¸¬æ•¸: ${numDetections}, é¡åˆ¥æ•¸: ${numClasses}`);

            // è§£ææ¯å€‹æª¢æ¸¬çµæœ
            for (let i = 0; i < numDetections; i++) {
                let x, y, w, h, confidence, classScores;

                if (dims[1] > dims[2]) {
                    // [1, 8400, 18] æ ¼å¼
                    const offset = i * (4 + numClasses);
                    x = data[offset];
                    y = data[offset + 1];
                    w = data[offset + 2];
                    h = data[offset + 3];
                    classScores = Array.from(data.slice(offset + 4, offset + 4 + numClasses));
                } else {
                    // [1, 18, 8400] æ ¼å¼ (è½‰ç½®)
                    x = data[i];
                    y = data[numDetections + i];
                    w = data[numDetections * 2 + i];
                    h = data[numDetections * 3 + i];
                    classScores = [];
                    for (let c = 0; c < numClasses; c++) {
                        classScores.push(data[numDetections * (4 + c) + i]);
                    }
                }

                // æ‰¾åˆ°æœ€é«˜åˆ†é¡åˆ¥
                let maxScore = 0;
                let maxIndex = 0;
                for (let c = 0; c < numClasses; c++) {
                    if (classScores[c] > maxScore) {
                        maxScore = classScores[c];
                        maxIndex = c;
                    }
                }

                confidence = maxScore;

                // éæ¿¾ä½ç½®ä¿¡åº¦
                if (confidence < confThreshold) continue;

                // ğŸ”¥ ä¿®å¾©ï¼šæ­£ç¢ºé‚„åŸåº§æ¨™
                // Step 1: æ¸›å» padding offset
                const x_unpadded = x - this.lastOffsetX;
                const y_unpadded = y - this.lastOffsetY;
                const w_unpadded = w;
                const h_unpadded = h;

                // Step 2: é™¤ä»¥ scale é‚„åŸåˆ°åŸå§‹å°ºå¯¸
                const centerX = x_unpadded / this.lastScale;
                const centerY = y_unpadded / this.lastScale;
                const width = w_unpadded / this.lastScale;
                const height = h_unpadded / this.lastScale;

                // ğŸ”¥ é‚Šç•Œæª¢æŸ¥ (éæ¿¾è¶…å‡ºç¯„åœçš„æª¢æ¸¬)
                if (centerX < 0 || centerX > originalWidth ||
                    centerY < 0 || centerY > originalHeight ||
                    width <= 0 || height <= 0) {
                    continue;
                }

                // ğŸ”¥ è½‰æ›ç‚º FEN ç¬¦è™Ÿ
                const pieceName = this.classNames[maxIndex] || '?';
                const fenSymbol = this.pieceToFEN[pieceName] || '?';

                detections.push({
                    x: centerX - width / 2,
                    y: centerY - height / 2,
                    width: width,
                    height: height,
                    centerX: centerX,
                    centerY: centerY,
                    confidence: confidence,
                    class: maxIndex,
                    pieceName: pieceName,  // ä¸­æ–‡åç¨±ï¼ˆç”¨æ–¼èª¿è©¦ï¼‰
                    piece: fenSymbol       // FEN ç¬¦è™Ÿï¼ˆç”¨æ–¼æ£‹ç›¤ï¼‰
                });
            }

            // NMS å»é‡
            return this.nonMaxSuppression(detections, iouThreshold);
        }

        nonMaxSuppression(detections, iouThreshold) {
            if (detections.length === 0) return [];

            // æŒ‰ç½®ä¿¡åº¦é™åºæ’åº
            detections.sort((a, b) => b.confidence - a.confidence);

            const keep = [];
            const suppressed = new Set();

            for (let i = 0; i < detections.length; i++) {
                if (suppressed.has(i)) continue;

                keep.push(detections[i]);

                for (let j = i + 1; j < detections.length; j++) {
                    if (suppressed.has(j)) continue;

                    const iou = this.calculateIOU(detections[i], detections[j]);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }

            return keep;
        }

        calculateIOU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;

            return intersection / union;
        }

        detectionsToBoard(detections, pawnPos) {
            // ğŸ”¥ ä¿®å¾© 1ï¼šåˆå§‹åŒ–ç‚º nullï¼Œä¸æ˜¯ '1'
            const board = Array(10).fill(null).map(() => Array(9).fill(null));

            console.log('ğŸ—ºï¸ åº§æ¨™æ˜ å°„é–‹å§‹...');
            console.log('  æª¢æ¸¬æ•¸é‡:', detections.length);
            console.log('  ä¸­å…µä½ç½®:', pawnPos);
            console.log('  æ˜¯å¦é€è¦–æ ¡æ­£:', !!window.perspectiveMatrix);

            // ğŸ”¥ åˆ¤æ–·æ˜¯å¦ç¶“éé€è¦–æ ¡æ­£
            if (window.perspectiveMatrix) {
                // ===== æƒ…æ³ Aï¼šå·²åŸ·è¡Œé€è¦–æ ¡æ­£ï¼ˆæ¨™æº– 540x600ï¼‰=====
                console.log('ğŸ“ ä½¿ç”¨é€è¦–æ ¡æ­£å¾Œçš„åº§æ¨™ç³»çµ±');

                const padding = 150;         // âœ… æ”¹æˆ 150
                const boardWidth = 1620;     // âœ… æ”¹æˆ 1620
                const boardHeight = 1800;    // âœ… æ”¹æˆ 1800
                const cellW = boardWidth / 8;   // 67.5
                const cellH = boardHeight / 9;  // 66.67

                // æ‰¾ä¸­å…µæ‰€åœ¨è¡Œï¼ˆå¾ä¸­å…µåæ¨æ£‹ç›¤åŸé»ï¼‰
                const centerCol = 4;
                const estimatedRow = Math.round((pawnPos.y - padding) / cellH);

                console.log(`  ä¸­å…µæ¨ç®—ä½ç½®: ç¬¬ ${estimatedRow} è¡Œ, ç¬¬ ${centerCol} åˆ—`);

                // æ˜ å°„æ‰€æœ‰æ£‹å­
                detections.forEach((det, idx) => {
                    const col = Math.round((det.centerX - padding) / cellW);
                    const row = Math.round((det.centerY - padding) / cellH);

                    if (row >= 0 && row < 10 && col >= 0 && col < 9) {
                        board[row][col] = det.piece;
                        console.log(`  ${idx + 1}. ${det.piece} (${det.pieceName}) -> [${row}, ${col}]`);
                    } else {
                        console.warn(`  âš ï¸ ${idx + 1}. ${det.piece} è¶…å‡ºé‚Šç•Œ: [${row}, ${col}]`);
                    }
                });

            } else {
                // ===== æƒ…æ³ Bï¼šè·³éé€è¦–æ ¡æ­£ï¼ˆä½¿ç”¨ç¶ æ¡†ä½œç‚ºçœŸå¯¦é‚Šç•Œï¼‰=====
                console.log('ğŸ“ ä½¿ç”¨åŸå§‹ç…§ç‰‡åº§æ¨™ç³»çµ± + ç¶ æ¡†é‚Šç•Œ');

                // ğŸ”¥ é—œéµï¼šç›´æ¥ä½¿ç”¨ç¶ æ¡†åº§æ¨™ä½œç‚ºæ£‹ç›¤é‚Šç•Œ
                const boardCorners = window.corners || null;

                let minX, maxX, minY, maxY;

                if (boardCorners && boardCorners.length === 4) {
                    // ğŸ”¥ é‡è¦ï¼šä½¿ç”¨åŸå§‹åœ–ç‰‡åº§æ¨™ï¼Œä¸æ˜¯ Canvas é¡¯ç¤ºåº§æ¨™
                    const xs = boardCorners.map(p => p.originalX || p.x);
                    const ys = boardCorners.map(p => p.originalY || p.y);
                    minX = Math.min(...xs);
                    maxX = Math.max(...xs);
                    minY = Math.min(...ys);
                    maxY = Math.max(...ys);
                    console.log('âœ… ä½¿ç”¨ç¶ æ¡†é‚Šç•Œ (åŸå§‹åœ–ç‰‡åº§æ¨™):', {minX, maxX, minY, maxY});
                } else {
                    // å‚™ç”¨æ–¹æ¡ˆï¼šç”¨æª¢æ¸¬åº§æ¨™æ¨ç®—ï¼ˆä½†æœƒå‘å¤–æ“´å±•ï¼‰
                    console.warn('âš ï¸ æ‰¾ä¸åˆ°ç¶ æ¡†åº§æ¨™ï¼Œä½¿ç”¨æª¢æ¸¬ç¯„åœæ¨ç®—');
                    const allX = detections.map(d => d.centerX);
                    const allY = detections.map(d => d.centerY);

                    const detMinX = Math.min(...allX);
                    const detMaxX = Math.max(...allX);
                    const detMinY = Math.min(...allY);
                    const detMaxY = Math.max(...allY);

                    // å‘å¤–æ“´å±•åŠæ ¼
                    const estimatedCellW = (detMaxX - detMinX) / 8;
                    const estimatedCellH = (detMaxY - detMinY) / 9;

                    minX = detMinX - estimatedCellW * 0.5;
                    maxX = detMaxX + estimatedCellW * 0.5;
                    minY = detMinY - estimatedCellH * 0.5;
                    maxY = detMaxY + estimatedCellH * 0.5;
                }

                const boardWidth = maxX - minX;
                const boardHeight = maxY - minY;

                console.log('  æ£‹ç›¤é‚Šç•Œ:');
                console.log('    X:', minX.toFixed(1), '~', maxX.toFixed(1), '(å¯¬åº¦', boardWidth.toFixed(1), ')');
                console.log('    Y:', minY.toFixed(1), '~', maxY.toFixed(1), '(é«˜åº¦', boardHeight.toFixed(1), ')');

                // ğŸ”¥ è¨ˆç®—æ ¼å­å°ºå¯¸ï¼ˆ9åˆ— Ã— 10è¡Œï¼‰
                const cellW = boardWidth / 8;   // 8å€‹é–“éš” = 9åˆ—
                const cellH = boardHeight / 9;  // 9å€‹é–“éš” = 10è¡Œ

                console.log('  è¨ˆç®—æ ¼å­å°ºå¯¸:', cellW.toFixed(1), 'x', cellH.toFixed(1));

                // ğŸ”¥ ä½¿ç”¨ä¸­å…µä½ç½®é©—è­‰
                const pawnCol = Math.round((pawnPos.x - minX) / cellW);
                const pawnRow = Math.round((pawnPos.y - minY) / cellH);

                console.log(`  ä¸­å…µæ˜ å°„çµæœ: [${pawnRow}, ${pawnCol}]`);
                console.log(`  é æœŸä¸­å…µåˆ—: 4 (ä¸­è·¯)`);

                // ğŸ”¥ è¨ˆç®—åˆ—åç§»ä¿®æ­£
                const colOffset = 4 - pawnCol;
                console.log(`  åˆ—åç§»ä¿®æ­£: ${colOffset}`);

                // æ˜ å°„æ‰€æœ‰æ£‹å­
                detections.forEach((det, idx) => {
                    const col = Math.round((det.centerX - minX) / cellW) + colOffset;
                    const row = Math.round((det.centerY - minY) / cellH);

                    if (row >= 0 && row < 10 && col >= 0 && col < 9) {
                        board[row][col] = det.piece;
                        console.log(`  ${idx + 1}. ${det.piece} (${det.pieceName}) åƒç´ (${det.centerX.toFixed(0)}, ${det.centerY.toFixed(0)}) -> [${row}, ${col}]`);
                    } else {
                        console.warn(`  âš ï¸ ${idx + 1}. ${det.piece} (${det.pieceName}) è¶…å‡ºé‚Šç•Œ: [${row}, ${col}]`);
                    }
                });
            }

            // ğŸ”¥ æœ€å¾Œé©—è­‰
            const totalPieces = board.flat().filter(p => p !== null).length;
            console.log(`âœ… æ˜ å°„å®Œæˆï¼Œæ£‹ç›¤ä¸Šå…± ${totalPieces} å€‹æ£‹å­`);

            return board;
        }

        boardToFEN(board, currentPlayer = 'red') {
            const fenRows = [];

            for (const row of board) {
                let fenRow = '';
                let emptyCount = 0;

                for (const piece of row) {
                    // ğŸ”¥ ä¿®å¾©ï¼šnull æ‰æ˜¯ç©ºæ ¼ï¼Œä¸æ˜¯ '1'
                    if (piece === null) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fenRow += emptyCount;
                            emptyCount = 0;
                        }
                        fenRow += piece;
                    }
                }

                if (emptyCount > 0) {
                    fenRow += emptyCount;
                }

                fenRows.push(fenRow);
            }

            const fen = fenRows.join('/');
            const player = currentPlayer === 'red' ? 'w' : 'b';

            return `${fen} ${player}`;
        }
    }

    // ========== åˆå§‹åŒ–æ¨¡å‹ ==========
    let recognitionModel = null;

    async function initRecognitionModel() {
        recognitionModel = new ChessRecognitionModel();
        const loaded = await recognitionModel.loadModel('Entity_chess_recognition_model.onnx');  // ä½¿ç”¨ä½ çš„æ¨¡å‹åç¨±

        if (loaded) {
            console.log('âœ… æ£‹ç›¤è­˜åˆ¥æ¨¡å‹å·²å°±ç·’');
        } else {
            console.error('âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ Entity_chess_recognition_model.onnx æ˜¯å¦å­˜åœ¨');
        }
    }

    // ========== ğŸ“Œ æ­¥é©Ÿ 1ï¼šæ–°å¢é›™æ¨¡å‹é¡åˆ¥ ==========
    // ğŸ® åœ¨ä½ åŸæœ‰çš„ ChessRecognitionModel é¡åˆ¥å¾Œé¢åŠ ä¸Šé€™å€‹æ–°é¡åˆ¥

    class OnlineGameRecognitionModel {
        constructor() {
            this.detectorSession = null;
            this.classifierSession = null;
            this.detectorInputSize = 640;
            this.classifierInputSize = 64;  // ğŸ”¥ æ”¹ç‚º 64x64

            this.backgroundType = null;  // ğŸ¨ èƒŒæ™¯é¡å‹å¿«å–

            this.detectorOutputNames = null;
            this.classifierOutputNames = null;

            this.lastScale = 1.0;
            this.lastOffsetX = 0;
            this.lastOffsetY = 0;

            // âœ… æ”¹æˆæ­£ç¢ºçš„ï¼ˆæŒ‰ç…§ Python æ¨¡å‹é †åºï¼‰ï¼š
            this.classNames = ['å£«', 'è»Š', 'é¦¬', 'å’', 'å°‡', 'ç‚®', 'ç›¸'];
// å°æ‡‰: 0: å£«,  1: è»Š,  2: é¦¬,  3: å’,  4: å°‡,  5: ç‚®,  6: ç›¸


// âŒ åŸæœ¬çš„ pieceToFEN å¯èƒ½ä¹Ÿè¦èª¿æ•´éµå
// âœ… ç¢ºä¿ pieceToFEN çš„éµåèˆ‡ classNames ä¸€è‡´ï¼š
            this.pieceToFEN = {
                'å£«_red': 'A', 'è»Š_red': 'R', 'é¦¬_red': 'N',
                'å’_red': 'P', 'å°‡_red': 'K', 'ç‚®_red': 'C', 'ç›¸_red': 'B',

                'å£«_black': 'a', 'è»Š_black': 'r', 'é¦¬_black': 'n',
                'å’_black': 'p', 'å°‡_black': 'k', 'ç‚®_black': 'c', 'ç›¸_black': 'b'
            };
        }

        async loadModels() {
            try {
                console.log('ğŸ® è¼‰å…¥ç·šä¸ŠéŠæˆ²è­˜åˆ¥æ¨¡å‹...');

                // è¼‰å…¥ Detection æ¨¡å‹
                this.detectorSession = await ort.InferenceSession.create(
                    'online_xiangqi_piece_detector.onnx',
                    { executionProviders: ['wasm'], graphOptimizationLevel: 'all' }
                );
                this.detectorOutputNames = this.detectorSession.outputNames;
                console.log('âœ… å®šä½æ¨¡å‹è¼‰å…¥æˆåŠŸ');

                // è¼‰å…¥ Classification æ¨¡å‹
                this.classifierSession = await ort.InferenceSession.create(
                    'online_xiangqi_classifier.onnx',
                    { executionProviders: ['wasm'], graphOptimizationLevel: 'all' }
                );
                this.classifierOutputNames = this.classifierSession.outputNames;
                console.log('âœ… åˆ†é¡æ¨¡å‹è¼‰å…¥æˆåŠŸ');

                return true;
            } catch (error) {
                console.error('âŒ ç·šä¸Šæ¨¡å‹è¼‰å…¥å¤±æ•—:', error);
                return false;
            }
        }

        // é è™•ç† Detection
        preprocessForDetection(canvas) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.detectorInputSize;
            tempCanvas.height = this.detectorInputSize;
            const ctx = tempCanvas.getContext('2d');

            ctx.fillStyle = 'rgb(114, 114, 114)';
            ctx.fillRect(0, 0, this.detectorInputSize, this.detectorInputSize);

            const scale = Math.min(
                this.detectorInputSize / canvas.width,
                this.detectorInputSize / canvas.height
            );
            const scaledWidth = canvas.width * scale;
            const scaledHeight = canvas.height * scale;
            const offsetX = (this.detectorInputSize - scaledWidth) / 2;
            const offsetY = (this.detectorInputSize - scaledHeight) / 2;

            ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height,
                offsetX, offsetY, scaledWidth, scaledHeight);

            this.lastScale = scale;
            this.lastOffsetX = offsetX;
            this.lastOffsetY = offsetY;

            const imageData = ctx.getImageData(0, 0, this.detectorInputSize, this.detectorInputSize);
            const { data } = imageData;
            const input = new Float32Array(3 * this.detectorInputSize * this.detectorInputSize);
            const size = this.detectorInputSize * this.detectorInputSize;

            for (let i = 0; i < size; i++) {
                input[i] = data[i * 4] / 255.0;
                input[size + i] = data[i * 4 + 1] / 255.0;
                input[size * 2 + i] = data[i * 4 + 2] / 255.0;
            }

            return input;
        }

        // é è™•ç† Classificationï¼ˆå–®å€‹ ROIï¼‰
        preprocessForClassification(canvas, box) {
            // ğŸ”¥ å‘å¤–æ“´å±• 15% é¿å…è£åˆ°å­—
            const expandRatio = 0.15;
            const expandW = box.width * expandRatio;
            const expandH = box.height * expandRatio;

            const x1 = Math.max(0, Math.floor(box.x - expandW));
            const y1 = Math.max(0, Math.floor(box.y - expandH));
            const x2 = Math.min(canvas.width, Math.ceil(box.x + box.width + expandW));
            const y2 = Math.min(canvas.height, Math.ceil(box.y + box.height + expandH));

            const roiWidth = x2 - x1;
            const roiHeight = y2 - y1;

            if (roiWidth <= 0 || roiHeight <= 0) {
                return null;
            }

            // è£åˆ‡ ROI
            const roiCanvas = document.createElement('canvas');
            roiCanvas.width = roiWidth;
            roiCanvas.height = roiHeight;
            const roiCtx = roiCanvas.getContext('2d');
            roiCtx.drawImage(canvas, x1, y1, roiWidth, roiHeight, 0, 0, roiWidth, roiHeight);

            // ğŸ”¥ ç¸®æ”¾åˆ° 64x64
            const resizedCanvas = document.createElement('canvas');
            resizedCanvas.width = 64;
            resizedCanvas.height = 64;
            const resizedCtx = resizedCanvas.getContext('2d');
            resizedCtx.drawImage(roiCanvas, 0, 0, 64, 64);

            // è½‰æ›ç‚º RGB
            const imageData = resizedCtx.getImageData(0, 0, 64, 64);
            const { data } = imageData;
            const input = new Float32Array(3 * 64 * 64);
            const size = 64 * 64;

            for (let i = 0; i < size; i++) {
                input[i] = data[i * 4] / 255.0;
                input[size + i] = data[i * 4 + 1] / 255.0;
                input[size * 2 + i] = data[i * 4 + 2] / 255.0;
            }

            return { input, roiCanvas };
        }

        // ğŸ¨ åµæ¸¬èƒŒæ™¯é¡å‹ (åªéœ€åŸ·è¡Œä¸€æ¬¡)
        detectBackgroundType(canvas) {


            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            let totalBrightness = 0;
            let warmPixels = 0;  // æš–è‰²èª¿åƒç´  (æ©˜/é»ƒ)
            let sampleCount = 0;

            // å–æ¨£é‚Šç·£å€åŸŸåˆ¤æ–·èƒŒæ™¯
            for (let i = 0; i < data.length; i += 16) {  // æ¯éš”4å€‹åƒç´ æ¡æ¨£
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                if (a > 128) {
                    sampleCount++;
                    const brightness = (r + g + b) / 3;
                    totalBrightness += brightness;

                    // æš–è‰²èª¿åˆ¤å®š: R å’Œ G éƒ½è¼ƒé«˜ (æ©˜/é»ƒè‰²èƒŒæ™¯)
                    if (r > 150 && g > 100 && r > b + 30) {
                        warmPixels++;
                    }
                }
            }

            const avgBrightness = totalBrightness / sampleCount;
            const warmRatio = warmPixels / sampleCount;

            // åˆ¤å®šèƒŒæ™¯é¡å‹
            if (avgBrightness > 130 && warmRatio > 0.3) {
                this.backgroundType = 'warm';  // æ©˜è‰²/æš–è‰²èƒŒæ™¯
                console.log('ğŸ¨ èƒŒæ™¯é¡å‹: æ©˜è‰²/æš–è‰² â†’ ä½¿ç”¨é®®ç´…åˆ¤å®šæ³•');
            } else if (avgBrightness < 100) {
                this.backgroundType = 'dark';  // æ·±è‰²/é»‘è‰²èƒŒæ™¯
                console.log('ğŸ¨ èƒŒæ™¯é¡å‹: æ·±è‰²/é»‘è‰² â†’ ä½¿ç”¨ç´…é»‘å°æ¯”æ³•');
            } else {
                this.backgroundType = 'neutral';  // ä¸­æ€§èƒŒæ™¯
                console.log('ğŸ¨ èƒŒæ™¯é¡å‹: ä¸­æ€§ â†’ ä½¿ç”¨æ··åˆåˆ¤å®šæ³•');
            }

            return this.backgroundType;
        }


        // ç´…é»‘é™£ç‡Ÿåˆ¤å®š (ä¸­å¤®å€åŸŸæª¢æ¸¬æ³•)
        determineColor(roiCanvas) {
            const ctx = roiCanvas.getContext('2d');
            const width = roiCanvas.width;
            const height = roiCanvas.height;

            // ğŸ¯ åªæª¢æ¸¬ä¸­å¤® 50% å€åŸŸ (é¿é–‹é‚Šç·£èƒŒæ™¯)
            const centerX = Math.floor(width * 0.25);
            const centerY = Math.floor(height * 0.25);
            const centerWidth = Math.floor(width * 0.5);
            const centerHeight = Math.floor(height * 0.5);

            const imageData = ctx.getImageData(centerX, centerY, centerWidth, centerHeight);
            const data = imageData.data;

            let redScore = 0;    // ç´…è‰²å¾—åˆ†
            let blackScore = 0;  // é»‘è‰²å¾—åˆ†
            let totalPixels = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                if (a > 128) {
                    totalPixels++;
                    const brightness = (r + g + b) / 3;

                    // ğŸ”´ ç´…è‰²åˆ¤å®š:R æ˜é¡¯å¤§æ–¼ G å’Œ B
                    if (r > g + 30 && r > b + 30) {
                        // æ ¹æ“šç´…è‰²å¼·åº¦çµ¦åˆ†
                        if (r > 150) {
                            redScore += 3;  // é®®ç´…
                        } else if (r > 100) {
                            redScore += 2;  // æ·±ç´…
                        } else {
                            redScore += 1;  // æš—ç´…
                        }
                    }

                    // âš« é»‘è‰²åˆ¤å®š:æ•´é«”äº®åº¦ä½ä¸”é¡è‰²å‡å‹»
                    else if (brightness < 80 && Math.abs(r - g) < 20 && Math.abs(g - b) < 20) {
                        blackScore += 3;
                    }
                    // æ·±ç°/æš—è‰²ä¹Ÿç®—é»‘è‰²
                    else if (brightness < 100) {
                        blackScore += 1;
                    }
                }
            }

            const isRed = redScore > blackScore;

            // ğŸ” Debug (15%æ©Ÿç‡)
            if (totalPixels > 0 && Math.random() < 0.15) {
                console.log(
                    `  [ä¸­å¤®å€åŸŸæª¢æ¸¬] ` +
                    `ç´…åˆ†:${redScore} é»‘åˆ†:${blackScore} ` +
                    `â†’ ${isRed ? 'ç´…æ–¹' : 'é»‘æ–¹'}`
                );
            }

            return isRed ? 'red' : 'black';
        }

        // æª¢æ¸¬ï¼ˆDetection + Classification + é™£ç‡Ÿåˆ¤å®šï¼‰
        async detect(canvas) {
            if (!this.detectorSession || !this.classifierSession) {
                throw new Error('æ¨¡å‹æœªè¼‰å…¥');
            }

            console.log('ğŸ® é–‹å§‹ç·šä¸Šæˆªåœ–è­˜åˆ¥...');

            // ğŸ¨ åµæ¸¬èƒŒæ™¯é¡å‹ (åªåŸ·è¡Œä¸€æ¬¡)
            this.detectBackgroundType(canvas);

            // æ­¥é©Ÿ 1ï¼šDetection æ¨¡å‹æª¢æ¸¬æ‰€æœ‰æ£‹å­ä½ç½®
            console.log('ğŸ“ æ­¥é©Ÿ 1ï¼šæª¢æ¸¬æ£‹å­ä½ç½®...');
            const detectionInput = this.preprocessForDetection(canvas);
            const detectionTensor = new ort.Tensor('float32', detectionInput,
                [1, 3, this.detectorInputSize, this.detectorInputSize]);

            const detectionResults = await this.detectorSession.run({ images: detectionTensor });
            const detectionOutput = detectionResults[this.detectorOutputNames[0]];

            // è§£æ Detection è¼¸å‡ºï¼ˆç²å– bounding boxesï¼‰
            const boxes = this.parseDetectionOutput(detectionOutput, canvas.width, canvas.height);
            console.log(`âœ… æª¢æ¸¬åˆ° ${boxes.length} å€‹æ£‹å­`);

            // æ­¥é©Ÿ 2ï¼šå°æ¯å€‹ box é€²è¡Œåˆ†é¡å’Œé™£ç‡Ÿåˆ¤å®š
            console.log('ğŸ” æ­¥é©Ÿ 2ï¼šè­˜åˆ¥æ£‹å­é¡å‹å’Œé™£ç‡Ÿ...');
            const detections = [];

            for (let i = 0; i < boxes.length; i++) {
                const box = boxes[i];

                // è£åˆ‡ ROI ä¸¦é è™•ç†
                const preprocessed = this.preprocessForClassification(canvas, box);
                if (!preprocessed) {
                    console.warn(`âš ï¸ è·³éç„¡æ•ˆ ROI: ${i}`);
                    continue;
                }

                const { input: classInput, roiCanvas } = preprocessed;

                // Classification æ¨¡å‹æ¨ç†
                const classTensor = new ort.Tensor('float32', classInput, [1, 3, 64, 64]);
                const classResults = await this.classifierSession.run({ images: classTensor });
                const classOutput = classResults[this.classifierOutputNames[0]];

                // æ‰¾åˆ°æœ€é«˜æ¦‚ç‡çš„é¡åˆ¥
                const classProbs = Array.from(classOutput.data);
                const maxProb = Math.max(...classProbs);
                const classIndex = classProbs.indexOf(maxProb);
                const pieceType = this.classNames[classIndex];

                // é™£ç‡Ÿåˆ¤å®šï¼ˆç´…é»‘ï¼‰
                const color = this.determineColor(roiCanvas);

                // ç”Ÿæˆ FEN ç¬¦è™Ÿ
                const fenKey = `${pieceType}_${color}`;
                const fenSymbol = this.pieceToFEN[fenKey] || '?';

                detections.push({
                    x: box.x,
                    y: box.y,
                    width: box.width,
                    height: box.height,
                    centerX: box.centerX,
                    centerY: box.centerY,
                    confidence: maxProb,
                    pieceType: pieceType,
                    color: color,
                    piece: fenSymbol
                });

                console.log(`  ${i+1}. ${color === 'red' ? 'ç´…' : 'é»‘'}${pieceType} (${fenSymbol}) - ç½®ä¿¡åº¦: ${maxProb.toFixed(3)}`);
            }

            console.log(`âœ… è­˜åˆ¥å®Œæˆï¼Œå…± ${detections.length} å€‹æ£‹å­`);
            return detections;
        }

        // è§£æ Detection è¼¸å‡ºï¼ˆYOLOv8 æ ¼å¼ï¼‰
        parseDetectionOutput(output, originalWidth, originalHeight) {
            const boxes = [];
            const confThreshold = 0.25;
            const iouThreshold = 0.45;

            const data = output.data;
            const dims = output.dims;

            let numDetections, batchSize;

            if (dims.length === 3) {
                if (dims[1] > dims[2]) {
                    // [1, 8400, 5] æ ¼å¼
                    batchSize = dims[0];
                    numDetections = dims[1];
                } else {
                    // [1, 5, 8400] æ ¼å¼
                    batchSize = dims[0];
                    numDetections = dims[2];
                }
            }

            for (let i = 0; i < numDetections; i++) {
                let x, y, w, h, confidence;

                if (dims[1] > dims[2]) {
                    // [1, 8400, 5]
                    const offset = i * 5;
                    x = data[offset];
                    y = data[offset + 1];
                    w = data[offset + 2];
                    h = data[offset + 3];
                    confidence = data[offset + 4];
                } else {
                    // [1, 5, 8400]
                    x = data[i];
                    y = data[numDetections + i];
                    w = data[numDetections * 2 + i];
                    h = data[numDetections * 3 + i];
                    confidence = data[numDetections * 4 + i];
                }

                if (confidence < confThreshold) continue;

                // é‚„åŸåº§æ¨™
                const x_unpadded = x - this.lastOffsetX;
                const y_unpadded = y - this.lastOffsetY;
                const centerX = x_unpadded / this.lastScale;
                const centerY = y_unpadded / this.lastScale;
                const width = w / this.lastScale;
                const height = h / this.lastScale;

                if (centerX < 0 || centerX > originalWidth ||
                    centerY < 0 || centerY > originalHeight ||
                    width <= 0 || height <= 0) {
                    continue;
                }

                boxes.push({
                    x: centerX - width / 2,
                    y: centerY - height / 2,
                    width: width,
                    height: height,
                    centerX: centerX,
                    centerY: centerY,
                    confidence: confidence
                });
            }

            return this.nonMaxSuppression(boxes, iouThreshold);
        }

        nonMaxSuppression(boxes, iouThreshold) {
            if (boxes.length === 0) return [];

            boxes.sort((a, b) => b.confidence - a.confidence);

            const keep = [];
            const suppressed = new Set();

            for (let i = 0; i < boxes.length; i++) {
                if (suppressed.has(i)) continue;
                keep.push(boxes[i]);

                for (let j = i + 1; j < boxes.length; j++) {
                    if (suppressed.has(j)) continue;
                    const iou = this.calculateIOU(boxes[i], boxes[j]);
                    if (iou > iouThreshold) {
                        suppressed.add(j);
                    }
                }
            }

            return keep;
        }

        calculateIOU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;

            return intersection / union;
        }

        // 6ï¸âƒ£ ä¿®æ”¹ OnlineGameRecognitionModel.detectionsToBoard()
// åœ¨é€™å€‹å‡½æ•¸ä¸­åŠ å…¥å° corners å’Œ pawnPos çš„è™•ç†

        detectionsToBoard(detections, pawnPos, corners) {
            const board = Array(10).fill(null).map(() => Array(9).fill(null));

            console.log('ğŸ—ºï¸ åº§æ¨™æ˜ å°„é–‹å§‹ï¼ˆç·šä¸Šæˆªåœ– + å››è§’ + ä¸­å…µï¼‰...');

            // ğŸ”¥ ä½¿ç”¨å››è§’ç¢ºå®šæ£‹ç›¤é‚Šç•Œ
            if (corners && corners.length === 4) {
                const xs = corners.map(c => c.originalX || c.x);
                const ys = corners.map(c => c.originalY || c.y);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);

                const boardWidth = maxX - minX;
                const boardHeight = maxY - minY;

                console.log('  ä½¿ç”¨å››è§’é‚Šç•Œ:', {
                    X: `${minX.toFixed(1)} ~ ${maxX.toFixed(1)}`,
                    Y: `${minY.toFixed(1)} ~ ${maxY.toFixed(1)}`,
                    size: `${boardWidth.toFixed(1)} x ${boardHeight.toFixed(1)}`
                });

                const cellW = boardWidth / 8;
                const cellH = boardHeight / 9;

                // ğŸ”¥ ä½¿ç”¨ä¸­å…µè¨ˆç®—åˆ—åç§»
                const pawnCol = Math.round((pawnPos.x - minX) / cellW);
                const colOffset = 4 - pawnCol;
                console.log('  ä¸­å…µåˆ—åç§»:', colOffset);

                // æ˜ å°„æ‰€æœ‰æ£‹å­
                detections.forEach((det, idx) => {
                    const col = Math.round((det.centerX - minX) / cellW) + colOffset;
                    const row = Math.round((det.centerY - minY) / cellH);

                    if (row >= 0 && row < 10 && col >= 0 && col < 9) {
                        board[row][col] = det.piece;
                        console.log(`  ${idx + 1}. ${det.piece} -> [${row}, ${col}]`);
                    }
                });

            } else {
                console.warn('âš ï¸ æœªæä¾›å››è§’ï¼Œä½¿ç”¨è‡ªå‹•æ¨ç®—');
                // åŸæœ‰çš„è‡ªå‹•æ¨ç®—é‚è¼¯...
            }

            const totalPieces = board.flat().filter(p => p !== null).length;
            console.log(`âœ… æ˜ å°„å®Œæˆï¼Œæ£‹ç›¤ä¸Šå…± ${totalPieces} å€‹æ£‹å­`);

            return board;
        }


        // è½‰æ›ç‚º FEN
        boardToFEN(board, currentPlayer = 'red') {
            const fenRows = [];

            for (const row of board) {
                let fenRow = '';
                let emptyCount = 0;

                for (const piece of row) {
                    if (piece === null) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fenRow += emptyCount;
                            emptyCount = 0;
                        }
                        fenRow += piece;
                    }
                }

                if (emptyCount > 0) {
                    fenRow += emptyCount;
                }

                fenRows.push(fenRow);
            }

            const fen = fenRows.join('/');
            const player = currentPlayer === 'red' ? 'w' : 'b';

            return `${fen} ${player}`;
        }
    }


    // ========== ğŸ“Œ æ­¥é©Ÿ 2ï¼šåˆå§‹åŒ–ç·šä¸ŠéŠæˆ²æ¨¡å‹ ==========
    // ğŸ”¥ åœ¨ä½ çš„ initRecognitionModel() å‡½æ•¸å¾Œé¢åŠ ä¸Šé€™å€‹

    let onlineGameModel = null;

    async function initOnlineGameModel() {
        onlineGameModel = new OnlineGameRecognitionModel();
        const loaded = await onlineGameModel.loadModels();

        if (loaded) {
            console.log('âœ… ç·šä¸ŠéŠæˆ²è­˜åˆ¥æ¨¡å‹å·²å°±ç·’');
        } else {
            console.error('âŒ ç·šä¸ŠéŠæˆ²æ¨¡å‹è¼‰å…¥å¤±æ•—');
        }
    }

    // ğŸ”¥ æ‹ç…§è­˜åˆ¥å°ˆç”¨çš„è¦–è§’ç„¡é—œé©—è­‰å™¨
    class PhotoRecognitionValidator {
        constructor(board) {
            this.board = board; // 10è¡Œ9åˆ—çš„æ£‹ç›¤
        }

        // ğŸ”¥ ç¬¬ä¸€æ­¥ï¼šæ‰¾å‡ºé›™æ–¹çš„å°‡å¸¥ä½ç½®
        findKings() {
            let redKing = null;
            let blackKing = null;

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        if (piece.type === 'å¸¥' && piece.color === 'red') {
                            redKing = { row, col };
                        } else if (piece.type === 'å°‡' && piece.color === 'black') {
                            blackKing = { row, col };
                        }
                    }
                }
            }

            return { redKing, blackKing };
        }

        // ğŸ”¥ ç¬¬äºŒæ­¥ï¼šåˆ¤æ–·æ£‹ç›¤è¦–è§’ï¼ˆç´…ä¸Šé»‘ä¸‹ or é»‘ä¸Šç´…ä¸‹ï¼‰
        detectOrientation() {
            const { redKing, blackKing } = this.findKings();

            if (!redKing || !blackKing) {
                return null; // ç¼ºå°‘å°‡å¸¥ï¼Œç„¡æ³•åˆ¤æ–·è¦–è§’
            }

            // åˆ¤æ–·é‚è¼¯ï¼šèª°åœ¨ä¸ŠåŠéƒ¨ï¼ˆ0-4è¡Œï¼‰ï¼Œèª°å°±æ˜¯"ä¸Šæ–¹"
            const redInTop = redKing.row <= 4;
            const blackInTop = blackKing.row <= 4;

            if (redInTop && !blackInTop) {
                return 'red-top'; // ç´…ä¸Šé»‘ä¸‹
            } else if (blackInTop && !redInTop) {
                return 'black-top'; // é»‘ä¸Šç´…ä¸‹ï¼ˆæ¨™æº–è¦–è§’ï¼‰
            } else {
                return 'invalid'; // å…©å€‹ç‹åœ¨åŒä¸€åŠé‚Šï¼Œä¸åˆæ³•
            }
        }

        // ğŸ”¥ ç¬¬ä¸‰æ­¥ï¼šæª¢æŸ¥å°‡å¸¥æ˜¯å¦åœ¨æ­£ç¢ºçš„ä¹å®®æ ¼å…§
        validateKingPositions() {
            const { redKing, blackKing } = this.findKings();
            const errors = [];

            if (!redKing) {
                errors.push('âŒ ç¼ºå°‘ç´…å¸¥');
                return errors;
            }
            if (!blackKing) {
                errors.push('âŒ ç¼ºå°‘é»‘å°‡');
                return errors;
            }

            const orientation = this.detectOrientation();

            if (orientation === 'invalid') {
                errors.push('âŒ ç´…å¸¥å’Œé»‘å°‡ä¸èƒ½åœ¨åŒä¸€åŠé‚Š');
                return errors;
            }

            // æ ¹æ“šè¦–è§’æª¢æŸ¥ä¹å®®æ ¼
            if (orientation === 'red-top') {
                // ç´…ä¸Šé»‘ä¸‹ï¼šç´…å¸¥åœ¨0-2è¡Œï¼Œé»‘å°‡åœ¨7-9è¡Œ
                if (!this.isInPalace(redKing.row, redKing.col, 0, 2)) {
                    errors.push('âŒ ç´…å¸¥å¿…é ˆåœ¨ä¹å®®æ ¼å…§ï¼ˆä¸Šæ–¹ï¼‰');
                }
                if (!this.isInPalace(blackKing.row, blackKing.col, 7, 9)) {
                    errors.push('âŒ é»‘å°‡å¿…é ˆåœ¨ä¹å®®æ ¼å…§ï¼ˆä¸‹æ–¹ï¼‰');
                }
            } else if (orientation === 'black-top') {
                // é»‘ä¸Šç´…ä¸‹ï¼šé»‘å°‡åœ¨0-2è¡Œï¼Œç´…å¸¥åœ¨7-9è¡Œ
                if (!this.isInPalace(blackKing.row, blackKing.col, 0, 2)) {
                    errors.push('âŒ é»‘å°‡å¿…é ˆåœ¨ä¹å®®æ ¼å…§ï¼ˆä¸Šæ–¹ï¼‰');
                }
                if (!this.isInPalace(redKing.row, redKing.col, 7, 9)) {
                    errors.push('âŒ ç´…å¸¥å¿…é ˆåœ¨ä¹å®®æ ¼å…§ï¼ˆä¸‹æ–¹ï¼‰');
                }
            }

            return errors;
        }

        // ğŸ”¥ æª¢æŸ¥æ˜¯å¦åœ¨ä¹å®®æ ¼å…§
        isInPalace(row, col, minRow, maxRow) {
            return row >= minRow && row <= maxRow && col >= 3 && col <= 5;
        }

        // ğŸ”¥ æª¢æŸ¥å°‡å¸¥æ˜¯å¦å°è‡‰
        areKingsFacing() {
            const { redKing, blackKing } = this.findKings();

            if (!redKing || !blackKing) {
                return false;
            }

            // å¿…é ˆåœ¨åŒä¸€åˆ—
            if (redKing.col !== blackKing.col) {
                return false;
            }

            // æª¢æŸ¥ä¸­é–“æ˜¯å¦æœ‰æ£‹å­
            const startRow = Math.min(redKing.row, blackKing.row) + 1;
            const endRow = Math.max(redKing.row, blackKing.row) - 1;

            for (let i = startRow; i <= endRow; i++) {
                if (this.board[i][redKing.col]) {
                    return false; // ä¸­é–“æœ‰æ£‹å­ï¼Œä¸ç®—å°è‡‰
                }
            }

            return true; // å°è‡‰äº†ï¼
        }

        // ğŸ”¥ ç¬¬å››æ­¥ï¼šé©—è­‰å£«çš„ä½ç½®
        validateAdvisors() {
            const errors = [];
            const orientation = this.detectOrientation();

            if (!orientation || orientation === 'invalid') {
                return errors; // è¦–è§’ç„¡æ•ˆï¼Œè·³éæª¢æŸ¥
            }

            let redAdvisors = [];
            let blackAdvisors = [];

            // æ”¶é›†æ‰€æœ‰å£«/ä»•
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        if (piece.type === 'ä»•' && piece.color === 'red') {
                            redAdvisors.push({ row, col });
                        } else if (piece.type === 'å£«' && piece.color === 'black') {
                            blackAdvisors.push({ row, col });
                        }
                    }
                }
            }

            // æª¢æŸ¥æ•¸é‡
            if (redAdvisors.length > 2) {
                errors.push('âŒ ç´…ä»•æœ€å¤šåªèƒ½æœ‰2å€‹');
            }
            if (blackAdvisors.length > 2) {
                errors.push('âŒ é»‘å£«æœ€å¤šåªèƒ½æœ‰2å€‹');
            }

            // æ ¹æ“šè¦–è§’æª¢æŸ¥ä½ç½®
            const redValidPositions = orientation === 'red-top' ?
                [[0,3], [0,5], [1,4], [2,3], [2,5]] :
                [[7,3], [7,5], [8,4], [9,3], [9,5]];

            const blackValidPositions = orientation === 'black-top' ?
                [[0,3], [0,5], [1,4], [2,3], [2,5]] :
                [[7,3], [7,5], [8,4], [9,3], [9,5]];

            for (const advisor of redAdvisors) {
                const valid = redValidPositions.some(pos =>
                    pos[0] === advisor.row && pos[1] === advisor.col
                );
                if (!valid) {
                    errors.push(`âŒ ç´…ä»•ä½ç½®éŒ¯èª¤ï¼š(${advisor.row},${advisor.col})`);
                }
            }

            for (const advisor of blackAdvisors) {
                const valid = blackValidPositions.some(pos =>
                    pos[0] === advisor.row && pos[1] === advisor.col
                );
                if (!valid) {
                    errors.push(`âŒ é»‘å£«ä½ç½®éŒ¯èª¤ï¼š(${advisor.row},${advisor.col})`);
                }
            }

            return errors;
        }

        // ğŸ”¥ ç¬¬äº”æ­¥ï¼šé©—è­‰ç›¸/è±¡çš„ä½ç½®
        validateElephants() {
            const errors = [];
            const orientation = this.detectOrientation();

            if (!orientation || orientation === 'invalid') {
                return errors;
            }

            let redElephants = [];
            let blackElephants = [];

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        if (piece.type === 'ç›¸' && piece.color === 'red') {
                            redElephants.push({ row, col });
                        } else if (piece.type === 'è±¡' && piece.color === 'black') {
                            blackElephants.push({ row, col });
                        }
                    }
                }
            }

            if (redElephants.length > 2) {
                errors.push('âŒ ç´…ç›¸æœ€å¤šåªèƒ½æœ‰2å€‹');
            }
            if (blackElephants.length > 2) {
                errors.push('âŒ é»‘è±¡æœ€å¤šåªèƒ½æœ‰2å€‹');
            }

            // æ ¹æ“šè¦–è§’æª¢æŸ¥ä½ç½®
            const redValidPositions = orientation === 'red-top' ?
                [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]] :
                [[5,2], [5,6], [7,0], [7,4], [7,8], [9,2], [9,6]];

            const blackValidPositions = orientation === 'black-top' ?
                [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]] :
                [[5,2], [5,6], [7,0], [7,4], [7,8], [9,2], [9,6]];

            for (const elephant of redElephants) {
                const valid = redValidPositions.some(pos =>
                    pos[0] === elephant.row && pos[1] === elephant.col
                );
                if (!valid) {
                    errors.push(`âŒ ç´…ç›¸ä½ç½®éŒ¯èª¤ï¼š(${elephant.row},${elephant.col})`);
                }
            }

            for (const elephant of blackElephants) {
                const valid = blackValidPositions.some(pos =>
                    pos[0] === elephant.row && pos[1] === elephant.col
                );
                if (!valid) {
                    errors.push(`âŒ é»‘è±¡ä½ç½®éŒ¯èª¤ï¼š(${elephant.row},${elephant.col})`);
                }
            }

            return errors;
        }

        // ğŸ”¥ ç¬¬å…­æ­¥ï¼šé©—è­‰å…µ/å’çš„ä½ç½®
        validateSoldiers() {
            const errors = [];
            const orientation = this.detectOrientation();

            if (!orientation || orientation === 'invalid') {
                return errors;
            }

            let redSoldiers = [];
            let blackSoldiers = [];

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        if (piece.type === 'å…µ' && piece.color === 'red') {
                            redSoldiers.push({ row, col });
                        } else if (piece.type === 'å’' && piece.color === 'black') {
                            blackSoldiers.push({ row, col });
                        }
                    }
                }
            }

            if (redSoldiers.length > 5) {
                errors.push('âŒ ç´…å…µæœ€å¤šåªèƒ½æœ‰5å€‹');
            }
            if (blackSoldiers.length > 5) {
                errors.push('âŒ é»‘å’æœ€å¤šåªèƒ½æœ‰5å€‹');
            }

            // æ ¹æ“šè¦–è§’æª¢æŸ¥å…µå’è¦å‰‡
            if (orientation === 'red-top') {
                // ç´…ä¸Šé»‘ä¸‹ï¼šç´…å·±æ–¹0-4è¡Œï¼Œé»‘å·±æ–¹5-9è¡Œ

                // ğŸ”¥ æª¢æŸ¥ç´…å…µ
                const redOwnTerritoryCols = {};
                for (const soldier of redSoldiers) {
                    // ğŸ”¥ ç´…æ–¹å·±æ–¹é ˜åœ°ï¼šåªèƒ½åœ¨3-4è¡Œï¼ˆé è¿‘æ²³ç•Œçš„å‰å…©è¡Œï¼‰
                    if (soldier.row >= 0 && soldier.row <= 4) {
                        if (soldier.row < 3) {
                            // 0-2è¡Œæ˜¯ç´…æ–¹å¾Œæ–¹ï¼Œä¸èƒ½æ”¾å…µ
                            errors.push(`âŒ ç´…å…µåœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨ç¬¬4-5è¡Œï¼ˆé è¿‘æ²³ç•Œï¼‰ï¼Œä¸èƒ½åœ¨ç¬¬${soldier.row + 1}è¡Œ`);
                        } else {
                            // 3-4è¡Œï¼ˆå·±æ–¹å‰ç·šï¼‰ï¼šå¿…é ˆåœ¨0,2,4,6,8åˆ—
                            if (![0, 2, 4, 6, 8].includes(soldier.col)) {
                                errors.push(`âŒ ç´…å…µåœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨1,3,5,7,9åˆ—ï¼š(${soldier.row},${soldier.col})`);
                            }

                            // ğŸ”¥ æª¢æŸ¥åŒåˆ—ç–Šå…µ
                            if (redOwnTerritoryCols[soldier.col]) {
                                errors.push(`âŒ ç´…æ–¹å·±æ–¹é ˜åœ°ç¬¬${soldier.col + 1}åˆ—ä¸èƒ½æœ‰å…©å€‹å…µ`);
                            } else {
                                redOwnTerritoryCols[soldier.col] = true;
                            }
                        }
                    }
                    // éæ²³å¾Œ(5-9è¡Œ)ç„¡é™åˆ¶
                }

                // ğŸ”¥ æª¢æŸ¥é»‘å’
                const blackOwnTerritoryCols = {};
                for (const soldier of blackSoldiers) {
                    // ğŸ”¥ é»‘æ–¹å·±æ–¹é ˜åœ°ï¼šåªèƒ½åœ¨5-6è¡Œï¼ˆé è¿‘æ²³ç•Œçš„å‰å…©è¡Œï¼‰
                    if (soldier.row >= 5 && soldier.row <= 9) {
                        if (soldier.row > 6) {
                            // 7-9è¡Œæ˜¯é»‘æ–¹å¾Œæ–¹ï¼Œä¸èƒ½æ”¾å’
                            errors.push(`âŒ é»‘å’åœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨ç¬¬6-7è¡Œï¼ˆé è¿‘æ²³ç•Œï¼‰ï¼Œä¸èƒ½åœ¨ç¬¬${soldier.row + 1}è¡Œ`);
                        } else {
                            // 5-6è¡Œï¼ˆå·±æ–¹å‰ç·šï¼‰ï¼šå¿…é ˆåœ¨0,2,4,6,8åˆ—
                            if (![0, 2, 4, 6, 8].includes(soldier.col)) {
                                errors.push(`âŒ é»‘å’åœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨1,3,5,7,9åˆ—ï¼š(${soldier.row},${soldier.col})`);
                            }

                            // ğŸ”¥ æª¢æŸ¥åŒåˆ—ç–Šå…µ
                            if (blackOwnTerritoryCols[soldier.col]) {
                                errors.push(`âŒ é»‘æ–¹å·±æ–¹é ˜åœ°ç¬¬${soldier.col + 1}åˆ—ä¸èƒ½æœ‰å…©å€‹å’`);
                            } else {
                                blackOwnTerritoryCols[soldier.col] = true;
                            }
                        }
                    }
                    // éæ²³å¾Œ(0-4è¡Œ)ç„¡é™åˆ¶
                }

            } else if (orientation === 'black-top') {
                // é»‘ä¸Šç´…ä¸‹ï¼ˆæ¨™æº–è¦–è§’ï¼‰ï¼šé»‘å·±æ–¹0-4è¡Œï¼Œç´…å·±æ–¹5-9è¡Œ

                // ğŸ”¥ æª¢æŸ¥é»‘å’
                const blackOwnTerritoryCols = {};
                for (const soldier of blackSoldiers) {
                    // ğŸ”¥ é»‘æ–¹å·±æ–¹é ˜åœ°ï¼šåªèƒ½åœ¨3-4è¡Œï¼ˆé è¿‘æ²³ç•Œçš„å‰å…©è¡Œï¼‰
                    if (soldier.row >= 0 && soldier.row <= 4) {
                        if (soldier.row < 3) {
                            // 0-2è¡Œæ˜¯é»‘æ–¹å¾Œæ–¹ï¼Œä¸èƒ½æ”¾å’
                            errors.push(`âŒ é»‘å’åœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨ç¬¬4-5è¡Œï¼ˆé è¿‘æ²³ç•Œï¼‰ï¼Œä¸èƒ½åœ¨ç¬¬${soldier.row + 1}è¡Œ`);
                        } else {
                            // 3-4è¡Œï¼ˆå·±æ–¹å‰ç·šï¼‰ï¼šå¿…é ˆåœ¨0,2,4,6,8åˆ—
                            if (![0, 2, 4, 6, 8].includes(soldier.col)) {
                                errors.push(`âŒ é»‘å’åœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨1,3,5,7,9åˆ—ï¼š(${soldier.row},${soldier.col})`);
                            }

                            // ğŸ”¥ æª¢æŸ¥åŒåˆ—ç–Šå…µ
                            if (blackOwnTerritoryCols[soldier.col]) {
                                errors.push(`âŒ é»‘æ–¹å·±æ–¹é ˜åœ°ç¬¬${soldier.col + 1}åˆ—ä¸èƒ½æœ‰å…©å€‹å’`);
                            } else {
                                blackOwnTerritoryCols[soldier.col] = true;
                            }
                        }
                    }
                    // éæ²³å¾Œ(5-9è¡Œ)ç„¡é™åˆ¶
                }

                // ğŸ”¥ æª¢æŸ¥ç´…å…µ
                const redOwnTerritoryCols = {};
                for (const soldier of redSoldiers) {
                    // ğŸ”¥ ç´…æ–¹å·±æ–¹é ˜åœ°ï¼šåªèƒ½åœ¨5-6è¡Œï¼ˆé è¿‘æ²³ç•Œçš„å‰å…©è¡Œï¼‰
                    if (soldier.row >= 5 && soldier.row <= 9) {
                        if (soldier.row > 6) {
                            // 7-9è¡Œæ˜¯ç´…æ–¹å¾Œæ–¹ï¼Œä¸èƒ½æ”¾å…µ
                            errors.push(`âŒ ç´…å…µåœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨ç¬¬6-7è¡Œï¼ˆé è¿‘æ²³ç•Œï¼‰ï¼Œä¸èƒ½åœ¨ç¬¬${soldier.row + 1}è¡Œ`);
                        } else {
                            // 5-6è¡Œï¼ˆå·±æ–¹å‰ç·šï¼‰ï¼šå¿…é ˆåœ¨0,2,4,6,8åˆ—
                            if (![0, 2, 4, 6, 8].includes(soldier.col)) {
                                errors.push(`âŒ ç´…å…µåœ¨å·±æ–¹é ˜åœ°åªèƒ½åœ¨1,3,5,7,9åˆ—ï¼š(${soldier.row},${soldier.col})`);
                            }

                            // ğŸ”¥ æª¢æŸ¥åŒåˆ—ç–Šå…µ
                            if (redOwnTerritoryCols[soldier.col]) {
                                errors.push(`âŒ ç´…æ–¹å·±æ–¹é ˜åœ°ç¬¬${soldier.col + 1}åˆ—ä¸èƒ½æœ‰å…©å€‹å…µ`);
                            } else {
                                redOwnTerritoryCols[soldier.col] = true;
                            }
                        }
                    }
                    // éæ²³å¾Œ(0-4è¡Œ)ç„¡é™åˆ¶
                }
            }

            return errors;
        }

        // ğŸ”¥ æª¢æŸ¥å…¶ä»–æ£‹å­æ•¸é‡
        validatePieceCounts() {
            const errors = [];
            const counts = {
                red: { è»Š: 0, ä¿¥: 0, é¦¬: 0, å‚Œ: 0, ç‚®: 0, åŒ…: 0 },
                black: { è»Š: 0, é¦¬: 0, ç‚®: 0, åŒ…: 0 }
            };

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = this.board[row][col];
                    if (piece) {
                        if (piece.color === 'red') {
                            if (counts.red[piece.type] !== undefined) {
                                counts.red[piece.type]++;
                            }
                        } else if (piece.color === 'black') {
                            if (counts.black[piece.type] !== undefined) {
                                counts.black[piece.type]++;
                            }
                        }
                    }
                }
            }

            // æª¢æŸ¥æ•¸é‡é™åˆ¶
            const redChariots = counts.red['è»Š'] + counts.red['ä¿¥'];
            const redHorses = counts.red['é¦¬'] + counts.red['å‚Œ'];
            const redCannons = counts.red['ç‚®'] + counts.red['åŒ…'];

            if (redChariots > 2) errors.push('âŒ ç´…è»Š/ä¿¥æœ€å¤š2å€‹');
            if (redHorses > 2) errors.push('âŒ ç´…é¦¬/å‚Œæœ€å¤š2å€‹');
            if (redCannons > 2) errors.push('âŒ ç´…ç‚®/åŒ…æœ€å¤š2å€‹');

            if (counts.black['è»Š'] > 2) errors.push('âŒ é»‘è»Šæœ€å¤š2å€‹');
            if (counts.black['é¦¬'] > 2) errors.push('âŒ é»‘é¦¬æœ€å¤š2å€‹');
            const blackCannons = counts.black['ç‚®'] + counts.black['åŒ…'];
            if (blackCannons > 2) errors.push('âŒ é»‘ç‚®/åŒ…æœ€å¤š2å€‹');

            return errors;
        }

        // ğŸ”¥ æª¢æŸ¥è·¯å¾‘æ˜¯å¦æš¢é€šï¼ˆè»Šã€å°‡å¸¥å°è‡‰ä½¿ç”¨ï¼‰
        isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow || col !== toCol) {
                if (this.board[row][col]) return false;
                row += rowStep;
                col += colStep;
            }
            return true;
        }

// ğŸ”¥ è¨ˆç®—è·¯å¾‘é–“çš„æ£‹å­æ•¸ï¼ˆç‚®ä½¿ç”¨ï¼‰
        countPiecesBetween(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let count = 0;
            let row = fromRow + rowStep;
            let col = fromCol + colStep;

            while (row !== toRow || col !== toCol) {
                if (this.board[row][col]) count++;
                row += rowStep;
                col += colStep;
            }
            return count;
        }

// ğŸ”¥ æª¢æŸ¥æ£‹å­æ˜¯å¦èƒ½æ”»æ“Šç›®æ¨™ä½ç½®
        canPieceAttack(fromRow, fromCol, toRow, toCol, piece) {
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            switch(piece.type) {
                case 'è»Š':
                case 'ä¿¥':
                    if (fromRow === toRow || fromCol === toCol) {
                        return this.isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'é¦¬':
                case 'å‚Œ':
                    if ((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)) {
                        let blockRow, blockCol;
                        if (rowDiff === 2) {
                            blockRow = fromRow + (toRow > fromRow ? 1 : -1);
                            blockCol = fromCol;
                        } else {
                            blockRow = fromRow;
                            blockCol = fromCol + (toCol > fromCol ? 1 : -1);
                        }
                        return !this.board[blockRow][blockCol];
                    }
                    return false;

                case 'ç‚®':
                case 'åŒ…':
                    if (fromRow === toRow || fromCol === toCol) {
                        const between = this.countPiecesBetween(fromRow, fromCol, toRow, toCol);
                        return between === 1;
                    }
                    return false;

                case 'å…µ':
                case 'å’':
                    const orientation = this.detectOrientation();
                    if (!orientation || orientation === 'invalid') return false;

                    if (orientation === 'red-top') {
                        // ç´…ä¸Šé»‘ä¸‹
                        if (piece.color === 'red') {
                            const forward = 1; // ç´…æ–¹å‘ä¸‹
                            const crossedRiver = fromRow >= 5;
                            if (toRow === fromRow + forward && toCol === fromCol) return true;
                            if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) return true;
                        } else {
                            const forward = -1; // é»‘æ–¹å‘ä¸Š
                            const crossedRiver = fromRow <= 4;
                            if (toRow === fromRow + forward && toCol === fromCol) return true;
                            if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) return true;
                        }
                    } else {
                        // é»‘ä¸Šç´…ä¸‹ï¼ˆæ¨™æº–è¦–è§’ï¼‰
                        if (piece.color === 'black') {
                            const forward = 1; // é»‘æ–¹å‘ä¸‹
                            const crossedRiver = fromRow >= 5;
                            if (toRow === fromRow + forward && toCol === fromCol) return true;
                            if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) return true;
                        } else {
                            const forward = -1; // ç´…æ–¹å‘ä¸Š
                            const crossedRiver = fromRow <= 4;
                            if (toRow === fromRow + forward && toCol === fromCol) return true;
                            if (crossedRiver && toRow === fromRow && Math.abs(toCol - fromCol) === 1) return true;
                        }
                    }
                    return false;

                case 'å°‡':
                case 'å¸¥':
                    const { redKing, blackKing } = this.findKings();
                    const kingPos = piece.color === 'red' ? redKing : blackKing;

                    // 1. æ­£å¸¸ç§»å‹•ï¼ˆä¹å®®æ ¼å…§ä¸€æ ¼ï¼‰
                    const minRow = kingPos.row <= 4 ? 0 : 7;
                    const maxRow = kingPos.row <= 4 ? 2 : 9;

                    if (toRow >= minRow && toRow <= maxRow && toCol >= 3 && toCol <= 5) {
                        if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                            return true;
                        }
                    }

                    // 2. å°‡å¸¥å°è‡‰æ”»æ“Š
                    if (fromCol === toCol) {
                        const targetPiece = this.board[toRow][toCol];
                        if (targetPiece &&
                            (targetPiece.type === 'å°‡' || targetPiece.type === 'å¸¥') &&
                            targetPiece.color !== piece.color) {
                            return this.isPathClear(fromRow, fromCol, toRow, toCol);
                        }
                    }
                    return false;

                case 'å£«':
                case 'ä»•':
                    const advisorMinRow = fromRow <= 4 ? 0 : 7;
                    const advisorMaxRow = fromRow <= 4 ? 2 : 9;
                    return rowDiff === 1 && colDiff === 1 &&
                        toRow >= advisorMinRow && toRow <= advisorMaxRow &&
                        toCol >= 3 && toCol <= 5;

                case 'è±¡':
                case 'ç›¸':
                    if (rowDiff === 2 && colDiff === 2) {
                        const midRow = (fromRow + toRow) / 2;
                        const midCol = (fromCol + toCol) / 2;
                        const elephantMaxRow = fromRow <= 4 ? 4 : 9;
                        return !this.board[midRow][midCol] && toRow <= elephantMaxRow;
                    }
                    return false;
            }
            return false;
        }

// ğŸ”¥ æª¢æŸ¥æŒ‡å®šä½ç½®æ˜¯å¦è¢«å°æ–¹æ”»æ“Š
        isPositionUnderAttack(row, col, color) {
            const opponent = color === 'red' ? 'black' : 'red';

            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 9; j++) {
                    const piece = this.board[i][j];
                    if (piece && piece.color === opponent) {
                        if (this.canPieceAttack(i, j, row, col, piece)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

// ğŸ”¥ æª¢æŸ¥æ˜¯å¦è¢«å°‡è»
        isCheck(color) {
            const { redKing, blackKing } = this.findKings();
            const kingPos = color === 'red' ? redKing : blackKing;

            if (!kingPos) return false;

            return this.isPositionUnderAttack(kingPos.row, kingPos.col, color);
        }

// ğŸ”¥ æ·±æ‹·è²æ£‹ç›¤
        deepCopyBoard() {
            const copy = [];
            for (let i = 0; i < 10; i++) {
                copy[i] = [];
                for (let j = 0; j < 9; j++) {
                    copy[i][j] = this.board[i][j] ? { ...this.board[i][j] } : null;
                }
            }
            return copy;
        }

// ğŸ”¥ æª¢æŸ¥æ˜¯å¦æœ‰åˆæ³•ç§»å‹•
        hasLegalMoves(color) {
            for (let fromRow = 0; fromRow < 10; fromRow++) {
                for (let fromCol = 0; fromCol < 9; fromCol++) {
                    const piece = this.board[fromRow][fromCol];
                    if (piece && piece.color === color) {
                        for (let toRow = 0; toRow < 10; toRow++) {
                            for (let toCol = 0; toCol < 9; toCol++) {
                                if (fromRow === toRow && fromCol === toCol) continue;

                                const target = this.board[toRow][toCol];
                                if (target && target.color === color) continue;

                                if (this.canPieceAttack(fromRow, fromCol, toRow, toCol, piece)) {
                                    // æ¨¡æ“¬ç§»å‹•
                                    const boardCopy = this.deepCopyBoard();
                                    boardCopy[toRow][toCol] = piece;
                                    boardCopy[fromRow][fromCol] = null;

                                    // æª¢æŸ¥ç§»å‹•å¾Œæ˜¯å¦é‚„è¢«å°‡è»
                                    const tempValidator = new PhotoRecognitionValidator(boardCopy);
                                    const stillInCheck = tempValidator.isCheck(color);

                                    if (!stillInCheck) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

// ğŸ”¥ æª¢æŸ¥æ˜¯å¦è¢«å°‡æ­»
        isCheckmate(color) {
            if (!this.isCheck(color)) return false;
            return !this.hasLegalMoves(color);
        }

// ğŸ”¥ æª¢æŸ¥æ˜¯å¦å›°æ–ƒ
        isStalemate(color) {
            if (this.isCheck(color)) return false;
            return !this.hasLegalMoves(color);
        }

// ğŸ”¥ é©—è­‰èµ°æ£‹æ–¹çš„åˆæ³•æ€§
        validateCurrentPlayer(currentPlayer) {
            const errors = [];

            const redCheck = this.isCheck('red');
            const blackCheck = this.isCheck('black');
            const redCheckmate = this.isCheckmate('red');
            const blackCheckmate = this.isCheckmate('black');

            // æœ€é«˜å„ªå…ˆç´šï¼šå°‡æ­»æª¢æŸ¥
            if (redCheckmate) {
                errors.push('âŒ ç´…æ–¹å·²è¢«å°‡æ­»ï¼Œä¸èƒ½è®“ä»»ä½•ä¸€æ–¹å…ˆèµ°');
                return errors;
            }
            if (blackCheckmate) {
                errors.push('âŒ é»‘æ–¹å·²è¢«å°‡æ­»ï¼Œä¸èƒ½è®“ä»»ä½•ä¸€æ–¹å…ˆèµ°');
                return errors;
            }

            // å›°æ–ƒæª¢æŸ¥
            const redStalemate = this.isStalemate('red');
            const blackStalemate = this.isStalemate('black');

            if (redStalemate && currentPlayer === 'red') {
                errors.push('âŒ ç´…æ–¹å·²å›°æ–ƒï¼ˆç„¡å­å¯å‹•ï¼‰ï¼Œä¸èƒ½è®“ç´…æ–¹å…ˆèµ°');
            }
            if (blackStalemate && currentPlayer === 'black') {
                errors.push('âŒ é»‘æ–¹å·²å›°æ–ƒï¼ˆç„¡å­å¯å‹•ï¼‰ï¼Œä¸èƒ½è®“é»‘æ–¹å…ˆèµ°');
            }

            // å°‡è»æª¢æŸ¥
            if (redCheck && currentPlayer === 'black') {
                errors.push('âš ï¸ ç´…æ–¹æ­£è¢«å°‡è»ï¼Œä¸èƒ½è®“é»‘æ–¹å…ˆèµ°ï¼ˆå°æ–¹å¯ç›´æ¥åƒå¸¥ï¼‰');
            }
            if (blackCheck && currentPlayer === 'red') {
                errors.push('âš ï¸ é»‘æ–¹æ­£è¢«å°‡è»ï¼Œä¸èƒ½è®“ç´…æ–¹å…ˆèµ°ï¼ˆå°æ–¹å¯ç›´æ¥åƒå°‡ï¼‰');
            }

            return errors;
        }

        // ğŸ”¥ å®Œæ•´é©—è­‰ï¼ˆä¿®æ”¹ç‰ˆï¼‰
        validateAll(currentPlayer = 'red') {
            const allErrors = [];

            // 1. æª¢æŸ¥å°‡å¸¥
            const kingErrors = this.validateKingPositions();
            allErrors.push(...kingErrors);

            if (kingErrors.length > 0) {
                return allErrors; // å°‡å¸¥æœ‰å•é¡Œå°±ä¸ç¹¼çºŒæª¢æŸ¥äº†
            }

            // 2. æª¢æŸ¥å°‡å¸¥å°è‡‰
            if (this.areKingsFacing()) {
                allErrors.push('âŒ å°‡å¸¥ä¸èƒ½å°è‡‰');
            }

            // 3. æª¢æŸ¥å£«
            allErrors.push(...this.validateAdvisors());

            // 4. æª¢æŸ¥ç›¸/è±¡
            allErrors.push(...this.validateElephants());

            // 5. æª¢æŸ¥å…µ/å’
            allErrors.push(...this.validateSoldiers());

            // 6. æª¢æŸ¥å…¶ä»–æ£‹å­æ•¸é‡
            allErrors.push(...this.validatePieceCounts());

            // ğŸ”¥ 7. æª¢æŸ¥å°‡è»ã€å°‡æ­»ã€å›°æ–ƒç‹€æ…‹
            allErrors.push(...this.validateCurrentPlayer(currentPlayer));

            return allErrors;
        }
    }


    // åœ¨è‡ªå®šç¾©æ£‹ç›¤æŒ‰éˆ•å¾Œé¢æ·»åŠ æ‹ç…§è­˜åˆ¥æŒ‰éˆ•
    function addPhotoRecognitionButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const photoButton = document.createElement('button');
        photoButton.textContent = 'ğŸ“¸ æ‹ç…§è­˜åˆ¥';

        if (regretButton) {
            photoButton.className = regretButton.className;
            photoButton.style.cssText = regretButton.style.cssText;
        } else {
            photoButton.style.cssText = `
            padding: 12px 20px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        `;
        }

        let photoInstance = null;

        photoButton.addEventListener('click', function() {
            if (!photoInstance) {
                photoInstance = createPhotoRecognitionInterface();
                photoButton.textContent = 'é—œé–‰è­˜åˆ¥';
                photoButton.style.backgroundColor = '#dc3545';

                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node === photoInstance?.container) {
                                    photoInstance = null;
                                    photoButton.textContent = 'ğŸ“¸ æ‹ç…§è­˜åˆ¥';
                                    photoButton.style.backgroundColor = '#17a2b8';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                photoInstance.close();
            }
        });

        buttonContainer.appendChild(photoButton);

        return {
            button: photoButton,
            getCurrentInstance: () => photoInstance
        };
    }

    // å‰µå»ºæ‹ç…§è­˜åˆ¥ç•Œé¢
    function createPhotoRecognitionInterface() {

        // ğŸ”¥ é€²å…¥ç•Œé¢æ™‚ç«‹å³é‡ç½®æ‰€æœ‰å…¨å±€è®Šé‡
        console.log('ğŸ”„ æ­£åœ¨é‡ç½®æ‹ç…§è­˜åˆ¥ç³»çµ±çš„å…¨å±€è®Šé‡...');

        // é‡ç½®æ¨¡å¼æ¨™è¨˜
        window.isOnlineMode = false;

        // é‡ç½®é€è¦–æ ¡æ­£ç›¸é—œ
        window.perspectiveMatrix = null;
        window.originalCorners = null;
        window.originalCanvasSize = null;

        // é‡ç½® Canvas ç›¸é—œ
        window.originalFullCanvas = null;
        window.correctedFullCanvas = null;

        // é‡ç½®æ£‹ç›¤ç›¸é—œ
        window.corners = [];
        window.boardBoundingBox = null;

        console.log('âœ… å…¨å±€è®Šé‡å·²é‡ç½®å®Œç•¢');

        const container = document.createElement('div');
        container.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

        const mainPanel = document.createElement('div');
        mainPanel.style.cssText = `
    background: white;
    border-radius: 10px;
    width: 95%;
    max-width: 1200px;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    overflow-y: auto;
`;
        const leftPanel = document.createElement('div');
        leftPanel.style.cssText = `
    width: 100%;
    background: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    flex-shrink: 0;
`;
        const leftTitle = document.createElement('h3');
        leftTitle.textContent = 'è™›æ“¬æ£‹ç›¤é è¦½';
        leftTitle.style.cssText = `
        margin: 0 0 15px 0;
        text-align: center;
        color: #333;
        font-size: 18px;
    `;

        // ç‹€æ…‹é¡¯ç¤º
        const statusDisplay = document.createElement('div');
        statusDisplay.style.cssText = `
        padding: 10px;
        background: #e7f3ff;
        border-radius: 5px;
        margin-bottom: 15px;
        font-size: 14px;
        color: #0066cc;
        text-align: center;
    `;
        statusDisplay.textContent = 'ç­‰å¾… AI è­˜åˆ¥çµæœ...';

        // ğŸ”¥ å‰µå»ºè™›æ“¬æ£‹ç›¤çš„è¦å‰‡é©—è­‰å™¨ï¼ˆç¨ç«‹å¯¦ä¾‹ï¼‰
        const virtualValidator = new ChessRuleValidator();

// ğŸ”¥ è¼‰å…¥ä¸»æ£‹ç›¤çš„ç•¶å‰å±€é¢
        if (typeof gameState !== 'undefined' && gameState.board) {
            console.log('ğŸ“¥ è™›æ“¬æ£‹ç›¤è¼‰å…¥ä¸»æ£‹ç›¤å±€é¢...');
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece) {
                        virtualValidator.customBoard[row][col] = {
                            type: piece.type,
                            color: piece.color
                        };
                    }
                }
            }
            virtualValidator.currentPlayer = gameState.currentTurn || 'red';

            // ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥ä¸»æ£‹ç›¤æ˜¯å¦ç¿»è½‰ï¼ŒåŒæ­¥ç¿»è½‰è™›æ“¬æ£‹ç›¤
            const isMainBoardFlipped = gameState.isFlipped || false;
            if (isMainBoardFlipped) {
                console.log('ğŸ”„ ä¸»æ£‹ç›¤å·²ç¿»è½‰ï¼ˆç´…ä¸Šé»‘ä¸‹ï¼‰ï¼Œè™›æ“¬æ£‹ç›¤åŒæ­¥ç¿»è½‰...');
                virtualValidator.customBoard = flipBoardData(virtualValidator.customBoard);
            }

            console.log('âœ… è™›æ“¬æ£‹ç›¤å·²è¼‰å…¥ä¸»æ£‹ç›¤å±€é¢ï¼Œè¦–è§’å·²åŒæ­¥');
        } else {
            // å¦‚æœæ²’æœ‰ä¸»æ£‹ç›¤ï¼Œä½¿ç”¨åˆå§‹ç›¤é¢
            virtualValidator.resetToInitial();
        }

        // è™›æ“¬æ£‹ç›¤é¡¯ç¤ºå€
        const boardDisplay = document.createElement('div');
        boardDisplay.style.cssText = `
        text-align: center;
        margin-bottom: 15px;
    `;

        const boardContainer = document.createElement('div');
        boardContainer.style.cssText = `
        display: inline-block;
        background: #f4d03f;
        padding: 20px;
        border: 3px solid #8b4513;
        border-radius: 8px;
    `;

        // ğŸ”¥ å‰µå»ºå®Œæ•´çš„è±¡æ£‹æ£‹ç›¤ï¼ˆå®Œå…¨ä»¿ç…§è‡ªå®šç¾©æ£‹ç›¤ï¼‰
        function createVirtualChessBoard() {
            boardContainer.innerHTML = '';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '300');   // æ”¹å°ï¼šåŸæœ¬ 360
            svg.setAttribute('height', '366');  // æ”¹å°ï¼šåŸæœ¬ 440
            svg.style.cssText = `
    background: #f4d03f;
    border: 2px solid #8b4513;
`;

            const cellWidth = 33.33;   // æ”¹å°ï¼šåŸæœ¬ 40
            const cellHeight = 36.6;   // æ”¹å°ï¼šåŸæœ¬ 44
            const startX = 16.67;      // æ”¹å°ï¼šåŸæœ¬ 20
            const startY = 16.67;      // æ”¹å°ï¼šåŸæœ¬ 20

            // ç¹ªè£½ç¸±ç·š
            for (let i = 0; i < 9; i++) {
                const x = startX + i * cellWidth;
                if (i === 0 || i === 8) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', startY);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', startY + 9 * cellHeight);
                    line.setAttribute('stroke', '#8b4513');
                    line.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line);
                } else {
                    const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line1.setAttribute('x1', x);
                    line1.setAttribute('y1', startY);
                    line1.setAttribute('x2', x);
                    line1.setAttribute('y2', startY + 4 * cellHeight);
                    line1.setAttribute('stroke', '#8b4513');
                    line1.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line1);

                    const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line2.setAttribute('x1', x);
                    line2.setAttribute('y1', startY + 5 * cellHeight);
                    line2.setAttribute('x2', x);
                    line2.setAttribute('y2', startY + 9 * cellHeight);
                    line2.setAttribute('stroke', '#8b4513');
                    line2.setAttribute('stroke-width', '1.5');
                    svg.appendChild(line2);
                }
            }

            // ç¹ªè£½æ©«ç·š
            for (let i = 0; i < 10; i++) {
                const y = startY + i * cellHeight;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', y);
                line.setAttribute('x2', startX + 8 * cellWidth);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#8b4513');
                line.setAttribute('stroke-width', '1.5');
                svg.appendChild(line);
            }

            // ç¹ªè£½ä¹å®®æ ¼å°è§’ç·š
            const blackDiag1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            blackDiag1.setAttribute('x1', startX + 3 * cellWidth);
            blackDiag1.setAttribute('y1', startY);
            blackDiag1.setAttribute('x2', startX + 5 * cellWidth);
            blackDiag1.setAttribute('y2', startY + 2 * cellHeight);
            blackDiag1.setAttribute('stroke', '#8b4513');
            blackDiag1.setAttribute('stroke-width', '1.5');
            svg.appendChild(blackDiag1);

            const blackDiag2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            blackDiag2.setAttribute('x1', startX + 5 * cellWidth);
            blackDiag2.setAttribute('y1', startY);
            blackDiag2.setAttribute('x2', startX + 3 * cellWidth);
            blackDiag2.setAttribute('y2', startY + 2 * cellHeight);
            blackDiag2.setAttribute('stroke', '#8b4513');
            blackDiag2.setAttribute('stroke-width', '1.5');
            svg.appendChild(blackDiag2);

            const redDiag1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            redDiag1.setAttribute('x1', startX + 3 * cellWidth);
            redDiag1.setAttribute('y1', startY + 7 * cellHeight);
            redDiag1.setAttribute('x2', startX + 5 * cellWidth);
            redDiag1.setAttribute('y2', startY + 9 * cellHeight);
            redDiag1.setAttribute('stroke', '#8b4513');
            redDiag1.setAttribute('stroke-width', '1.5');
            svg.appendChild(redDiag1);

            const redDiag2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            redDiag2.setAttribute('x1', startX + 5 * cellWidth);
            redDiag2.setAttribute('y1', startY + 7 * cellHeight);
            redDiag2.setAttribute('x2', startX + 3 * cellWidth);
            redDiag2.setAttribute('y2', startY + 9 * cellHeight);
            redDiag2.setAttribute('stroke', '#8b4513');
            redDiag2.setAttribute('stroke-width', '1.5');
            svg.appendChild(redDiag2);

            // æ·»åŠ æ¥šæ²³æ¼¢ç•Œæ–‡å­—
            const riverText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            riverText.setAttribute('x', startX + 1.2 * cellWidth);
            riverText.setAttribute('y', startY + 4.5 * cellHeight + 8);
            riverText.setAttribute('fill', '#2c3e50');
            riverText.setAttribute('font-size', '14');
            riverText.setAttribute('font-weight', 'bold');
            riverText.textContent = 'æ¥šæ²³';
            svg.appendChild(riverText);

            const boundaryText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            boundaryText.setAttribute('x', startX + 5.8 * cellWidth);
            boundaryText.setAttribute('y', startY + 4.5 * cellHeight + 8);
            boundaryText.setAttribute('fill', '#2c3e50');
            boundaryText.setAttribute('font-size', '14');
            boundaryText.setAttribute('font-weight', 'bold');
            boundaryText.textContent = 'æ¼¢ç•Œ';
            svg.appendChild(boundaryText);

            // ğŸ”¥ æ¸²æŸ“æ£‹å­
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = virtualValidator.customBoard[row][col];
                    if (piece) {
                        const cx = startX + col * cellWidth;
                        const cy = startY + row * cellHeight;

                        // æ£‹å­åœ“åœˆ
                        const pieceCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        pieceCircle.setAttribute('cx', cx);
                        pieceCircle.setAttribute('cy', cy);
                        pieceCircle.setAttribute('r', '13');
                        pieceCircle.setAttribute('fill', piece.color === 'red' ? '#ff4757' : '#2f3542');
                        pieceCircle.setAttribute('stroke', 'white');
                        pieceCircle.setAttribute('stroke-width', '2');
                        svg.appendChild(pieceCircle);

                        // æ£‹å­æ–‡å­—
                        const pieceText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        pieceText.setAttribute('x', cx);
                        pieceText.setAttribute('y', cy);
                        pieceText.setAttribute('text-anchor', 'middle');
                        pieceText.setAttribute('dominant-baseline', 'central');
                        pieceText.setAttribute('fill', 'white');
                        pieceText.setAttribute('font-size', '12');
                        pieceText.setAttribute('font-weight', 'bold');
                        pieceText.textContent = piece.type;
                        svg.appendChild(pieceText);
                    }
                }
            }

            // ğŸ”¥ æ–°å¢ï¼šå‰µå»ºå¯é»æ“Šçš„äº¤äº’é»
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');

                    const cx = startX + col * cellWidth;
                    const cy = startY + row * cellHeight;

                    circle.setAttribute('cx', cx);
                    circle.setAttribute('cy', cy);
                    circle.setAttribute('r', '8');
                    circle.setAttribute('fill', 'transparent');
                    circle.setAttribute('stroke', 'transparent');
                    circle.setAttribute('cursor', 'pointer');
                    circle.setAttribute('data-row', row);
                    circle.setAttribute('data-col', col);

                    circle.addEventListener('mouseenter', () => {
                        circle.setAttribute('fill', 'rgba(0,123,255,0.2)');
                    });

                    circle.addEventListener('mouseleave', () => {
                        circle.setAttribute('fill', 'transparent');
                    });

                    circle.addEventListener('click', () => {
                        const existingPiece = virtualValidator.customBoard[row][col];

                        // æ¸…é™¤æ¨¡å¼
                        if (selectedPiece === 'clear') {
                            if (existingPiece) {
                                virtualValidator.clearPiece(row, col);
                                createVirtualChessBoard();
                                statusDisplay.textContent = `å·²æ¸…é™¤ ${existingPiece.color === 'red' ? 'ç´…' : 'é»‘'}${existingPiece.type}`;
                                statusDisplay.style.background = '#d4edda';
                                statusDisplay.style.color = '#155724';
                            }
                            return;
                        }

// æ”¾ç½®æ¨¡å¼
                        if (selectedPiece && selectedPiece !== 'clear') {
                            if (existingPiece) {
                                // é¸ä¸­æ£‹å­æ¨¡å¼
                                selectedPosition = { row, col, piece: existingPiece };
                                selectedPiece = null;
                                document.querySelectorAll('.selected-piece').forEach(btn => {
                                    btn.classList.remove('selected-piece');
                                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                                });
                                createVirtualChessBoard();
                                statusDisplay.textContent = `å·²é¸ä¸­ ${existingPiece.color === 'red' ? 'ç´…' : 'é»‘'}${existingPiece.type}`;
                                statusDisplay.style.background = '#fff3cd';
                                statusDisplay.style.color = '#856404';
                                return;
                            }

                            // ğŸ”¥ ä¿®æ”¹ï¼šç›´æ¥æ”¾ç½®ï¼Œä¸æª¢æŸ¥
                            virtualValidator.customBoard[row][col] = selectedPiece;
                            selectedPosition = null;
                            createVirtualChessBoard();
                            statusDisplay.textContent = `å·²æ”¾ç½® ${selectedPiece.color === 'red' ? 'ç´…' : 'é»‘'}${selectedPiece.type}`;
                            statusDisplay.style.background = '#d4edda';
                            statusDisplay.style.color = '#155724';
                            return;
                        }

// ç§»å‹•æ¨¡å¼
                        if (selectedPosition && selectedPosition.row !== undefined) {
                            const fromRow = selectedPosition.row;
                            const fromCol = selectedPosition.col;
                            const movingPiece = virtualValidator.customBoard[fromRow][fromCol];

                            if (movingPiece) {
                                // ğŸ”¥ ä¿®æ”¹ï¼šç›´æ¥ç§»å‹•ï¼Œä¸æª¢æŸ¥
                                virtualValidator.customBoard[fromRow][fromCol] = null;
                                virtualValidator.customBoard[row][col] = movingPiece;
                                selectedPosition = null;
                                createVirtualChessBoard();
                                statusDisplay.textContent = `${movingPiece.color === 'red' ? 'ç´…' : 'é»‘'}${movingPiece.type} å·²ç§»å‹•`;
                                statusDisplay.style.background = '#d4edda';
                                statusDisplay.style.color = '#155724';
                            }
                            return;
                        }

// é¸ä¸­æ£‹ç›¤ä¸Šçš„æ£‹å­
                        if (existingPiece) {
                            selectedPosition = { row, col, piece: existingPiece };
                            selectedPiece = null;
                            document.querySelectorAll('.selected-piece').forEach(btn => {
                                btn.classList.remove('selected-piece');
                                const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                                btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                            });
                            createVirtualChessBoard();
                            statusDisplay.textContent = `å·²é¸ä¸­ ${existingPiece.color === 'red' ? 'ç´…' : 'é»‘'}${existingPiece.type}`;
                            statusDisplay.style.background = '#fff3cd';
                            statusDisplay.style.color = '#856404';
                        }
                    });

                    svg.appendChild(circle);
                }
            }

            boardContainer.appendChild(svg);
        }

        createVirtualChessBoard();
        boardDisplay.appendChild(boardContainer);

        // ğŸ”¥ FEN å°å…¥åŠŸèƒ½
        const fenInput = document.createElement('textarea');
        fenInput.placeholder = 'AI è­˜åˆ¥å¾Œçš„ FEN ç¢¼å°‡è‡ªå‹•å¡«å…¥æ­¤è™•...';
        fenInput.style.cssText = `
        width: 100%;
        height: 80px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        resize: vertical;
        font-family: monospace;
        font-size: 12px;
        margin-bottom: 10px;
    `;

        // ğŸ”¥ FEN ç¢¼è§£æå‡½æ•¸
        function parseFENToBoard(fen) {
            const pieceMap = {
                'K': { type: 'å¸¥', color: 'red' },
                'A': { type: 'ä»•', color: 'red' },
                'B': { type: 'ç›¸', color: 'red' },
                'N': { type: 'å‚Œ', color: 'red' },
                'R': { type: 'ä¿¥', color: 'red' },
                'C': { type: 'ç‚®', color: 'red' },
                'P': { type: 'å…µ', color: 'red' },
                'k': { type: 'å°‡', color: 'black' },
                'a': { type: 'å£«', color: 'black' },
                'b': { type: 'è±¡', color: 'black' },
                'n': { type: 'é¦¬', color: 'black' },
                'r': { type: 'è»Š', color: 'black' },
                'c': { type: 'åŒ…', color: 'black' },
                'p': { type: 'å’', color: 'black' }
            };

            virtualValidator.clearBoard();

            const parts = fen.trim().split(' ');
            const rows = parts[0].split('/');

            for (let row = 0; row < Math.min(10, rows.length); row++) {
                let col = 0;
                for (let char of rows[row]) {
                    if (char >= '1' && char <= '9') {
                        col += parseInt(char);
                    } else if (pieceMap[char]) {
                        if (col < 9) {
                            virtualValidator.customBoard[row][col] = {
                                type: pieceMap[char].type,
                                color: pieceMap[char].color
                            };
                            col++;
                        }
                    }
                }
            }

            // è¨­ç½®èµ°æ£‹æ–¹
            if (parts.length > 1) {
                virtualValidator.currentPlayer = parts[1] === 'w' ? 'red' : 'black';
            }

            createVirtualChessBoard();


                statusDisplay.textContent = 'âœ… FEN ç¢¼å·²æˆåŠŸè§£æä¸¦é¡¯ç¤º';
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';
                return true;
            }


        // ğŸ”¥ æ‡‰ç”¨ FEN æŒ‰éˆ•
        const applyFenBtn = document.createElement('button');
        applyFenBtn.textContent = 'é è¦½ FEN ç¢¼';
        applyFenBtn.style.cssText = `
    width: 100%;
    padding: 10px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin-bottom: 10px;
`;

        // ğŸ”¥ å°å…¥åˆ°ä¸»æ£‹ç›¤æŒ‰éˆ•
        const applyToMainBtn = document.createElement('button');
        applyToMainBtn.textContent = 'å°å…¥åˆ°ä¸»æ£‹ç›¤';
        applyToMainBtn.style.cssText = `
    width: 100%;
    padding: 10px;
    background: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin-bottom: 10px;
`;
        applyToMainBtn.addEventListener('click', () => {
            // ğŸ”¥ğŸ”¥ğŸ”¥ ä½¿ç”¨è¦–è§’ç„¡é—œçš„é©—è­‰å™¨ï¼Œä¸¦å‚³å…¥èµ°æ£‹æ–¹
            const photoValidator = new PhotoRecognitionValidator(virtualValidator.customBoard);
            const errors = photoValidator.validateAll(virtualValidator.currentPlayer);

            if (errors.length > 0) {
                const randomError = errors[Math.floor(Math.random() * errors.length)];
                statusDisplay.innerHTML = `âŒ ç„¡æ³•åŒ¯å…¥ï¼æ£‹ç›¤ä¸ç¬¦åˆè¦å‰‡ï¼š<br><strong>${randomError}</strong><br><span style="font-size: 12px; opacity: 0.8;">(å…±${errors.length}å€‹å•é¡Œï¼Œè«‹ä¿®æ­£å¾Œå†åŒ¯å…¥)</span>`;
                statusDisplay.style.background = '#f8d7da';
                statusDisplay.style.color = '#721c24';
                console.error('âŒ è¦å‰‡é©—è­‰å¤±æ•—:', errors);
                return; // ğŸš« é˜»æ­¢å¾ŒçºŒç¨‹å¼ç¢¼åŸ·è¡Œ
            }

            console.log('âœ… è¦å‰‡é©—è­‰é€šéï¼ˆåŒ…å«å°‡è»ç‹€æ…‹æª¢æŸ¥ï¼‰ï¼Œé–‹å§‹åŒ¯å…¥...');

            // ğŸ”¥ æ­¥é©Ÿ 1ï¼šå–å¾—åŸå§‹è­˜åˆ¥çµæœçš„ FEN ç¢¼ï¼ˆæœªç¿»è½‰ï¼‰
            const originalBoard = virtualValidator.customBoard;
            const originalPlayer = virtualValidator.currentPlayer;
            const originalFen = boardToFEN(originalBoard);

            // ğŸ”¥ æ­¥é©Ÿ 2ï¼šæª¢æŸ¥å° k (é»‘å°‡) åœ¨ç¬¬å¹¾åˆ—
            const rows = originalFen.split(' ')[0].split('/');
            const topHalf = rows.slice(0, 5).join('');  // ç¬¬ 1-5 åˆ—
            const bottomHalf = rows.slice(5, 10).join(''); // ç¬¬ 6-10 åˆ—

            const blackKingInTop = /k/.test(topHalf);    // å°kåœ¨ä¸Š = é»‘ä¸Šç´…ä¸‹
            const blackKingInBottom = /k/.test(bottomHalf); // å°kåœ¨ä¸‹ = ç´…ä¸Šé»‘ä¸‹

            console.log('ğŸ” åŸå§‹è­˜åˆ¥çµæœ FEN:', originalFen);
            console.log('  é»‘å°‡ä½ç½®:', blackKingInTop ? 'ä¸ŠåŠéƒ¨(1-5åˆ—)' : 'ä¸‹åŠéƒ¨(6-10åˆ—)');

            // ğŸ”¥ æ­¥é©Ÿ 3ï¼šæª¢æŸ¥ä¸»æ£‹ç›¤ç•¶å‰è¦–è§’
            const currentFlipState = (typeof gameState !== 'undefined' && gameState.isFlipped) || false;
            const mainBoardIsBlackTop = !currentFlipState; // isFlipped=false ä»£è¡¨é»‘ä¸Šç´…ä¸‹

            console.log('ğŸ” ä¸»æ£‹ç›¤ç•¶å‰è¦–è§’:', mainBoardIsBlackTop ? 'é»‘ä¸Šç´…ä¸‹' : 'ç´…ä¸Šé»‘ä¸‹');

            // ğŸ”¥ æ­¥é©Ÿ 4ï¼šåˆ¤æ–·æ˜¯å¦éœ€è¦è©¢å•
            const recognitionIsBlackTop = blackKingInTop;
            const needAsk = (recognitionIsBlackTop !== mainBoardIsBlackTop);

            console.log('ğŸ¤” è­˜åˆ¥çµæœè¦–è§’:', recognitionIsBlackTop ? 'é»‘ä¸Šç´…ä¸‹' : 'ç´…ä¸Šé»‘ä¸‹');
            console.log('ğŸ¤” æ˜¯å¦éœ€è¦è©¢å•:', needAsk);

            if (!needAsk) {
                // âœ… è¦–è§’ä¸€è‡´ï¼Œç›´æ¥å°å…¥
                console.log('âœ… è¦–è§’ä¸€è‡´ï¼Œç›´æ¥å°å…¥');

                // æ¨™æº–åŒ–ç‚ºé»‘ä¸Šç´…ä¸‹
                let finalBoard = originalBoard;
                if (!recognitionIsBlackTop) {
                    finalBoard = flipBoardData(originalBoard);
                }

                // è¨­å®šä¸»æ£‹ç›¤è¦–è§’
                if (!mainBoardIsBlackTop) {
                    // ä¸»æ£‹ç›¤ç•¶å‰æ˜¯ç´…ä¸Šé»‘ä¸‹ï¼Œå…ˆåˆ‡å›é»‘ä¸Šç´…ä¸‹å†å°å…¥
                    if (typeof applyBoardFlip === 'function') {
                        applyBoardFlip(false);
                    } else if (typeof gameState !== 'undefined') {
                        gameState.isFlipped = false;
                    }
                }

                applyToMainBoard(finalBoard, originalPlayer);

                statusDisplay.innerHTML = `
            <div style="text-align: center;">
                âœ… å°å…¥æˆåŠŸï¼è¦–è§’èˆ‡åŸæ£‹ç›¤ä¸€è‡´
            </div>
        `;
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';

            } else {
                // â“ è¦–è§’ä¸ä¸€è‡´ï¼Œè©¢å•ç”¨æˆ¶
                showOrientationChoice(originalBoard, originalPlayer, recognitionIsBlackTop, mainBoardIsBlackTop);
            }
        });

        function flipBoardData(board) {
            const flipped = [];
            for (let row = 0; row < 10; row++) {
                flipped[row] = [];
                for (let col = 0; col < 9; col++) {
                    // âœ… åªç¿»è½‰ rowï¼ˆä¸Šä¸‹ï¼‰ï¼Œcol ä¿æŒä¸è®Šï¼ˆå·¦å³ä¸è®Šï¼‰
                    const piece = board[9 - row][col];
                    if (piece) {
                        flipped[row][col] = {
                            type: piece.type,
                            color: piece.color
                        };
                    } else {
                        flipped[row][col] = null;
                    }
                }
            }
            return flipped;
        }

// ğŸ”¥ boardToFEN å‡½æ•¸ï¼ˆç”Ÿæˆ FEN ç¢¼ï¼‰
        function boardToFEN(board) {
            const pieceToFEN = {
                'å¸¥': 'K', 'ä»•': 'A', 'ç›¸': 'B', 'å‚Œ': 'N', 'ä¿¥': 'R', 'ç‚®': 'C', 'å…µ': 'P',
                'å°‡': 'k', 'å£«': 'a', 'è±¡': 'b', 'é¦¬': 'n', 'è»Š': 'r', 'åŒ…': 'c', 'å’': 'p'
            };

            let fen = '';
            for (let row = 0; row < 10; row++) {
                let emptyCount = 0;
                for (let col = 0; col < 9; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        fen += pieceToFEN[piece.type] || piece.type;
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (row < 9) fen += '/';
            }

            return fen + ' w';
        }

// ğŸ”¥ é¡¯ç¤ºè¦–è§’é¸æ“‡å°è©±æ¡†
        function showOrientationChoice(originalBoard, originalPlayer, recognitionIsBlackTop, mainBoardIsBlackTop) {
            const dialog = document.createElement('div');
            dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10001;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 12px;
        max-width: 500px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

            // æ ¹æ“šè­˜åˆ¥çµæœæ±ºå®šæ–‡å­—æè¿°
            const photoOrientation = recognitionIsBlackTop ? 'é»‘å°‡åœ¨ä¸Šæ–¹' : 'ç´…å¸¥åœ¨ä¸Šæ–¹';
            const boardOrientation = mainBoardIsBlackTop ? 'é»‘å°‡åœ¨ä¸Šæ–¹' : 'ç´…å¸¥åœ¨ä¸Šæ–¹';

            dialogContent.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <div style="font-size: 48px; margin-bottom: 15px;">ğŸ¯</div>
            <h3 style="margin: 0 0 10px 0; color: #333;">è­˜åˆ¥å®Œæˆï¼è«‹é¸æ“‡è¦–è§’</h3>
            <p style="color: #666; font-size: 14px; line-height: 1.6;">
                æª¢æ¸¬åˆ°è¦–è§’ä¸ä¸€è‡´ï¼Œè«‹é¸æ“‡æ‚¨åå¥½çš„è¦–è§’
            </p>
        </div>

        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button id="use-photo-orientation-btn" style="
                padding: 15px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102,126,234,0.4);
            ">
                ğŸ“· ä½¿ç”¨ç…§ç‰‡ä¸­çš„è¦–è§’
                <div style="font-size: 11px; opacity: 0.9; margin-top: 5px;">
                   (${photoOrientation})
                </div>
            </button>

            <button id="keep-board-orientation-btn" style="
                padding: 15px;
                background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(245,87,108,0.4);
            ">
                ğŸ® ä¿æŒç›®å‰æ£‹ç›¤è¦–è§’
                <div style="font-size: 11px; opacity: 0.9; margin-top: 5px;">
                   (${boardOrientation})
                </div>
            </button>
        </div>
    `;

            dialog.appendChild(dialogContent);
            document.body.appendChild(dialog);

            const usePhotoBtn = dialog.querySelector('#use-photo-orientation-btn');
            const keepBoardBtn = dialog.querySelector('#keep-board-orientation-btn');

            // ğŸ“· é¸æ“‡ï¼šä½¿ç”¨ç…§ç‰‡è¦–è§’
            usePhotoBtn.addEventListener('click', () => {
                dialog.remove();

                // æ¨™æº–åŒ–ç‚ºé»‘ä¸Šç´…ä¸‹
                let finalBoard = originalBoard;
                if (!recognitionIsBlackTop) {
                    finalBoard = flipBoardData(originalBoard);
                }

                // è¨­å®šä¸»æ£‹ç›¤ç‚ºç…§ç‰‡è¦–è§’
                const targetFlipState = !recognitionIsBlackTop; // é»‘ä¸Š=false, ç´…ä¸Š=true

                if (typeof applyBoardFlip === 'function') {
                    applyBoardFlip(targetFlipState);
                } else if (typeof gameState !== 'undefined') {
                    gameState.isFlipped = targetFlipState;
                }

                applyToMainBoard(finalBoard, originalPlayer);

                statusDisplay.innerHTML = `
            <div style="text-align: center;">
                âœ… å°å…¥æˆåŠŸï¼å·²ä½¿ç”¨ç…§ç‰‡è¦–è§’ï¼š<strong>${photoOrientation}</strong>
            </div>
        `;
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';
            });

            // ğŸ® é¸æ“‡ï¼šä¿æŒæ£‹ç›¤è¦–è§’
            keepBoardBtn.addEventListener('click', () => {
                dialog.remove();

                // æ¨™æº–åŒ–ç‚ºé»‘ä¸Šç´…ä¸‹
                let finalBoard = originalBoard;
                if (!recognitionIsBlackTop) {
                    finalBoard = flipBoardData(originalBoard);
                }

                // ä¿æŒä¸»æ£‹ç›¤ç•¶å‰è¦–è§’
                const targetFlipState = !mainBoardIsBlackTop; // é»‘ä¸Š=false, ç´…ä¸Š=true

                if (typeof applyBoardFlip === 'function') {
                    applyBoardFlip(targetFlipState);
                } else if (typeof gameState !== 'undefined') {
                    gameState.isFlipped = targetFlipState;
                }

                applyToMainBoard(finalBoard, originalPlayer);

                statusDisplay.innerHTML = `
            <div style="text-align: center;">
                âœ… å°å…¥æˆåŠŸï¼å·²ä¿æŒæ£‹ç›¤è¦–è§’ï¼š<strong>${boardOrientation}</strong>
            </div>
        `;
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';
            });

            // æ»‘é¼ æ‡¸åœæ•ˆæœ
            [usePhotoBtn, keepBoardBtn].forEach(btn => {
                btn.addEventListener('mouseenter', () => {
                    btn.style.transform = 'translateY(-2px)';
                    btn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.3)';
                });
                btn.addEventListener('mouseleave', () => {
                    btn.style.transform = 'none';
                    btn.style.boxShadow = btn.id === 'use-photo-orientation-btn'
                        ? '0 4px 15px rgba(102,126,234,0.4)'
                        : '0 4px 15px rgba(245,87,108,0.4)';
                });
            });
        }

// ğŸ”¥ applyToMainBoard ä¿æŒä¸è®Š
        function applyToMainBoard(board, currentPlayer) {
            try {
                const boardContainer = document.querySelector('#chess-board') ||
                    document.querySelector('#gameBoard') ||
                    document.querySelector('.board');

                if (!boardContainer) {
                    throw new Error('æ‰¾ä¸åˆ°ä¸»æ£‹ç›¤å®¹å™¨');
                }

                const correctBoard = [];
                for (let i = 0; i < 10; i++) {
                    correctBoard[i] = [];
                    for (let j = 0; j < 9; j++) {
                        const piece = board[i][j];
                        correctBoard[i][j] = piece ? { type: piece.type, color: piece.color } : null;
                    }
                }

                if (typeof gameState === 'undefined') {
                    window.gameState = {};
                }

                const currentFlipState = gameState.isFlipped;

                gameState.initialBoard = JSON.parse(JSON.stringify(correctBoard));
                gameState.initialTurn = currentPlayer;
                gameState.board = JSON.parse(JSON.stringify(correctBoard));
                gameState.currentTurn = currentPlayer;
                gameState.gameRecord = [];
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.gameOver = false;
                gameState.checkStatus = null;
                gameState.isFlipped = currentFlipState;

                if (typeof window.renderBoard === 'function') {
                    window.renderBoard();
                }

                console.log('âœ… å·²å°å…¥åˆ°ä¸»æ£‹ç›¤, isFlipped =', gameState.isFlipped);

            } catch (error) {
                console.error('æ‡‰ç”¨å¤±æ•—:', error);
                statusDisplay.textContent = 'âŒ æ‡‰ç”¨å¤±æ•—ï¼š' + error.message;
                statusDisplay.style.background = '#f8d7da';
                statusDisplay.style.color = '#721c24';
            }
        }


        leftPanel.appendChild(leftTitle);
        leftPanel.appendChild(statusDisplay);
        leftPanel.appendChild(boardDisplay);
        leftPanel.appendChild(fenInput);


        // ğŸ”¥ æ–°å¢ï¼šæ£‹å­é¸æ“‡å€åŸŸï¼ˆå®Œå…¨è¤‡è£½è‡ªå®šç¾©æ£‹ç›¤çš„é‚è¼¯ï¼‰
        const pieceSelector = document.createElement('div');
        pieceSelector.style.cssText = `
    margin: 15px 0;
    padding: 15px;
    background: #fff;
    border-radius: 8px;
    border: 2px solid #ddd;
`;

        const selectorTitle = document.createElement('div');
        selectorTitle.textContent = 'é¸æ“‡æ£‹å­ï¼š';
        selectorTitle.style.cssText = `
    margin-bottom: 12px;
    font-weight: bold;
    color: #333;
    font-size: 14px;
`;

        const redPieces = [
            { type: 'å¸¥', name: 'å¸¥' }, { type: 'ä¿¥', name: 'ä¿¥' }, { type: 'å‚Œ', name: 'å‚Œ' },
            { type: 'ç›¸', name: 'ç›¸' }, { type: 'ä»•', name: 'ä»•' }, { type: 'ç‚®', name: 'ç‚®' }, { type: 'å…µ', name: 'å…µ' }
        ];

        const blackPieces = [
            { type: 'å°‡', name: 'å°‡' }, { type: 'è»Š', name: 'è»Š' }, { type: 'é¦¬', name: 'é¦¬' },
            { type: 'è±¡', name: 'è±¡' }, { type: 'å£«', name: 'å£«' }, { type: 'åŒ…', name: 'åŒ…' }, { type: 'å’', name: 'å’' }
        ];

        let selectedPiece = null;
        let selectedPosition = null;

        function createPieceButton(piece, color) {
            const button = document.createElement('button');
            button.textContent = piece.name;
            button.style.cssText = `
        margin: 3px;
        padding: 6px 10px;
        border: 2px solid ${color === 'red' ? '#d32f2f' : '#2e7d32'};
        border-radius: 50%;
        cursor: pointer;
        background: ${color === 'red' ? '#ffebee' : '#e8f5e8'};
        color: ${color === 'red' ? '#d32f2f' : '#2e7d32'};
        font-weight: bold;
        font-size: 13px;
        min-width: 38px;
        min-height: 38px;
    `;

            button.addEventListener('click', function() {
                document.querySelectorAll('.selected-piece').forEach(btn => {
                    btn.classList.remove('selected-piece');
                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                });

                selectedPiece = { type: piece.type, color: color };
                selectedPosition = null; // æ¸…é™¤æ£‹ç›¤é¸ä¸­
                button.classList.add('selected-piece');
                button.style.border = '3px solid #007bff';
            });

            return button;
        }

// ç´…æ–¹æ£‹å­
        const redSection = document.createElement('div');
        redSection.style.cssText = `
    margin-bottom: 8px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 3px;
`;
        const redTitle = document.createElement('strong');
        redTitle.textContent = 'ç´…æ–¹ï¼š';
        redTitle.style.cssText = `color: #d32f2f; margin-right: 8px; font-size: 13px;`;
        redSection.appendChild(redTitle);

        redPieces.forEach(piece => {
            redSection.appendChild(createPieceButton(piece, 'red'));
        });

// é»‘æ–¹æ£‹å­
        const blackSection = document.createElement('div');
        blackSection.style.cssText = `
    margin-bottom: 8px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 3px;
`;
        const blackTitle = document.createElement('strong');
        blackTitle.textContent = 'é»‘æ–¹ï¼š';
        blackTitle.style.cssText = `color: #2e7d32; margin-right: 8px; font-size: 13px;`;
        blackSection.appendChild(blackTitle);

        blackPieces.forEach(piece => {
            blackSection.appendChild(createPieceButton(piece, 'black'));
        });

// æ¸…é™¤æŒ‰éˆ•
        const clearButton = document.createElement('button');
        clearButton.textContent = 'æ¸…é™¤';
        clearButton.style.cssText = `
    margin: 3px;
    padding: 6px 10px;
    border: 2px solid #856404;
    border-radius: 50%;
    cursor: pointer;
    background: #fff3cd;
    color: #856404;
    font-weight: bold;
    font-size: 13px;
    min-width: 50px;
    min-height: 38px;
`;

        clearButton.addEventListener('click', function() {
            selectedPiece = 'clear';
            selectedPosition = null;
            document.querySelectorAll('.selected-piece').forEach(btn => {
                btn.classList.remove('selected-piece');
                if (btn === clearButton) {
                    btn.style.border = '2px solid #856404';
                } else {
                    const btnColor = btn.textContent.match(/[å¸¥ä¿¥å‚Œç›¸ä»•ç‚®å…µ]/) ? 'red' : 'black';
                    btn.style.border = `2px solid ${btnColor === 'red' ? '#d32f2f' : '#2e7d32'}`;
                }
            });
            clearButton.style.border = '3px solid #007bff';
            clearButton.classList.add('selected-piece');
        });

        const actionSection = document.createElement('div');
        actionSection.style.cssText = `
    margin-top: 8px;
    display: flex;
    align-items: center;
    gap: 3px;
`;
        const actionTitle = document.createElement('strong');
        actionTitle.textContent = 'æ“ä½œï¼š';
        actionTitle.style.cssText = `color: #6c757d; margin-right: 8px; font-size: 13px;`;
        actionSection.appendChild(actionTitle);
        actionSection.appendChild(clearButton);

        pieceSelector.appendChild(selectorTitle);
        pieceSelector.appendChild(redSection);
        pieceSelector.appendChild(blackSection);
        pieceSelector.appendChild(actionSection);

        // ğŸ”¥ æ–°å¢ï¼šæ§åˆ¶æŒ‰é’®åŒºåŸŸï¼ˆå®Œå…¨ä»¿ç…§è‡ªå®šä¹‰æ£‹ç›˜ï¼‰
        const controlPanel = document.createElement('div');
        controlPanel.style.cssText = `
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin: 15px 0;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 8px;
    align-items: center;
`;

        function createControlButton(text, onClick, color = '#28a745') {
            const button = document.createElement('button');
            button.textContent = text;
            button.style.cssText = `
        padding: 8px 16px;
        background-color: ${color};
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        font-weight: bold;
        transition: all 0.2s ease;
    `;
            button.addEventListener('mouseenter', () => {
                button.style.transform = 'translateY(-1px)';
                button.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            });
            button.addEventListener('mouseleave', () => {
                button.style.transform = 'none';
                button.style.boxShadow = 'none';
            });
            button.addEventListener('click', onClick);
            return button;
        }

        const clearBoardBtn = createControlButton('ä¸€éµæ¸…ç©º', () => {
            virtualValidator.clearBoard();
            createVirtualChessBoard();
            statusDisplay.textContent = 'å·²æ¸…ç©ºæ£‹ç›¤';
            statusDisplay.style.background = '#d4edda';
            statusDisplay.style.color = '#155724';
        }, '#dc3545');

        const resetBoardBtn = createControlButton('é‡ç½®åˆå§‹', () => {
            virtualValidator.resetToInitial();
            createVirtualChessBoard();
            statusDisplay.textContent = 'å·²é‡ç½®ç‚ºåˆå§‹ç›¤é¢';
            statusDisplay.style.background = '#d4edda';
            statusDisplay.style.color = '#155724';
        }, '#6c757d');

        const playerLabel = document.createElement('span');
        playerLabel.textContent = 'èµ°æ£‹æ–¹ï¼š';
        playerLabel.style.cssText = `
    font-weight: bold;
    align-self: center;
    margin: 0 10px 0 20px;
    color: #333;
`;

        const playerToggle = createControlButton(
            virtualValidator.currentPlayer === 'red' ? 'ç´…æ–¹å…ˆèµ°' : 'é»‘æ–¹å…ˆèµ°',
            () => {
                const errors = virtualValidator.validateBoard();
                if (errors.length > 0) {
                    statusDisplay.textContent = 'âŒ ' + errors.join('ï¼›');
                    statusDisplay.style.background = '#f8d7da';
                    statusDisplay.style.color = '#721c24';
                    return;
                }

                virtualValidator.currentPlayer = virtualValidator.currentPlayer === 'red' ? 'black' : 'red';
                playerToggle.textContent = virtualValidator.currentPlayer === 'red' ? 'ç´…æ–¹å…ˆèµ°' : 'é»‘æ–¹å…ˆèµ°';
                playerToggle.style.backgroundColor = virtualValidator.currentPlayer === 'red' ? '#dc3545' : '#343a40';

                statusDisplay.textContent = `å·²åˆ‡æ›ç‚º${virtualValidator.currentPlayer === 'red' ? 'ç´…' : 'é»‘'}æ–¹å…ˆèµ°`;
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';
            },
            virtualValidator.currentPlayer === 'red' ? '#dc3545' : '#343a40'
        );

        const exportFenBtn = createControlButton('å°å‡ºFENç¢¼', () => {
            const errors = virtualValidator.validateBoard();
            if (errors.length > 0) {
                statusDisplay.textContent = 'âŒ æ£‹ç›¤æœ‰éŒ¯èª¤ï¼Œç„¡æ³•å°å‡ºï¼š' + errors.join('ï¼›');
                statusDisplay.style.background = '#f8d7da';
                statusDisplay.style.color = '#721c24';
                return;
            }

            const fen = boardToFEN(virtualValidator.customBoard, virtualValidator.currentPlayer);

            const tempInput = document.createElement('textarea');
            tempInput.value = fen;
            tempInput.style.position = 'fixed';
            tempInput.style.left = '-9999px';
            document.body.appendChild(tempInput);
            tempInput.select();

            try {
                document.execCommand('copy');
                statusDisplay.textContent = 'âœ… FENç¢¼å·²è¤‡è£½åˆ°å‰ªè²¼æ¿ï¼';
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';
                console.log('FENç¢¼:', fen);
            } catch (err) {
                statusDisplay.textContent = 'âš ï¸ è¤‡è£½å¤±æ•—ï¼ŒFENç¢¼ï¼š' + fen;
                statusDisplay.style.background = '#fff3cd';
                statusDisplay.style.color = '#856404';
                console.log('FENç¢¼:', fen);
            }

            document.body.removeChild(tempInput);
        }, '#17a2b8');

        controlPanel.appendChild(clearBoardBtn);
        controlPanel.appendChild(resetBoardBtn);
        controlPanel.appendChild(playerLabel);
        controlPanel.appendChild(playerToggle);
        controlPanel.appendChild(exportFenBtn);

        leftPanel.appendChild(pieceSelector);      // ğŸ”¥ æ£‹å­åŒºæå‰
        leftPanel.appendChild(controlPanel);        // ğŸ”¥ åŠŸèƒ½åŒºæ”¾åé¢



        // ========== å³å´ï¼šåœ–ç‰‡è­˜åˆ¥å€ ==========
        const rightPanel = document.createElement('div');
        rightPanel.style.cssText = `
    width: 100%;
    min-height: 400px;
    background: #fff;
    border-radius: 8px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    border: 2px solid #e0e0e0;
`;
        const rightTitle = document.createElement('h3');
        rightTitle.textContent = 'ğŸ“¸ æ‹ç…§è­˜åˆ¥';
        rightTitle.style.cssText = `
        margin: 0 0 15px 0;
        text-align: center;
        color: #333;
        font-size: 18px;
    `;

        // æ­¥é©ŸæŒ‡ç¤ºå™¨
        const stepIndicator = document.createElement('div');
        stepIndicator.style.cssText = `
        display: flex;
        justify-content: space-around;
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    `;

        const steps = ['ä¸Šå‚³ç…§ç‰‡', 'æ¨™è¨»å››è§’', 'æ¨™è¨»ä¸­å…µ', 'AIè­˜åˆ¥', 'ç¢ºèªçµæœ'];
        let currentStep = 0;

        function updateStepIndicator() {
            stepIndicator.innerHTML = '';
            steps.forEach((stepName, index) => {
                const stepItem = document.createElement('div');
                stepItem.style.cssText = `
                text-align: center;
                flex: 1;
            `;

                const circle = document.createElement('div');
                circle.style.cssText = `
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: ${index <= currentStep ? '#28a745' : '#ddd'};
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0 auto 8px;
                font-weight: bold;
            `;
                circle.textContent = index + 1;

                const label = document.createElement('div');
                label.style.cssText = `
                font-size: 12px;
                color: ${index <= currentStep ? '#28a745' : '#666'};
                font-weight: ${index === currentStep ? 'bold' : 'normal'};
            `;
                label.textContent = stepName;

                stepItem.appendChild(circle);
                stepItem.appendChild(label);
                stepIndicator.appendChild(stepItem);
            });
        }

        updateStepIndicator();

        const imageContainer = document.createElement('div');
        imageContainer.style.cssText = `
    flex: 1;
    min-height: 350px;
    max-height: 500px;
    background: #f8f9fa;
    border: 2px dashed #ddd;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
`;
        imageContainer.setAttribute('tabindex', '0');

        // ä¸Šå‚³æç¤º
        const uploadPrompt = document.createElement('div');
        uploadPrompt.style.cssText = `
    text-align: center;
    color: #666;
`;
        uploadPrompt.innerHTML = `
    <div style="font-size: 48px; margin-bottom: 20px;">ğŸ“·</div>
    <div style="font-size: 18px; margin-bottom: 10px;">ä¸Šå‚³æˆ–æ‹æ”æ£‹ç›¤ç…§ç‰‡</div>
    <div style="font-size: 14px; color: #999; margin-bottom: 15px;">æ”¯æ´ JPGã€PNG æ ¼å¼</div>
    <div style="
        display: inline-block;
        padding: 12px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        font-size: 14px;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(102,126,234,0.3);
        animation: pulse 2s infinite;
    ">
        âŒ¨ï¸ æˆ–æŒ‰ Ctrl+V è²¼ä¸Šæˆªåœ–
    </div>
    <style>
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
`;
        // æ–‡ä»¶è¼¸å…¥
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none';

        // Canvas ç”¨æ–¼é¡¯ç¤ºå’Œæ¨™è¨»
        const canvas = document.createElement('canvas');
        canvas.style.cssText = `
        max-width: 100%;
        max-height: 100%;
        display: none;
        cursor: crosshair;
    `;

        imageContainer.appendChild(uploadPrompt);
        imageContainer.appendChild(canvas);

        const actionButtons = document.createElement('div');
        actionButtons.style.cssText = `
    display: flex;
    gap: 10px;
    margin: 15px 0;  // ğŸ‘ˆ æ”¹è¿™é‡Œï¼šå¢åŠ ä¸Šä¸‹è¾¹è·
    justify-content: center;
`;

        const uploadBtn = document.createElement('button');
        uploadBtn.innerHTML = 'ğŸ“ é¸æ“‡ç…§ç‰‡';
        uploadBtn.style.cssText = `
    padding: 12px 24px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
`;
        uploadBtn.addEventListener('click', () => fileInput.click());

// ğŸ‘‡ æ–°å¢ï¼šæ‹ç…§æŒ‰é’®
        const cameraBtn = document.createElement('button');
        cameraBtn.innerHTML = 'ğŸ“· æ‹ç…§ä¸Šå‚³';
        cameraBtn.style.cssText = `
    padding: 12px 24px;
    background: #17a2b8;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
`;

// åˆ›å»ºä¸“é—¨ç”¨äºæ‹ç…§çš„ input
        const cameraInput = document.createElement('input');
        cameraInput.type = 'file';
        cameraInput.accept = 'image/*';
        cameraInput.capture = 'environment';  // ğŸ‘ˆ å…³é”®ï¼šè°ƒç”¨åç½®æ‘„åƒå¤´
        cameraInput.style.display = 'none';

// ç‚¹å‡»æ‹ç…§æŒ‰é’®æ—¶è§¦å‘ç›¸æœº
        cameraBtn.addEventListener('click', () => {
            cameraInput.click();
        });

// å¤„ç†æ‹ç…§åçš„å›¾ç‰‡
        cameraInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // æ˜¾ç¤ºåŠ è½½æç¤º
            statusDisplay.textContent = 'ğŸ“· æ­£åœ¨è¼‰å…¥æ‹æ”çš„ç…§ç‰‡...';
            statusDisplay.style.background = '#d1ecf1';
            statusDisplay.style.color = '#0c5460';

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;

                    // åˆ›å»ºåŸå§‹å…¨å°ºå¯¸ canvas
                    const originalFullCanvas = document.createElement('canvas');
                    originalFullCanvas.width = img.naturalWidth;
                    originalFullCanvas.height = img.naturalHeight;
                    const fullCtx = originalFullCanvas.getContext('2d');
                    fullCtx.drawImage(img, 0, 0);
                    window.originalFullCanvas = originalFullCanvas;
                    console.log('âœ… æ‹ç…§å›¾ç‰‡å·²è½½å…¥:', originalFullCanvas.width, 'x', originalFullCanvas.height);

                    // è®¾ç½®æ˜¾ç¤º canvas å°ºå¯¸
                    const maxWidth = imageContainer.clientWidth - 40;
                    const maxHeight = imageContainer.clientHeight - 40;
                    const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);

                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // æ˜¾ç¤º canvas
                    uploadPrompt.style.display = 'none';
                    canvas.style.display = 'block';
                    uploadBtn.style.display = 'none';
                    cameraBtn.style.display = 'none';  // éšè—æ‹ç…§æŒ‰é’®
                    resetBtn.style.display = 'block';
                    undoBtn.style.display = 'block';

                    // æ˜¾ç¤ºè¯†åˆ«æ–¹å¼é€‰æ‹©
                    currentStep = 1;
                    updateStepIndicator();
                    showRecognitionChoice();

                    statusDisplay.textContent = 'âœ… ç…§ç‰‡å·²è¼‰å…¥ï¼è«‹é¸æ“‡è­˜åˆ¥æ–¹å¼';
                    statusDisplay.style.background = '#d4edda';
                    statusDisplay.style.color = '#155724';

                    console.log('âœ… æ‹ç…§åŠŸèƒ½å®Œæˆ');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });


        const resetBtn = document.createElement('button');
        resetBtn.innerHTML = 'ğŸ”„ é‡æ–°é–‹å§‹';
        resetBtn.style.cssText = `
        padding: 12px 24px;
        background: #6c757d;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        display: none;
    `;
        resetBtn.addEventListener('click', resetInterface);

        actionButtons.appendChild(uploadBtn);
        actionButtons.appendChild(cameraBtn);  // ğŸ‘ˆ æ·»åŠ é€™ä¸€è¡Œ
        actionButtons.appendChild(resetBtn);

        const undoBtn = document.createElement('button');
        undoBtn.innerHTML = 'â†¶ å›é€€ä¸€æ­¥';
        undoBtn.style.cssText = `
    padding: 12px 24px;
    background: #ffc107;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
    display: none;
`;

// ğŸ”¥ å®Œæ•´çš„ undoBtn å¯¦ç¾ï¼ˆåŒ…å«é€è¦–æ ¡æ­£ä¿è­·ï¼‰
        undoBtn.addEventListener('click', () => {
            // ğŸ”¥ æª¢æŸ¥æ˜¯å¦å·²å®Œæˆé€è¦–æ ¡æ­£ï¼ˆé€è¦–æ ¡æ­£å¾Œ corners æœƒè®Šæˆæ¨™æº–çŸ©å½¢å››è§’ï¼‰
            const isPerspectiveCorrected = corners.length === 4 &&
                corners[0].x === 40 &&
                corners[0].y === 40 &&
                pawns.length === 0;

            if (isPerspectiveCorrected) {
                // ğŸ”¥ å·²å®Œæˆé€è¦–æ ¡æ­£ï¼Œä¸å…è¨±å›é€€è§’é»
                statusDisplay.textContent = 'âš ï¸ å·²å®Œæˆé€è¦–æ ¡æ­£ï¼Œç„¡æ³•å›é€€è§’é»æ¨™è¨»ã€‚å¦‚éœ€é‡æ–°æ¨™è¨»è«‹é»æ“Šã€Œé‡æ–°é–‹å§‹ã€';
                statusDisplay.style.background = '#fff3cd';
                statusDisplay.style.color = '#856404';
                return;
            }

            if (corners.length > 0 && pawns.length === 0) {
                // å›é€€è§’é»æ¨™è¨»ï¼ˆé€è¦–æ ¡æ­£å‰ï¼‰
                corners.pop();

                // é‡ç¹ªåœ–ç‰‡
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

                // é‡ç¹ªå‰©é¤˜çš„è§’é»
                corners.forEach((corner, i) => {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(corner.x, corner.y, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(i + 1, corner.x, corner.y);
                });

                // å¦‚æœé‚„æœ‰è§’é»ä½†æœªæ»¿4å€‹ï¼Œç¹¼çºŒæ¨™è¨»æ¨¡å¼
                if (corners.length < 4) {
                    canvas.addEventListener('click', handleCornerClick);
                    const cornerNames = ['å·¦ä¸Š', 'å³ä¸Š', 'å³ä¸‹', 'å·¦ä¸‹'];
                    statusDisplay.textContent = `å·²å›é€€ï¼è«‹é»æ“Šï¼š${cornerNames[corners.length]}`;
                    statusDisplay.style.background = '#fff3cd';
                    statusDisplay.style.color = '#856404';
                }

            } else if (pawns.length > 0) {
                // ğŸ”¥ å›é€€ä¸­å…µæ¨™è¨»ï¼ˆé€è¦–æ ¡æ­£å¾Œæ‰èƒ½æ¨™è¨»ä¸­å…µï¼‰
                pawns.pop();

                // é‡ç¹ªåœ–ç‰‡ï¼ˆé€è¦–æ ¡æ­£å¾Œçš„åœ–ç‰‡ï¼‰
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

                // ğŸ”¥ é€è¦–æ ¡æ­£å¾Œä¸éœ€è¦é‡ç¹ªè§’é»å’Œé€£ç·šï¼ˆå› ç‚ºå·²ç¶“æ˜¯æ¨™æº–çŸ©å½¢äº†ï¼‰

                // ç¹¼çºŒä¸­å…µæ¨™è¨»æ¨¡å¼
                canvas.addEventListener('click', handlePawnClick);
                statusDisplay.textContent = 'å·²å›é€€ï¼è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®';
                statusDisplay.style.background = '#fff3cd';
                statusDisplay.style.color = '#856404';

                // ğŸ”¥ é‡ç½®ç•¶å‰æ­¥é©Ÿç‚ºæ¨™è¨»ä¸­å…µéšæ®µ
                currentStep = 2;
                updateStepIndicator();
            } else {
                // ğŸ”¥ ç„¡å¯å›é€€å…§å®¹
                statusDisplay.textContent = 'âš ï¸ ç„¡å¯å›é€€çš„æ¨™è¨»';
                statusDisplay.style.background = '#fff3cd';
                statusDisplay.style.color = '#856404';
            }
        });

        actionButtons.appendChild(undoBtn);

        // ğŸ”¥ æ–°å¢ï¼šå¸®åŠ©æŒ‰é’®ï¼ˆä¸€æ‰“å¼€å°±æ˜¾ç¤ºï¼‰
        const helpBtn = document.createElement('button');
        helpBtn.innerHTML = 'ğŸ“– æ“ä½œèªªæ˜';
        helpBtn.style.cssText = `
    padding: 12px 24px;
    background: #17a2b8;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
    transition: all 0.2s;
`;
        helpBtn.addEventListener('mouseenter', () => {
            helpBtn.style.background = '#138496';
            helpBtn.style.transform = 'translateY(-2px)';
        });
        helpBtn.addEventListener('mouseleave', () => {
            helpBtn.style.background = '#17a2b8';
            helpBtn.style.transform = 'translateY(0)';
        });
        helpBtn.addEventListener('click', showHelpDialog);

        actionButtons.appendChild(helpBtn);

        let originalImage = null;
        let originalFullCanvas = null;      // ğŸ”¥ æ–°å¢
        let correctedFullCanvas = null;     // ğŸ”¥ æ–°å¢
        let corners = [];
        let pawns = [];

        function showHelpDialog() {
            const helpDialog = document.createElement('div');
            helpDialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 10002;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s;
    `;

            const helpContent = document.createElement('div');
            helpContent.style.cssText = `
        background: white;
        width: 90%;
        max-width: 900px;
        height: 85vh;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        animation: slideIn 0.3s;
    `;

            const helpHeader = document.createElement('div');
            helpHeader.style.cssText = `
        padding: 20px 30px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 12px 12px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    `;
            helpHeader.innerHTML = `
        <div>
            <h2 style="margin: 0; font-size: 24px;">ğŸ“¸ è±¡æ£‹æ‹ç…§è­˜åˆ¥ç³»çµ± - å®Œæ•´ä½¿ç”¨èªªæ˜</h2>
            <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">è©³ç´°åŠŸèƒ½ä»‹ç´¹èˆ‡æ“ä½œæŒ‡å—</div>
        </div>
    `;

            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = 'âœ•';
            closeBtn.style.cssText = `
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255,255,255,0.2);
        color: white;
        border: none;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.2s;
    `;
            closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = 'rgba(255,255,255,0.3)';
                closeBtn.style.transform = 'rotate(90deg)';
            });
            closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = 'rgba(255,255,255,0.2)';
                closeBtn.style.transform = 'rotate(0deg)';
            });
            closeBtn.addEventListener('click', () => helpDialog.remove());

            helpHeader.appendChild(closeBtn);

            const helpBody = document.createElement('div');
            helpBody.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 30px;
        line-height: 1.8;
        color: #333;
    `;

            helpBody.innerHTML = `
        <style>
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes slideIn {
                from { transform: translateY(-50px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
            .help-section {
                margin-bottom: 30px;
            }
            .help-section h3 {
                color: #667eea;
                font-size: 20px;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 2px solid #e0e0e0;
            }
            .help-section h4 {
                color: #764ba2;
                font-size: 16px;
                margin: 20px 0 10px 0;
            }
            .help-section ul {
                margin: 10px 0;
                padding-left: 25px;
            }
            .help-section li {
                margin: 8px 0;
            }
            .highlight {
                background: #fff3cd;
                padding: 2px 6px;
                border-radius: 3px;
                font-weight: bold;
                color: #856404;
            }
            .warning {
                background: #f8d7da;
                border-left: 4px solid #dc3545;
                padding: 12px 15px;
                margin: 15px 0;
                border-radius: 4px;
                color: #721c24;
            }
            .tip {
                background: #d4edda;
                border-left: 4px solid #28a745;
                padding: 12px 15px;
                margin: 15px 0;
                border-radius: 4px;
                color: #155724;
            }
            .info {
                background: #d1ecf1;
                border-left: 4px solid #17a2b8;
                padding: 12px 15px;
                margin: 15px 0;
                border-radius: 4px;
                color: #0c5460;
            }
            .step-box {
                background: #f8f9fa;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                border: 1px solid #dee2e6;
            }
            .mode-badge {
                display: inline-block;
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 13px;
                font-weight: bold;
                margin-right: 8px;
            }
            .mode-1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
            .mode-2 { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; }
            .mode-3 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; }
            code {
                background: #f4f4f4;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Courier New', monospace;
                color: #e83e8c;
            }
        </style>

        <div class="help-section">
            <h3>ğŸ¯ ç³»çµ±æ¦‚è¿°</h3>
            <p>é€™æ˜¯ä¸€å€‹å¼·å¤§çš„è±¡æ£‹æ£‹ç›¤è­˜åˆ¥ç³»çµ±ï¼Œèƒ½å¤ å°‡å¯¦é«”æ£‹ç›¤ç…§ç‰‡æˆ–ç·šä¸ŠéŠæˆ²æˆªåœ–å¿«é€Ÿè½‰æ›ç‚ºå¯æ“ä½œçš„é›»å­æ£‹ç›¤ã€‚ç³»çµ±é›†æˆäº†ä¸‰ç¨®è­˜åˆ¥æ–¹å¼ï¼Œæ”¯æ´é€è¦–æ ¡æ­£ã€æ™ºèƒ½åº§æ¨™æ˜ å°„ï¼Œä¸¦æä¾›å®Œæ•´çš„è¦å‰‡é©—è­‰åŠŸèƒ½ã€‚</p>
        </div>

        <div class="help-section">
            <h3>ğŸš€ å¿«é€Ÿé–‹å§‹</h3>
            <div class="step-box">
                <strong>å•Ÿå‹•ç³»çµ±</strong>
                <ol>
                    <li>é»æ“Šä¸»ç•Œé¢çš„ <span class="highlight">ã€ŒğŸ“¸ æ‹ç…§è­˜åˆ¥ã€</span> æŒ‰éˆ•</li>
                    <li>ç³»çµ±å°‡å½ˆå‡ºè­˜åˆ¥å·¥ä½œå€ï¼Œåˆ†ç‚ºå·¦å³å…©å€‹é¢æ¿ï¼š
                        <ul>
                            <li><strong>å·¦å´</strong>ï¼šè™›æ“¬æ£‹ç›¤é è¦½èˆ‡ç·¨è¼¯å€</li>
                            <li><strong>å³å´</strong>ï¼šç…§ç‰‡ä¸Šå‚³èˆ‡æ¨™è¨»å€</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>

        <div class="help-section">
            <h3>ğŸ“‹ ä¸‰ç¨®è­˜åˆ¥æ¨¡å¼</h3>

            <h4><span class="mode-badge mode-1">ğŸ–¥ï¸ æ¨¡å¼ä¸€</span> å¯¦é«”æ£‹ç›¤è­˜åˆ¥</h4>
            <p><strong>é©ç”¨å ´æ™¯</strong>ï¼šæ‹æ”çœŸå¯¦çš„è±¡æ£‹æ£‹ç›¤ï¼ˆæœ¨è³ªæ£‹ç›¤ã€ç´™è³ªæ£‹ç›¤ç­‰ï¼‰</p>

            <div class="warning">
                <strong>âš ï¸ é‡è¦æé†’</strong><br>
                å¯¦é«”æ£‹å­è­˜åˆ¥ä¸»è¦ä»¥<strong>æ·ºè‰²ç³»æ£‹å­</strong>ç‚ºä¸»ï¼ˆå¦‚ç™½è‰²ç­‰ï¼‰ã€‚<br>
                ç•°è‰²ç³»æˆ–æ·±è‰²ç³»æ£‹å­ï¼ˆå¦‚é»‘è‰²ã€æ·±æ£•è‰²ï¼‰æº–ç¢ºç‡è¼ƒä½ï¼Œ<strong>å»ºè­°å„ªå…ˆä½¿ç”¨çš®å¡é­šç·šä¸Šè­˜åˆ¥</strong>ã€‚
            </div>

            <div class="step-box">
                <strong>æ­¥é©Ÿ 1ï¼šä¸Šå‚³ç…§ç‰‡</strong>
                <ul>
                    <li>é»æ“Š <span class="highlight">ã€ŒğŸ“ é¸æ“‡ç…§ç‰‡ã€</span> æŒ‰éˆ•ï¼Œæˆ–</li>
                    <li>ç›´æ¥æŒ‰ <code>Ctrl+V</code> è²¼ä¸Šå‰ªè²¼æ¿ä¸­çš„æˆªåœ–</li>
                    <li>æ”¯æ´ JPGã€PNG æ ¼å¼</li>
                </ul>
            </div>

            <div class="step-box">
                <strong>æ­¥é©Ÿ 2ï¼šæ¨™è¨»æ£‹ç›¤å››è§’</strong>
                <ul>
                    <li>ç³»çµ±æç¤ºï¼šã€Œè«‹ä¾åºé»æ“Šæ£‹ç›¤å››å€‹è§’ã€</li>
                    <li>æ¨™è¨»é †åºï¼š<span class="highlight">å·¦ä¸Š â†’ å³ä¸Š â†’ å³ä¸‹ â†’ å·¦ä¸‹</span></li>
                    <li>æ¯é»æ“Šä¸€æ¬¡ï¼Œç³»çµ±æœƒé¡¯ç¤ºç´…è‰²åœ“é»å’Œç·¨è™Ÿ</li>
                    <li>å®Œæˆå››è§’å¾Œè‡ªå‹•ç¹ªè£½ç¶ è‰²é€£ç·šæ¡†</li>
                </ul>
            </div>

            <div class="step-box">
                <strong>æ­¥é©Ÿ 3ï¼šé¸æ“‡é€è¦–æ ¡æ­£</strong>
                <p>ç³»çµ±æœƒæ ¹æ“šç…§ç‰‡è§’åº¦è‡ªå‹•åˆ¤æ–·ï¼š</p>

                <p><strong>æƒ…æ³ Aï¼šéœ€è¦æ ¡æ­£</strong>ï¼ˆæ‹æ”è§’åº¦å‚¾æ–œï¼‰</p>
                <ul>
                    <li>é»æ“Š <span class="highlight">ã€ŒğŸ”„ åŸ·è¡Œé€è¦–æ ¡æ­£ã€</span></li>
                    <li>ç³»çµ±è‡ªå‹•å°‡æ¢¯å½¢æ£‹ç›¤çŸ¯æ­£ç‚ºæ¨™æº–çŸ©å½¢</li>
                    <li>é©ç”¨æ–¼æ–œè§’æ‹æ”çš„ç…§ç‰‡</li>
                </ul>

                <p><strong>æƒ…æ³ Bï¼šè·³éæ ¡æ­£</strong>ï¼ˆæ¥è¿‘æ­£ä¿¯è¦–åœ–ï¼‰</p>
                <ul>
                    <li>é»æ“Š <span class="highlight">ã€Œâ­ï¸ è·³éæ ¡æ­£ã€</span></li>
                    <li>ç›´æ¥ä½¿ç”¨åŸå§‹ç…§ç‰‡</li>
                    <li>é©ç”¨æ–¼å·²ç¶“å¾ˆæ–¹æ­£çš„ç…§ç‰‡</li>
                </ul>

                <div class="tip">
                    <strong>ğŸ’¡ å¦‚ä½•åˆ¤æ–·æ˜¯å¦éœ€è¦æ ¡æ­£ï¼Ÿ</strong><br>
                    â€¢ æ£‹ç›¤çœ‹èµ·ä¾†æ˜¯æ¢¯å½¢ â†’ éœ€è¦æ ¡æ­£<br>
                    â€¢ æ£‹ç›¤çœ‹èµ·ä¾†æ˜¯çŸ©å½¢ â†’ å¯è·³é
                </div>
            </div>

            <div class="step-box">
                <strong>æ­¥é©Ÿ 4ï¼šæ¨™è¨»ä¸­å…µä½ç½®</strong>
                <div class="warning">
                    <strong>âš ï¸ éå¸¸é‡è¦</strong><br>
                    å¿…é ˆé»æ“Š<strong>ç¬¬ 5 åˆ—ï¼ˆä¸­è·¯ï¼‰æœªç§»å‹•éçš„ç´…å…µ(ä¸­ç‚®å‰çš„é‚£å€‹ä½ç½®)</strong>ï¼<br>
                    é€™æ˜¯äº”è·¯å…µçš„åˆå§‹ä½ç½®ï¼Œå¾ä¸‹å¾€ä¸Šæ•¸ç¬¬ 4 è¡Œã€‚<br>
                    å³ä½¿ä¸­å…µå·²ç¶“ç§»å‹•éï¼Œä¹Ÿè¦é»æ“Šå®ƒåŸæœ¬çš„åˆå§‹ä½ç½®ï¼ˆç©ºä½ä¹Ÿæ²’é—œä¿‚ï¼‰ã€‚
                </div>
                <ul>
                    <li>ç³»çµ±æç¤ºï¼šã€Œè«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®ã€</li>
                    <li>é»æ“Šå¾Œé¡¯ç¤ºè—è‰²æ¨™è¨˜ï¼Œæ¨™ç¤ºã€Œä¸­ã€å­—</li>
                </ul>

                <div class="info">
                    <strong>â“ ç‚ºä»€éº¼è¦æ¨™è¨»ä¸­å…µï¼Ÿ</strong><br>
                    â€¢ ç”¨æ–¼å®šä½æ£‹ç›¤çš„ä¸­å¿ƒç·š<br>
                    â€¢ å¹«åŠ© AI æ­£ç¢ºæ˜ å°„å…¶ä»–æ£‹å­çš„ä½ç½®<br>
                    â€¢ ä¿®æ­£å¯èƒ½çš„åˆ—åç§»éŒ¯èª¤
                </div>
            </div>

            <div class="step-box">
                <strong>æ­¥é©Ÿ 5ï¼šAI è‡ªå‹•è­˜åˆ¥</strong>
                <ul>
                    <li>ç³»çµ±è‡ªå‹•ä½¿ç”¨æ¨¡å‹è­˜åˆ¥æ‰€æœ‰æ£‹å­</li>
                    <li>è­˜åˆ¥çµæœè‡ªå‹•é¡¯ç¤ºåœ¨å·¦å´è™›æ“¬æ£‹ç›¤</li>
                    <li>åŒæ™‚ç”Ÿæˆæ¨™æº– FEN ç¢¼</li>
                </ul>
            </div>

            <hr style="margin: 30px 0; border: none; border-top: 2px dashed #e0e0e0;">

            <h4><span class="mode-badge mode-2">ğŸ® æ¨¡å¼äºŒ</span> ç·šä¸Šæˆªåœ–è­˜åˆ¥</h4>
            <p><strong>é©ç”¨å ´æ™¯</strong>ï¼šç·šä¸Šè±¡æ£‹éŠæˆ²çš„å±å¹•æˆªåœ–ï¼ˆå¦‚è±¡æ£‹è»Ÿä»¶ã€ç¶²é éŠæˆ²ç­‰ï¼‰</p>

            <div class="step-box">
                <strong>æ“ä½œæµç¨‹</strong>
                <p><strong>æ­¥é©Ÿ 1-2ï¼šèˆ‡æ¨¡å¼ä¸€ç›¸åŒ</strong></p>
                <ul>
                    <li>ä¸Šå‚³æˆªåœ–</li>
                    <li>æ¨™è¨»å››è§’ï¼ˆ<strong>ä¸åŸ·è¡Œé€è¦–æ ¡æ­£</strong>ï¼Œç›´æ¥è·³åˆ°ä¸­å…µæ¨™è¨»ï¼‰</li>
                </ul>

                <p><strong>æ­¥é©Ÿ 3ï¼šæ¨™è¨»ä¸­å…µ</strong></p>
                <ul>
                    <li>åŒæ¨£é»æ“Šç¬¬ 5 åˆ—æœªç§»å‹•çš„ç´…å…µä½ç½®ï¼ˆåˆå§‹ä½ç½®ï¼‰</li>
                </ul>

                <p><strong>æ­¥é©Ÿ 4ï¼šé›™æ¨¡å‹è­˜åˆ¥</strong></p>
                <ul>
                    <li>ç³»çµ±ä½¿ç”¨å°ˆé–€çš„ç·šä¸ŠéŠæˆ²è­˜åˆ¥æ¨¡å‹ï¼š
                        <ul>
                            <li><strong>Detection Model</strong>ï¼šå®šä½æ‰€æœ‰æ£‹å­ä½ç½®</li>
                            <li><strong>Classification Model</strong>ï¼šè­˜åˆ¥æ£‹å­é¡å‹èˆ‡é™£ç‡Ÿï¼ˆç´…/é»‘ï¼‰</li>
                        </ul>
                    </li>
                    <li>è‡ªå‹•å€åˆ†ç´…é»‘æ–¹æ£‹å­</li>
                    <li>çµæœé¡¯ç¤ºåœ¨è™›æ“¬æ£‹ç›¤</li>
                </ul>

                <div class="tip">
                    <strong>ğŸ’¡ ç·šä¸Šæ¨¡å¼çš„å„ªå‹¢</strong><br>
                    â€¢ é‡å°æ•¸ä½åŒ–æ£‹ç›¤å„ªåŒ–<br>
                    â€¢ è‡ªå‹•è­˜åˆ¥ç´…é»‘é™£ç‡Ÿ<br>
                    â€¢ ä¸éœ€è¦é€è¦–æ ¡æ­£
                </div>
            </div>

            <hr style="margin: 30px 0; border: none; border-top: 2px dashed #e0e0e0;">

            <h4><span class="mode-badge mode-3">ğŸŸ æ¨¡å¼ä¸‰</span> çš®å¡é­š API è­˜åˆ¥ï¼ˆæ¨è–¦ï¼‰</h4>
            <p><strong>é©ç”¨å ´æ™¯</strong>ï¼šè¿½æ±‚æœ€é«˜æº–ç¢ºåº¦ï¼Œä¸”æœ‰ç¶²è·¯é€£ç·š</p>

          <div class="tip">
    <strong>âœ¨ å¼·çƒˆæ¨è–¦</strong><br>
    çš®å¡é­šç·šä¸Šè¾¨è­˜æ˜¯<strong>æº–ç¢ºåº¦æœ€é«˜ã€æœ€çœæ™‚</strong>çš„è­˜åˆ¥æ–¹å¼ï¼<br>
    ç‰¹åˆ¥é©åˆå¯¦é«”æ£‹ç›¤ï¼ˆæ·±è‰²/ç•°è‰²æ£‹å­ä¹Ÿèƒ½æº–ç¢ºè­˜åˆ¥ï¼‰
</div>

<div class="warning" style="margin-top: 10px;">
    <strong>âš ï¸ å¹³å°é™åˆ¶</strong><br>
    æœ¬åŠŸèƒ½ç‚º<strong>é›»è…¦ç‰ˆæ‡‰ç”¨è»Ÿé«”å°ˆç”¨</strong>ï¼Œç›®å‰å°šæœªé–‹æ”¾æ‰‹æ©Ÿç‰ˆæœ¬ä½¿ç”¨
</div>

            <div class="step-box">
                <strong>æ“ä½œæµç¨‹</strong>

                <p><strong>æ­¥é©Ÿ 1ï¼šä¸Šå‚³ç…§ç‰‡</strong></p>
                <ul>
                    <li>èˆ‡å‰å…©ç¨®æ¨¡å¼ç›¸åŒ</li>
                </ul>

                <p><strong>æ­¥é©Ÿ 2ï¼šè‡ªå‹•ä¸Šå‚³è­˜åˆ¥</strong></p>
                <ul>
                    <li>ç³»çµ±è‡ªå‹•å°‡ç…§ç‰‡ä¸Šå‚³è‡³çš®å¡é­šé›²ç«¯ API</li>
                    <li><strong>ç„¡éœ€æ‰‹å‹•æ¨™è¨»å››è§’æˆ–ä¸­å…µ</strong></li>
                    <li>ç­‰å¾… 3-5 ç§’è‡ªå‹•è¿”å›çµæœ</li>
                </ul>

                <div class="warning">
                    <strong>âš ï¸ ä½¿ç”¨é™åˆ¶</strong><br>
                    â€¢ <strong>éœ€è¦ç¶²è·¯é€£ç·š</strong><br>
                    â€¢ <strong>æ¯ 10 ç§’åªèƒ½è­˜åˆ¥ä¸€æ¬¡</strong>ï¼ˆAPI é »ç‡é™åˆ¶ï¼‰<br>
                    â€¢ å¦‚æœç¶²è·¯æ–·ç·šï¼Œç³»çµ±æœƒæç¤ºæ”¹ç”¨é›¢ç·šæ¨¡å¼
                </div>

                <div class="tip">
                    <strong>ğŸ’¡ å„ªå‹¢</strong><br>
                    â€¢ æº–ç¢ºåº¦æœ€é«˜ï¼ˆé›²ç«¯å°ˆæ¥­æ¨¡å‹ï¼‰<br>
                    â€¢ å…¨è‡ªå‹•è­˜åˆ¥ï¼Œç„¡éœ€æ¨™è¨»<br>
                    â€¢ é©åˆå¿«é€Ÿè­˜åˆ¥å¤šå¼µç…§ç‰‡<br>
                    â€¢ æ”¯æ´å„ç¨®é¡è‰²çš„æ£‹å­
                </div>
            </div>
        </div>

        <div class="help-section">
            <h3>ğŸ¨ è™›æ“¬æ£‹ç›¤ç·¨è¼¯åŠŸèƒ½</h3>
            <p>è­˜åˆ¥å®Œæˆå¾Œï¼Œå·¦å´è™›æ“¬æ£‹ç›¤æ”¯æ´æ‰‹å‹•èª¿æ•´ï¼š</p>

            <h4>1ï¸âƒ£ æ”¾ç½®æ£‹å­</h4>
            <ul>
                <li>é»æ“Šä¸‹æ–¹ <span class="highlight">ã€Œç´…æ–¹ã€</span> æˆ– <span class="highlight">ã€Œé»‘æ–¹ã€</span> å€åŸŸé¸æ“‡æ£‹å­</li>
                <li>è¢«é¸ä¸­çš„æ£‹å­æŒ‰éˆ•æœƒé¡¯ç¤ºè—è‰²é‚Šæ¡†</li>
                <li>é»æ“Šæ£‹ç›¤ä¸Šçš„ç©ºä½å³å¯æ”¾ç½®</li>
            </ul>

            <h4>2ï¸âƒ£ ç§»å‹•æ£‹å­</h4>
            <ul>
                <li>é»æ“Šæ£‹ç›¤ä¸Šçš„æ£‹å­é¸ä¸­ï¼ˆé¡¯ç¤ºæç¤ºï¼‰</li>
                <li>å†é»æ“Šç›®æ¨™ä½ç½®å®Œæˆç§»å‹•</li>
                <li>ç³»çµ±<strong>ä¸æª¢æŸ¥ç§»å‹•åˆæ³•æ€§</strong>ï¼Œå¯è‡ªç”±æ“ºæ”¾</li>
            </ul>

            <h4>3ï¸âƒ£ æ¸…é™¤æ£‹å­</h4>
            <ul>
                <li>é»æ“Š <span class="highlight">ã€Œæ¸…é™¤ã€</span> æŒ‰éˆ•ï¼ˆé»ƒè‰²ï¼‰</li>
                <li>å†é»æ“Šè¦åˆªé™¤çš„æ£‹å­å³å¯ç§»é™¤</li>
            </ul>

            <h4>4ï¸âƒ£ åŠŸèƒ½æŒ‰éˆ•</h4>
            <ul>
                <li><strong>ä¸€éµæ¸…ç©º</strong>ï¼šæ¸…é™¤æ£‹ç›¤ä¸Šæ‰€æœ‰æ£‹å­</li>
                <li><strong>é‡ç½®åˆå§‹</strong>ï¼šæ¢å¾©è±¡æ£‹åˆå§‹ç›¤é¢</li>
                <li><strong>èµ°æ£‹æ–¹åˆ‡æ›</strong>ï¼šåˆ‡æ›ç´…æ–¹/é»‘æ–¹å…ˆèµ°</li>
                <li><strong>å°å‡º FEN ç¢¼</strong>ï¼šè¤‡è£½ç•¶å‰ç›¤é¢çš„ FEN ç¢¼åˆ°å‰ªè²¼æ¿</li>
            </ul>

            <h4>5ï¸âƒ£ FEN ç¢¼é è¦½</h4>
            <ul>
                <li>æ–‡å­—æ¡†é¡¯ç¤º AI è­˜åˆ¥çµæœçš„ FEN ç¢¼</li>
                <li>å¯æ‰‹å‹•ä¿®æ”¹ FEN ç¢¼</li>
                <li>é»æ“Š <span class="highlight">ã€Œé è¦½ FEN ç¢¼ã€</span> æŒ‰éˆ•è¼‰å…¥ä¿®æ”¹å¾Œçš„ FEN</li>
            </ul>
        </div>

        <div class="help-section">
            <h3>âœ… è¦å‰‡é©—è­‰ç³»çµ±</h3>
            <p>ç³»çµ±å…§å»º<strong>è¦–è§’ç„¡é—œ</strong>çš„è±¡æ£‹è¦å‰‡é©—è­‰å™¨ï¼Œæœƒæª¢æŸ¥ï¼š</p>

            <h4>åŸºç¤è¦å‰‡</h4>
            <ul>
                <li>âœ“ å°‡å¸¥ä½ç½®ï¼ˆå¿…é ˆåœ¨ä¹å®®æ ¼å…§ï¼‰</li>
                <li>âœ“ å°‡å¸¥ä¸èƒ½å°è‡‰</li>
                <li>âœ“ å£«/ä»•ä½ç½®ï¼ˆåªèƒ½åœ¨ä¹å®®æ ¼çš„ 5 å€‹é»ï¼‰</li>
                <li>âœ“ ç›¸/è±¡ä½ç½®ï¼ˆä¸èƒ½éæ²³ï¼‰</li>
                <li>âœ“ å…µ/å’ä½ç½®ï¼ˆå·±æ–¹é ˜åœ°åªèƒ½åœ¨ç‰¹å®šè¡Œåˆ—ï¼‰</li>
                <li>âœ“ æ£‹å­æ•¸é‡é™åˆ¶</li>
            </ul>

            <h4>é«˜ç´šæª¢æŸ¥</h4>
            <ul>
                <li>âœ“ å°‡è»ç‹€æ…‹ï¼ˆæ˜¯å¦è¢«å°‡è»ï¼‰</li>
                <li>âœ“ å°‡æ­»æª¢æ¸¬ï¼ˆç„¡æ£‹å¯èµ°ä¸”è¢«å°‡è»ï¼‰</li>
                <li>âœ“ å›°æ–ƒæª¢æ¸¬ï¼ˆç„¡æ£‹å¯èµ°ä½†æœªè¢«å°‡è»ï¼‰</li>
                <li>âœ“ èµ°æ£‹æ–¹åˆæ³•æ€§ï¼ˆè¢«å°‡è»æ™‚å¿…é ˆæ‡‰å°‡ï¼‰</li>
            </ul>

            <div class="warning">
                <strong>âš ï¸ åªæœ‰é€šéæ‰€æœ‰é©—è­‰æ‰èƒ½å°å…¥ä¸»æ£‹ç›¤</strong>
            </div>
        </div>

        <div class="help-section">
            <h3>ğŸ¯ å°å…¥åˆ°ä¸»æ£‹ç›¤</h3>

            <h4>è‡ªå‹•è¦–è§’è™•ç†</h4>
            <p>ç•¶é»æ“Š <span class="highlight">ã€Œå°å…¥åˆ°ä¸»æ£‹ç›¤ã€</span> æ™‚ï¼Œç³»çµ±æœƒæ™ºèƒ½è™•ç†è¦–è§’ï¼š</p>

            <div class="step-box">
                <p><strong>æƒ…æ³ 1ï¼šè¦–è§’ä¸€è‡´</strong></p>
                <ul>
                    <li>è­˜åˆ¥çµæœèˆ‡ç•¶å‰æ£‹ç›¤è¦–è§’ç›¸åŒ</li>
                    <li>ç›´æ¥å°å…¥ï¼Œç„¡éœ€è©¢å•</li>
                </ul>

                <p><strong>æƒ…æ³ 2ï¼šè¦–è§’ä¸ä¸€è‡´</strong></p>
                <p>ç³»çµ±å½ˆå‡ºé¸æ“‡å°è©±æ¡†ï¼š</p>
                <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #667eea;">
ğŸ“· ä½¿ç”¨ç…§ç‰‡ä¸­çš„è¦–è§’
   (é»‘å°‡åœ¨ä¸Šæ–¹ / ç´…å¸¥åœ¨ä¸Šæ–¹)

ğŸ® ä¿æŒç›®å‰æ£‹ç›¤è¦–è§’
   (é»‘å°‡åœ¨ä¸Šæ–¹ / ç´…å¸¥åœ¨ä¸Šæ–¹)</pre>
                <ul>
                    <li>é¸æ“‡å¾Œç³»çµ±è‡ªå‹•èª¿æ•´è¦–è§’ä¸¦å°å…¥</li>
                    <li>ä¸»æ£‹ç›¤æœƒåŒæ­¥ç¿»è½‰ï¼ˆå¦‚æœéœ€è¦ï¼‰</li>
                </ul>
            </div>
        </div>

        <div class="help-section">
            <h3>ğŸ”§ è¼”åŠ©åŠŸèƒ½</h3>

            <h4>â†¶ å›é€€ä¸€æ­¥</h4>
            <ul>
                <li>æ’¤éŠ·æœ€è¿‘ä¸€æ¬¡çš„æ¨™è¨»æ“ä½œ</li>
                <li>æ”¯æ´å›é€€è§’é»æˆ–ä¸­å…µæ¨™è¨»</li>
                <li><strong>é€è¦–æ ¡æ­£å¾Œç„¡æ³•å›é€€è§’é»</strong>ï¼ˆéœ€é‡æ–°é–‹å§‹ï¼‰</li>
            </ul>

            <h4>ğŸ”„ é‡æ–°é–‹å§‹</h4>
            <ul>
                <li>æ¸…é™¤æ‰€æœ‰æ¨™è¨»å’Œè­˜åˆ¥çµæœ</li>
                <li>è¿”å›ä¸Šå‚³ç…§ç‰‡éšæ®µ</li>
                <li>é‡ç½®è™›æ“¬æ£‹ç›¤ç‚ºåˆå§‹ç›¤é¢</li>
            </ul>
        </div>

        <div class="help-section">
            <h3>âš ï¸ å¸¸è¦‹å•é¡Œ</h3>

            <h4>Q1ï¼šç‚ºä»€éº¼å¿…é ˆæ¨™è¨»ä¸­å…µï¼Ÿ</h4>
            <p><strong>A</strong>ï¼šä¸­å…µï¼ˆç¬¬ 5 åˆ—ç´…å…µï¼‰æ˜¯æ£‹ç›¤çš„ä¸­å¿ƒåƒè€ƒé»ã€‚AI è­˜åˆ¥å¾Œçš„åº§æ¨™å¯èƒ½æœ‰åç§»ï¼Œé€šéä¸­å…µä½ç½®å¯ä»¥ä¿®æ­£åˆ—åç§»ï¼Œç¢ºä¿å…¶ä»–æ£‹å­æ˜ å°„åˆ°æ­£ç¢ºçš„ä½ç½®ã€‚</p>

            <h4>Q2ï¼šå¦‚æœä¸­å…µå·²ç¶“ç§»å‹•éæ€éº¼è¾¦ï¼Ÿ</h4>
            <p><strong>A</strong>ï¼šæ¨™è¨»æ™‚è«‹é»æ“Š<strong>åŸæœ¬ä¸­å…µæ‡‰è©²åœ¨çš„åˆå§‹ä½ç½®</strong>ï¼ˆç¬¬ 5 åˆ—å¾ä¸‹æ•¸ç¬¬ 4 è¡Œçš„ç©ºä½ï¼‰ï¼Œè€Œä¸æ˜¯ç§»å‹•å¾Œçš„ä½ç½®ã€‚</p>

            <h4>Q3ï¼šæ¨™è¨»å››è§’æ™‚é †åºéŒ¯äº†æ€éº¼è¾¦ï¼Ÿ</h4>
            <p><strong>A</strong>ï¼šé»æ“Š <span class="highlight">ã€Œâ†¶ å›é€€ä¸€æ­¥ã€</span> æŒ‰éˆ•é€æ­¥æ’¤éŠ·ï¼Œæˆ–é»æ“Š <span class="highlight">ã€ŒğŸ”„ é‡æ–°é–‹å§‹ã€</span> å¾é ­ä¾†éã€‚</p>

            <h4>Q4ï¼šè­˜åˆ¥çµæœæœ‰éŒ¯èª¤æ€éº¼è¾¦ï¼Ÿ</h4>
            <p><strong>A</strong>ï¼šåœ¨å·¦å´è™›æ“¬æ£‹ç›¤æ‰‹å‹•èª¿æ•´ï¼š</p>
            <ol>
                <li>ä½¿ç”¨ã€Œæ¸…é™¤ã€åŠŸèƒ½åˆªé™¤éŒ¯èª¤æ£‹å­</li>
                <li>é¸æ“‡æ­£ç¢ºçš„æ£‹å­é¡å‹</li>
                <li>é»æ“Šæ­£ç¢ºä½ç½®æ”¾ç½®</li>
                <li>å®Œæˆå¾Œå†å°å…¥ä¸»æ£‹ç›¤</li>
            </ol>

            <h4>Q5ï¼šçš®å¡é­šé¡¯ç¤ºã€Œè«‹ç­‰å¾… X ç§’ã€</h4>
            <p><strong>A</strong>ï¼šAPI æœ‰é »ç‡é™åˆ¶ï¼ˆ10 ç§’ 1 æ¬¡ï¼‰ï¼Œç­‰å¾…å€’æ•¸çµæŸå¾Œé‡è©¦ï¼Œæˆ–æ”¹ç”¨æœ¬åœ°æ¨¡å‹è­˜åˆ¥ã€‚</p>

            <h4>Q6ï¼šå°å…¥æ™‚æç¤ºã€Œæ£‹ç›¤ä¸ç¬¦åˆè¦å‰‡ã€</h4>
            <p><strong>A</strong>ï¼šç³»çµ±æª¢æ¸¬åˆ°æ£‹ç›¤é•åè±¡æ£‹è¦å‰‡ï¼ˆå¦‚å°‡å¸¥å°è‡‰ã€å…µå’ä½ç½®éŒ¯èª¤ç­‰ï¼‰ã€‚è«‹æª¢æŸ¥è™›æ“¬æ£‹ç›¤ï¼Œä¿®æ­£éŒ¯èª¤å¾Œå†å°å…¥ã€‚éŒ¯èª¤è¨Šæ¯æœƒæç¤ºå…·é«”å•é¡Œã€‚</p>

            <h4>Q7ï¼šå¯¦é«”æ£‹å­è­˜åˆ¥æ•ˆæœä¸å¥½ï¼Ÿ</h4>
            <p><strong>A</strong>ï¼šæœ¬åœ°æ¨¡å‹ä¸»è¦é‡å°æ·ºè‰²ç³»æ£‹å­è¨“ç·´ã€‚å¦‚æœæ‚¨çš„æ£‹å­æ˜¯æ·±è‰²æˆ–ç•°è‰²ç³»ï¼Œ<strong>å¼·çƒˆå»ºè­°ä½¿ç”¨çš®å¡é­šç·šä¸Šè­˜åˆ¥</strong>ï¼Œæº–ç¢ºåº¦æœƒå¤§å¹…æå‡ã€‚</p>
        </div>

        <div class="help-section">
            <h3>ğŸ’¡ ä½¿ç”¨æŠ€å·§</h3>

            <h4>æ‹ç…§å»ºè­°</h4>
            <ul>
                <li><strong>å…‰ç·šå……è¶³</strong>ï¼šé¿å…é™°å½±é®æ“‹æ£‹å­</li>
                <li><strong>ç›¡é‡ä¿¯è¦–</strong>ï¼šè§’åº¦è¶Šæ­£è­˜åˆ¥è¶Šæº–ç¢ºï¼ˆæˆ–é¸æ“‡é€è¦–æ ¡æ­£ï¼‰</li>
                <li><strong>æ£‹å­æ¸…æ™°</strong>ï¼šé¿å…æ¨¡ç³Šæˆ–åå…‰</li>
                <li><strong>èƒŒæ™¯ä¹¾æ·¨</strong>ï¼šæ¸›å°‘å¹²æ“¾å…ƒç´ </li>
                <li><strong>æ·ºè‰²æ£‹å­å„ªå…ˆ</strong>ï¼šæœ¬åœ°æ¨¡å‹å°æ·ºè‰²æ£‹å­æ•ˆæœæœ€å¥½</li>
            </ul>

            <h4>æ¨™è¨»æŠ€å·§</h4>
            <ul>
                <li><strong>å››è§’æ¨™è¨»</strong>ï¼šç›¡é‡é»æ“Šæ£‹ç›¤é‚Šç·šçš„äº¤å‰é»</li>
                <li><strong>ä¸­å…µæ¨™è¨»</strong>ï¼šé»æ“Šæ£‹å­çš„ä¸­å¿ƒä½ç½®ï¼ˆæˆ–åˆå§‹ä½ç½®çš„ç©ºä½ä¸­å¿ƒï¼‰</li>
                <li><strong>ç·šä¸Šæˆªåœ–</strong>ï¼šç¢ºä¿æˆªåœ–åŒ…å«å®Œæ•´æ£‹ç›¤ï¼ˆä¸è¦è£åˆ‡ï¼‰</li>
            </ul>

            <h4>æ•ˆç‡æå‡</h4>
            <ul>
                <li><strong>å¿«é€Ÿæˆªåœ–</strong>ï¼šä½¿ç”¨ <code>Ctrl+V</code> ç›´æ¥è²¼ä¸Š</li>
                <li><strong>æ‰¹æ¬¡è™•ç†</strong>ï¼šç›¸åŒè¦–è§’çš„ç…§ç‰‡å¯è·³éé€è¦–æ ¡æ­£</li>
                <li><strong>é è¦½èª¿æ•´</strong>ï¼šåœ¨è™›æ“¬æ£‹ç›¤å…ˆç¢ºèªç„¡èª¤å†å°å…¥</li>
                <li><strong>å„ªå…ˆçš®å¡é­š</strong>ï¼šè¿½æ±‚æº–ç¢ºåº¦æ™‚é¦–é¸çš®å¡é­š API</li>
            </ul>
        </div>

        <div class="help-section">
            <h3>ğŸ“ ç¸½çµ</h3>
<p>é€™å¥—è­˜åˆ¥ç³»çµ±æä¾›äº†å¾ç…§ç‰‡åˆ°å¯æ“ä½œæ£‹ç›¤çš„å®Œæ•´æµç¨‹ï¼š</p>
<pre style="background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%); padding: 20px; border-radius: 8px; border-left: 4px solid #667eea; line-height: 2;">
ğŸ“¸ ä¸Šå‚³ç…§ç‰‡
â†“
ğŸ¯ é¸æ“‡æ¨¡å¼ï¼ˆå¯¦é«”/ç·šä¸Š/çš®å¡é­šï¼‰
â†“
âœï¸ æ¨™è¨»å®šä½ï¼ˆå››è§’ + ä¸­å…µï¼‰*
â†“
ğŸ¤– AI è‡ªå‹•è­˜åˆ¥
â†“
ğŸ¨ è™›æ“¬æ£‹ç›¤é è¦½èˆ‡ç·¨è¼¯
â†“
âœ… è¦å‰‡é©—è­‰
â†“
ğŸ® å°å…¥ä¸»æ£‹ç›¤ï¼ˆè‡ªå‹•è™•ç†è¦–è§’ï¼‰
<span style="font-size: 12px; color: #666;">* çš®å¡é­šæ¨¡å¼ç„¡éœ€æ¨™è¨»</span></pre>
        <p style="text-align: center; font-size: 18px; margin-top: 30px; color: #667eea;">
            <strong>ç„¡è«–æ˜¯å¯¦é«”æ£‹è­œéŒ„å…¥ã€ç·šä¸Šå°å±€åˆ†æï¼Œé‚„æ˜¯å¿«é€Ÿæ“ºç›¤ï¼Œéƒ½èƒ½è¼•é¬†å®Œæˆï¼</strong>
        </p>
        <p style="text-align: center; font-size: 24px; margin-top: 20px;">ğŸ‰ ç¥æ‚¨ä½¿ç”¨æ„‰å¿«ï¼</p>
    </div>
`;

            helpContent.appendChild(helpHeader);
            helpContent.appendChild(helpBody);
            helpDialog.appendChild(helpContent);
            document.body.appendChild(helpDialog);

// é»æ“ŠèƒŒæ™¯é—œé–‰
            helpDialog.addEventListener('click', (e) => {
                if (e.target === helpDialog) {
                    helpDialog.remove();
                }
            });
        }

        // ğŸ”¥ å®Œæ•´æ›¿æ›æˆä»¥ä¸‹ç‰ˆæœ¬ï¼š

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;

                    // ğŸ”¥ å‰µå»ºåŸå§‹å…¨å°ºå¯¸ canvas
                    const originalFullCanvas = document.createElement('canvas');
                    originalFullCanvas.width = img.naturalWidth;
                    originalFullCanvas.height = img.naturalHeight;
                    const fullCtx = originalFullCanvas.getContext('2d');
                    fullCtx.drawImage(img, 0, 0);
                    window.originalFullCanvas = originalFullCanvas;
                    console.log('âœ… åŸå§‹å…¨å°ºå¯¸ Canvas:', originalFullCanvas.width, 'x', originalFullCanvas.height);

                    // è¨­ç½®é¡¯ç¤º canvas å°ºå¯¸
                    const maxWidth = imageContainer.clientWidth - 40;
                    const maxHeight = imageContainer.clientHeight - 40;
                    const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);

                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // é¡¯ç¤º canvas
                    uploadPrompt.style.display = 'none';
                    canvas.style.display = 'block';
                    uploadBtn.style.display = 'none';
                    resetBtn.style.display = 'block';
                    undoBtn.style.display = 'block';

                    // ğŸ”¥ æ–°å¢ï¼šé¡¯ç¤ºè­˜åˆ¥æ–¹å¼é¸æ“‡ç•Œé¢
                    currentStep = 1;
                    updateStepIndicator();
                    showRecognitionChoice();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

// ğŸ”¥ å‰ªè²¼æ¿è²¼ä¸ŠåŠŸèƒ½
        imageContainer.addEventListener('paste', async (e) => {
            e.preventDefault();
            console.log('ğŸ“‹ åµæ¸¬åˆ°è²¼ä¸Šäº‹ä»¶');

            const items = e.clipboardData?.items;
            if (!items) {
                console.warn('âš ï¸ ç„¡æ³•è®€å–å‰ªè²¼æ¿å…§å®¹');
                return;
            }

            // å°‹æ‰¾åœ–ç‰‡é¡å‹
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                console.log(`ğŸ“ å‰ªè²¼æ¿é …ç›® ${i}:`, item.type);

                if (item.type.indexOf('image') !== -1) {
                    const file = item.getAsFile();
                    if (!file) continue;

                    console.log('âœ… æˆåŠŸå¾å‰ªè²¼æ¿ç²å–åœ–ç‰‡:', file.name, file.size, 'bytes');

                    // ğŸ”¥ é¡¯ç¤ºè¼‰å…¥æç¤º
                    statusDisplay.textContent = 'ğŸ“‹ æ­£åœ¨è¼‰å…¥è²¼ä¸Šçš„åœ–ç‰‡...';
                    statusDisplay.style.background = '#d1ecf1';
                    statusDisplay.style.color = '#0c5460';

                    // è®€å–åœ–ç‰‡
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            originalImage = img;

                            // ğŸ”¥ å‰µå»ºåŸå§‹å…¨å°ºå¯¸ canvas
                            const originalFullCanvas = document.createElement('canvas');
                            originalFullCanvas.width = img.naturalWidth;
                            originalFullCanvas.height = img.naturalHeight;
                            const fullCtx = originalFullCanvas.getContext('2d');
                            fullCtx.drawImage(img, 0, 0);
                            window.originalFullCanvas = originalFullCanvas;
                            console.log('âœ… åŸå§‹å…¨å°ºå¯¸ Canvas:', originalFullCanvas.width, 'x', originalFullCanvas.height);

                            // è¨­ç½®é¡¯ç¤º canvas å°ºå¯¸
                            const maxWidth = imageContainer.clientWidth - 40;
                            const maxHeight = imageContainer.clientHeight - 40;
                            const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);

                            canvas.width = img.width * scale;
                            canvas.height = img.height * scale;

                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                            // é¡¯ç¤º canvas
                            uploadPrompt.style.display = 'none';
                            canvas.style.display = 'block';
                            uploadBtn.style.display = 'none';
                            resetBtn.style.display = 'block';
                            undoBtn.style.display = 'block';

                            // ğŸ”¥ é¡¯ç¤ºè­˜åˆ¥æ–¹å¼é¸æ“‡ç•Œé¢
                            currentStep = 1;
                            updateStepIndicator();
                            showRecognitionChoice();

                            console.log('âœ… åœ–ç‰‡å·²æˆåŠŸå¾å‰ªè²¼æ¿è¼‰å…¥');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);

                    break; // åªè™•ç†ç¬¬ä¸€å¼µåœ–ç‰‡
                }
            }
        });

// ğŸ”¥ å…¨å±€è²¼ä¸Šäº‹ä»¶ï¼ˆç•¶ç„¦é»åœ¨å…¶ä»–åœ°æ–¹æ™‚ä¹Ÿèƒ½æ•æ‰ï¼‰
        document.addEventListener('paste', (e) => {
            // åªåœ¨æ‹ç…§è­˜åˆ¥ç•Œé¢é–‹å•Ÿä¸”æœªè¼‰å…¥åœ–ç‰‡æ™‚è§¸ç™¼
            if (document.body.contains(container) && !originalImage) {
                imageContainer.dispatchEvent(new ClipboardEvent('paste', {
                    clipboardData: e.clipboardData
                }));
            }
        });

// ğŸ”¥ é»æ“Šå®¹å™¨æ™‚è‡ªå‹•èšç„¦ï¼ˆæ–¹ä¾¿æ¥æ”¶éµç›¤äº‹ä»¶ï¼‰
        imageContainer.addEventListener('click', () => {
            if (!originalImage) {
                imageContainer.focus();
            }
        });

// ğŸ”¥ è¦–è¦ºåé¥‹ï¼šèšç„¦æ™‚é«˜äº®é‚Šæ¡†
        imageContainer.addEventListener('focus', () => {
            if (!originalImage) {
                imageContainer.style.borderColor = '#667eea';
                imageContainer.style.boxShadow = '0 0 0 3px rgba(102,126,234,0.2)';
            }
        });

        imageContainer.addEventListener('blur', () => {
            imageContainer.style.borderColor = '#ddd';
            imageContainer.style.boxShadow = 'none';
        });

        // ==================== ç¬¬å››éƒ¨åˆ†ï¼šæœ¬åœ°æ¨¡å‹æµç¨‹ï¼ˆä½ åŸæœ¬çš„é‚è¼¯ï¼‰ ====================

        function startLocalModelFlow() {
            console.log('ğŸ–¥ï¸ ç”¨æˆ¶é¸æ“‡ï¼šæœ¬åœ°æ¨¡å‹è­˜åˆ¥');

            currentStep = 1;
            updateStepIndicator();
            statusDisplay.textContent = 'è«‹ä¾åºé»æ“Šæ£‹ç›¤å››å€‹è§’ï¼šå·¦ä¸Š â†’ å³ä¸Š â†’ å³ä¸‹ â†’ å·¦ä¸‹';
            statusDisplay.style.background = '#fff3cd';
            statusDisplay.style.color = '#856404';
            statusDisplay.style.border = '2px solid #ffc107';

            // é–‹å§‹ä½ åŸæœ¬çš„æ¨™è¨»æµç¨‹
            startCornerAnnotation();
        }

        // æ¨™è¨»å››è§’
        function startCornerAnnotation() {
            corners = [];
            canvas.addEventListener('click', handleCornerClick);
        }

        // ========== å®Œæ•´çš„ handleCornerClick å‡½æ•¸ ==========

        function handleCornerClick(e) {
            if (corners.length >= 4) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // ğŸ”¥ è¨ˆç®—åŸå§‹åœ–ç‰‡åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
            const scaleX = originalImage.width / canvas.width;
            const scaleY = originalImage.height / canvas.height;
            const originalX = x * scaleX;
            const originalY = y * scaleY;

            corners.push({
                x,
                y,
                originalX,  // ä¿å­˜åŸå§‹åº§æ¨™
                originalY
            });

            // ç¹ªè£½æ¨™è¨˜é»
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(corners.length, x, y);

            if (corners.length === 4) {
                canvas.removeEventListener('click', handleCornerClick);

                // ç¹ªè£½é€£ç·š
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                corners.forEach((corner, i) => {
                    if (i === 0) ctx.moveTo(corner.x, corner.y);
                    else ctx.lineTo(corner.x, corner.y);
                });
                ctx.closePath();
                ctx.stroke();

                // ğŸ”¥ ä¿å­˜åˆ°å…¨å±€è®Šé‡
                window.corners = corners;
                console.log('âœ… å››è§’å·²ä¿å­˜åˆ° window.corners:', window.corners);

                // ğŸ”¥ åˆ¤æ–·æ˜¯ç·šä¸Šæ¨¡å¼é‚„æ˜¯æœ¬åœ°æ¨¡å¼
                if (window.isOnlineMode) {
                    // ç·šä¸Šæ¨¡å¼ï¼šè·³éé€è¦–æ ¡æ­£ï¼Œç›´æ¥é€²ä¸­å…µæ¨™è¨»
                    console.log('ğŸ® ç·šä¸Šæ¨¡å¼ï¼šè·³éé€è¦–æ ¡æ­£');
                    currentStep = 2;
                    updateStepIndicator();
                    statusDisplay.textContent = 'âœ… å››è§’æ¨™è¨»å®Œæˆï¼è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®';
                    statusDisplay.style.background = '#d4edda';
                    statusDisplay.style.color = '#155724';

                    setTimeout(() => {
                        startPawnAnnotationForOnline();
                    }, 500);

                } else {
                    // æœ¬åœ°æ¨¡å¼ï¼šé¡¯ç¤ºé€è¦–æ ¡æ­£é¸æ“‡
                    console.log('ğŸ–¥ï¸ æœ¬åœ°æ¨¡å¼ï¼šé¡¯ç¤ºé€è¦–æ ¡æ­£é¸æ“‡');
                    currentStep = 1.5;
                    updateStepIndicator();
                    statusDisplay.innerHTML = `
âœ… å››è§’æ¨™è¨»å®Œæˆï¼<br>
<small style="color: #666;">å¦‚æœç…§ç‰‡æ¥è¿‘ä¿¯è¦–åœ–ï¼ˆæ£‹ç›¤çœ‹èµ·ä¾†æ˜¯çŸ©å½¢ï¼‰ï¼Œå¯ç›´æ¥è·³éæ ¡æ­£</small>
`;
                    statusDisplay.style.background = '#fff3cd';
                    statusDisplay.style.color = '#856404';

                    showPerspectiveCorrectionChoice();
                }

            } else {
                // æœªå®Œæˆå››è§’æ¨™è¨»
                const cornerNames = ['å·¦ä¸Š', 'å³ä¸Š', 'å³ä¸‹', 'å·¦ä¸‹'];
                statusDisplay.textContent = `å·²æ¨™è¨» ${corners.length}/4 å€‹è§’é»ï¼Œè«‹é»æ“Šï¼š${cornerNames[corners.length]}`;
            }
        }

// ğŸ”¥ æ–°å¢ï¼šé¡¯ç¤ºé€è¦–æ ¡æ­£é¸æ“‡ç•Œé¢
        function showPerspectiveCorrectionChoice() {
            // ç§»é™¤ä¹‹å‰å¯èƒ½å­˜åœ¨çš„é¸æ“‡æŒ‰éˆ•
            const existingChoice = document.getElementById('perspective-choice');
            if (existingChoice) existingChoice.remove();

            const choiceContainer = document.createElement('div');
            choiceContainer.id = 'perspective-choice';
            choiceContainer.style.cssText = `
        display: flex;
        gap: 15px;
        margin: 15px 0;
        padding: 15px;
        background: #fff3cd;
        border-radius: 8px;
        border: 2px dashed #ffc107;
    `;

            const infoText = document.createElement('div');
            infoText.style.cssText = `
        flex: 1;
        font-size: 13px;
        color: #856404;
        line-height: 1.5;
    `;
            infoText.innerHTML = `
        <strong>ğŸ“ é€è¦–æ ¡æ­£èªªæ˜ï¼š</strong><br>
        â€¢ <strong>éœ€è¦æ ¡æ­£</strong>ï¼šæ‹æ”è§’åº¦å‚¾æ–œï¼Œæ£‹ç›¤å‘ˆæ¢¯å½¢<br>
        â€¢ <strong>è·³éæ ¡æ­£</strong>ï¼šå·²æ¥è¿‘æ­£ä¸Šæ–¹ä¿¯æ‹ï¼Œæ£‹ç›¤æ˜¯çŸ©å½¢
    `;

            const btnContainer = document.createElement('div');
            btnContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 10px;
    `;

            // åŸ·è¡Œæ ¡æ­£æŒ‰éˆ•
            const correctBtn = document.createElement('button');
            correctBtn.innerHTML = 'ğŸ”„ åŸ·è¡Œé€è¦–æ ¡æ­£';
            correctBtn.style.cssText = `
        padding: 10px 20px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        transition: all 0.2s;
    `;
            correctBtn.addEventListener('mouseenter', () => {
                correctBtn.style.transform = 'translateY(-2px)';
                correctBtn.style.boxShadow = '0 4px 12px rgba(0,123,255,0.3)';
            });
            correctBtn.addEventListener('mouseleave', () => {
                correctBtn.style.transform = 'none';
                correctBtn.style.boxShadow = 'none';
            });
            correctBtn.addEventListener('click', () => {
                choiceContainer.remove();
                performPerspectiveCorrection();
            });

            // è·³éæ ¡æ­£æŒ‰éˆ•
            const skipBtn = document.createElement('button');
            skipBtn.innerHTML = 'â­ï¸ è·³éæ ¡æ­£';
            skipBtn.style.cssText = `
        padding: 10px 20px;
        background: #28a745;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
        font-size: 14px;
        transition: all 0.2s;
    `;
            skipBtn.addEventListener('mouseenter', () => {
                skipBtn.style.transform = 'translateY(-2px)';
                skipBtn.style.boxShadow = '0 4px 12px rgba(40,167,69,0.3)';
            });
            skipBtn.addEventListener('mouseleave', () => {
                skipBtn.style.transform = 'none';
                skipBtn.style.boxShadow = 'none';
            });
            skipBtn.addEventListener('click', () => {
                choiceContainer.remove();
                skipPerspectiveCorrection();
            });

            btnContainer.appendChild(correctBtn);
            btnContainer.appendChild(skipBtn);

            choiceContainer.appendChild(infoText);
            choiceContainer.appendChild(btnContainer);

            // æ’å…¥åˆ°åœ–ç‰‡å®¹å™¨å¾Œé¢
            imageContainer.parentNode.insertBefore(choiceContainer, actionButtons);
        }

// ğŸ”¥ æ–°å¢ï¼šè·³éé€è¦–æ ¡æ­£ï¼Œç›´æ¥é€²å…¥ä¸­å…µæ¨™è¨»
        function skipPerspectiveCorrection() {
            console.log('â­ï¸ ç”¨æˆ¶é¸æ“‡è·³éé€è¦–æ ¡æ­£');

            // æ¨™è¨˜ç‚ºæœªæ ¡æ­£ç‹€æ…‹
            window.perspectiveMatrix = null;
            window.originalCorners = null;
            window.originalCanvasSize = null;

            currentStep = 2;
            updateStepIndicator();
            statusDisplay.textContent = 'âœ… å·²è·³éæ ¡æ­£ï¼è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®';
            statusDisplay.style.background = '#d4edda';
            statusDisplay.style.color = '#155724';

            setTimeout(() => {
                startPawnAnnotation();
            }, 500);
        }

        /**
         * ğŸ”¥ ä¿®æ­£ç‰ˆï¼šé€è¦–æ ¡æ­£å‡½æ•¸
         * æ ¡æ­£å¾Œçš„åœ–å°‡ç›´æ¥ç”¨æ–¼ AI è­˜åˆ¥ï¼Œæ‰€æœ‰å¾ŒçºŒæ“ä½œéƒ½åœ¨æ ¡æ­£å¾Œçš„åœ–ä¸Šé€²è¡Œ
         */
        function performPerspectiveCorrection() {
            statusDisplay.textContent = 'ğŸ”„ æ­£åœ¨é€²è¡Œé€è¦–æ ¡æ­£...';
            statusDisplay.style.background = '#cce5ff';
            statusDisplay.style.color = '#004085';

            const ctx = canvas.getContext('2d');

            // æ·»åŠ å…§é‚Šè·
            const padding = 150;
            const targetWidth = 1620;   // 3å€æ”¾å¤§ (540 Ã— 3)
            const targetHeight = 1800;  // 3å€æ”¾å¤§ (600 Ã— 3)
            const fullWidth = targetWidth + padding * 2;
            const fullHeight = targetHeight + padding * 2;

            // å‰µå»ºè‡¨æ™‚ canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = fullWidth;
            tempCanvas.height = fullHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // ğŸ”¥ ä¿å­˜åŸå§‹è§’é»ï¼ˆåœ¨æ ¡æ­£å‰ï¼‰
            window.originalCorners = JSON.parse(JSON.stringify(corners));
            console.log('âœ… å·²ä¿å­˜åŸå§‹è§’é»:', window.originalCorners);

            // ğŸ”¥ é‡è¦ï¼šæºåº§æ¨™ï¼ˆåŸå§‹æ–œè¦–åœ–çš„å››è§’ï¼‰
            const srcPoints = [
                corners[0].x, corners[0].y,  // å·¦ä¸Š
                corners[1].x, corners[1].y,  // å³ä¸Š
                corners[2].x, corners[2].y,  // å³ä¸‹
                corners[3].x, corners[3].y   // å·¦ä¸‹
            ];

            // ğŸ”¥ é‡è¦ï¼šç›®æ¨™åº§æ¨™ï¼ˆæ ¡æ­£å¾Œçš„æ¨™æº–çŸ©å½¢ï¼‰
            const dstPoints = [
                padding, padding,                              // å·¦ä¸Š
                padding + targetWidth, padding,                // å³ä¸Š
                padding + targetWidth, padding + targetHeight, // å³ä¸‹
                padding, padding + targetHeight                // å·¦ä¸‹
            ];

            console.log('ğŸ“Š é€è¦–è®Šæ›è³‡è¨Š:');
            console.log('  æºå››è§’ (åŸå§‹åœ–):', srcPoints);
            console.log('  ç›®æ¨™å››è§’ (æ ¡æ­£å¾Œ):', dstPoints);

            // ğŸ”¥ è¨ˆç®—ä¸¦ä¿å­˜é€è¦–è®Šæ›çŸ©é™£
            window.perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);

            // ğŸ”¥ åŒæ™‚ä¿å­˜åŸå§‹ canvas å°ºå¯¸
            window.originalCanvasSize = {
                width: canvas.width,
                height: canvas.height
            };

            console.log('âœ… å·²ä¿å­˜é€è¦–çŸ©é™£:', window.perspectiveMatrix);
            console.log('âœ… å·²ä¿å­˜åŸå§‹ Canvas å°ºå¯¸:', window.originalCanvasSize);

            // åŸ·è¡Œé€è¦–è®Šæ›
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const transformedData = tempCtx.createImageData(fullWidth, fullHeight);
            const srcData = imageData.data;
            const dstData = transformedData.data;

            // ä½¿ç”¨é›™ç·šæ€§æ’å€¼
            for (let y = 0; y < fullHeight; y++) {
                for (let x = 0; x < fullWidth; x++) {
                    const srcCoord = applyPerspectiveTransform(x, y, window.perspectiveMatrix, true);
                    const interpolated = bilinearInterpolation(imageData, srcCoord.x, srcCoord.y);

                    const dstIdx = (y * fullWidth + x) * 4;
                    dstData[dstIdx] = interpolated.r;
                    dstData[dstIdx + 1] = interpolated.g;
                    dstData[dstIdx + 2] = interpolated.b;
                    dstData[dstIdx + 3] = interpolated.a;
                }
            }

            tempCtx.putImageData(transformedData, 0, 0);

            // æ›´æ–°ä¸» canvas
            canvas.width = fullWidth;
            canvas.height = fullHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);

            // æ›´æ–° originalImage
            originalImage = new Image();
            originalImage.onload = () => {

                // ğŸ”¥ æ–°å¢ï¼šä¿å­˜æ ¡æ­£å¾Œçš„å…¨å°ºå¯¸ canvas
                const correctedFullCanvas = document.createElement('canvas');
                correctedFullCanvas.width = fullWidth;  // 620 (540 + 40*2)
                correctedFullCanvas.height = fullHeight; // 680 (600 + 40*2)
                const corrFullCtx = correctedFullCanvas.getContext('2d');
                corrFullCtx.drawImage(tempCanvas, 0, 0);

                window.correctedFullCanvas = correctedFullCanvas;
                console.log('âœ… æ ¡æ­£å¾Œå…¨å°ºå¯¸ Canvas:', correctedFullCanvas.width, 'x', correctedFullCanvas.height);

                // æ›´æ–°è§’é»åº§æ¨™ï¼ˆæ ¡æ­£å¾Œçš„æ¨™æº–çŸ©å½¢ï¼‰
                corners = [
                    { x: padding, y: padding },
                    { x: padding + targetWidth, y: padding },
                    { x: padding + targetWidth, y: padding + targetHeight },
                    { x: padding, y: padding + targetHeight }
                ];

                console.log('âœ… é€è¦–æ ¡æ­£å®Œæˆ');
                console.log('   - Canvas å°ºå¯¸:', canvas.width, 'x', canvas.height);
                console.log('   - æ–°è§’é»:', corners);
                console.log('   - çŸ©é™£å·²ä¿å­˜:', !!window.perspectiveMatrix);
                console.log('   - åŸå§‹è§’é»å·²ä¿å­˜:', !!window.originalCorners);

                statusDisplay.textContent = 'âœ… é€è¦–æ ¡æ­£å®Œæˆï¼';
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';

                setTimeout(() => {
                    currentStep = 2;
                    updateStepIndicator();
                    statusDisplay.textContent = 'è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®ï¼ˆç¬¬5åˆ—å¾ä¸‹æ•¸ç¬¬3è¡Œï¼‰';
                    statusDisplay.style.background = '#fff3cd';
                    statusDisplay.style.color = '#856404';
                    startPawnAnnotation();
                }, 1000);
            };
            originalImage.src = canvas.toDataURL();
        }


        /**
         * ğŸ”¥ æ–°å¢: é›™ç·šæ€§æ’å€¼å‡½æ•¸ï¼ˆæ”¹å–„å½±åƒå“è³ªï¼‰
         */
        function bilinearInterpolation(imageData, x, y) {
            const w = imageData.width;
            const h = imageData.height;
            const data = imageData.data;

            // é‚Šç•Œæª¢æŸ¥
            if (x < 0 || x >= w - 1 || y < 0 || y >= h - 1) {
                return { r: 0, g: 0, b: 0, a: 0 };
            }

            const x1 = Math.floor(x);
            const y1 = Math.floor(y);
            const x2 = x1 + 1;
            const y2 = y1 + 1;

            const dx = x - x1;
            const dy = y - y1;

            // å–å¾—å››å€‹é„°è¿‘åƒç´ 
            const getPixel = (px, py) => {
                if (px < 0 || px >= w || py < 0 || py >= h) {
                    return { r: 0, g: 0, b: 0, a: 0 };
                }
                const idx = (py * w + px) * 4;
                return {
                    r: data[idx],
                    g: data[idx + 1],
                    b: data[idx + 2],
                    a: data[idx + 3]
                };
            };

            const p11 = getPixel(x1, y1);
            const p21 = getPixel(x2, y1);
            const p12 = getPixel(x1, y2);
            const p22 = getPixel(x2, y2);

            // é›™ç·šæ€§æ’å€¼è¨ˆç®—
            const interpolate = (v11, v21, v12, v22) => {
                return Math.round(
                    v11 * (1 - dx) * (1 - dy) +
                    v21 * dx * (1 - dy) +
                    v12 * (1 - dx) * dy +
                    v22 * dx * dy
                );
            };

            return {
                r: interpolate(p11.r, p21.r, p12.r, p22.r),
                g: interpolate(p11.g, p21.g, p12.g, p22.g),
                b: interpolate(p11.b, p21.b, p12.b, p22.b),
                a: interpolate(p11.a, p21.a, p12.a, p22.a)
            };
        }

        /**
         * è¨ˆç®—é€è¦–è®Šæ›çŸ©é™£ (8åƒæ•¸æ³•)
         */
        function getPerspectiveTransform(src, dst) {
            const A = [];
            for (let i = 0; i < 4; i++) {
                const sx = src[i * 2];
                const sy = src[i * 2 + 1];
                const dx = dst[i * 2];
                const dy = dst[i * 2 + 1];

                A.push([sx, sy, 1, 0, 0, 0, -dx * sx, -dx * sy]);
                A.push([0, 0, 0, sx, sy, 1, -dy * sx, -dy * sy]);
            }

            const b = [dst[0], dst[1], dst[2], dst[3], dst[4], dst[5], dst[6], dst[7]];
            const h = solveLinearSystem(A, b);

            return [
                h[0], h[1], h[2],
                h[3], h[4], h[5],
                h[6], h[7], 1
            ];
        }

        /**
         * æ‡‰ç”¨é€è¦–è®Šæ›
         */
        function applyPerspectiveTransform(x, y, matrix, inverse = false) {
            if (inverse) {
                const invMatrix = invertMatrix3x3(matrix);
                return applyMatrix(x, y, invMatrix);
            }
            return applyMatrix(x, y, matrix);
        }

        function applyMatrix(x, y, m) {
            const w = m[6] * x + m[7] * y + m[8];
            return {
                x: (m[0] * x + m[1] * y + m[2]) / w,
                y: (m[3] * x + m[4] * y + m[5]) / w
            };
        }

        /**
         * è§£ç·šæ€§æ–¹ç¨‹çµ„ (é«˜æ–¯æ¶ˆå»æ³•)
         */
        function solveLinearSystem(A, b) {
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        /**
         * è¨ˆç®— 3x3 çŸ©é™£çš„é€†çŸ©é™£
         */
        function invertMatrix3x3(m) {
            const det = m[0] * (m[4] * m[8] - m[5] * m[7]) -
                m[1] * (m[3] * m[8] - m[5] * m[6]) +
                m[2] * (m[3] * m[7] - m[4] * m[6]);

            if (Math.abs(det) < 1e-10) {
                console.error('çŸ©é™£ä¸å¯é€†');
                return m;
            }

            return [
                (m[4] * m[8] - m[5] * m[7]) / det,
                (m[2] * m[7] - m[1] * m[8]) / det,
                (m[1] * m[5] - m[2] * m[4]) / det,
                (m[5] * m[6] - m[3] * m[8]) / det,
                (m[0] * m[8] - m[2] * m[6]) / det,
                (m[2] * m[3] - m[0] * m[5]) / det,
                (m[3] * m[7] - m[4] * m[6]) / det,
                (m[1] * m[6] - m[0] * m[7]) / det,
                (m[0] * m[4] - m[1] * m[3]) / det
            ];
        }

        function startPawnAnnotation() {
            pawns = [];
            statusDisplay.textContent = 'è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®ï¼ˆç¬¬5åˆ—æœªç§»å‹•éçš„ä¸­å…µä½ç½®ï¼‰(æ£‹ç›¤å·²æ ¡æ­£ç‚ºæ¨™æº–ä¿¯è¦–åœ–)';
            statusDisplay.style.background = '#fff3cd';
            statusDisplay.style.color = '#856404';

            canvas.addEventListener('click', handlePawnClick);
        }

        function handlePawnClick(e) {
            if (pawns.length >= 1) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // ç¬¬ä¸€æ­¥ï¼šè¢å¹•åº§æ¨™ â†’ Canvas å…§éƒ¨åº§æ¨™
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = clickX * scaleX;
            const canvasY = clickY * scaleY;

            // ğŸ”¥ ç¬¬äºŒæ­¥ï¼šCanvas å…§éƒ¨åº§æ¨™ â†’ åŸå§‹åœ–ç‰‡åº§æ¨™
            const imgScaleX = originalImage.width / canvas.width;
            const imgScaleY = originalImage.height / canvas.height;
            const originalX = canvasX * imgScaleX;
            const originalY = canvasY * imgScaleY;

            console.log('=== ä¸­å…µé»æ“Šåº§æ¨™è½‰æ› ===');
            console.log('ğŸ” ä¸‰å±¤åº§æ¨™ç³»çµ±:');
            console.log('  1. è¢å¹•åº§æ¨™:', clickX.toFixed(1), clickY.toFixed(1));
            console.log('  2. Canvas å…§éƒ¨åº§æ¨™:', canvasX.toFixed(1), canvasY.toFixed(1));
            console.log('  3. åŸå§‹åœ–ç‰‡åº§æ¨™:', originalX.toFixed(1), originalY.toFixed(1));
            console.log('ğŸ”§ è½‰æ›æ¯”ä¾‹:');
            console.log('  è¢å¹•â†’Canvas:', scaleX.toFixed(2), 'x', scaleY.toFixed(2));
            console.log('  Canvasâ†’åŸåœ–:', imgScaleX.toFixed(2), 'x', imgScaleY.toFixed(2));
            console.log('  ç¸½æ¯”ä¾‹:', (scaleX * imgScaleX).toFixed(2), 'x', (scaleY * imgScaleY).toFixed(2));
            console.log('ğŸ“ å°ºå¯¸è³‡è¨Š:');
            console.log('  åŸå§‹åœ–ç‰‡:', originalImage.width, 'x', originalImage.height);
            console.log('  Canvas:', canvas.width, 'x', canvas.height);
            console.log('  è¢å¹•é¡¯ç¤º:', rect.width.toFixed(1), 'x', rect.height.toFixed(1));

            // ğŸ”¥ ä¿å­˜åŸå§‹åœ–ç‰‡åº§æ¨™ (ç”¨æ–¼ AI æª¢æ¸¬æ˜ å°„)
            pawns.push({ x: originalX, y: originalY });

            console.log('âœ… å·²ä¿å­˜ä¸­å…µåŸå§‹åº§æ¨™:', pawns);
            console.log('===============');

            // ç¹ªè£½æ¨™è¨˜é» (ä½¿ç”¨ Canvas å…§éƒ¨åº§æ¨™)
            const ctx = canvas.getContext('2d');

// âœ… æ ¹æ“š Canvas å°ºå¯¸å‹•æ…‹èª¿æ•´å¤§å°
            const scale = Math.min(canvas.width, canvas.height) / 640;  // ä»¥ 640 ç‚ºåŸºæº–
            const outerRadius = 15 * scale;   // å¤–åœˆ
            const innerRadius = 8 * scale;    // å…§åœˆ
            const fontSize = 16 * scale;      // æ–‡å­—

            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, outerRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#0000ff';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, innerRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ä¸­', canvasX, canvasY);
            canvas.removeEventListener('click', handlePawnClick);

            currentStep = 3;
            updateStepIndicator();
            statusDisplay.textContent = 'âœ… æ¨™è¨»å®Œæˆï¼æº–å‚™é–‹å§‹ AI è­˜åˆ¥...';
            statusDisplay.style.background = '#d4edda';
            statusDisplay.style.color = '#155724';

            setTimeout(() => {
                simulateAIDetection();
            }, 2000);
        }


        // ğŸ”¥ ä¿®å¾©ç‰ˆï¼šå®Œæ•´çš„ AI è­˜åˆ¥å‡½æ•¸ï¼ˆè™•ç† label å¯èƒ½ç‚º undefinedï¼‰
        async function simulateAIDetection() {
            currentStep = 3;
            updateStepIndicator();
            statusDisplay.textContent = 'ğŸ¤– AI æ­£åœ¨è­˜åˆ¥æ£‹å­...';
            statusDisplay.style.background = '#cce5ff';
            statusDisplay.style.color = '#004085';

            try {
                // ğŸ”¥ åŠ å…¥é€™æ®µ
                if (!pawns || pawns.length === 0) {
                    throw new Error('æœªæ‰¾åˆ°ä¸­å…µæ¨™è¨»ä½ç½®');
                }
                const pawnPos = pawns[0];  // å®šç¾© pawnPos

                // æª¢æŸ¥æ¨¡å‹æ˜¯å¦å·²è¼‰å…¥
                if (!recognitionModel || !recognitionModel.session) {
                    throw new Error('æ¨¡å‹å°šæœªè¼‰å…¥å®Œæˆï¼Œè«‹ç¨å¾Œå†è©¦');
                }

                console.log('========================================');
                console.log('ğŸ” é–‹å§‹ AI è­˜åˆ¥...');
                console.log('========================================');
                console.log('ğŸ“ åŸºæœ¬ä¿¡æ¯:');
                console.log('  Canvas å°ºå¯¸:', canvas.width, 'x', canvas.height);
                console.log('  ä¸­å…µä½ç½®:', pawns[0]);
                console.log('  æ˜¯å¦è·³éæ ¡æ­£:', window.perspectiveMatrix === null);

                if (window.boardBoundingBox) {
                    console.log('  æ£‹ç›¤é‚Šç•Œæ¡†:', window.boardBoundingBox);
                }

                if (window.originalCorners) {
                    console.log('  åŸå§‹å››è§’:', window.originalCorners);
                }

                // ğŸ”¥ æ™ºèƒ½é¸æ“‡æª¢æ¸¬æº
                let detectionCanvas;
                if (window.correctedFullCanvas) {
                    // æƒ…æ³ Aï¼šæœ‰é€è¦–æ ¡æ­£ â†’ ä½¿ç”¨æ ¡æ­£å¾Œçš„å…¨å°ºå¯¸ canvas
                    detectionCanvas = window.correctedFullCanvas;
                    console.log('ğŸ“ ä½¿ç”¨æ ¡æ­£å¾Œçš„å…¨å°ºå¯¸ Canvas:', detectionCanvas.width, 'x', detectionCanvas.height);
                } else if (window.originalFullCanvas) {
                    // æƒ…æ³ Bï¼šç„¡é€è¦–æ ¡æ­£ â†’ ä½¿ç”¨åŸå§‹å…¨å°ºå¯¸ canvas
                    detectionCanvas = window.originalFullCanvas;
                    console.log('ğŸ“ ä½¿ç”¨åŸå§‹å…¨å°ºå¯¸ Canvas:', detectionCanvas.width, 'x', detectionCanvas.height);
                } else {
                    // æƒ…æ³ Cï¼šé™ç´šæ–¹æ¡ˆï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿï¼‰
                    detectionCanvas = canvas;
                    console.warn('âš ï¸ ä½¿ç”¨é¡¯ç¤º Canvasï¼ˆå¯èƒ½å½±éŸ¿æº–ç¢ºåº¦ï¼‰');
                }

// ğŸ”¥ åŸ·è¡Œ YOLOv5 æª¢æ¸¬
                const detections = await recognitionModel.detect(detectionCanvas);

                console.log('\nâœ… æª¢æ¸¬å®Œæˆï¼');
                console.log('  æª¢æ¸¬åˆ°æ£‹å­æ•¸é‡:', detections.length);

                // ğŸ”¥ å…ˆæª¢æŸ¥æª¢æ¸¬çµæœçš„çµæ§‹
                console.log('\nğŸ” æª¢æŸ¥ç¬¬ä¸€å€‹æª¢æ¸¬çµæœçš„çµæ§‹:');
                if (detections.length > 0) {
                    console.log('  ç¬¬ä¸€å€‹æª¢æ¸¬:', detections[0]);
                    console.log('  å¯ç”¨å±¬æ€§:', Object.keys(detections[0]));
                }

                // ğŸ”¥ èª¿è©¦1ï¼šæ‰“å°æ‰€æœ‰æª¢æ¸¬åº§æ¨™ï¼ˆæŒ‰ Y è»¸æ’åºï¼Œè™•ç† label å¯èƒ½ç‚ºç©ºï¼‰
                console.log('\nğŸ“ æ‰€æœ‰æª¢æ¸¬åº§æ¨™ï¼ˆæŒ‰ Y è»¸ç”±ä¸Šåˆ°ä¸‹æ’åºï¼‰:');
                console.log('åºè™Ÿ | æ£‹å­é¡å‹     | X åº§æ¨™  | Y åº§æ¨™  | ç½®ä¿¡åº¦');
                console.log('-----|-------------|---------|---------|--------');

                const sortedDetections = [...detections].sort((a, b) => a.y - b.y);
                sortedDetections.forEach((det, i) => {
                    const index = String(i + 1).padStart(2, '0');
                    // ğŸ”¥ ä¿®å¾©ï¼šè™•ç† label å¯èƒ½ç‚º undefined æˆ–å…¶ä»–å±¬æ€§å
                    const label = (det.label || det.class || det.name || 'unknown').toString().padEnd(12);
                    const x = det.x.toFixed(1).padStart(7);
                    const y = det.y.toFixed(1).padStart(7);
                    const conf = (det.confidence || det.score || 0).toFixed(3);
                    console.log(`${index}   | ${label} | ${x} | ${y} | ${conf}`);
                });

                // ğŸ”¥ èª¿è©¦2ï¼šçµ±è¨ˆ Y åº§æ¨™åˆ†å¸ƒ
                const yCoords = detections.map(d => d.y);
                const minY = Math.min(...yCoords);
                const maxY = Math.max(...yCoords);
                const rangeY = maxY - minY;

                console.log('\nğŸ“Š Y åº§æ¨™çµ±è¨ˆ:');
                console.log('  æœ€å° Y (æœ€ä¸Šé¢çš„æ£‹å­):', minY.toFixed(1));
                console.log('  æœ€å¤§ Y (æœ€ä¸‹é¢çš„æ£‹å­):', maxY.toFixed(1));
                console.log('  Y è»¸ç¯„åœ:', rangeY.toFixed(1), 'pixels');
                console.log('  Canvas ç¸½é«˜åº¦:', canvas.height, 'pixels');
                console.log('  ä¸­å…µ Y åº§æ¨™:', pawns[0].y.toFixed(1));
                console.log('  ä½¿ç”¨ç‡:', (rangeY / canvas.height * 100).toFixed(1) + '%');

                // ğŸ”¥ èª¿è©¦3ï¼šæª¢æŸ¥ X åº§æ¨™åˆ†å¸ƒ
                const xCoords = detections.map(d => d.x);
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                const rangeX = maxX - minX;

                console.log('\nğŸ“Š X åº§æ¨™çµ±è¨ˆ:');
                console.log('  æœ€å° X (æœ€å·¦é‚Šçš„æ£‹å­):', minX.toFixed(1));
                console.log('  æœ€å¤§ X (æœ€å³é‚Šçš„æ£‹å­):', maxX.toFixed(1));
                console.log('  X è»¸ç¯„åœ:', rangeX.toFixed(1), 'pixels');
                console.log('  Canvas ç¸½å¯¬åº¦:', canvas.width, 'pixels');
                console.log('  ä½¿ç”¨ç‡:', (rangeX / canvas.width * 100).toFixed(1) + '%');

                // ğŸ”¥ èª¿è©¦4ï¼šæŒ‰è¡Œçµ±è¨ˆæ£‹å­åˆ†å¸ƒ
                console.log('\nğŸ“Š æ£‹å­æŒ‰ Y åº§æ¨™åˆ†æ®µçµ±è¨ˆ (å‡è¨­æ£‹ç›¤ä½”æ»¿æ•´å€‹ Canvas):');
                const rowHeight = canvas.height / 10;
                for (let row = 0; row < 10; row++) {
                    const rowStart = row * rowHeight;
                    const rowEnd = (row + 1) * rowHeight;
                    const piecesInRow = detections.filter(d => d.y >= rowStart && d.y < rowEnd);
                    const pieceLabels = piecesInRow.map(p => p.label || p.class || '?').join(', ');
                    console.log(`  ç¬¬ ${row} è¡Œ (Y: ${rowStart.toFixed(0).padStart(3)}-${rowEnd.toFixed(0).padStart(3)}): ${piecesInRow.length} å€‹ ${pieceLabels ? 'â†’ ' + pieceLabels : ''}`);
                }

                // ğŸ”¥ è½‰æ›ç‚ºæ£‹ç›¤é™£åˆ—
                console.log('\nğŸ—ºï¸ é–‹å§‹åº§æ¨™æ˜ å°„...');
                // åœ¨ä½ èª¿ç”¨ detectionsToBoard çš„åœ°æ–¹
                const board = recognitionModel.detectionsToBoard(detections, pawnPos, window.corners);

                // ğŸ”¥ èª¿è©¦5ï¼šæ‰“å°æ£‹ç›¤é™£åˆ—
                console.log('\nğŸ² æ£‹ç›¤é™£åˆ—:');
                for (let row = 0; row < 10; row++) {
                    const rowStr = board[row].map(cell => cell || 'ã€€').join(' ');
                    const count = board[row].filter(c => c !== null).length;
                    console.log(`  ç¬¬ ${row} è¡Œ: ${rowStr} (${count} å€‹æ£‹å­)`);
                }

                // ğŸ”¥ è½‰æ›ç‚º FEN ç¢¼
                const fen = recognitionModel.boardToFEN(board, 'red');
                console.log('\nğŸ“ ç”Ÿæˆ FEN:', fen);
                console.log('========================================\n');

                // ğŸ”¥ è‡ªå‹•å°å…¥åˆ°è™›æ“¬æ£‹ç›¤
                fenInput.value = fen;
                parseFENToBoard(fen);

                currentStep = 4;
                updateStepIndicator();
                statusDisplay.textContent = 'âœ… AI è­˜åˆ¥å®Œæˆï¼è«‹æª¢æŸ¥è™›æ“¬æ£‹ç›¤';
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';

            } catch (error) {
                console.error('========================================');
                console.error('âŒ AI è­˜åˆ¥å¤±æ•—:', error);
                console.error('éŒ¯èª¤å †ç–Š:', error.stack);
                console.error('========================================');

                statusDisplay.textContent = 'âŒ è­˜åˆ¥å¤±æ•—: ' + error.message;
                statusDisplay.style.background = '#f8d7da';
                statusDisplay.style.color = '#721c24';

                // ğŸ”¥ é™ç´šæ–¹æ¡ˆï¼šä½¿ç”¨æ¨¡æ“¬æ•¸æ“š
                setTimeout(() => {
                    statusDisplay.textContent = 'âš ï¸ ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šï¼ˆæ¨¡å‹å¯èƒ½æœªå°±ç·’ï¼‰';
                    statusDisplay.style.background = '#fff3cd';
                    statusDisplay.style.color = '#856404';

                    const mockFen = 'rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w';
                    fenInput.value = mockFen;
                    parseFENToBoard(mockFen);
                }, 2000);
            }
        }

        // ========== ğŸ”¥ è¦æ”¹çš„åœ°æ–¹ ==========

// 1ï¸âƒ£ ä¿®æ”¹ startOnlineScreenshotFlow()
        async function startOnlineScreenshotFlow() {
            console.log('ğŸ® ç”¨æˆ¶é¸æ“‡ï¼šç·šä¸Šæˆªåœ–è­˜åˆ¥ï¼ˆå¸¶å››è§’æ¨™è¨»ï¼‰');

            // ğŸ”¥ æ¨™è¨˜ç‚ºç·šä¸Šæ¨¡å¼
            window.isOnlineMode = true;

            currentStep = 1;
            updateStepIndicator();
            statusDisplay.textContent = 'è«‹ä¾åºé»æ“Šæ£‹ç›¤å››å€‹è§’ï¼šå·¦ä¸Š â†’ å³ä¸Š â†’ å³ä¸‹ â†’ å·¦ä¸‹';
            statusDisplay.style.background = '#fff3cd';
            statusDisplay.style.color = '#856404';
            statusDisplay.style.border = '2px solid #ffc107';

            // é–‹å§‹å››è§’æ¨™è¨»
            startCornerAnnotation();
        }

        // 3ï¸âƒ£ æ–°å¢ startPawnAnnotationForOnline() å‡½æ•¸
        function startPawnAnnotationForOnline() {
            pawns = [];
            statusDisplay.textContent = 'è«‹é»æ“Šä¸­è·¯çš„ç´…å…µä½ç½®ï¼ˆç¬¬5åˆ—ï¼Œç”¨æ–¼å®šä½ï¼‰';
            statusDisplay.style.background = '#fff3cd';
            statusDisplay.style.color = '#856404';

            canvas.addEventListener('click', handlePawnClickForOnline);
        }

        // 4ï¸âƒ£ æ–°å¢ handlePawnClickForOnline() å‡½æ•¸
        function handlePawnClickForOnline(e) {
            if (pawns.length >= 1) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // è¢å¹•åº§æ¨™ â†’ Canvas åº§æ¨™
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = clickX * scaleX;
            const canvasY = clickY * scaleY;

            // Canvas åº§æ¨™ â†’ åŸå§‹åœ–ç‰‡åº§æ¨™
            const imgScaleX = originalImage.width / canvas.width;
            const imgScaleY = originalImage.height / canvas.height;
            const originalX = canvasX * imgScaleX;
            const originalY = canvasY * imgScaleY;

            console.log('=== ç·šä¸Šæ¨¡å¼ä¸­å…µåº§æ¨™ ===');
            console.log('  åŸå§‹åœ–ç‰‡åº§æ¨™:', originalX.toFixed(1), originalY.toFixed(1));

            pawns.push({ x: originalX, y: originalY });

            // ç¹ªè£½æ¨™è¨˜
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 15, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#0000ff';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ä¸­', canvasX, canvasY);

            canvas.removeEventListener('click', handlePawnClickForOnline);

            currentStep = 3;
            updateStepIndicator();
            statusDisplay.textContent = 'âœ… æ¨™è¨»å®Œæˆï¼æº–å‚™é–‹å§‹ AI è­˜åˆ¥...';
            statusDisplay.style.background = '#d4edda';
            statusDisplay.style.color = '#155724';

            setTimeout(() => {
                executeOnlineRecognition();
            }, 1000);
        }


// 5ï¸âƒ£ æ–°å¢ executeOnlineRecognition() å‡½æ•¸
        async function executeOnlineRecognition() {
            currentStep = 3;
            updateStepIndicator();
            statusDisplay.textContent = 'ğŸ® æ­£åœ¨ä½¿ç”¨é›™æ¨¡å‹è­˜åˆ¥ï¼Œè«‹ç¨å€™...';
            statusDisplay.style.background = '#d1f2eb';
            statusDisplay.style.color = '#155724';
            statusDisplay.style.border = '2px solid #28a745';

            try {
                if (!onlineGameModel || !onlineGameModel.detectorSession || !onlineGameModel.classifierSession) {
                    throw new Error('ç·šä¸ŠéŠæˆ²æ¨¡å‹å°šæœªè¼‰å…¥');
                }

                const sourceCanvas = window.originalFullCanvas || canvas;
                console.log('ğŸ“¤ è­˜åˆ¥åœ–ç‰‡å°ºå¯¸:', sourceCanvas.width, 'x', sourceCanvas.height);

                // åŸ·è¡Œè­˜åˆ¥
                const detections = await onlineGameModel.detect(sourceCanvas);

                // ğŸ”¥ ä½¿ç”¨å››è§’å’Œä¸­å…µé€²è¡Œåº§æ¨™æ˜ å°„
                const board = onlineGameModel.detectionsToBoard(detections, pawns[0], window.corners);

                // ç”Ÿæˆ FEN
                const fen = onlineGameModel.boardToFEN(board, 'red');
                console.log('ğŸ“ ç”Ÿæˆ FEN:', fen);

                // å°å…¥è™›æ“¬æ£‹ç›¤
                fenInput.value = fen;
                parseFENToBoard(fen);

                currentStep = 4;
                updateStepIndicator();

                statusDisplay.innerHTML = `
            <div style="text-align: center;">
                <div style="font-size: 20px; margin-bottom: 8px;">âœ… è­˜åˆ¥å®Œæˆï¼</div>
                <div style="font-size: 13px; color: #155724; line-height: 1.6;">
                    <strong>è­˜åˆ¥æ•¸é‡:</strong> ${detections.length} å€‹æ£‹å­<br>
                    <strong>å®šä½æ–¹å¼:</strong> å››è§’ + ä¸­å…µ
                </div>
            </div>
        `;
                statusDisplay.style.background = '#d4edda';
                statusDisplay.style.color = '#155724';

                // ğŸ”¥ æ¸…é™¤ç·šä¸Šæ¨¡å¼æ¨™è¨˜
                window.isOnlineMode = false;

            } catch (error) {
                console.error('âŒ è­˜åˆ¥å¤±æ•—:', error);
                statusDisplay.textContent = 'âŒ è­˜åˆ¥å¤±æ•—: ' + error.message;
                statusDisplay.style.background = '#f8d7da';
                statusDisplay.style.color = '#721c24';
                window.isOnlineMode = false;
            }
        }





        function showRecognitionChoice() {
            // åˆ›å»ºé®ç½©å±‚
            const overlay = document.createElement('div');
            overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 10001;
        display: flex;
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s;
    `;

            // åˆ›å»ºå¼¹çª—
            const dialog = document.createElement('div');
            dialog.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 30px;
        max-width: 450px;
        width: 90%;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        animation: slideIn 0.3s;
    `;

            dialog.innerHTML = `
        <style>
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes slideIn {
                from { transform: translateY(-50px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
        </style>

        <div style="text-align: center; margin-bottom: 25px;">
            <div style="font-size: 48px; margin-bottom: 12px;">ğŸ“¸</div>
            <h2 style="margin: 0; font-size: 22px; color: #333;">è«‹é¸æ“‡è­˜åˆ¥æ–¹å¼</h2>
        </div>

        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button id="choose-local-model" style="
                padding: 16px 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-weight: bold;
                font-size: 15px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(102,126,234,0.4);
            ">
                ğŸ–¥ï¸ å¯¦é«”æ£‹ç›¤
                <div style="font-size: 11px; margin-top: 6px; opacity: 0.95;">
                    æ‹æ”å¯¦é«”æ£‹ç›¤ï¼Œéœ€æ‰‹å‹•æ¨™è¨»å››è§’+ä¸­å…µ
                </div>
            </button>

            <button id="choose-online-screenshot" style="
                padding: 16px 20px;
                background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-weight: bold;
                font-size: 15px;
                transition: all 0.3s;
                box-shadow: 0 4px 15px rgba(17,153,142,0.4);
            ">
                ğŸ® ç·šä¸Šæˆªåœ–
                <div style="font-size: 11px; margin-top: 6px; opacity: 0.95;">
                    éŠæˆ²è»Ÿé«”æˆªåœ–ï¼Œé›™æ¨¡å‹è‡ªå‹•è­˜åˆ¥
                </div>
            </button>
        </div>

        <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 8px; font-size: 11px; color: #666; line-height: 1.6;">
            ğŸ’¡ <strong>å¯¦é«”æ£‹ç›¤</strong>ï¼šé©åˆæ·ºè‰²ç³»æ£‹å­<br>
            ğŸ® <strong>ç·šä¸Šæˆªåœ–</strong>ï¼šé›™æ¨¡å‹è‡ªå‹•è­˜åˆ¥ç´…é»‘é™£ç‡Ÿ
        </div>

        <button id="close-choice-dialog" style="
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        ">å–æ¶ˆ</button>
    `;

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            setTimeout(() => {
                const localBtn = document.getElementById('choose-local-model');
                const onlineBtn = document.getElementById('choose-online-screenshot');
                const closeBtn = document.getElementById('close-choice-dialog');

                // å…³é—­å¼¹çª—å‡½æ•°
                const closeDialog = () => overlay.remove();

                // å®ä½“æ£‹ç›˜
                if (localBtn) {
                    localBtn.addEventListener('click', () => {
                        closeDialog();
                        startLocalModelFlow();
                    });
                    localBtn.addEventListener('mouseenter', () => {
                        localBtn.style.transform = 'translateY(-2px)';
                        localBtn.style.boxShadow = '0 6px 20px rgba(102,126,234,0.6)';
                    });
                    localBtn.addEventListener('mouseleave', () => {
                        localBtn.style.transform = 'none';
                        localBtn.style.boxShadow = '0 4px 15px rgba(102,126,234,0.4)';
                    });
                }

                // çº¿ä¸Šæˆªå›¾
                if (onlineBtn) {
                    onlineBtn.addEventListener('click', () => {
                        closeDialog();
                        startOnlineScreenshotFlow();
                    });
                    onlineBtn.addEventListener('mouseenter', () => {
                        onlineBtn.style.transform = 'translateY(-2px)';
                        onlineBtn.style.boxShadow = '0 6px 20px rgba(17,153,142,0.6)';
                    });
                    onlineBtn.addEventListener('mouseleave', () => {
                        onlineBtn.style.transform = 'none';
                        onlineBtn.style.boxShadow = '0 4px 15px rgba(17,153,142,0.4)';
                    });
                }

                // å–æ¶ˆæŒ‰é’®
                if (closeBtn) {
                    closeBtn.addEventListener('click', closeDialog);
                    closeBtn.addEventListener('mouseenter', () => {
                        closeBtn.style.background = '#5a6268';
                    });
                    closeBtn.addEventListener('mouseleave', () => {
                        closeBtn.style.background = '#6c757d';
                    });
                }

                // ç‚¹å‡»é®ç½©å…³é—­
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) closeDialog();
                });
            }, 50);
        }

        // é‡ç½®ç•Œé¢
        function resetInterface() {
            // ğŸ”¥ æ¸…é™¤æ‰€æœ‰æ¨™è¨»æ•¸æ“š
            corners = [];
            pawns = [];
            originalImage = null;

            // ğŸ”¥ æ¸…é™¤å…¨å±€è®Šæ•¸(é˜²æ­¢ä¸Šæ¬¡çš„é€è¦–æ ¡æ­£æ®˜ç•™)
            window.corners = [];
            window.pawnPositions = [];
            window.originalFullCanvas = null;
            window.correctedFullCanvas = null;
            window.perspectiveMatrix = null;
            window.originalCorners = null;
            window.originalCanvasSize = null;
            window.boardBoundingBox = null;
            window.isOnlineMode = false;

            // é‡ç½®æ­¥é©Ÿ
            currentStep = 0;
            updateStepIndicator();

            // é‡ç½® UI é¡¯ç¤º
            canvas.style.display = 'none';
            uploadPrompt.style.display = 'block';
            uploadBtn.style.display = 'block';
            cameraBtn.style.display = 'block';  // ğŸ‘ˆ æ·»åŠ è¿™è¡Œ
            resetBtn.style.display = 'none';
            undoBtn.style.display = 'none';

            statusDisplay.textContent = 'ç­‰å¾… AI è­˜åˆ¥çµæœ...';
            statusDisplay.style.background = '#e7f3ff';
            statusDisplay.style.color = '#0066cc';
            statusDisplay.style.border = 'none';

            fenInput.value = '';

            // ğŸ”¥ é‡ç½®è™›æ“¬æ£‹ç›¤ç‚ºåˆå§‹ç›¤é¢
            virtualValidator.resetToInitial();
            createVirtualChessBoard();

            fileInput.value = '';

            cameraInput.value = '';  // ğŸ‘ˆ æ·»åŠ è¿™è¡Œ

            console.log('ğŸ”„ ç•Œé¢å·²å®Œå…¨é‡ç½®');
        }

        rightPanel.appendChild(rightTitle);
        rightPanel.appendChild(stepIndicator);
        rightPanel.appendChild(imageContainer);
        rightPanel.appendChild(actionButtons);
        rightPanel.appendChild(fileInput);
        rightPanel.appendChild(cameraInput);  // ğŸ‘ˆ æ·»åŠ ç›¸æœº input

// ğŸ‘‡ åˆ›å»ºé—´è·å®¹å™¨
        const buttonSpacer = document.createElement('div');
        buttonSpacer.style.cssText = `
    margin-top: 20px;
    padding-top: 20px;
    border-top: 2px solid #e0e0e0;
`;

// ğŸ‘‡ ä¿®æ”¹ä¸¤ä¸ªæŒ‰é’®çš„æ ·å¼ï¼ˆå¢åŠ é—´è·ï¼‰
        applyFenBtn.style.marginBottom = '10px';
        applyToMainBtn.style.marginBottom = '20px';

// ğŸ‘‡ å°†ä¸¤ä¸ªæŒ‰é’®æ·»åŠ åˆ°é—´è·å®¹å™¨ä¸­
        buttonSpacer.appendChild(applyFenBtn);
        buttonSpacer.appendChild(applyToMainBtn);

// ğŸ‘‡ å°†å®¹å™¨æ·»åŠ åˆ° rightPanel
        rightPanel.appendChild(buttonSpacer);

        // ========== é—œé–‰æŒ‰éˆ• ==========
        const closeButton = document.createElement('button');
        closeButton.innerHTML = 'âœ•';
        closeButton.style.cssText = `
        position: absolute;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #dc3545;
        color: white;
        border: none;
        font-size: 24px;
        cursor: pointer;
        z-index: 10000;
    `;
        closeButton.addEventListener('click', () => {
            document.body.removeChild(container);
        });

        mainPanel.appendChild(leftPanel);
        mainPanel.appendChild(rightPanel);
        mainPanel.appendChild(closeButton);
        container.appendChild(mainPanel);
        document.body.appendChild(container);

        // ğŸ”¥ æš´éœ²å°å…¥ FEN çš„æ¥å£çµ¦å¤–éƒ¨èª¿ç”¨
        return {
            container: container,
            close: () => {
                if (document.body.contains(container)) {
                    document.body.removeChild(container);
                }
            },
            // ğŸ”¥ æ–°å¢ï¼šä¾› AI è­˜åˆ¥å®Œæˆå¾Œèª¿ç”¨
            importFEN: (fenCode) => {
                fenInput.value = fenCode;
                parseFENToBoard(fenCode);
            }
        };
    }

    // åˆå§‹åŒ–
    function initPhotoRecognitionSystem() {
        console.log('ğŸ“¸ æ‹ç…§è­˜åˆ¥ç³»çµ±è¼‰å…¥ä¸­...');
        const button = addPhotoRecognitionButton();
        console.log('âœ… æ‹ç…§è­˜åˆ¥ç³»çµ±å·²å°±ç·’ï¼');
        return {
            button: button,
            openUI: createPhotoRecognitionInterface
        };
    }

    // ========== ğŸ“Œ æ­¥é©Ÿ 5ï¼šåœ¨åˆå§‹åŒ–æ™‚åŒæ™‚è¼‰å…¥å…©å¥—æ¨¡å‹ ==========
    // ğŸ”¥ ä¿®æ”¹ä½ çš„è‡ªå‹•åˆå§‹åŒ–éƒ¨åˆ†

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initRecognitionModel();      // å¯¦é«”æ£‹ç›¤æ¨¡å‹
            initOnlineGameModel();        // ğŸ”¥ æ–°å¢ï¼šç·šä¸ŠéŠæˆ²æ¨¡å‹
            initPhotoRecognitionSystem();
        });
    } else {
        initRecognitionModel();
        initOnlineGameModel();            // ğŸ”¥ æ–°å¢ï¼šç·šä¸ŠéŠæˆ²æ¨¡å‹
        initPhotoRecognitionSystem();
    }

    // å°å‡ºä¾›å¤–éƒ¨ä½¿ç”¨
    if (typeof window !== 'undefined') {
        window.createPhotoRecognitionInterface = createPhotoRecognitionInterface;
        window.initPhotoRecognitionSystem = initPhotoRecognitionSystem;
    }

    console.log('âœ… æ‹ç…§è­˜åˆ¥åŠŸèƒ½æ¨¡å¡Šå·²è¼‰å…¥å®Œç•¢ - å¢å¼·ç‰ˆè™›æ“¬æ£‹ç›¤')

    // AIå°æˆ°æ¨¡å¼é…ç½® - æ–°çµæ§‹
    const AI_DIFFICULTIES = [
        { name: "ç°¡å–®", depth: 3 },
        { name: "ä¸­ç´š", depth: 6 },
        { name: "é«˜ç´š", depth: 9 },
        { name: "å°ˆæ¥­", depth: 12 },
        { name: "å¤§å¸«", depth: 15 }
    ];

    const AI_MODES = [];

    // å‹•æ…‹ç”Ÿæˆæ‰€æœ‰é›£åº¦+å…ˆå¾Œæ‰‹çµ„åˆ
    AI_DIFFICULTIES.forEach(difficulty => {
        // AIå¾Œæ‰‹ï¼ˆç©å®¶å…ˆæ‰‹ï¼‰
        AI_MODES.push({
            name: `${difficulty.name} - ç©å®¶å…ˆæ‰‹`,
            depth: difficulty.depth,
            aiFirst: false,
            aiColor: 'black',
            description: `AIæ·±åº¦${difficulty.depth}ï¼ŒAIåŸ·é»‘ï¼Œç©å®¶å…ˆæ‰‹`,
            difficultyName: difficulty.name
        });

        // AIå…ˆæ‰‹
        AI_MODES.push({
            name: `${difficulty.name} - AIå…ˆæ‰‹`,
            depth: difficulty.depth,
            aiFirst: true,
            aiColor: 'red',
            description: `AIæ·±åº¦${difficulty.depth}ï¼ŒAIåŸ·ç´…å…ˆæ‰‹`,
            difficultyName: difficulty.name
        });
    });

    // æ·»åŠ é—œé–‰AIé¸é …
    AI_MODES.push({
        name: "é—œé–‰AI",
        depth: 0,
        aiFirst: false,
        aiColor: null,
        description: "äººvsäººæ¨¡å¼",
        difficultyName: "é—œé–‰"
    });

    let currentAIMode = null;
    let isAIThinking = false;
    let isAIClickSource = false;  // å…¨åŸŸè®Šæ•¸

    // AIå°æˆ°ç³»çµ±ç®¡ç†å™¨
    class AIBattleManager {
        constructor() {
            this.isInitialized = false;
            this.currentMode = null;
            this.isAITurnActive = false;
            // åœ¨æ„é€ å‡½æ•°æˆ–åˆå§‹åŒ–æ—¶
            this.translator = new XiangqiTranslator();

        }

        // åˆå§‹åŒ–AIç³»çµ±
        async initialize() {
            if (this.isInitialized) return true;

            try {
                console.log('åˆå§‹åŒ–AIå°æˆ°ç³»çµ±...');

                // åˆå§‹åŒ–AIå¼•æ“
                if (typeof gameAI === 'undefined' || !gameAI) {
                    if (typeof XiangqiGameAI !== 'undefined') {
                        gameAI = new XiangqiGameAI(this.getCurrentBoard());
                        const success = await gameAI.initializeAI();
                        if (!success) {
                            throw new Error('AIå¼•æ“åˆå§‹åŒ–å¤±æ•—');
                        }
                    } else {
                        console.warn('XiangqiGameAI é¡ä¸å­˜åœ¨ï¼Œå°‡ä½¿ç”¨ç°¡åŒ–AI');
                        gameAI = this.createSimpleAI();
                    }
                }

                // åˆå§‹åŒ–AIåˆ†æç®¡ç†å™¨
                if (typeof aiAnalysisManager === 'undefined' || !aiAnalysisManager) {
                    if (typeof AIAnalysisManager !== 'undefined') {
                        aiAnalysisManager = new AIAnalysisManager();
                    } else {
                        console.warn('AIAnalysisManager é¡ä¸å­˜åœ¨');
                    }
                }

                // æ·»åŠ CSSæ¨£å¼
                this.addAIStyles();

                this.isInitialized = true;
                console.log('AIå°æˆ°ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
                return true;
            } catch (error) {
                console.error('AIç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
                return false;
            }
        }

        // å‰µå»ºç°¡åŒ–AIï¼ˆç•¶ä¸»AIä¸å¯ç”¨æ™‚ï¼‰
        createSimpleAI() {
            return {
                board: null,
                setDifficulty: (diff) => console.log('è¨­å®šé›£åº¦:', diff),
                getAISuggestion: async () => {
                    // ç°¡å–®çš„éš¨æ©Ÿç§»å‹•AI
                    const moves = this.getAllValidMoves();
                    if (moves.length > 0) {
                        const randomMove = moves[Math.floor(Math.random() * moves.length)];
                        return {
                            from: randomMove.from,
                            to: randomMove.to,
                            description: 'éš¨æ©Ÿç§»å‹•'
                        };
                    }
                    return null;
                }
            };
        }

        // ç²å–æ‰€æœ‰æœ‰æ•ˆç§»å‹•ï¼ˆç°¡åŒ–ç‰ˆæœ¬ï¼‰
        getAllValidMoves() {
            const moves = [];
            const board = this.getCurrentBoard();
            const currentPlayer = this.getCurrentPlayer();

            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === currentPlayer) {
                        // ç°¡å–®åœ°å˜—è©¦æ‰€æœ‰å¯èƒ½çš„ç§»å‹•ä½ç½®
                        for (let toRow = 0; toRow < 10; toRow++) {
                            for (let toCol = 0; toCol < 9; toCol++) {
                                if (row !== toRow || col !== toCol) {
                                    moves.push({
                                        from: { row, col },
                                        to: { row: toRow, col: toCol }
                                    });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        // ç²å–ç•¶å‰æ£‹ç›¤ç‹€æ…‹
        getCurrentBoard() {
            // å„ªå…ˆå¾å…¨åŸŸè®Šæ•¸ç²å–
            if (typeof gameState !== 'undefined' && gameState.board) {
                return gameState.board;
            }
            if (typeof current_board !== 'undefined') {
                return current_board;
            }

            // å¾DOMæå–
            return this.extractBoardFromDOM();
        }

        // å¾DOMæå–æ£‹ç›¤ç‹€æ…‹
        extractBoardFromDOM() {
            const board = Array(10).fill().map(() => Array(9).fill(null));
            const tiles = document.querySelectorAll('.tile');

            tiles.forEach(tile => {
                const row = parseInt(tile.dataset.row);
                const col = parseInt(tile.dataset.col);
                const piece = tile.querySelector('.chess-piece');

                if (piece && !isNaN(row) && !isNaN(col)) {
                    const alt = piece.alt;
                    const pieceInfo = this.parsePieceInfo(alt, piece.src);
                    if (pieceInfo) {
                        board[row][col] = pieceInfo;
                    }
                }
            });

            return board;
        }

        // è§£ææ£‹å­è³‡è¨Š
        parsePieceInfo(alt, src) {
            const pieceMap = {
                'ä¿¥': { type: 'ä¿¥', color: 'red' },
                'å‚Œ': { type: 'å‚Œ', color: 'red' },
                'ç›¸': { type: 'ç›¸', color: 'red' },
                'ä»•': { type: 'ä»•', color: 'red' },
                'å¸¥': { type: 'å¸¥', color: 'red' },
                'ç‚®': { type: 'ç‚®', color: 'red' },
                'å…µ': { type: 'å…µ', color: 'red' },
                'è»Š': { type: 'è»Š', color: 'black' },
                'é¦¬': { type: 'é¦¬', color: 'black' },
                'è±¡': { type: 'è±¡', color: 'black' },
                'å£«': { type: 'å£«', color: 'black' },
                'å°‡': { type: 'å°‡', color: 'black' },
                'åŒ…': { type: 'åŒ…', color: 'black' },
                'ç ²': { type: 'åŒ…', color: 'black' },
                'å’': { type: 'å’', color: 'black' }
            };

            return pieceMap[alt] || null;
        }

        // ==================== åœ¨ AIBattleManager é¡ä¸­ä¿®æ”¹ setAIMode æ–¹æ³• ====================

        async setAIMode(mode) {
            if (!this.isInitialized) {
                const success = await this.initialize();
                if (!success) {
                    throw new Error('AIç³»çµ±åˆå§‹åŒ–å¤±æ•—');
                }
            }

            this.currentMode = mode;
            currentAIMode = mode;

            if (mode.depth > 0) {
                // ğŸ”¥ é—œéµä¿®æ­£ï¼šç›´æ¥è¨­å®šæ·±åº¦ï¼Œä¸é€šéé›£åº¦åç¨±è½‰æ›
                if (gameAI) {
                    gameAI.gameMode = {
                        depth: mode.depth,              // â† ç›´æ¥ä¿å­˜æ•¸å­—æ·±åº¦
                        aiColor: mode.aiColor,
                        aiFirst: mode.aiFirst,
                        name: mode.name
                    };

                    // ğŸ”¥ é‡è¦ï¼šdifficulty åªç”¨æ–¼é¡¯ç¤ºï¼Œä¸ç”¨æ–¼è¨ˆç®—æ·±åº¦
                    const difficultyName = this.getDifficultyFromDepth(mode.depth);
                    gameAI.difficulty = difficultyName;  // åªç”¨æ–¼æ—¥èªŒé¡¯ç¤º

                    console.log(`âœ… AI æ¨¡å¼å·²è¨­å®š:`);
                    console.log(`   - å¯¦éš›æ·±åº¦: ${mode.depth} â† é€™å€‹æœƒè¢«ç›´æ¥ä½¿ç”¨`);
                    console.log(`   - é¡¯ç¤ºé›£åº¦: ${difficultyName} â† åƒ…ä¾›é¡¯ç¤º`);
                    console.log(`   - AI é¡è‰²: ${mode.aiColor}`);
                }

                console.log(`AIæ¨¡å¼è¨­å®š: ${mode.name}`);

                // ğŸ”¥ é—œéµä¿®æ­£ï¼šè¨­å®šå®Œæˆå¾Œï¼Œç«‹å³æª¢æŸ¥ç•¶å‰å±€é¢
                setTimeout(() => {
                    console.log('ğŸ” æª¢æŸ¥ç•¶å‰å±€é¢ï¼Œåˆ¤æ–·æ˜¯å¦è©²AIä¸‹æ£‹...');

                    // æª¢æŸ¥æ˜¯å¦è¼ªåˆ°AI
                    const isAITurn = this.checkIsAITurn();
                    console.log(`ğŸ‘¤ ç•¶å‰ç©å®¶: ${this.getCurrentPlayer()}, AIé¡è‰²: ${mode.aiColor}, æ˜¯å¦AIå›åˆ: ${isAITurn}`);

                    if (isAITurn) {
                        console.log('âœ… æª¢æ¸¬åˆ°AIå›åˆï¼Œç«‹å³è§¸ç™¼AIä¸‹æ£‹');
                        this.makeAIMove();
                    } else {
                        console.log('â¸ï¸ ç•¶å‰æ˜¯ç©å®¶å›åˆï¼Œç­‰å¾…ç©å®¶ä¸‹æ£‹');
                    }
                }, 500);
            }
        }

        // æ ¹æ“šæ·±åº¦ç²å–é›£åº¦ç­‰ç´š
        getDifficultyFromDepth(depth) {
            if (depth <= 3) return 'easy';
            if (depth <= 5) return 'medium';
            if (depth <= 7) return 'hard';
            return 'expert';
        }

        /**
         * æª¢æŸ¥æ£‹å­æ˜¯å¦å±¬æ–¼ AI
         */
        isAIPiece(piece) {
            if (!piece) return false;

            // æ ¹æ“šä½ çš„ AIBattleManager å¯¦ä¾‹ä¸­çš„ currentMode åˆ¤æ–·
            if (!this.currentMode || !this.currentMode.aiColor) {
                return false;
            }

            return piece.color === this.currentMode.aiColor;
        }

        /**
         * æª¢æŸ¥ç›®å‰æ˜¯å¦åœ¨ AI å°æˆ°æ¨¡å¼
         */
        isInAIBattleMode() {
            return this.isInitialized && this.currentMode && this.currentMode.depth > 0;
        }


        /**
         * ğŸ”¥ å®Œæ•´æ›¿æ¢ï¼šmakeAIMove - æ”¯æŒç¿»è½¬è§†è§’ + å°†æ­»æ£€æµ‹ + MultiPVé€‰æ‹©
         */
        async makeAIMove() {
            console.log('ğŸš€ makeAIMove è¢«è°ƒç”¨...');

            // è°ƒè¯•å„ä¸ªæ¡ä»¶
            console.log(`ğŸ“Š isAIThinking: ${isAIThinking}`);

            const aiTurnCheck = this.checkIsAITurn();
            console.log(`ğŸ” checkIsAITurn() è¿”å›: ${aiTurnCheck}`);

            // è¯¦ç»†æ£€æŸ¥ checkIsAITurn çš„æ¡ä»¶
            if (this.currentMode) {
                console.log(`ğŸ“‹ currentMode å­˜åœ¨:`);
                console.log(`   - depth: ${this.currentMode.depth}`);
                console.log(`   - aiColor: ${this.currentMode.aiColor}`);
            } else {
                console.log(`âŒ currentMode ä¸å­˜åœ¨!`);
            }

            const currentPlayer = this.getCurrentPlayer();
            console.log(`ğŸ‘¤ å½“å‰ç©å®¶: ${currentPlayer}`);

            // ğŸ”§ ä¿®æ­£ï¼šåªåœ¨éAIå›åˆæˆ–é‡å¤æ€è€ƒæ—¶è¿”å›
            if (isAIThinking && !aiTurnCheck) {
                console.log(`ğŸ›‘ æå‰è¿”å› - éAIå›åˆä¸”æ­£åœ¨æ€è€ƒ`);
                return;
            }

            // ğŸ”§ å¦‚æœæ˜¯AIå›åˆä½†å·²ç»åœ¨æ€è€ƒï¼Œç›´æ¥è¿”å›é¿å…é‡å¤è°ƒç”¨
            if (isAIThinking && aiTurnCheck) {
                console.log(`â³ AIå·²åœ¨æ€è€ƒä¸­ï¼Œé¿å…é‡å¤è°ƒç”¨`);
                return;
            }

            // ğŸ”§ å¦‚æœä¸æ˜¯AIå›åˆï¼Œç›´æ¥è¿”å›
            if (!aiTurnCheck) {
                console.log(`ğŸ›‘ éAIå›åˆï¼Œè¿”å›`);
                return;
            }

            try {
                isAIThinking = true;
                this.showAIThinking(true);

                console.log('ğŸ¤– AIå¼€å§‹å¯¹æˆ˜ç§»åŠ¨åˆ†æ...');

                // ğŸ”¥ å…³é”®ï¼šæ£€æŸ¥æ£‹ç›˜ç¿»è½¬çŠ¶æ€
                const isFlipped = this.checkBoardFlipState();
                console.log(`ğŸ”„ å½“å‰æ£‹ç›˜è§†è§’: ${isFlipped ? 'å·²ç¿»è½¬(é»‘æ–¹åœ¨ä¸‹)' : 'æ­£å¸¸(çº¢æ–¹åœ¨ä¸‹)'}`);

                // ğŸ¯ å…³é”®ï¼šAIå›åˆæ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å¯¹æˆ˜æ¨¡å¼
                if (gameAI && aiTurnCheck) {
                    console.log('ğŸ”„ AIå›åˆå¼€å§‹ - åˆ‡æ¢åˆ°å¯¹æˆ˜æ¨¡å¼');
                    gameAI.analysisMode = 'battle';

                    // æ›´æ–°AIçš„æ£‹ç›˜çŠ¶æ€å’Œæ¨¡å¼
                    gameAI.board = this.getCurrentBoard();
                    gameAI.setCurrentMode(this.currentMode);

                    // ç¡®è®¤éš¾åº¦è®¾å®š
                    if (!gameAI.difficulty) {
                        gameAI.difficulty = 'medium';
                        console.log('âš ï¸ æœªè®¾å®šéš¾åº¦ï¼Œä½¿ç”¨é¢„è®¾: medium');
                    } else {
                        console.log(`ğŸ® å½“å‰AIéš¾åº¦: ${gameAI.difficulty}`);
                    }
                }

                let suggestion = null;

                if (gameAI) {
                    console.log(`ğŸ”„ ä½¿ç”¨å¯¹æˆ˜æ¨¡å¼ï¼Œæ·±åº¦: ${this.currentMode?.depth || 'default'}`);

                    try {
                        console.log(`ğŸ” [MAKEAI] æ£€æŸ¥ getAISuggestionWithBattleMode æ–¹æ³•...`);
                        console.log(`ğŸ” [MAKEAI] æ–¹æ³•å­˜åœ¨æ€§: ${typeof gameAI.getAISuggestionWithBattleMode}`);

                        if (gameAI.getAISuggestionWithBattleMode && typeof gameAI.getAISuggestionWithBattleMode === 'function') {
                            console.log(`âš”ï¸ [MAKEAI] ä½¿ç”¨å¯¹æˆ˜ä¸“ç”¨æ–¹æ³•ï¼Œéš¾åº¦: ${gameAI.difficulty}`);
                            suggestion = await gameAI.getAISuggestionWithBattleMode(this.getCurrentBoard(), gameAI.difficulty);
                            console.log(`âœ… [MAKEAI] å¯¹æˆ˜ä¸“ç”¨æ–¹æ³•å®Œæˆï¼Œå®é™…æ·±åº¦: ${suggestion?.usedDepth}`);
                        } else {
                            console.error(`âŒ [MAKEAI] getAISuggestionWithBattleMode æ–¹æ³•ä¸å­˜åœ¨!`);
                            throw new Error('å¯¹æˆ˜ä¸“ç”¨æ–¹æ³• getAISuggestionWithBattleMode ä¸å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ AI å¼•æ“åˆå§‹åŒ–');
                        }

                        // ğŸ”¥ æ–°å¢ï¼šå°†æ­»æ£€æµ‹
                        if (!suggestion ||
                            suggestion.moveString === 'CHECKMATE' ||
                            suggestion.isCheckmate === true ||
                            !suggestion.from ||
                            !suggestion.to) {

                            console.log('ğŸ AIè¢«å°†æ­»ï¼Œæ— åˆæ³•ç§»åŠ¨');
                            return; // ç›´æ¥è¿”å›ï¼Œä¸æ˜¾ç¤ºé€šçŸ¥ï¼Œè®©å…¶ä»–ç³»ç»Ÿå¤„ç†å°†æ­»é€šçŸ¥
                        }

                        if (suggestion && suggestion.from && suggestion.to) {
                            // ğŸ”¥ ä¿®æ­£æ—¥å¿—æ˜¾ç¤º
                            const actualDepth = suggestion.usedDepth || suggestion.battleDepth || 'unknown';
                            const configDepth = this.currentMode?.depth || 'unknown';
                            const difficultyInfo = suggestion.difficulty ? `éš¾åº¦: ${suggestion.difficulty}` : '';

                            console.log(`ğŸ¯ AIå¯¹æˆ˜ç§»åŠ¨`);
                            console.log(`   - é…ç½®æ·±åº¦: ${configDepth}`);
                            console.log(`   - å®é™…æ·±åº¦: ${actualDepth}`);
                            console.log(`   - æ˜¾ç¤ºéš¾åº¦: ${suggestion.difficulty || 'N/A'}`);

                            // ğŸ”¥ ç¡®è®¤æ·±åº¦æ˜¯å¦åŒ¹é…
                            if (configDepth !== actualDepth && configDepth !== 'unknown' && actualDepth !== 'unknown') {
                                console.warn(`âš ï¸ æ·±åº¦ä¸åŒ¹é…ï¼é…ç½®: ${configDepth}, å®é™…: ${actualDepth}`);
                            } else {
                                console.log(`âœ… æ·±åº¦åŒ¹é…ç¡®è®¤ï¼šé…ç½® ${configDepth} = å®é™… ${actualDepth}`);
                            }

                            // ğŸ”¥ æ–°å¢ï¼šè°ƒç”¨è°ƒè¯•æ—¥å¿—ï¼ˆå¼€å‘ç”¨ï¼‰
                            if (typeof this.logMoveSelectionDebug === 'function') {
                                this.logMoveSelectionDebug(suggestion);
                            }
                        }

                    } catch (analysisError) {
                        console.error('âŒ AIåˆ†æè¿‡ç¨‹å‡ºé”™:', analysisError);
                        throw analysisError;
                    }
                } else {
                    console.error('âŒ gameAI ä¸å­˜åœ¨');
                    throw new Error('AIå¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼ŒgameAI å¯¹è±¡ä¸å­˜åœ¨');
                }

                if (suggestion && suggestion.from && suggestion.to) {
                    // ğŸ”¥ å…³é”®ï¼šå¦‚æœè§†è§’ç¿»è½¬ï¼Œéœ€è¦è½¬æ¢åº§æ ‡
                    if (isFlipped) {
                        console.log('ğŸ”„ è§†è§’ç¿»è½¬ - è½¬æ¢AIåº§æ ‡ä¸ºæ˜¾ç¤ºåº§æ ‡');

                        // è§£æå¼•æ“åº§æ ‡
                        const engineFromRow = typeof suggestion.from.row === 'number' ? suggestion.from.row : parseInt(suggestion.from.row);
                        const engineFromCol = this.convertColToNumber(suggestion.from.col);
                        const engineToRow = typeof suggestion.to.row === 'number' ? suggestion.to.row : parseInt(suggestion.to.row);
                        const engineToCol = this.convertColToNumber(suggestion.to.col);

                        // è½¬æ¢ä¸ºæ˜¾ç¤ºåº§æ ‡
                        const displayFrom = this.convertEngineToDisplayCoord(engineFromRow, engineFromCol);
                        const displayTo = this.convertEngineToDisplayCoord(engineToRow, engineToCol);

                        // ğŸ”¥ æ›´æ–° suggestion çš„åº§æ ‡ä¸ºæ˜¾ç¤ºåº§æ ‡
                        suggestion.from = {
                            row: displayFrom.row,
                            col: displayFrom.col
                        };
                        suggestion.to = {
                            row: displayTo.row,
                            col: displayTo.col
                        };

                        console.log('ğŸ“ è½¬æ¢å(æ˜¾ç¤ºåº§æ ‡):', {
                            from: `(${suggestion.from.row}, ${suggestion.from.col})`,
                            to: `(${suggestion.to.row}, ${suggestion.to.col})`
                        });

                        // ğŸ”¥ æ ‡è®°å·²è½¬æ¢
                        suggestion.coordsConverted = true;
                    } else {
                        console.log('ğŸ“ æ­£å¸¸è§†è§’ - ç›´æ¥ä½¿ç”¨å¼•æ“åº§æ ‡');
                        suggestion.coordsConverted = false;
                    }

                    const difficultyInfo = suggestion.difficulty ? `éš¾åº¦: ${suggestion.difficulty}` : '';
                    const depthInfo = suggestion.usedDepth || suggestion.battleDepth ? `æ·±åº¦: ${suggestion.usedDepth || suggestion.battleDepth}` : '';
                    const modeInfo = suggestion.autoModeSwitch ? '(æ™ºèƒ½æ¨¡å¼åˆ‡æ¢)' : '';
                    const flipInfo = suggestion.coordsConverted ? '(å·²è½¬æ¢åº§æ ‡)' : '';

                    console.log(`ğŸ¯ AIå¯¹æˆ˜ç§»åŠ¨ ${difficultyInfo} ${depthInfo} ${modeInfo} ${flipInfo}`);

                    // âœ… ç¬¬ä¸€æ­¥ï¼šæ‰§è¡Œç§»åŠ¨ï¼ˆä½¿ç”¨æ­£ç¡®çš„æ˜¾ç¤ºåº§æ ‡ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è®°å½•æ£‹è°±ï¼‰
                    const success = await this.executeMove(suggestion);

                    if (success) {
                        // âœ… ç¬¬äºŒæ­¥ï¼šè·å–æœ€æ–°æ£‹è°±ï¼ˆç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆçš„ï¼‰
                        const latestNotation = this.getLatestNotation();
                        console.log(`ğŸ“– è·å–æœ€æ–°æ£‹è°±: ${latestNotation}`);

                        // âœ… ç¬¬ä¸‰æ­¥ï¼šå°†æ£‹è°±æ·»åŠ åˆ° suggestion å¯¹è±¡ä¸­
                        if (latestNotation) {
                            suggestion.notation = latestNotation;
                            console.log(`âœ… å·²å°†æ£‹è°±é™„åŠ åˆ° suggestion: ${suggestion.notation}`);
                        }

                        // ğŸ‰ ç§»åŠ¨æˆåŠŸåç«‹å³åˆ‡æ¢åˆ°åˆ†ææ¨¡å¼
                        if (gameAI) {
                            gameAI.analysisMode = 'analysis';
                            console.log(`ğŸ”„ AIèµ°æ£‹å®Œæ¯• - ç«‹å³åˆ‡æ¢åˆ°åˆ†ææ¨¡å¼ï¼Œç©å®¶å¯å¼€å§‹åˆ†æ`);
                        }

                        // âœ… ç¬¬å››æ­¥ï¼šæ˜¾ç¤ºé€šçŸ¥ï¼ˆç°åœ¨æœ‰å®Œæ•´çš„æ£‹è°±äº†ï¼‰
                        this.showMoveNotification(suggestion);

                        // ğŸ”„ AIç§»åŠ¨å®Œæˆï¼Œè½®åˆ°ç©å®¶ - åˆ†ææ¨¡å¼å·²å°±ç»ª
                        console.log(`ğŸ”„ AIç§»åŠ¨å®Œæˆï¼Œè½®åˆ°ç©å®¶ - åˆ†ææ¨¡å¼å·²å°±ç»ª`);

                        // ğŸ¯ ä¸ºç©å®¶å›åˆåšå‡†å¤‡
                        this.prepareForHumanTurn();
                    } else {
                        console.error('âŒ AIç§»åŠ¨æ‰§è¡Œå¤±è´¥');
                        throw new Error('ç§»åŠ¨æ‰§è¡Œå¤±è´¥ï¼Œå¯èƒ½æ˜¯æ— æ•ˆç§»åŠ¨');
                    }
                } else {
                    console.error('âŒ AIæ— æ³•æ‰¾åˆ°æœ‰æ•ˆç§»åŠ¨');
                    throw new Error('AIæ— æ³•æ‰¾åˆ°æœ‰æ•ˆç§»åŠ¨ï¼Œå¯èƒ½æ¸¸æˆå·²ç»“æŸ');
                }

            } catch (error) {
                console.error('âŒ AIä¸‹æ£‹å¤±è´¥:', error);

                // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å› ä¸ºå°†æ­»å¯¼è‡´çš„é”™è¯¯
                if (error.message.includes('æ— æ³•æ‰¾åˆ°æœ‰æ•ˆç§»åŠ¨') ||
                    error.message.includes('none') ||
                    error.message.includes('CHECKMATE')) {
                    console.log('ğŸ AIæ— åˆæ³•ç§»åŠ¨ï¼Œåˆ¤å®šä¸ºå°†æ­»');
                    return; // ç›´æ¥è¿”å›ï¼Œä¸æ˜¾ç¤ºé”™è¯¯é€šçŸ¥
                }

                // è¯¦ç»†çš„é”™è¯¯å¤„ç†ï¼ˆéå°†æ­»æƒ…å†µï¼‰
                let errorMessage = 'AIæ€è€ƒå¤±è´¥';
                if (error.message.includes('getAISuggestionWithBattleMode')) {
                    errorMessage = 'AIå¼•æ“ç¼ºå°‘å¯¹æˆ˜ä¸“ç”¨æ–¹æ³•ï¼Œè¯·æ£€æŸ¥ä»£ç åˆå§‹åŒ–';
                } else {
                    errorMessage += ': ' + error.message;
                }

                // ä½¿ç”¨ UI é€šçŸ¥æ›¿ä»£ alert
                showErrorNotification(errorMessage);

                // é”™è¯¯å‘ç”Ÿæ—¶ä¹Ÿè¦æ¢å¤åˆ†ææ¨¡å¼
                if (gameAI) {
                    gameAI.analysisMode = 'analysis';
                    console.log(`âŒ é”™è¯¯å¤„ç† - æ¢å¤åˆ†ææ¨¡å¼`);
                }
            } finally {
                isAIThinking = false;
                this.showAIThinking(false);
            }
        }

        /**
         * ğŸ” è°ƒè¯•æ¨¡å¼ï¼šè®°å½•AIé€‰æ‹©ä¿¡æ¯ï¼ˆä»…å¼€å‘ç”¨ï¼‰
         * åœ¨ makeAIMove ä¸­è¢«è°ƒç”¨ï¼Œç”¨äºå¼€å‘è°ƒè¯•
         */
        logMoveSelectionDebug(suggestion) {
            if (!suggestion.moveSelection) {
                console.log('ğŸ² [AIé€‰æ‹©] æ— é€‰æ‹©ä¿¡æ¯ï¼ˆå¯èƒ½åªæœ‰ä¸€ä¸ªé€‰é¡¹ï¼‰');
                return;
            }

            const selection = suggestion.moveSelection;
            const debugInfo = {
                é€‰æ‹©ç±»å‹: selection.reason,
                é€‰æ‹©ç´¢å¼•: selection.selectionIndex,
                é€‰æ‹©æœºç‡: (selection.probability * 100).toFixed(1) + '%',
                æ‰€æœ‰é€‰é¡¹: selection.allChoices?.map(c => ({
                    åºå·: c.index,
                    æ‹›æ³•: c.move,
                    åˆ†æ•°: c.score,
                    æ˜¯å¦é€‰ä¸­: c.isSelected ? 'âœ“' : ''
                }))
            };

            console.log('ğŸ² [AIé€‰æ‹©è°ƒè¯•]', debugInfo);

            // å¦‚æœèµ°çš„ä¸æ˜¯æœ€ä½³æ‹›ï¼Œé¢å¤–é«˜äº®æ˜¾ç¤º
            if (selection.selectionType !== 'best') {
                console.log(`âš ï¸ AIèµ°äº†éæœ€ä½³æ‹›ï¼š${selection.reason}`);
            }
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šæª¢æŸ¥æ£‹ç›¤ç¿»è½‰ç‹€æ…‹
         */
        checkBoardFlipState() {
            // å„ªå…ˆç´š1: gameState
            if (typeof gameState !== 'undefined' && gameState.isFlipped !== undefined) {
                return gameState.isFlipped;
            }

            // å„ªå…ˆç´š2: currentSettings
            if (typeof currentSettings !== 'undefined' && currentSettings.boardFlipped !== undefined) {
                return currentSettings.boardFlipped;
            }

            // å„ªå…ˆç´š3: localStorage
            try {
                const saved = localStorage.getItem('chessGameSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.boardFlipped !== undefined) {
                        return settings.boardFlipped;
                    }
                }
            } catch (e) {
                console.warn('ç„¡æ³•å¾ localStorage è®€å–ç¿»è½‰ç‹€æ…‹');
            }

            // å„ªå…ˆç´š4: DOM æŒ‡ç¤ºå™¨
            const flipIndicator = document.getElementById('flip-indicator');
            if (flipIndicator) {
                return true;
            }

            return false; // é»˜èªæœªç¿»è½‰
        }

        /**
         * ğŸ”¥ æ–°å¢ï¼šå°‡å¼•æ“åº§æ¨™è½‰æ›ç‚ºé¡¯ç¤ºåº§æ¨™
         */
        convertEngineToDisplayCoord(engineRow, engineCol) {
            const isFlipped = this.checkBoardFlipState();

            if (isFlipped) {
                // ç¿»è½‰ï¼šé¡¯ç¤ºè¡Œ = 9 - å¼•æ“è¡Œ
                const displayRow = 9 - engineRow;
                console.log(`ğŸ”„ [AIå°æˆ°] åº§æ¨™è½‰æ›(ç¿»è½‰): å¼•æ“(${engineRow},${engineCol}) -> é¡¯ç¤º(${displayRow},${engineCol})`);
                return { row: displayRow, col: engineCol };
            } else {
                // æ­£å¸¸ï¼šé¡¯ç¤ºè¡Œ = å¼•æ“è¡Œ
                console.log(`ğŸ”„ [AIå°æˆ°] åº§æ¨™è½‰æ›(æ­£å¸¸): å¼•æ“(${engineRow},${engineCol}) -> é¡¯ç¤º(${engineRow},${engineCol})`);
                return { row: engineRow, col: engineCol };
            }
        }



// ========================================
// âœ… æ–°å¢ï¼šç²å–æœ€æ–°æ£‹è­œçš„è¼”åŠ©å‡½æ•¸
// ========================================
        getLatestNotation() {
            if (!gameState || !gameState.gameRecord || gameState.gameRecord.length === 0) {
                console.warn('âš ï¸ gameState.gameRecord ç‚ºç©ºï¼Œç„¡æ³•ç²å–æ£‹è­œ');
                return null;
            }

            const lastRecord = gameState.gameRecord[gameState.gameRecord.length - 1];

            // å¦‚æœé»‘æ–¹å·²èµ°ï¼Œè¿”å›é»‘æ–¹æ£‹è­œï¼›å¦å‰‡è¿”å›ç´…æ–¹æ£‹è­œ
            const notation = lastRecord.black || lastRecord.red;

            console.log(`ğŸ“– å¾ gameRecord è®€å–æœ€æ–°æ£‹è­œ: ${notation}`);
            console.log(`ğŸ“Š ç•¶å‰æ£‹è­œè¨˜éŒ„é•·åº¦: ${gameState.gameRecord.length}`);
            console.log(`ğŸ“‹ æœ€å¾Œä¸€æ¢è¨˜éŒ„:`, lastRecord);

            return notation;
        }

        /**
         * ç‚ºäººé¡å›åˆåšæº–å‚™
         */
        prepareForHumanTurn() {
            console.log('ğŸ¯ æº–å‚™äººé¡å›åˆ - ç¢ºä¿åˆ†ææ¨¡å¼å¯ç”¨');

            if (gameAI) {
                // ç¢ºä¿è™•æ–¼åˆ†ææ¨¡å¼
                gameAI.analysisMode = 'analysis';

                // æ›´æ–°æ£‹ç›¤ç‹€æ…‹
                gameAI.board = this.getCurrentBoard();

                console.log('âœ… äººé¡å›åˆæº–å‚™å®Œæˆ - å¯ä½¿ç”¨AIåˆ†æåŠŸèƒ½');
            }
        }



        /**
         * ç²å–ç•¶å‰ç©å®¶ - ä½¿ç”¨ä½ ç¾æœ‰çš„é‚è¼¯
         */
        getCurrentPlayer() {
            if (typeof gameState !== 'undefined' && gameState.currentTurn) {
                return gameState.currentTurn;
            }

            // å¾ç§»å‹•æ­·å²æ¨æ–·
            if (typeof gameHistory !== 'undefined' && gameHistory.moves) {
                return gameHistory.moves.length % 2 === 0 ? 'red' : 'black';
            }

            return 'red'; // é»˜èªç´…æ–¹å…ˆæ‰‹
        }

        /**
         * æª¢æŸ¥æ˜¯å¦è¼ªåˆ°AI - æ”¯æŒå…ˆå¾Œæ‰‹è‡ªå‹•åˆ¤æ–·
         */
        checkIsAITurn() {
            if (!this.currentMode || this.currentMode.depth === 0) return false;

            const currentPlayer = this.getCurrentPlayer();

            // **æ–°å¢ï¼šè‡ªå‹•åˆ¤æ–·AIé¡è‰²é‚è¼¯**
            let aiColor = this.currentMode.aiColor;

            // å¦‚æœAIé¡è‰²æœªè¨­å®šï¼Œæˆ–è€…éœ€è¦é‡æ–°åˆ¤æ–·
            if (!aiColor || this.needsAutoColorDetection) {
                aiColor = this.determineAIColor();
                if (this.currentMode) {
                    this.currentMode.aiColor = aiColor;
                    console.log(`ğŸ¯ è‡ªå‹•è¨­å®šAIé¡è‰²: ${aiColor}`);
                }
                this.needsAutoColorDetection = false;
            }

            const isAITurn = currentPlayer === aiColor;

            console.log(`ğŸ” AIå›åˆæª¢æ¸¬ - ç•¶å‰ç©å®¶: ${currentPlayer}, AIé¡è‰²: ${aiColor}, æ˜¯AIå›åˆ: ${isAITurn}`);
            return isAITurn;
        }

        /**
         * è‡ªå‹•åˆ¤æ–·AIæ‡‰è©²æ˜¯å“ªå€‹é¡è‰²
         */
        determineAIColor() {
            console.log(`ğŸ¤– é–‹å§‹åˆ¤æ–·AIå…ˆå¾Œæ‰‹...`);

            // æª¢æŸ¥éŠæˆ²æ˜¯å¦å‰›é–‹å§‹ (æ²’æœ‰ç§»å‹•æˆ–åªæœ‰å¾ˆå°‘ç§»å‹•)
            const moveCount = this.getMoveCount();
            console.log(`ğŸ“Š ç•¶å‰ç§»å‹•æ•¸: ${moveCount}`);

            if (moveCount === 0) {
                // éŠæˆ²å‰›é–‹å§‹ï¼Œæª¢æŸ¥è¨­å®šæˆ–é è¨­AIå…ˆæ‰‹
                const aiIsFirstPlayer = this.getAIPlayerOrder(); // å¾è¨­å®šç²å–
                const aiColor = aiIsFirstPlayer ? 'red' : 'black';
                console.log(`ğŸ†• éŠæˆ²é–‹å§‹ - AIè¨­å®šç‚º${aiIsFirstPlayer ? 'å…ˆæ‰‹' : 'å¾Œæ‰‹'}: ${aiColor}`);
                return aiColor;

            } else if (moveCount === 1) {
                // æœ‰ä¸€æ­¥ç§»å‹•ï¼Œåˆ¤æ–·æ˜¯äººé¡é‚„æ˜¯AIèµ°çš„
                const currentPlayer = this.getCurrentPlayer(); // ç¾åœ¨è©²èª°èµ°

                if (this.wasFirstMoveByHuman()) {
                    // ç¬¬ä¸€æ­¥æ˜¯äººé¡èµ°çš„ï¼Œé‚£AIæ˜¯å¾Œæ‰‹ (black)
                    console.log(`ğŸ‘¤ æª¢æ¸¬åˆ°äººé¡å…ˆæ‰‹ï¼ŒAIç‚ºå¾Œæ‰‹: black`);
                    return 'black';
                } else {
                    // ç¬¬ä¸€æ­¥æ˜¯AIèµ°çš„ï¼Œé‚£AIæ˜¯å…ˆæ‰‹ (red)
                    console.log(`ğŸ¤– æª¢æ¸¬åˆ°AIå…ˆæ‰‹: red`);
                    return 'red';
                }

            } else {
                // éŠæˆ²é€²è¡Œä¸­ï¼Œå¾ç§»å‹•æ­·å²åˆ†æ
                const aiColor = this.detectAIColorFromHistory();
                console.log(`ğŸ“œ å¾æ­·å²è¨˜éŒ„åˆ¤æ–·AIé¡è‰²: ${aiColor}`);
                return aiColor;
            }
        }

        /**
         * ç²å–ç§»å‹•ç¸½æ•¸
         */
        getMoveCount() {
            if (typeof gameHistory !== 'undefined' && gameHistory.moves) {
                return gameHistory.moves.length;
            }
            return 0;
        }

        /**
         * åˆ¤æ–·ç¬¬ä¸€æ­¥æ˜¯å¦ç”±äººé¡èµ°çš„
         * é€™å€‹éœ€è¦æ ¹æ“šä½ çš„å…·é«”å¯¦ç¾ä¾†èª¿æ•´
         */
        wasFirstMoveByHuman() {
            // æ–¹æ³•1ï¼šæª¢æŸ¥ç¬¬ä¸€æ­¥ç§»å‹•çš„æ™‚é–“æˆ³æˆ–æ¨™è¨˜
            if (typeof gameHistory !== 'undefined' && gameHistory.moves && gameHistory.moves[0]) {
                const firstMove = gameHistory.moves[0];
                // å¦‚æœç§»å‹•æœ‰æ¨™è¨˜æ˜¯å¦ç‚ºAIç§»å‹•
                if (firstMove.isAIMove !== undefined) {
                    return !firstMove.isAIMove;
                }

                // æ–¹æ³•2ï¼šæª¢æŸ¥ç§»å‹•çš„æ€è€ƒæ™‚é–“ (AIé€šå¸¸æ€è€ƒæ™‚é–“è¼ƒçŸ­ä¸”å›ºå®š)
                if (firstMove.thinkingTime) {
                    // å¦‚æœæ€è€ƒæ™‚é–“å¾ˆçŸ­ä¸”æ¥è¿‘å›ºå®šå€¼ï¼Œå¯èƒ½æ˜¯AI
                    return firstMove.thinkingTime > 1000; // å‡è¨­äººé¡æ€è€ƒè¶…é1ç§’
                }
            }

            // æ–¹æ³•3ï¼šé è¨­é‚è¼¯ - å¦‚æœéŠæˆ²æ¨¡å¼æ˜¯äººé¡vs AIï¼Œä¸”åªæœ‰1æ­¥ç§»å‹•
            // é€šå¸¸è¡¨ç¤ºäººé¡å…ˆèµ°äº†ç¬¬ä¸€æ­¥
            return true;
        }

        /**
         * å¾ç§»å‹•æ­·å²ä¸­æª¢æ¸¬AIé¡è‰²
         */
        detectAIColorFromHistory() {
            if (typeof gameHistory !== 'undefined' && gameHistory.moves) {
                // æŸ¥æ‰¾ç¬¬ä¸€å€‹æ¨™è¨˜ç‚ºAIç§»å‹•çš„æ­¥æ•¸
                for (let i = 0; i < gameHistory.moves.length; i++) {
                    const move = gameHistory.moves[i];
                    if (move.isAIMove) {
                        // æ ¹æ“šç§»å‹•ç´¢å¼•åˆ¤æ–·é¡è‰² (å¶æ•¸ç´¢å¼•=ç´…æ–¹ï¼Œå¥‡æ•¸ç´¢å¼•=é»‘æ–¹)
                        return i % 2 === 0 ? 'red' : 'black';
                    }
                }
            }

            // å¦‚æœç„¡æ³•å¾æ­·å²åˆ¤æ–·ï¼Œä½¿ç”¨é è¨­é‚è¼¯
            return 'black'; // é è¨­AIç‚ºå¾Œæ‰‹
        }

        /**
         * ç²å–AIç©å®¶é †åºè¨­å®š (éœ€è¦æ ¹æ“šä½ çš„è¨­å®šç³»çµ±èª¿æ•´)
         */
        getAIPlayerOrder() {
            // é€™å€‹éœ€è¦æ ¹æ“šä½ çš„éŠæˆ²è¨­å®šä¾†å¯¦ç¾
            // å¯èƒ½å¾è¨­å®šé¸å–®ã€URLåƒæ•¸ã€æˆ–éŠæˆ²æ¨¡å¼ä¸­ç²å–

            // ç¤ºä¾‹ï¼šå¾è¨­å®šä¸­ç²å–
            if (typeof gameSettings !== 'undefined' && gameSettings.aiFirst !== undefined) {
                return gameSettings.aiFirst;
            }

            // ç¤ºä¾‹ï¼šå¾éŠæˆ²æ¨¡å¼ç²å–
            if (this.currentMode && this.currentMode.aiFirst !== undefined) {
                return this.currentMode.aiFirst;
            }

            // é è¨­AIå¾Œæ‰‹
            return false;
        }



        async executeMove(suggestion) {
            try {
                console.log('AIå¼€å§‹ç§»åŠ¨:', suggestion);
                const { from, to } = suggestion;

                const fromCol = this.convertColToNumber(from.col);
                const toCol = this.convertColToNumber(to.col);

                if (fromCol === -1 || toCol === -1) {
                    console.error('åæ ‡è½¬æ¢å¤±è´¥');
                    return false;
                }

                console.log('è½¬æ¢åçš„åæ ‡:', {
                    from: `(${from.row}, ${fromCol})`,
                    to: `(${to.row}, ${toCol})`
                });

                if (typeof clearSelection === 'function') {
                    clearSelection();
                }

                await new Promise(resolve => setTimeout(resolve, 100));

                // ğŸ‘‡ ã€é—œéµã€‘è¨­å®šæ¨™è¨˜ï¼šé€™æ˜¯ AI çš„é»æ“Š
                isAIClickSource = true;

                if (typeof handleTileClick === 'function') {
                    handleTileClick(from.row, fromCol);

                    await new Promise(resolve => setTimeout(resolve, 200));

                    handleTileClick(to.row, toCol);

                    console.log('âœ… AIç§»åŠ¨å®Œæˆ');

                    // ğŸ‘‡ ã€é—œéµã€‘é‡ç½®æ¨™è¨˜
                    isAIClickSource = false;
                    return true;
                }

                // ğŸ‘‡ å‡ºéŒ¯æ™‚ä¹Ÿè¦é‡ç½®
                isAIClickSource = false;
                console.error('æ‰¾ä¸åˆ°handleTileClickå‡½æ•°');
                return false;

            } catch (error) {
                // ğŸ‘‡ ç•°å¸¸æ™‚ä¹Ÿè¦é‡ç½®
                isAIClickSource = false;
                console.error('AIç§»åŠ¨å¤±è´¥:', error);
                return false;
            }
        }

// åæ ‡è½¬æ¢è¾…åŠ©å‡½æ•°
        convertColToNumber(col) {
            if (typeof col === 'number') {
                return col; // å¦‚æœå·²ç»æ˜¯æ•°å­—ï¼Œç›´æ¥è¿”å›
            }

            if (typeof col === 'string' && col.length === 1) {
                // å°† 'a' -> 0, 'b' -> 1, ..., 'i' -> 8
                const colNum = col.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
                if (colNum >= 0 && colNum <= 8) {
                    return colNum;
                }
            }

            console.error('æ— æ•ˆçš„åˆ—åæ ‡:', col);
            return -1;
        }

// è™•ç†éŠæˆ²çµæŸ
        handleGameEnd(winner) {
            try {
                if (winner) {
                    alert(`éŠæˆ²çµæŸï¼${winner === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}ç²å‹ï¼`);
                } else {
                    alert('éŠæˆ²çµæŸï¼');
                }
            } catch (error) {
                console.error('âŒ è™•ç†éŠæˆ²çµæŸå¤±æ•—:', error);
            }
        }

// åº§æ¨™è½‰æ›è¼”åŠ©æ–¹æ³• - ä¹Ÿè¦åŠ åˆ°ä½ çš„é¡ä¸­
        notationToIndex(notation) {
            if (notation.length < 2) {
                console.error('âŒ ç„¡æ•ˆçš„åº§æ¨™æ ¼å¼:', notation);
                return -1;
            }

            const col = notation.charAt(0);
            const row = notation.substring(1);

            // åˆ—: a=0, b=1, ..., i=8
            const colIndex = col.charCodeAt(0) - 'a'.charCodeAt(0);
            const rowIndex = parseInt(row);

            // é©—è­‰ç¯„åœ
            if (colIndex < 0 || colIndex > 8 || rowIndex < 0 || rowIndex > 9) {
                console.error('âŒ åº§æ¨™è¶…å‡ºç¯„åœ:', notation, `col:${colIndex}, row:${rowIndex}`);
                return -1;
            }

            // è¨ˆç®—ç´¢å¼•: row * 9 + col
            const index = rowIndex * 9 + colIndex;
            console.log(`ğŸ“ åº§æ¨™è½‰æ›: ${notation} â†’ col:${colIndex}, row:${rowIndex} â†’ ç´¢å¼•:${index}`);

            return index;
        }
        // æ”¹é€²çš„é»æ“Šæ“ä½œ
        async improvedClickMove(suggestion) {
            try {
                const { from, to } = suggestion;

                const fromTile = document.querySelector(`[data-row="${from.row}"][data-col="${from.col}"]`);
                const toTile = document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);

                if (!fromTile || !toTile) return false;

                // ç¢ºä¿æ¸…é™¤ä¹‹å‰çš„é¸æ“‡
                document.querySelectorAll('.chess-tile').forEach(tile => {
                    tile.classList.remove('selected', 'highlighted');
                });

                // è§¸ç™¼æ›´çœŸå¯¦çš„é»æ“Šäº‹ä»¶
                const clickEvent1 = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });

                const clickEvent2 = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });

                // é»æ“Šèµ·å§‹ä½ç½®
                fromTile.dispatchEvent(clickEvent1);
                await new Promise(resolve => setTimeout(resolve, 200));

                // é»æ“Šç›®æ¨™ä½ç½®
                toTile.dispatchEvent(clickEvent2);
                await new Promise(resolve => setTimeout(resolve, 200));

                // é©—è­‰ç§»å‹•æ˜¯å¦æˆåŠŸ
                return this.verifyMove(suggestion);

            } catch (error) {
                console.error('é»æ“Šç§»å‹•å¤±æ•—:', error);
                return false;
            }
        }

// å¼·åˆ¶ç§»å‹•
        forceMove(suggestion) {
            try {
                const { from, to } = suggestion;

                const fromTile = document.querySelector(`[data-row="${from.row}"][data-col="${from.col}"]`);
                const toTile = document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);

                if (!fromTile || !toTile) return false;

                const piece = fromTile.querySelector('.chess-piece');
                if (!piece) return false;

                // ç§»é™¤ç›®æ¨™ä½ç½®çš„æ£‹å­
                const targetPiece = toTile.querySelector('.chess-piece');
                if (targetPiece) targetPiece.remove();

                // ç§»å‹•æ£‹å­
                toTile.appendChild(piece);

                return true;

            } catch (error) {
                return false;
            }
        }

// é©—è­‰ç§»å‹•æ˜¯å¦æˆåŠŸ
        verifyMove(suggestion) {
            try {
                const { from, to } = suggestion;

                const fromTile = document.querySelector(`[data-row="${from.row}"][data-col="${from.col}"]`);
                const toTile = document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);

                const pieceInFrom = fromTile?.querySelector('.chess-piece');
                const pieceInTo = toTile?.querySelector('.chess-piece');

                // æª¢æŸ¥èµ·å§‹ä½ç½®æ˜¯å¦ç‚ºç©ºï¼Œç›®æ¨™ä½ç½®æ˜¯å¦æœ‰æ£‹å­
                return !pieceInFrom && !!pieceInTo;

            } catch (error) {
                return false;
            }
        }


        // ç©å®¶ç§»å‹•å¾Œçš„å›èª¿
        onPlayerMove() {
            if (this.currentMode && this.currentMode.depth > 0) {
                // å»¶é²ä¸€é»è®“ç©å®¶ç§»å‹•å®Œæˆ
                setTimeout(() => {
                    if (this.checkIsAITurn()) {
                        this.makeAIMove();
                    }
                }, 500);
            }
        }

        // é¡¯ç¤ºAIæ€è€ƒç‹€æ…‹
        showAIThinking(isThinking) {
            let indicator = document.getElementById('ai-thinking-indicator');

            if (isThinking) {
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'ai-thinking-indicator';
                    indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px 30px;
                    border-radius: 10px;
                    font-size: 18px;
                    z-index: 2000;
                    text-align: center;
                `;
                    document.body.appendChild(indicator);
                }

                indicator.innerHTML = `
                <div style="margin-bottom: 10px;">AIæ€è€ƒä¸­...</div>
                <div class="ai-loading-dots">
                    <span>â—</span><span>â—</span><span>â—</span>
                </div>
            `;
            } else {
                if (indicator) {
                    indicator.remove();
                }
            }
        }


        // ========================================
// âœ… ä¿®æ”¹ï¼šshowMoveNotification åŠ å…¥å¾Œå‚™è®€å–
// ========================================
        showMoveNotification(suggestion) {
            // âœ… ç¬¬ä¸€å„ªå…ˆï¼šä½¿ç”¨å‚³å…¥çš„ notation
            let notation = suggestion.notation;

            // âœ… ç¬¬äºŒå„ªå…ˆï¼šå¦‚æœæ²’æœ‰ï¼Œå¾ gameRecord è®€å–
            if (!notation) {
                notation = this.getLatestNotation();
                console.log('ğŸ“– å¾ gameRecord å¾Œå‚™è®€å–æ£‹è­œ:', notation);
            }

            // âœ… ç¬¬ä¸‰å„ªå…ˆï¼šä½¿ç”¨å…¶ä»–å¯èƒ½çš„å±¬æ€§
            if (!notation) {
                notation = suggestion.moveString || suggestion.move || 'æœªçŸ¥ç§»å‹•';
                console.warn('âš ï¸ ä½¿ç”¨å¾Œå‚™æ£‹è­œæ ¼å¼:', notation);
            }

            console.log('âœ… æœ€çµ‚é¡¯ç¤º AI ç§»å‹•è¨˜è­œæ³•:', notation);

            const notification = document.createElement('div');
            notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 1500;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        animation: slideIn 0.3s ease-out;
        border: 1px solid rgba(255, 255, 255, 0.2);
    `;

            notification.innerHTML = `
        <style>
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
        </style>
        <div style="font-weight: bold; display: flex; align-items: center; margin-bottom: 8px;">
            ğŸ¤– <span style="margin-left: 8px;">AI ç§»å‹•</span>
        </div>
        <div style="font-size: 20px; color: #00ff88; font-weight: bold; text-align: center; margin: 8px 0; letter-spacing: 3px;">
            ${notation}
        </div>
        ${suggestion.description ? `<div style="margin-top: 8px; font-size: 12px; opacity: 0.9;">${suggestion.description}</div>` : ''}
        ${suggestion.difficulty ? `<div style="margin-top: 4px; font-size: 11px; opacity: 0.7;">é›£åº¦: ${suggestion.difficulty}</div>` : ''}
    `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // æ·»åŠ AIç›¸é—œæ¨£å¼
        addAIStyles() {
            if (document.getElementById('ai-battle-styles')) return;

            const style = document.createElement('style');
            style.id = 'ai-battle-styles';
            style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }

            @keyframes loadingDots {
                0%, 20% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }

            .ai-loading-dots span {
                display: inline-block;
                animation: loadingDots 1.4s infinite;
            }

            .ai-loading-dots span:nth-child(1) { animation-delay: 0s; }
            .ai-loading-dots span:nth-child(2) { animation-delay: 0.2s; }
            .ai-loading-dots span:nth-child(3) { animation-delay: 0.4s; }

            /* AIè¨­å®šå°è©±æ¡†æ¨£å¼ - æ¨¡ä»¿å›é¥‹å°è©±æ¡† */
            .ai-settings-dialog {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
                font-family: 'Microsoft JhengHei', sans-serif;
            }

            .ai-settings-content {
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                max-width: 500px;
                width: 90%;
                text-align: center;
            }

            .ai-settings-title {
                margin-bottom: 20px;
                color: #333;
                font-size: 20px;
                font-weight: bold;
            }

            .ai-settings-section {
                margin-bottom: 25px;
                text-align: left;
            }

            .ai-settings-section-title {
                font-size: 16px;
                font-weight: bold;
                color: #333;
                margin-bottom: 15px;
            }

            .ai-option-group {
                background: #f8f9fa;
                padding: 20px;
                border-radius: 8px;
                margin-bottom: 20px;
            }

            .ai-radio-option {
                display: flex;
                align-items: center;
                margin-bottom: 12px;
                padding: 8px;
                cursor: pointer;
                border-radius: 6px;
                transition: background-color 0.2s;
            }

            .ai-radio-option:hover {
                background: rgba(0, 123, 255, 0.1);
            }

            .ai-radio-option:last-child {
                margin-bottom: 0;
            }

            .ai-radio-button {
                width: 20px;
                height: 20px;
                border: 2px solid #007bff;
                border-radius: 50%;
                margin-right: 12px;
                position: relative;
                flex-shrink: 0;
                background: white;
            }

            .ai-radio-button.selected::after {
                content: '';
                width: 10px;
                height: 10px;
                background: #007bff;
                border-radius: 50%;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .ai-option-text {
                flex: 1;
            }

            .ai-option-title {
                font-weight: 600;
                color: #333;
                margin-bottom: 2px;
            }

            .ai-option-desc {
                font-size: 12px;
                color: #666;
                line-height: 1.3;
            }

            .ai-settings-buttons {
                display: flex;
                gap: 15px;
                justify-content: center;
                margin-top: 30px;
            }

            .ai-btn {
                padding: 12px 24px;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: all 0.3s ease;
                min-width: 100px;
            }

            .ai-btn.primary {
                background: #007bff;
                color: white;
                box-shadow: 0 2px 10px rgba(0, 123, 255, 0.3);
            }

            .ai-btn.primary:hover {
                background: #0056b3;
                transform: translateY(-2px);
            }

            .ai-btn.secondary {
                background: #6c757d;
                color: white;
            }

            .ai-btn.secondary:hover {
                background: #545b62;
                transform: translateY(-2px);
            }
        `;

            document.head.appendChild(style);
        }
    }

    // AIè¨­å®šå°è©±æ¡†é¡ - å®Œæ•´æ•´åˆç‰ˆæœ¬
    class AISettingsDialog {
        constructor(manager) {
            this.manager = manager;
            this.selectedMode = null;
            // ç¢ºä¿CSSè¼‰å…¥
            this.ensureStyles();
        }

        // ç¢ºä¿æ¨£å¼è¼‰å…¥çš„æ–¹æ³• - å¾ç¬¬äºŒæ®µæ•´åˆ
        ensureStyles() {
            if (document.getElementById('ai-battle-styles')) return;

            const style = document.createElement('style');
            style.id = 'ai-battle-styles';
            style.textContent = `
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes loadingDots {
            0%, 20% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .ai-loading-dots span {
            display: inline-block;
            animation: loadingDots 1.4s infinite;
        }

        .ai-loading-dots span:nth-child(1) { animation-delay: 0s; }
        .ai-loading-dots span:nth-child(2) { animation-delay: 0.2s; }
        .ai-loading-dots span:nth-child(3) { animation-delay: 0.4s; }

        /* AIè¨­å®šå°è©±æ¡†æ¨£å¼ - åŠ å¼·æ¬Šé‡ */
        .ai-settings-dialog {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.7) !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            z-index: 9999 !important;
            font-family: 'Microsoft JhengHei', sans-serif !important;
        }

        .ai-settings-content {
            background: white !important;
            padding: 30px !important;
            border-radius: 10px !important;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3) !important;
            max-width: 500px !important;
            width: 90% !important;
            max-height: 90vh !important;
            overflow-y: auto !important;
            text-align: center !important;
            position: relative !important;
            min-height: 200px !important;
        }

        .ai-settings-title {
            margin-bottom: 20px !important;
            color: #333 !important;
            font-size: 20px !important;
            font-weight: bold !important;
        }

        .ai-option-group {
            background: #f8f9fa !important;
            padding: 20px !important;
            border-radius: 8px !important;
            margin-bottom: 20px !important;
            text-align: left !important;
        }

        .ai-radio-option {
            display: flex !important;
            align-items: center !important;
            padding: 12px 15px !important;
            cursor: pointer !important;
            border-radius: 8px !important;
            transition: all 0.2s !important;
            border: 2px solid #e9ecef !important;
            background: white !important;
            margin-bottom: 10px !important;
        }

        .ai-radio-option:hover {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: #007bff !important;
        }

        .ai-radio-option.selected {
            background: rgba(0, 123, 255, 0.1) !important;
            border-color: #007bff !important;
            box-shadow: 0 2px 8px rgba(0, 123, 255, 0.2) !important;
        }

        .ai-radio-button {
            width: 18px !important;
            height: 18px !important;
            border: 2px solid #007bff !important;
            border-radius: 50% !important;
            margin-right: 15px !important;
            position: relative !important;
            flex-shrink: 0 !important;
            background: white !important;
        }

        .ai-radio-button.selected::after {
            content: '' !important;
            width: 8px !important;
            height: 8px !important;
            background: #007bff !important;
            border-radius: 50% !important;
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }

        .ai-option-text {
            flex: 1 !important;
        }

        .ai-option-title {
            font-weight: 600 !important;
            color: #333 !important;
            margin-bottom: 4px !important;
            font-size: 14px !important;
        }

        .ai-option-desc {
            font-size: 12px !important;
            color: #666 !important;
            line-height: 1.3 !important;
        }

        .ai-settings-buttons {
            display: flex !important;
            gap: 15px !important;
            justify-content: center !important;
            margin-top: 30px !important;
            padding-top: 20px !important;
            border-top: 1px solid #e9ecef !important;
        }

        .ai-btn {
            padding: 12px 24px !important;
            border: none !important;
            border-radius: 8px !important;
            cursor: pointer !important;
            font-size: 16px !important;
            font-weight: bold !important;
            transition: all 0.3s ease !important;
            min-width: 100px !important;
        }

        .ai-btn.primary {
            background: #007bff !important;
            color: white !important;
            box-shadow: 0 2px 10px rgba(0, 123, 255, 0.3) !important;
        }

        .ai-btn.primary:hover {
            background: #0056b3 !important;
            transform: translateY(-2px) !important;
        }

        .ai-btn.secondary {
            background: #6c757d !important;
            color: white !important;
        }

        .ai-btn.secondary:hover {
            background: #545b62 !important;
            transform: translateY(-2px) !important;
        }
        `;

            document.head.appendChild(style);
            console.log('AIå°è©±æ¡†æ¨£å¼å·²è¼‰å…¥');
        }

        show() {
            // ç¢ºä¿æ¨£å¼å­˜åœ¨
            this.ensureStyles();
            // å°å»¶é²ç¢ºä¿CSSè¼‰å…¥
            setTimeout(() => {
                this.createDialog();
            }, 50);
        }

        // ğŸ”¥ å®Œæ•´çš„ createDialog() æ–¹æ³• - æ›¿æ›æ•´å€‹æ–¹æ³•
        createDialog() {
            // ç§»é™¤ç¾æœ‰å°è©±æ¡†
            this.hide();

            const dialog = document.createElement('div');
            dialog.className = 'ai-settings-dialog';
            dialog.id = 'ai-settings-dialog';

            const dialogContent = document.createElement('div');
            dialogContent.className = 'ai-settings-content';

            // ğŸ”¥ æ–°çš„ HTML çµæ§‹
            dialogContent.innerHTML = `
            <h3 class="ai-settings-title">AIå°æˆ°è¨­å®š</h3>

            <div style="margin-bottom: 20px; font-size: 14px; color: #555;">
                <p>å·¦å´é¸æ“‡é›£åº¦ï¼Œå³å´é¸æ“‡å…ˆå¾Œæ‰‹</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <!-- å·¦å´ï¼šé›£åº¦é¸æ“‡ -->
                <div class="ai-option-group">
                    <div style="font-size: 14px; font-weight: bold; color: #333; margin-bottom: 12px; text-align: center;">
                        é›£åº¦ç­‰ç´š
                    </div>
                    <div id="difficulty-options">
                        ${AI_DIFFICULTIES.map((diff, index) => `
                            <div class="ai-radio-option difficulty-option" data-difficulty-index="${index}">
                                <div class="ai-radio-button ${index === 0 ? 'selected' : ''}"></div>
                                <div class="ai-option-text">
                                    <div class="ai-option-title">${diff.name}</div>
                                    <div class="ai-option-desc">æ·±åº¦ ${diff.depth}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- å³å´ï¼šå…ˆå¾Œæ‰‹é¸æ“‡ -->
                <div class="ai-option-group">
                    <div style="font-size: 14px; font-weight: bold; color: #333; margin-bottom: 12px; text-align: center;">
                        å…ˆå¾Œæ‰‹
                    </div>
                    <div id="order-options">
                        <div class="ai-radio-option order-option" data-ai-first="false">
                            <div class="ai-radio-button selected"></div>
                            <div class="ai-option-text">
                                <div class="ai-option-title">ç©å®¶å…ˆæ‰‹</div>
                                <div class="ai-option-desc">AIåŸ·é»‘å¾Œæ‰‹</div>
                            </div>
                        </div>
                        <div class="ai-radio-option order-option" data-ai-first="true">
                            <div class="ai-radio-button"></div>
                            <div class="ai-option-text">
                                <div class="ai-option-title">AIå…ˆæ‰‹</div>
                                <div class="ai-option-desc">AIåŸ·ç´…å…ˆæ‰‹</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- é—œé–‰AIé¸é … -->
            <div class="ai-option-group" style="margin-top: 15px;">
                <div class="ai-radio-option close-ai-option" data-close-ai="true">
                    <div class="ai-radio-button"></div>
                    <div class="ai-option-text">
                        <div class="ai-option-title">é—œé–‰AI</div>
                        <div class="ai-option-desc">äººvsäººæ¨¡å¼</div>
                    </div>
                </div>
            </div>

            <div class="ai-settings-buttons">
                <button class="ai-btn secondary" onclick="aiSettingsDialog.hide()">å–æ¶ˆ</button>
                <button class="ai-btn primary" onclick="aiSettingsDialog.startGame()">é–‹å§‹å°æˆ°</button>
            </div>
        `;

            dialog.appendChild(dialogContent);
            document.body.appendChild(dialog);

            // ğŸ”¥ èª¿ç”¨æ–°çš„äº‹ä»¶ç›£è½å™¨
            this.addEventListeners();

            // é»æ“ŠèƒŒæ™¯é—œé–‰å°è©±æ¡†
            dialog.addEventListener('click', (e) => {
                if (e.target === dialog) {
                    this.hide();
                }
            });
        }



        // ğŸ”¥ å®Œæ•´çš„ addEventListeners() æ–¹æ³• - æ›¿æ›æ•´å€‹æ–¹æ³•
        addEventListeners() {
            let selectedDifficultyIndex = 0;
            let selectedAIFirst = false;
            let closeAI = false;

            // é›£åº¦é¸é …äº‹ä»¶
            const difficultyOptions = document.querySelectorAll('.difficulty-option');
            difficultyOptions.forEach((option, index) => {
                option.addEventListener('click', () => {
                    // æ¸…é™¤é—œé–‰AIé¸é …
                    const closeAIButton = document.querySelector('.close-ai-option .ai-radio-button');
                    if (closeAIButton) {
                        closeAIButton.classList.remove('selected');
                    }
                    closeAI = false;

                    // æ›´æ–°é›£åº¦é¸æ“‡
                    difficultyOptions.forEach(opt =>
                        opt.querySelector('.ai-radio-button').classList.remove('selected')
                    );
                    option.querySelector('.ai-radio-button').classList.add('selected');
                    selectedDifficultyIndex = index;

                    this.updateSelectedMode(selectedDifficultyIndex, selectedAIFirst, false);
                });
            });

            // å…ˆå¾Œæ‰‹é¸é …äº‹ä»¶
            const orderOptions = document.querySelectorAll('.order-option');
            orderOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // æ¸…é™¤é—œé–‰AIé¸é …
                    const closeAIButton = document.querySelector('.close-ai-option .ai-radio-button');
                    if (closeAIButton) {
                        closeAIButton.classList.remove('selected');
                    }
                    closeAI = false;

                    // æ›´æ–°å…ˆå¾Œæ‰‹é¸æ“‡
                    orderOptions.forEach(opt =>
                        opt.querySelector('.ai-radio-button').classList.remove('selected')
                    );
                    option.querySelector('.ai-radio-button').classList.add('selected');
                    selectedAIFirst = option.dataset.aiFirst === 'true';

                    this.updateSelectedMode(selectedDifficultyIndex, selectedAIFirst, false);
                });
            });

            // é—œé–‰AIé¸é …äº‹ä»¶
            const closeAIOption = document.querySelector('.close-ai-option');
            if (closeAIOption) {
                closeAIOption.addEventListener('click', () => {
                    // æ¸…é™¤å…¶ä»–é¸é …
                    difficultyOptions.forEach(opt =>
                        opt.querySelector('.ai-radio-button').classList.remove('selected')
                    );
                    orderOptions.forEach(opt =>
                        opt.querySelector('.ai-radio-button').classList.remove('selected')
                    );

                    // é¸ä¸­é—œé–‰AI
                    closeAIOption.querySelector('.ai-radio-button').classList.add('selected');
                    closeAI = true;

                    this.updateSelectedMode(0, false, true);
                });
            }

            // è¨­å®šé è¨­é¸æ“‡ï¼ˆç°¡å–®é›£åº¦ + ç©å®¶å…ˆæ‰‹ï¼‰
            this.updateSelectedMode(selectedDifficultyIndex, selectedAIFirst, false);
        }

        // ğŸ”¥ æ–°å¢è¼”åŠ©æ–¹æ³• - æ·»åŠ åˆ° AISettingsDialog é¡ä¸­
        updateSelectedMode(difficultyIndex, aiFirst, closeAI) {
            if (closeAI) {
                this.selectedMode = {
                    name: "é—œé–‰AI",
                    depth: 0,
                    aiFirst: false,
                    aiColor: null,
                    description: "äººvsäººæ¨¡å¼"
                };
            } else {
                const difficulty = AI_DIFFICULTIES[difficultyIndex];
                this.selectedMode = {
                    name: `${difficulty.name} - ${aiFirst ? 'AIå…ˆæ‰‹' : 'ç©å®¶å…ˆæ‰‹'}`,
                    depth: difficulty.depth,
                    aiFirst: aiFirst,
                    aiColor: aiFirst ? 'red' : 'black',
                    description: `AIæ·±åº¦${difficulty.depth}ï¼Œ${aiFirst ? 'AIåŸ·ç´…å…ˆæ‰‹' : 'AIåŸ·é»‘ï¼Œç©å®¶å…ˆæ‰‹'}`,
                    difficultyName: difficulty.name
                };
            }

            console.log('å·²é¸æ“‡æ¨¡å¼:', this.selectedMode);
        }

        async startGame() {
            if (!this.selectedMode) {
                alert('è«‹é¸æ“‡å°æˆ°æ¨¡å¼');
                return;
            }

            try {
                console.log('é–‹å§‹AIå°æˆ°ï¼Œè¨­å®š:', this.selectedMode);

                await this.manager.setAIMode(this.selectedMode);

                // ã€æ ¸å¿ƒé˜²è­·ã€‘è¨­å®š gameState å±¬æ€§
                gameState.isAIBattle = true;
                gameState.aiColor = this.selectedMode.aiColor;
                gameState.aiMode = this.selectedMode;

                console.log(`âœ… AI å°æˆ°å·²å•Ÿå‹• - AIé¡è‰²: ${this.selectedMode.aiColor}, é›£åº¦: ${this.selectedMode.name}`);

                this.hide();
                this.showStartNotification(this.selectedMode);

            } catch (error) {
                console.error('é–‹å§‹AIå°æˆ°å¤±æ•—:', error);
                alert('é–‹å§‹AIå°æˆ°å¤±æ•—: ' + error.message);
            }
        }

        // ç¬¬ä¸€æ®µçš„åŸå§‹æ–¹æ³• (ä¿æŒAIå°æˆ°åŠŸèƒ½å®Œæ•´)
        createArrowPath(fromX, fromY, toX, toY) {
            return `M ${fromX} ${fromY} L ${toX} ${toY}`;
        }

        clearMoveArrow() {
            const existingArrows = document.querySelectorAll('.move-arrow');
            existingArrows.forEach(arrow => arrow.remove());
        }

        getColIndex(col) {
            const colLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];
            return colLetters.indexOf(col);
        }

        displayAIMove(moveResult) {
            console.log('é¡¯ç¤º AI æ¨è–¦ç§»å‹•ç®­é ­');
            this.showMoveArrow(moveResult.from, moveResult.to);

            // 3ç§’å¾Œè‡ªå‹•æ¸…é™¤ç®­é ­
            setTimeout(() => {
                this.clearMoveArrow();
            }, 3000);
        }

        // æ”¹é€²ç‰ˆé€šçŸ¥ (å¾ç¬¬äºŒæ®µæ•´åˆ)
        showStartNotification(mode) {
            const notification = document.createElement('div');
            notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1500;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            max-width: 300px;
        `;

            notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">AIå°æˆ°é–‹å§‹ï¼</div>
            <div style="font-size: 12px; opacity: 0.9;">${mode.name}</div>
            <div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">${mode.description}</div>
        `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        hide() {
            const dialog = document.getElementById('ai-settings-dialog');
            if (dialog) {
                dialog.remove();
            }
        }
    }

    // å‰µå»ºAIå°æˆ°æŒ‰éˆ•å‡½æ•¸ (ä¿æŒç¬¬ä¸€æ®µçš„å®Œæ•´åŠŸèƒ½)
    function addAIBattleButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const aiButton = document.createElement('button');

        // å‰µå»ºAIæˆ°é¬¥ç®¡ç†å™¨
        const aiBattleManager = new AIBattleManager();

        // å‰µå»ºAIè¨­å®šå°è©±æ¡†
        const aiSettingsDialog = new AISettingsDialog(aiBattleManager);
        window.aiSettingsDialog = aiSettingsDialog; // å…¨å±€è¨ªå•

        // åˆå§‹åŒ–æŒ‰éˆ•
        aiButton.textContent = 'AIå°æˆ°';

        if (regretButton) {
            aiButton.className = regretButton.className;
            aiButton.style.cssText = regretButton.style.cssText;
        } else {
            aiButton.style.cssText = `
            padding: 12px 20px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        `;
        }

        // æ‡¸åœæ•ˆæœ
        aiButton.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-2px)';
            this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
        });

        aiButton.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
            this.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';
        });

        // 1. ä¿®æ”¹ä½ åŸæœ¬çš„æŒ‰éˆ•é»æ“Šäº‹ä»¶
        aiButton.addEventListener('click', function() {
            if (isAIThinking) {
                showAIThinkingUI();
                return;
            }

            aiSettingsDialog.show();
        });

        buttonContainer.appendChild(aiButton);

        // å‰µå»ºé—œé–‰AIæŒ‰éˆ•
        const closeAIButton = document.createElement('button');
        closeAIButton.textContent = 'é—œé–‰AI';
        closeAIButton.style.cssText = `
        padding: 10px 16px;
        background: #6c757d;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        margin: 5px;
        transition: all 0.3s;
        display: none;
    `;

        closeAIButton.addEventListener('click', async function() {
            try {
                // ğŸ”¥ é—œéµä¿®å¾©ï¼šç«‹å³æ¸…é™¤æ‰€æœ‰AIå°æˆ°ç‹€æ…‹
                console.log('ğŸ›‘ é—œé–‰AIå°æˆ°æ¨¡å¼...');

                // 1. æ¸…é™¤ç®¡ç†å™¨ç‹€æ…‹
                aiBattleManager.currentMode = null;
                aiBattleManager.isAITurnActive = false;
                currentAIMode = null;
                isAIThinking = false;

                // 2. æ¸…é™¤ gameState ä¸­çš„ AI æ¨™è¨˜
                if (typeof gameState !== 'undefined') {
                    gameState.isAIBattle = false;
                    gameState.aiColor = null;
                    gameState.aiMode = null;
                    console.log('âœ… å·²æ¸…é™¤ gameState.isAIBattle');
                }

                // 3. æ¸…é™¤ gameAI çš„å°æˆ°æ¨¡å¼
                if (typeof gameAI !== 'undefined' && gameAI) {
                    gameAI.gameMode = null;
                    gameAI.analysisMode = 'analysis'; // æ¢å¾©åˆ†ææ¨¡å¼
                    console.log('âœ… å·²é‡ç½® gameAI æ¨¡å¼');
                }

                // 4. è¨­å®šç‚ºé—œé–‰æ¨¡å¼
                await aiBattleManager.setAIMode({
                    name: "é—œé–‰AI",
                    depth: 0,
                    aiFirst: false,
                    aiColor: null,
                    description: "äººvsäººæ¨¡å¼"
                });

                // 5. éš±è—æŒ‰éˆ•
                closeAIButton.style.display = 'none';

                // 6. é¡¯ç¤ºé€šçŸ¥
                showModeNotification({
                    name: "AIå·²é—œé–‰",
                    description: "å·²åˆ‡æ›åˆ°äººvsäººæ¨¡å¼ï¼Œç¾åœ¨å¯ä»¥è‡ªç”±ç§»å‹•é›™æ–¹æ£‹å­"
                });

                console.log('âœ… AIå°æˆ°æ¨¡å¼å·²å®Œå…¨é—œé–‰');

            } catch (error) {
                console.error('âŒ é—œé–‰AIå¤±æ•—:', error);
                alert('é—œé–‰AIå¤±æ•—: ' + error.message);
            }
        });

        buttonContainer.appendChild(closeAIButton);

        // ç›£è½ç©å®¶ç§»å‹•
        const originalAddEventListeners = window.addEventListeners;
        if (originalAddEventListeners) {
            window.addEventListeners = function() {
                originalAddEventListeners();
                // åœ¨ç¾æœ‰äº‹ä»¶ç›£è½å™¨ä¹‹å¾Œæ·»åŠ AIå›èª¿
                document.querySelectorAll('.tile').forEach(tile => {
                    tile.addEventListener('click', () => {
                        setTimeout(() => aiBattleManager.onPlayerMove(), 200);
                    });
                });
            };
        } else {
            // å¦‚æœæ²’æœ‰åŸå§‹çš„äº‹ä»¶ç›£è½å™¨ï¼Œç›´æ¥æ·»åŠ 
            document.querySelectorAll('.tile').forEach(tile => {
                tile.addEventListener('click', () => {
                    setTimeout(() => aiBattleManager.onPlayerMove(), 200);
                });
            });
        }

        // ä¿®æ”¹è¨­å®šå°è©±æ¡†çš„startGameæ–¹æ³•ï¼Œé¡¯ç¤ºé—œé–‰æŒ‰éˆ•
        const originalStartGame = aiSettingsDialog.startGame.bind(aiSettingsDialog);
        aiSettingsDialog.startGame = async function() {
            await originalStartGame();
            closeAIButton.style.display = 'inline-block';
        };

        return {
            button: aiButton,
            closeButton: closeAIButton,
            manager: aiBattleManager,
            settingsDialog: aiSettingsDialog
        };
    }

    // 2. æ–°å¢é¡¯ç¤º UI çš„å‡½æ•¸

    // é¡¯ç¤º AI æ€è€ƒä¸­çš„ UI
    function showAIThinkingUI() {
        // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œå…ˆç§»é™¤
        const existing = document.getElementById('aiThinkingOverlay');
        if (existing) existing.remove();

        // å‰µå»ºé®ç½©å±¤
        const overlay = document.createElement('div');
        overlay.id = 'aiThinkingOverlay';
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        animation: fadeIn 0.3s;
    `;

        // å‰µå»ºå¡ç‰‡
        const card = document.createElement('div');
        card.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 40px 60px;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        text-align: center;
        animation: slideUp 0.4s ease-out;
    `;

        card.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 20px; animation: pulse 1.5s ease-in-out infinite;">ğŸ¤–</div>
        <div style="color: white; font-size: 24px; font-weight: 600; margin-bottom: 10px;">AI æ­£åœ¨æ€è€ƒä¸­</div>
        <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px; margin-bottom: 20px;">è«‹ç¨å¾Œ...</div>
        <div style="display: flex; justify-content: center; gap: 8px;">
            <div class="ai-dot" style="width: 12px; height: 12px; background: white; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite;"></div>
            <div class="ai-dot" style="width: 12px; height: 12px; background: white; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite 0.2s;"></div>
            <div class="ai-dot" style="width: 12px; height: 12px; background: white; border-radius: 50%; animation: bounce 1.4s ease-in-out infinite 0.4s;"></div>
        </div>
    `;

        overlay.appendChild(card);
        document.body.appendChild(overlay);

        // é»æ“Šé®ç½©é—œé–‰
        overlay.addEventListener('click', function() {
            overlay.style.animation = 'fadeOut 0.3s';
            setTimeout(() => overlay.remove(), 300);
        });

        // æ·»åŠ å‹•ç•«æ¨£å¼ï¼ˆå¦‚æœé‚„æ²’æœ‰çš„è©±ï¼‰
        if (!document.getElementById('aiThinkingStyles')) {
            const style = document.createElement('style');
            style.id = 'aiThinkingStyles';
            style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes fadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
            @keyframes slideUp {
                from { transform: translateY(30px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
            @keyframes pulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
            }
            @keyframes bounce {
                0%, 80%, 100% { transform: translateY(0); }
                40% { transform: translateY(-20px); }
            }
        `;
            document.head.appendChild(style);
        }
    }


    let isReplayClickSource = false;  // ğŸ‘ˆ æ–°å¢è¦†ç›¤æ¨™è¨˜


    // é¡¯ç¤ºæ¨¡å¼åˆ‡æ›é€šçŸ¥
    function showModeNotification(mode) {
        const notification = document.createElement('div');
        notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 1001;
        animation: slideIn 0.3s ease-out;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    `;

        notification.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 5px;">${mode.name}</div>
        <div style="font-size: 12px; opacity: 0.9;">${mode.description}</div>
    `;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.animation = 'slideIn 0.3s ease-out reverse';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    // ä½¿ç”¨æ–¹æ³•ï¼š
    // 1. åœ¨é é¢è¼‰å…¥å¾Œèª¿ç”¨ addAIBattleButton() ä¾†å‰µå»ºAIå°æˆ°æŒ‰éˆ•
    // 2. é»æ“ŠæŒ‰éˆ•æœƒé¡¯ç¤ºè¨­å®šå°è©±æ¡†ï¼Œè®“ç”¨æˆ¶é¸æ“‡æ¨¡å¼
    // 3. ä½¿ç”¨å–®é¸æŒ‰éˆ•ï¼ˆradio buttonï¼‰é¸æ“‡ï¼Œä¸€æ¬¡åªèƒ½é¸ä¸€å€‹
    // 4. ç¢ºèªè¨­å®šå¾Œé–‹å§‹AIå°æˆ°

    // è‡ªå‹•åˆå§‹åŒ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (typeof window !== 'undefined') {
        window.addEventListener('load', function() {
            // ç­‰å¾…ä¸€é»æ™‚é–“ç¢ºä¿å…¶ä»–è…³æœ¬è¼‰å…¥å®Œæˆ
            setTimeout(() => {
                try {
                    const aiSystem = addAIBattleButton();
                    console.log('AIå°æˆ°ç³»çµ±å·²åˆå§‹åŒ–', aiSystem);
                } catch (error) {
                    console.error('AIå°æˆ°ç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
                }
            }, 1000);
        });
    }



    // AI å¿ƒè·³æª¢æ¸¬å™¨ï¼ˆæ”¹é€²ç‰ˆï¼‰
    class AIHeartbeatMonitor {
        constructor() {
            this.initialized = false;

            this.checkpoints = {
                wasmReady: false,           // "Pikafish WASM è¼‰å…¥å®Œæˆ"
                engineIdentified: false,    // "å¼•æ“å·²è­˜åˆ¥"
                uciOkReceived: false,       // "æ”¶åˆ° uciok"
                readyOkReceived: false,     // "æ”¶åˆ° readyok"
                engineInitComplete: false,  // "å¼•æ“åˆå§‹åŒ–å®Œæˆ"
                aiReady: false              // "AI å·²æº–å‚™å°±ç·’"
            };

            this.readyOkCount = 0;            // è¿½è¹¤æ”¶åˆ° readyok çš„æ¬¡æ•¸
            this.initTimeout = null;
            this.healthCheckInterval = null;
            this.timeoutDuration = 20000; // 20ç§’è¶…æ™‚ï¼ˆå› ç‚ºæµç¨‹è¼ƒé•·ï¼‰
            this.warningShown = false;
            this.lastActivityTime = Date.now();
            this.healthCheckAttempts = 0;
            this.maxHealthCheckAttempts = 3;
        }

        // é–‹å§‹ç›£æ§åˆå§‹åŒ–éç¨‹
        startMonitoring() {
            console.log('ğŸ” é–‹å§‹ç›£æ§ AI åˆå§‹åŒ–...');
            this.warningShown = false;
            this.lastActivityTime = Date.now();
            this.healthCheckAttempts = 0;

            // è¨­å®šè¶…æ™‚æª¢æŸ¥
            this.initTimeout = setTimeout(() => {
                if (!this.initialized) {
                    console.error('âŒ AI åˆå§‹åŒ–è¶…æ™‚ï¼');
                    this.showAIWarning('timeout');
                }
            }, this.timeoutDuration);

            // é–‹å§‹å®šæœŸå¥åº·æª¢æŸ¥ï¼ˆæ¯5ç§’ï¼‰
            this.startHealthCheck();
        }

        // å®šæœŸå¥åº·æª¢æŸ¥
        startHealthCheck() {
            this.healthCheckInterval = setInterval(() => {
                if (this.initialized) {
                    // å·²åˆå§‹åŒ–ï¼Œé€²è¡ŒåŠŸèƒ½æ¸¬è©¦
                    this.performFunctionalTest();
                } else {
                    // æœªåˆå§‹åŒ–ï¼Œæª¢æŸ¥æ˜¯å¦æœ‰é€²å±•
                    const timeSinceLastActivity = Date.now() - this.lastActivityTime;
                    if (timeSinceLastActivity > 10000) { // 10ç§’ç„¡æ´»å‹•
                        console.warn('âš ï¸ AI åˆå§‹åŒ–åœæ»¯');
                        this.healthCheckAttempts++;
                        if (this.healthCheckAttempts >= this.maxHealthCheckAttempts) {
                            this.showAIWarning('stalled');
                        }
                    }
                }
            }, 5000);
        }

        // è¨˜éŒ„æª¢æŸ¥é»
        markCheckpoint(checkpoint, data = null) {
            if (this.checkpoints.hasOwnProperty(checkpoint)) {
                this.checkpoints[checkpoint] = true;
                this.lastActivityTime = Date.now();
                this.healthCheckAttempts = 0; // é‡ç½®å¥åº·æª¢æŸ¥è¨ˆæ•¸

                // ç‰¹åˆ¥è™•ç† readyokï¼ˆæœƒå‡ºç¾å¤šæ¬¡ï¼‰
                if (checkpoint === 'readyOkReceived') {
                    this.readyOkCount++;
                    console.log(`âœ… æª¢æŸ¥é»é€šé: ${checkpoint} (ç¬¬ ${this.readyOkCount} æ¬¡)`, data || '');
                } else {
                    console.log(`âœ… æª¢æŸ¥é»é€šé: ${checkpoint}`, data || '');
                }

                this.checkInitializationStatus();
            }
        }

        checkInitializationStatus() {
            const requiredCheckpoints = [
                'wasmReady',
                'engineIdentified',
                'uciOkReceived',
                'readyOkReceived',
                'engineInitComplete',
                'aiReady'
            ];
            // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å¿…è¦æª¢æŸ¥é»éƒ½é€šé
            const allPassed = requiredCheckpoints.every(cp => this.checkpoints[cp] === true);

            // é¡å¤–æª¢æŸ¥ï¼šè‡³å°‘æ”¶åˆ° 1 æ¬¡ readyok
            const readyOkValid = this.readyOkCount >= 1;

            if (allPassed && readyOkValid && !this.initialized) {
                this.initialized = true;
                console.log('ğŸ‰ AI å¼•æ“å®Œå…¨åˆå§‹åŒ–æˆåŠŸï¼æ‰€æœ‰æª¢æŸ¥é»å·²é€šé');
                console.log(`ğŸ“Š æ”¶åˆ° ${this.readyOkCount} æ¬¡ readyok ç¢ºèª`);
                if (this.initTimeout) {
                    clearTimeout(this.initTimeout);
                }
                // åˆå§‹åŒ–å¾Œä»ç¹¼çºŒå¥åº·æª¢æŸ¥
            }
        }

        // åŸ·è¡ŒåŠŸèƒ½æ¸¬è©¦ï¼ˆæ¸¬è©¦ AI æ˜¯å¦çœŸçš„èƒ½å·¥ä½œï¼‰
        async performFunctionalTest() {
            if (!window.xiangqiGameAI) {
                console.warn('âš ï¸ xiangqiGameAI æœªå®šç¾©');
                this.showAIWarning('not_working');
                return;
            }

            // é€™è£¡å¯ä»¥åŠ å…¥å¯¦éš›çš„ AI åŠŸèƒ½æ¸¬è©¦
            // ä¾‹å¦‚ï¼šæ¸¬è©¦èƒ½å¦å–å¾—å±€é¢åˆ†æ
            try {
                // å‡è¨­æœ‰å€‹æ¸¬è©¦æ–¹æ³•ï¼ˆéœ€è¦æ ¹æ“šä½ çš„å¯¦éš› API èª¿æ•´ï¼‰
                const isWorking = await this.testAIResponse();
                if (!isWorking) {
                    console.error('âŒ AI åŠŸèƒ½æ¸¬è©¦å¤±æ•—');
                    this.showAIWarning('not_working');
                }
            } catch (error) {
                console.error('âŒ AI åŠŸèƒ½æ¸¬è©¦ç•°å¸¸:', error);
                this.showAIWarning('not_working');
            }
        }

        // æ¸¬è©¦ AI å›æ‡‰ï¼ˆéœ€è¦æ ¹æ“šä½ çš„å¯¦éš› API èª¿æ•´ï¼‰
        async testAIResponse() {
            // é€™æ˜¯ä¸€å€‹ç¯„ä¾‹ï¼Œä½ éœ€è¦æ ¹æ“šå¯¦éš›çš„ AI API ä¾†å¯¦ä½œ
            // ä¾‹å¦‚ï¼šç™¼é€ä¸€å€‹ç°¡å–®çš„ä½ç½®è«‹æ±‚ï¼Œçœ‹æ˜¯å¦èƒ½å¾—åˆ°å›æ‡‰
            return new Promise((resolve) => {
                // å¦‚æœä½ çš„ AI æœ‰ isReady æˆ–é¡ä¼¼æ–¹æ³•
                if (window.xiangqiGameAI && typeof window.xiangqiGameAI.isReady === 'function') {
                    resolve(window.xiangqiGameAI.isReady());
                } else {
                    // å¦å‰‡å‡è¨­å·²å°±ç·’
                    resolve(true);
                }
            });
        }

        // é¡¯ç¤º AI è­¦å‘Šå½ˆçª—
        showAIWarning(reason = 'unknown') {
            if (this.warningShown) return;
            this.warningShown = true;

            let message = 'AI åŠŸèƒ½å°šæœªå•Ÿå‹•ï¼Œç¹¼çºŒä½¿ç”¨å°‡ç„¡æ³•äº«æœ‰ AI åŠŸèƒ½ã€‚\nå»ºè­°é‡æ–°é–‹å•ŸéŠæˆ²ä»¥å•Ÿç”¨å®Œæ•´åŠŸèƒ½ã€‚';
            let details = this.getFailureDetails(reason);

            showAIWarningDialog(message, details);

            // åœæ­¢å¥åº·æª¢æŸ¥
            if (this.healthCheckInterval) {
                clearInterval(this.healthCheckInterval);
            }
        }

        // å–å¾—å¤±æ•—è©³æƒ…
        getFailureDetails(reason) {
            const failed = [];
            const checkpointNames = {
                wasmReady: 'WASM è¼‰å…¥',
                engineIdentified: 'å¼•æ“è­˜åˆ¥',
                uciOkReceived: 'UCI ç¢ºèª',
                readyOkReceived: 'ReadyOK ç¢ºèª',
                engineInitComplete: 'å¼•æ“åˆå§‹åŒ–å®Œæˆ',
                aiReady: 'AI å°±ç·’ç¢ºèª'
            };

            Object.keys(this.checkpoints).forEach(key => {
                if (!this.checkpoints[key]) {
                    failed.push(checkpointNames[key]);
                }
            });

            let reasonText = '';
            switch(reason) {
                case 'timeout':
                    reasonText = 'åˆå§‹åŒ–è¶…æ™‚';
                    break;
                case 'stalled':
                    reasonText = 'åˆå§‹åŒ–åœæ»¯';
                    break;
                case 'not_working':
                    reasonText = 'AI åŠŸèƒ½ç•°å¸¸';
                    break;
                default:
                    reasonText = 'æœªçŸ¥éŒ¯èª¤';
            }

            const detail = failed.length > 0
                ? `${reasonText} - æœªå®Œæˆ: ${failed.join('ã€')}`
                : `${reasonText} - ReadyOK æ¬¡æ•¸: ${this.readyOkCount}`;

            return detail;
        }

        // é‡ç½®ç›£æ§å™¨
        reset() {
            if (this.initTimeout) {
                clearTimeout(this.initTimeout);
            }
            if (this.healthCheckInterval) {
                clearInterval(this.healthCheckInterval);
            }
            this.initialized = false;
            this.warningShown = false;
            this.healthCheckAttempts = 0;
            this.readyOkCount = 0;
            Object.keys(this.checkpoints).forEach(key => {
                this.checkpoints[key] = false;
            });
        }

        // å–å¾—ç•¶å‰ç‹€æ…‹å ±å‘Š
        getStatusReport() {
            return {
                initialized: this.initialized,
                checkpoints: {...this.checkpoints},
                timeSinceLastActivity: Date.now() - this.lastActivityTime,
                healthCheckAttempts: this.healthCheckAttempts
            };
        }
    }

    window.aiMonitor = new AIHeartbeatMonitor();

    // ğŸ”§ ä¿®æ­£ï¼šè™•ç†é•·æ‰è­¦å‘Šå‡½æ•¸
    function handleLongCaptureWarning(longCaptureResult) {
        console.log('âš ï¸ è™•ç†é•·æ‰è­¦å‘Š:', longCaptureResult);

        // ğŸ”§ ç¢ºä¿æœ‰æ­£ç¢ºçš„ç©å®¶è³‡è¨Š
        if (!longCaptureResult.longCapturePlayer) {
            console.error('âŒ é•·æ‰è­¦å‘Šç¼ºå°‘ç©å®¶è³‡è¨Š');
            return;
        }

        showLongCaptureWarning(longCaptureResult);

        // å¯ä»¥åœ¨é€™è£¡æ·»åŠ å…¶ä»–è­¦å‘Šè™•ç†é‚è¼¯
        // - æ’­æ”¾è­¦å‘ŠéŸ³æ•ˆ
        // - é«˜äº®ç›¸é—œæ£‹å­
        // - è¨˜éŒ„è­¦å‘Šåˆ°éŠæˆ²æ—¥èªŒ
    }
    // ğŸ”§ ä¿®æ­£ï¼šè™•ç†é•·æ‰åˆ¤è² å‡½æ•¸
    function handleLongCaptureLoss(longCaptureResult) {
        console.log('ğŸ” è™•ç†é•·æ‰åˆ¤è² :', longCaptureResult);

        // ğŸ”§ ç¢ºä¿æœ‰æ­£ç¢ºçš„ç©å®¶è³‡è¨Š
        if (!longCaptureResult.longCapturePlayer) {
            console.error('âŒ é•·æ‰åˆ¤è² ç¼ºå°‘ç©å®¶è³‡è¨Š');
            return;
        }

        // é¡¯ç¤ºåˆ¤è² è¨Šæ¯
        showLongCaptureLoss(longCaptureResult);

        // ğŸ”§ åˆ¤è² é‚è¼¯
        if (longCaptureResult.shouldEndGame) {
            console.log('ğŸš« éŠæˆ²å› é•·æ‰çµæŸ');

            // éŠæˆ²çµæŸè™•ç†
            gameState.gameEnded = true;
            gameState.gameResult = {
                type: 'long_capture_loss',
                winner: longCaptureResult.longCapturePlayer === 'red' ? 'black' : 'red', // ğŸ”§ ä¿®æ­£ï¼šé•·æ‰æ–¹åˆ¤è² 
                loser: longCaptureResult.longCapturePlayer,
                reason: 'é•·æ‰åˆ¤è² ',
                details: longCaptureResult
            };

            console.log('ğŸ éŠæˆ²çµæŸçµæœ:', gameState.gameResult);
        } else {
            console.log(`âš ï¸ é•·æ‰è­¦å‘Šéšæ®µï¼ŒéŠæˆ²ç¹¼çºŒ`);
        }
    }
    // è™•ç†é•·å°‡åˆ¤è² 
    function handlePerpetualCheckLoss(cycleResult) {
        console.log('ğŸš« é•·å°‡åˆ¤è² ï¼', cycleResult);

        // è¨­å®šéŠæˆ²çµæŸç‹€æ…‹
        gameState.gameOver = true;
        gameState.winner = cycleResult.perpetualCheckPlayer === 'red' ? 'black' : 'red';

        // é¡¯ç¤ºåˆ¤è² è¨Šæ¯
        showGameMessage(cycleResult.description, 'error');

        // è¨˜éŒ„åˆ°éŠæˆ²æ­·å²
        gameState.gameResult = {
            type: 'perpetual_check_loss',
            winner: gameState.winner,
            loser: cycleResult.perpetualCheckPlayer,
            description: cycleResult.description,
            pattern: cycleResult.patternDisplay,
            cycleCount: cycleResult.cycleCount
        };

        // åœæ­¢è¨ˆæ™‚å™¨
        if (typeof stopTimer === 'function') {
            stopTimer();
        }
    }

    // å¤„ç†é•¿å°†è­¦å‘Š - ä¿®æ­£ç‰ˆï¼ŒåŒºåˆ†è­¦å‘Šå’Œæœ€ç»ˆåˆ¤å®š
    function handlePerpetualCheckWarning(cycleResult) {
        console.log('âš ï¸ é•¿å°†è­¦å‘Šå¤„ç†ï¼', cycleResult);

        // æ£€æŸ¥æ˜¯å¦ä¸ºé•¿å°†æ£€æµ‹ç»“æœ
        if (cycleResult.isPerpetualCheck) {
            if (cycleResult.isMutualPerpetualCheck) {
                // åŒæ–¹äº’ç›¸é•¿å°† - æ˜¾ç¤ºè­¦å‘Šï¼ˆä¸æ˜¯æœ€ç»ˆåˆ¤å®šï¼‰
                console.log('âš ï¸ æ£€æµ‹åˆ°åŒæ–¹äº’ç›¸é•¿å°†ï¼Œæ˜¾ç¤ºè­¦å‘Š');
                showMutualPerpetualCheckWarning(cycleResult);
            } else if (cycleResult.perpetualCheckPlayer === 'red') {
                console.log('âš ï¸ æ£€æµ‹åˆ°çº¢æ–¹é•¿å°†ï¼Œæ˜¾ç¤ºè­¦å‘Š');
                showPerpetualCheckWarning(cycleResult);
            } else if (cycleResult.perpetualCheckPlayer === 'black') {
                console.log('âš ï¸ æ£€æµ‹åˆ°é»‘æ–¹é•¿å°†ï¼Œæ˜¾ç¤ºè­¦å‘Š');
                showPerpetualCheckWarning(cycleResult);
            }
        } else {
            // åŸæœ‰çš„å¾ªç¯è­¦å‘Šé€»è¾‘ï¼ˆéé•¿å°†æƒ…å†µï¼‰
            console.log('ğŸ”„ å¾ªç¯è­¦å‘Šï¼ˆéé•¿å°†ï¼‰');
            showPerpetualWarningMessage(cycleResult);
        }

        if (cycleDetector && cycleDetector.markWarningShown) {
            cycleDetector.markWarningShown(cycleResult);
        }

        return null; // è­¦å‘Šé˜¶æ®µä¸è¿”å›æ¸¸æˆç»“æœ
    }

    // è™•ç†å¾ªç’°è­¦å‘Š
    function handleCycleWarning(cycleResult) {
        console.log('âš ï¸ å¾ªç’°è­¦å‘Šï¼', cycleResult);
        showWarningMessage(cycleResult);
        cycleDetector.markWarningShown(cycleResult);
    }

    // è™•ç†å¾ªç’°åˆ¤å’Œ
    function handleCycleDraw(cycleResult) {
        console.log('ğŸ”„ å¾ªç’°åˆ¤å’Œï¼', cycleResult);

        // è¨­å®šéŠæˆ²çµæŸç‹€æ…‹
        gameState.gameOver = true;
        gameState.winner = 'draw';

        // é¡¯ç¤ºåˆ¤å’Œè¨Šæ¯
        showDrawMessage(cycleResult);

        // è¨˜éŒ„åˆ°éŠæˆ²æ­·å²
        gameState.gameResult = {
            type: 'cycle_draw',
            description: cycleResult.description,
            pattern: cycleResult.patternDisplay,
            cycleCount: cycleResult.cycleCount
        };

        // åœæ­¢è¨ˆæ™‚å™¨
        if (typeof stopTimer === 'function') {
            stopTimer();
        }

        // å»¶é²é¡¯ç¤ºå°è©±æ¡†
        setTimeout(() => {
            showCustomDialog('éŠæˆ²å·²åˆ¤å’Œï¼æ˜¯å¦é‡æ–°é–‹å§‹ï¼Ÿ', () => {
                resetGameAfterDraw();
            });
        }, 2000);
    }


    // ğŸ†• é‡ç½®é•·æ‰è­¦å‘Šçš„å‡½æ•¸ï¼ˆéŠæˆ²é‡æ–°é–‹å§‹æ™‚èª¿ç”¨ï¼‰
    function resetLongCaptureWarnings() {
        longCaptureWarnings.red = 0;
        longCaptureWarnings.black = 0;
        console.log('ğŸ”„ é‡ç½®é•·æ‰è­¦å‘Šç‹€æ…‹');
    }

    function createGameNotification(type, message, pattern, detectionType = 'cycle') {
        // ç§»é™¤ä¹‹å‰çš„é€šçŸ¥
        const existingNotification = document.getElementById('game-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        const notification = document.createElement('div');
        notification.id = 'game-notification';
        notification.className = `game-notification ${type}`;

        // æ ¹æ“šæª¢æ¸¬é¡å‹å’Œçµæœé¡å‹é¸æ“‡åœ–æ¨™
        const getIcon = () => {
            if (detectionType === 'perpetual_check') {
                return type === 'warning' ? 'â™”' : type === 'loss' ? 'âŒ' : 'â™”';
            } else {
                return type === 'warning' ? 'âš ï¸' : type === 'perpetual_warning' ? 'âš ï¸' : type === 'loss' ? 'âŒ' : 'ğŸ”„';
            }
        };

        notification.innerHTML = `
        <div class="notification-content">
            <div class="notification-icon">
                ${getIcon()}
            </div>
            <div class="notification-text">
                <div class="notification-title">${message}</div>
                ${pattern ? `<div class="notification-pattern">${detectionType === 'perpetual_check' ? 'é•·å°‡æ¨¡å¼ï¼š' : 'å¾ªç’°æ¨¡å¼ï¼š'}${pattern}</div>` : ''}
            </div>
            <button class="notification-close" onclick="closeGameNotification()">Ã—</button>
        </div>
    `;

        document.body.appendChild(notification);

        // è‡ªå‹•éš±è—è­¦å‘Šï¼ˆåˆ¤å’Œ/åˆ¤è² ä¸è‡ªå‹•éš±è—ï¼‰
        if (type === 'warning' || type === 'perpetual_warning') {
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('fade-out');
                    setTimeout(() => notification.remove(), 300);
                }
            }, 5000);
        }
    }

    // é¡¯ç¤ºæ£‹è­œéŒ¯èª¤è­¦å‘Š
    function showNotationError(stepNumber, notation, reason = 'è©²ä½ç½®æ²’æœ‰å°æ‡‰çš„æ£‹å­æˆ–ç§»å‹•ä¸åˆæ³•') {
        const message = `æ£‹è­œè§£æå¤±æ•—ï¼`;
        const detail = `ç¬¬ ${stepNumber} æ­¥ã€Œ${notation}ã€æœ‰èª¤\n\néŒ¯èª¤åŸå› ï¼š${reason}\n\nè«‹æª¢æŸ¥ä¸¦ä¿®æ­£æ£‹è­œå¾Œé‡æ–°åˆ†æ`;
        createGameNotification('error', message, detail, 'notation-error');
    }

    // é¡¯ç¤ºè¦†ç›¤åˆ†æä¿è­·è­¦å‘Š
    function showReplayProtectionWarning() {
        const message = `è¦†ç›¤åˆ†æé€²è¡Œä¸­ï¼`;
        const detail = `è«‹ä½¿ç”¨æ§åˆ¶æŒ‰éˆ•æ“ä½œï¼Œç¦æ­¢æ‰‹å‹•ç§»å‹•æ£‹å­ï¼Œé¿å…é€ æˆè»Ÿé«”ç„¡æ³•æ­£ç¢ºåˆ†æ`;
        createGameNotification('warning', message, detail, 'replay-protection');
    }

    // é¡¯ç¤ºAIæ£‹å­ä¿è­·è­¦å‘Šè¨Šæ¯ï¼ˆå…©ç¨®æƒ…æ³ï¼‰
    function showAIProtectionWarning(aiColor, isAITurn = false) {
        const colorName = aiColor === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';

        let message, detail;

        if (isAITurn) {
            // æƒ…æ³1: AIå›åˆæ™‚ç©å®¶é»æ“Š
            message = `ç¾åœ¨æ˜¯${colorName}(AI)çš„å›åˆï¼`;
            detail = `è«‹ç­‰å¾…AIæ€è€ƒä¸¦å®Œæˆç§»å‹•`;
        } else {
            // æƒ…æ³2: ç©å®¶å›åˆæ™‚è©¦åœ–ç§»å‹•AIæ£‹å­
            message = `ä¸å¯ç§»å‹•${colorName}(AI)çš„æ£‹å­ï¼`;
            detail = `${colorName}ç”±AIæ§åˆ¶ï¼Œè«‹ç§»å‹•æ‚¨è‡ªå·±çš„æ£‹å­`;
        }

        createGameNotification('warning', message, detail, 'ai-protection');
    }


    // é¡¯ç¤ºå¾ªç’°è­¦å‘Šè¨Šæ¯
    function showWarningMessage(cycleResult) {
        const message = `æª¢æ¸¬åˆ°${cycleResult.cycleCount}æ¬¡å¾ªç’°ï¼å†å¾ªç’°1æ¬¡å°‡åˆ¤å’Œ`;
        createGameNotification('warning', message, cycleResult.patternDisplay, 'cycle');
    }

    // é¡¯ç¤ºé•·å°‡è­¦å‘Šè¨Šæ¯ï¼ˆå¾ªç’°ä¸­çš„é•·å°‡ï¼‰
    function showPerpetualWarningMessage(cycleResult) {
        const message = `æ³¨æ„ï¼š${cycleResult.perpetualCheckPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹'}é•·å°‡è­¦å‘Šï¼å†å¾ªç’°1æ¬¡å°‡åˆ¤è² `;
        createGameNotification('perpetual_warning', message, cycleResult.patternDisplay, 'cycle');
    }

    // ä¿®æ­£ç‰ˆå•æ–¹é•¿å°†è­¦å‘Šæ¶ˆæ¯
    function showPerpetualCheckWarning(perpetualCheckResult) {
        // ä¿®æ­£ï¼šä»ä¼ å…¥çš„æ•°æ®ç»“æ„ä¸­è·å–æ­£ç¡®çš„ player å­—æ®µ
        let playerName;
        if (perpetualCheckResult.player) {
            // å¦‚æœæœ‰ player å­—æ®µï¼Œä½¿ç”¨å®ƒ
            playerName = perpetualCheckResult.player === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
        } else if (perpetualCheckResult.perpetualCheckPlayer) {
            // å¦åˆ™ä½¿ç”¨ perpetualCheckPlayer å­—æ®µ
            playerName = perpetualCheckResult.perpetualCheckPlayer === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';
        } else {
            console.error('âŒ æ— æ³•ç¡®å®šé•¿å°†æ–¹ï¼Œæ•°æ®ç»“æ„ï¼š', perpetualCheckResult);
            return;
        }

        const message = `è­¦å‘Šï¼šæ£€æµ‹åˆ°${playerName}é•¿å°†ï¼ç»§ç»­ä¸‹å»å°†è¢«åˆ¤è´Ÿ`;

        // è·å–æ­£ç¡®çš„å°†å†›æ¯”ä¾‹
        let checkRatio = 1.0; // é»˜è®¤å€¼ï¼Œå› ä¸ºèƒ½è¿›å…¥é•¿å°†æ£€æµ‹è¯´æ˜æ¯”ä¾‹æ˜¯1.0
        if (perpetualCheckResult.redCheckRatio !== undefined && perpetualCheckResult.blackCheckRatio !== undefined) {
            checkRatio = (perpetualCheckResult.player || perpetualCheckResult.perpetualCheckPlayer) === 'red' ?
                perpetualCheckResult.redCheckRatio : perpetualCheckResult.blackCheckRatio;
        }

        const details = `${playerName}å°†å†›æ¯”ä¾‹: ${(checkRatio * 100).toFixed(0)}%, ` +
            `å¾ªç¯æ¬¡æ•°: ${perpetualCheckResult.cycleCount || perpetualCheckResult.internalCycleCount || 1}`;
        createGameNotification('warning', message, details, 'perpetual_check_warning');
        console.log(`âš ï¸ æ˜¾ç¤º${playerName}é•¿å°†è­¦å‘Šæ¶ˆæ¯`);
    }
    // æ–°å¢ï¼šä¸“é—¨å¤„ç†åŒæ–¹äº’ç›¸é•¿å°†å’Œæ£‹çš„å‡½æ•°
    function showMutualPerpetualCheckDraw(perpetualCheckResult) {
        const message = 'æ¸¸æˆç»“æŸï¼åŒæ–¹äº’ç›¸é•¿å°†ï¼Œåˆ¤å®šä¸ºå’Œæ£‹';
        const details = `çº¢æ–¹å°†å†›æ¯”ä¾‹: ${(perpetualCheckResult.redCheckRatio * 100).toFixed(0)}%, ` +
            `é»‘æ–¹å°†å†›æ¯”ä¾‹: ${(perpetualCheckResult.blackCheckRatio * 100).toFixed(0)}%`;
        createGameNotification('draw', message, details, 'mutual_perpetual_check');
        console.log('ğŸ¤ æ˜¾ç¤ºåŒæ–¹äº’ç›¸é•¿å°†å’Œæ£‹æ¶ˆæ¯');
    }

    // æ–°å¢ï¼šä¸“é—¨çš„åŒæ–¹äº’ç›¸é•¿å°†è­¦å‘Šå‡½æ•°
    function showMutualPerpetualCheckWarning(perpetualCheckResult) {
        const message = 'è­¦å‘Šï¼šæ£€æµ‹åˆ°åŒæ–¹äº’ç›¸é•¿å°†ï¼å†ç»§ç»­å¾ªç¯å°†åˆ¤å®šä¸ºå’Œæ£‹';
        const details = `çº¢æ–¹å°†å†›æ¯”ä¾‹: ${(perpetualCheckResult.redCheckRatio * 100).toFixed(0)}%, ` +
            `é»‘æ–¹å°†å†›æ¯”ä¾‹: ${(perpetualCheckResult.blackCheckRatio * 100).toFixed(0)}%, ` +
            `å¾ªç¯æ¬¡æ•°: ${perpetualCheckResult.internalCycleCount || 1}`;
        createGameNotification('warning', message, details, 'mutual_perpetual_warning');
        console.log('âš ï¸ æ˜¾ç¤ºåŒæ–¹äº’ç›¸é•¿å°†è­¦å‘Šæ¶ˆæ¯');
    }
    // ä¿®æ­£ç‰ˆé•¿å°†åˆ¤è´Ÿæ¶ˆæ¯ - ä¿®å¤ç©å®¶åç§°è·å–é€»è¾‘
    function showPerpetualCheckLoss(perpetualCheckResult) {
        console.log('ğŸ” åˆ¤è´Ÿæ¶ˆæ¯æ•°æ®ï¼š', perpetualCheckResult);

        // ç¡®å®šé•¿å°†æ–¹ï¼ˆè¿è§„æ–¹ï¼‰
        let perpetualPlayer;
        if (perpetualCheckResult.perpetualCheckPlayer) {
            perpetualPlayer = perpetualCheckResult.perpetualCheckPlayer;
        } else if (perpetualCheckResult.player) {
            perpetualPlayer = perpetualCheckResult.player;
        } else {
            console.error('âŒ æ— æ³•ç¡®å®šé•¿å°†æ–¹ï¼Œæ•°æ®ç»“æ„ï¼š', perpetualCheckResult);
            return;
        }

        const perpetualPlayerName = perpetualPlayer === 'red' ? 'çº¢æ–¹' : 'é»‘æ–¹';

        // ç¡®å®šè·èƒœæ–¹
        let winnerName;
        if (perpetualCheckResult.gameResult === 'red_wins') {
            winnerName = 'çº¢æ–¹';
        } else if (perpetualCheckResult.gameResult === 'black_wins') {
            winnerName = 'é»‘æ–¹';
        } else {
            // é•¿å°†æ–¹çš„å¯¹æ‰‹è·èƒœ
            winnerName = perpetualPlayer === 'red' ? 'é»‘æ–¹' : 'çº¢æ–¹';
        }

        console.log(`ğŸ” é•¿å°†æ–¹: ${perpetualPlayerName}, è·èƒœæ–¹: ${winnerName}`);

        const message = `æ¸¸æˆç»“æŸï¼${perpetualPlayerName}å› é•¿å°†åˆ¤è´Ÿï¼Œ${winnerName}è·èƒœ`;
        const details = `${perpetualPlayerName}å°†å†›æ¯”ä¾‹: 100%ï¼Œè¿ç»­å°†å†›è¿åè§„åˆ™`;
        createGameNotification('loss', message, details, 'perpetual_check_loss');
        console.log(`âŒ æ˜¾ç¤º${perpetualPlayerName}é•¿å°†åˆ¤è´Ÿï¼Œ${winnerName}è·èƒœ`);
    }

    // ğŸ”§ ä¿®æ­£ï¼šé•·æ‰è­¦å‘Šé¡¯ç¤ºå‡½æ•¸
    function showLongCaptureWarning(longCaptureResult) {
        console.log('ğŸ” é¡¯ç¤ºé•·æ‰è­¦å‘Šï¼Œçµæœ:', longCaptureResult);

        // ğŸ”§ ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„ç©å®¶è³‡è¨Š
        const longCapturePlayer = longCaptureResult.longCapturePlayer;
        const playerName = longCapturePlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';

        // ğŸ”§ ä½¿ç”¨å¾ªç’°è¨ˆæ•¸è€Œä¸æ˜¯æ‰å­æ¬¡æ•¸
        const cycleCount = longCaptureResult.internalCycleCount || longCaptureResult.cycleCount || 0;
        const captureCount = longCaptureResult.playerCaptureCounts?.[longCapturePlayer] || 0;

        const message = `æª¢æ¸¬åˆ°${playerName}é•·æ‰ï¼å·²å¾ªç’°${cycleCount}æ¬¡ï¼Œå…±æ‰å­${captureCount}æ¬¡`;

        console.log(`ğŸ“¢ é•·æ‰è­¦å‘Šè¨Šæ¯: ${message}`);
        createGameNotification('warning', message, longCaptureResult.patternDisplay, 'long_capture');
    }
    // æ–°å¢ï¼šå°ˆé–€è™•ç†é›™æ–¹äº’ç›¸é•·æ‰å’Œæ£‹çš„å‡½æ•¸
    function showMutualLongCaptureDraw(longCaptureResult) {
        const message = 'éŠæˆ²çµæŸï¼é›™æ–¹äº’ç›¸é•·æ‰ï¼Œåˆ¤å®šç‚ºå’Œæ£‹';
        const details = `ç´…æ–¹é•·æ‰åºåˆ—: ${longCaptureResult.filteredRedSequences.length}å€‹, ` +
            `é»‘æ–¹é•·æ‰åºåˆ—: ${longCaptureResult.filteredBlackSequences.length}å€‹, ` +
            `ç´…æ–¹æ‰å­æ¯”ä¾‹: ${(longCaptureResult.redCaptureRatio * 100).toFixed(0)}%, ` +
            `é»‘æ–¹æ‰å­æ¯”ä¾‹: ${(longCaptureResult.blackCaptureRatio * 100).toFixed(0)}%`;
        createGameNotification('draw', message, details, 'mutual_long_capture');
        console.log('ğŸ¤ é¡¯ç¤ºé›™æ–¹äº’ç›¸é•·æ‰å’Œæ£‹æ¶ˆæ¯');
    }

    // æ–°å¢ï¼šå°ˆé–€çš„é›™æ–¹äº’ç›¸é•·æ‰è­¦å‘Šå‡½æ•¸
    function showMutualLongCaptureWarning(longCaptureResult) {
        const message = 'è­¦å‘Šï¼šæª¢æ¸¬åˆ°é›™æ–¹äº’ç›¸é•·æ‰ï¼å†ç¹¼çºŒå¾ªç’°å°‡åˆ¤å®šç‚ºå’Œæ£‹';
        const details = `ç´…æ–¹é•·æ‰åºåˆ—: ${longCaptureResult.filteredRedSequences.length}å€‹, ` +
            `é»‘æ–¹é•·æ‰åºåˆ—: ${longCaptureResult.filteredBlackSequences.length}å€‹, ` +
            `ç´…æ–¹æ‰å­æ¯”ä¾‹: ${(longCaptureResult.redCaptureRatio * 100).toFixed(0)}%, ` +
            `é»‘æ–¹æ‰å­æ¯”ä¾‹: ${(longCaptureResult.blackCaptureRatio * 100).toFixed(0)}%, ` +
            `å¾ªç’°æ¬¡æ•¸: ${longCaptureResult.internalCycleCount || 1}`;
        createGameNotification('warning', message, details, 'mutual_long_capture_warning');
        console.log('âš ï¸ é¡¯ç¤ºé›™æ–¹äº’ç›¸é•·æ‰è­¦å‘Šæ¶ˆæ¯');
    }

    // ğŸ”§ ä¿®æ­£ï¼šé•·æ‰åˆ¤è² é¡¯ç¤ºå‡½æ•¸
    function showLongCaptureLoss(longCaptureResult) {
        console.log('ğŸ” é¡¯ç¤ºé•·æ‰åˆ¤è² ï¼Œçµæœ:', longCaptureResult);

        // ğŸ”§ ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„ç©å®¶è³‡è¨Š
        const longCapturePlayer = longCaptureResult.longCapturePlayer;
        const playerName = longCapturePlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';

        // ğŸ”§ ä½¿ç”¨å¾ªç’°è¨ˆæ•¸
        const cycleCount = longCaptureResult.internalCycleCount || longCaptureResult.cycleCount || 0;

        const message = `éŠæˆ²çµæŸï¼${playerName}å› é•·æ‰åˆ¤è² ï¼ˆå¾ªç’°${cycleCount}æ¬¡ï¼‰`;

        console.log(`ğŸ“¢ é•·æ‰åˆ¤è² è¨Šæ¯: ${message}`);
        createGameNotification('loss', message, longCaptureResult.patternDisplay, 'long_capture');
    }

    // é¡¯ç¤ºåˆ¤å’Œè¨Šæ¯
    function showDrawMessage(cycleResult) {
        const message = `éŠæˆ²çµæŸï¼æ ¹æ“šè±¡æ£‹è¦å‰‡ï¼Œå¾ªç’°${cycleResult.cycleCount}æ¬¡åˆ¤å®šå’Œæ£‹`;
        createGameNotification('draw', message, cycleResult.patternDisplay, 'cycle');
    }

    // ã€é¡å¤–ã€‘é¡¯ç¤ºé›™æ–¹ç„¡å¯éæ²³æ£‹å­å’Œæ£‹è¨Šæ¯çš„å‡½æ•¸ï¼ˆæ”¾åœ¨é¡åˆ¥å¤–é¢ï¼‰
    function showInsufficientMaterialDrawMessage(materialResult) {
        console.log('\nğŸ³ï¸ é¡¯ç¤ºé›™æ–¹ç„¡å¯éæ²³æ£‹å­å’Œæ£‹è¨Šæ¯...');

        // æ§‹å»ºè©³ç´°è¨Šæ¯
        const redPieces = materialResult.boardState.red.pieceList || 'ç„¡';
        const blackPieces = materialResult.boardState.black.pieceList || 'ç„¡';
        const totalPieces = materialResult.boardState.totalPieces || 0;

        const message = `éŠæˆ²çµæŸï¼æ ¹æ“šè±¡æ£‹è¦å‰‡ï¼Œé›™æ–¹å‡ç„¡å¯éæ²³å­åŠ›ï¼Œåˆ¤å®šå’Œæ£‹`;

        const detailMessage = [
            `æª¢æ¸¬çµæœï¼š${materialResult.drawReason}`,
            `æ£‹ç›¤ç‹€æ³ï¼šå…± ${totalPieces} å€‹æ£‹å­`,
            `ç´…æ–¹å‰©é¤˜ï¼š${redPieces}`,
            `é»‘æ–¹å‰©é¤˜ï¼š${blackPieces}`,
            `è¦å‰‡ä¾æ“šï¼š${materialResult.ruleReference.explanation}`
        ].join('\n');

        // èª¿ç”¨é€šçŸ¥ç³»çµ±
        if (typeof createGameNotification === 'function') {
            createGameNotification('draw', message, detailMessage, 'insufficient-material');
        } else {
            // å¦‚æœæ²’æœ‰é€šçŸ¥ç³»çµ±ï¼Œç›´æ¥è¼¸å‡º
            console.log('ğŸ³ï¸ å’Œæ£‹é€šçŸ¥:');
            console.log('è¨Šæ¯:', message);
            console.log('è©³æƒ…:', detailMessage);
        }

        console.log('âœ… é›™æ–¹ç„¡å¯éæ²³æ£‹å­å’Œæ£‹è¨Šæ¯å·²é¡¯ç¤º');
        return true;
    }
    // ğŸ”§ å›°æ–ƒé¡¯ç¤ºå‡½æ•¸
    function showStalemateMessage(stalematedPlayer) {
        console.log('ğŸ” é¡¯ç¤ºå›°æ–ƒè¨Šæ¯ï¼Œè¢«å›°æ–ƒæ–¹:', stalematedPlayer);

        const playerName = stalematedPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
        const winnerName = stalematedPlayer === 'red' ? 'é»‘æ–¹' : 'ç´…æ–¹';

        const message = `${playerName}è¢«å›°æ–ƒï¼${winnerName}ç²å‹ï¼`;

        console.log(`ğŸ“¢ å›°æ–ƒè¨Šæ¯: ${message}`);
        createGameNotification('victory', message, null, 'stalemate');
    }

    // ğŸ”§ 50æ­¥æœªåƒå­åˆ¤å’Œé¡¯ç¤ºå‡½æ•¸
    function showFiftyMoveDrawMessage(moveCount) {
        console.log('ğŸ” é¡¯ç¤º50æ­¥æœªåƒå­å’Œæ£‹è¨Šæ¯ï¼Œæ­¥æ•¸:', moveCount);

        const message = `å·²é€£çºŒ${moveCount}æ­¥æœªåƒå­ï¼Œä¾è¦å‰‡åˆ¤å®šå’Œæ£‹ï¼`;

        console.log(`ğŸ“¢ 50æ­¥å’Œæ£‹è¨Šæ¯: ${message}`);
        createGameNotification('draw', message, null, 'fifty_moves');
    }

    // ğŸ”§ æ²’æœ‰åˆæ³•æ‡‰å°‡èµ°æ³•çš„é¡¯ç¤ºå‡½æ•¸
    function showNoValidCheckResponseMessage(checkedPlayer) {
        console.log('ğŸ” é¡¯ç¤ºæ²’æœ‰åˆæ³•æ‡‰å°‡èµ°æ³•è¨Šæ¯ï¼Œè¢«å°‡è»æ–¹:', checkedPlayer);

        const playerName = checkedPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
        const message = `${playerName}æ­£è¢«å°‡è»ï¼Œä½†æ²’æœ‰åˆæ³•çš„æ‡‰å°‡èµ°æ³•ï¼è«‹æª¢æŸ¥æ£‹å±€ã€‚`;

        console.log(`ğŸ“¢ ç„¡æ‡‰å°‡èµ°æ³•è¨Šæ¯: ${message}`);
        createGameNotification('error', message, null, 'no_valid_check_response');
    }

    // ğŸ”§ å°‡æ­»é¡¯ç¤ºå‡½æ•¸
    function showCheckmateMessage(checkmatedPlayer) {
        console.log('ğŸ” é¡¯ç¤ºå°‡æ­»è¨Šæ¯ï¼Œè¢«å°‡æ­»æ–¹:', checkmatedPlayer);

        const playerName = checkmatedPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
        const winnerName = checkmatedPlayer === 'red' ? 'é»‘æ–¹' : 'ç´…æ–¹';

        const message = `${playerName}è¢«å°‡æ­»ï¼${winnerName}ç²å‹ï¼`;

        console.log(`ğŸ“¢ å°‡æ­»è¨Šæ¯: ${message}`);
        createGameNotification('victory', message, null, 'checkmate');
    }

    function showNoValidMovesUnderCheckMessage(checkedPlayer) {
        console.log('ğŸ” é¡¯ç¤ºé¸æ“‡æ£‹å­æ™‚æ²’æœ‰æ‡‰å°‡èµ°æ³•è¨Šæ¯ï¼Œè¢«å°‡è»æ–¹:', checkedPlayer);

        const playerName = checkedPlayer === 'red' ? 'ç´…æ–¹' : 'é»‘æ–¹';
        const message = `${playerName}è¢«å°‡è»ï¼æ­¤æ£‹å­æ²’æœ‰åˆæ³•çš„æ‡‰å°‡èµ°æ³•ï¼`;

        console.log(`ğŸ“¢ é¸æ“‡æ£‹å­ç„¡æ‡‰å°‡èµ°æ³•è¨Šæ¯: ${message}`);
        createGameNotification('warning', message, null, 'no_valid_moves_under_check');
    }

    // ğŸ”§ 50æ­¥æœªåƒå­è­¦å‘Šæé†’å‡½æ•¸ï¼ˆ35å›åˆæ™‚ä½¿ç”¨ï¼‰
    function showFiftyMoveWarning(moveCount) {
        console.log('ğŸ” é¡¯ç¤º50æ­¥æœªåƒå­è­¦å‘Šï¼Œç•¶å‰æ­¥æ•¸:', moveCount);

        const remainingMoves = 100 - moveCount;
        const message = `å·²é€£çºŒ${moveCount}æ­¥æœªåƒå­ï¼Œé‚„æœ‰${remainingMoves}æ­¥å°‡è‡ªå‹•åˆ¤å’Œï¼`;

        console.log(`ğŸ“¢ 50æ­¥è­¦å‘Šè¨Šæ¯: ${message}`);
        createGameNotification('warning', message, null, 'fifty_moves_warning');
    }
    // é¡¯ç¤ºéŠæˆ²è¨Šæ¯ï¼ˆé€šç”¨ï¼‰
    function showGameMessage(message, type, detectionType = 'general') {
        createGameNotification(type === 'error' ? 'loss' : type, message, '', detectionType);
    }

    // é—œé–‰éŠæˆ²é€šçŸ¥ï¼ˆæ›´åä»¥ä¿æŒä¸€è‡´æ€§ï¼‰
    function closeGameNotification() {
        const notification = document.getElementById('game-notification');
        if (notification) {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }
    }

    // å‘å¾Œå…¼å®¹çš„åˆ¥å
    function closeCycleNotification() {
        closeGameNotification();
    }

    // å»ºç«‹ AI è­¦å‘Šå°è©±æ¡†
    function showAIWarningDialog(message, details) {
        // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨å°è©±æ¡†
        if (document.getElementById('ai-warning-dialog')) {
            return;
        }

        // å»ºç«‹å°è©±æ¡†å®¹å™¨
        const dialog = document.createElement('div');
        dialog.id = 'ai-warning-dialog';
        dialog.className = 'ai-warning-dialog';

        dialog.innerHTML = `
        <div class="ai-warning-overlay"></div>
        <div class="ai-warning-content">
            <div class="ai-warning-header">
                <span class="ai-warning-icon">âš ï¸</span>
                <h3>AI åˆå§‹åŒ–å¤±æ•—</h3>
            </div>
            <div class="ai-warning-body">
                <p class="ai-warning-message">${message}</p>
                ${details ? `<p class="ai-warning-details">${details}</p>` : ''}
            </div>
            <div class="ai-warning-footer">
                <button class="ai-warning-btn ai-warning-btn-primary" onclick="closeAIWarning()">
                    æˆ‘çŸ¥é“äº†
                </button>
                <button class="ai-warning-btn ai-warning-btn-secondary" onclick="location.reload()">
                    é‡æ–°é–‹å•ŸéŠæˆ²
                </button>
            </div>
            <div class="ai-warning-timer">
                <span id="ai-warning-countdown">30</span> ç§’å¾Œè‡ªå‹•é—œé–‰
            </div>
        </div>
    `;

        document.body.appendChild(dialog);

        // æ·»åŠ  CSS æ¨£å¼
        if (!document.getElementById('ai-warning-styles')) {
            const styles = document.createElement('style');
            styles.id = 'ai-warning-styles';
            styles.textContent = `
            .ai-warning-dialog {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .ai-warning-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(4px);
            }

            .ai-warning-content {
                position: relative;
                background: white;
                border-radius: 12px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                max-width: 480px;
                width: 90%;
                padding: 24px;
                animation: slideIn 0.3s ease-out;
            }

            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateY(-20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .ai-warning-header {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 20px;
            }

            .ai-warning-icon {
                font-size: 32px;
            }

            .ai-warning-header h3 {
                margin: 0;
                font-size: 20px;
                color: #d97706;
            }

            .ai-warning-body {
                margin-bottom: 24px;
            }

            .ai-warning-message {
                font-size: 16px;
                color: #374151;
                line-height: 1.6;
                margin: 0 0 12px 0;
                white-space: pre-line;
            }

            .ai-warning-details {
                font-size: 14px;
                color: #6b7280;
                padding: 12px;
                background: #f3f4f6;
                border-radius: 6px;
                margin: 0;
            }

            .ai-warning-footer {
                display: flex;
                gap: 12px;
                margin-bottom: 16px;
            }

            .ai-warning-btn {
                flex: 1;
                padding: 12px 24px;
                border: none;
                border-radius: 8px;
                font-size: 15px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .ai-warning-btn-primary {
                background: #3b82f6;
                color: white;
            }

            .ai-warning-btn-primary:hover {
                background: #2563eb;
                transform: translateY(-1px);
            }

            .ai-warning-btn-secondary {
                background: #10b981;
                color: white;
            }

            .ai-warning-btn-secondary:hover {
                background: #059669;
                transform: translateY(-1px);
            }

            .ai-warning-timer {
                text-align: center;
                font-size: 13px;
                color: #6b7280;
            }

            #ai-warning-countdown {
                font-weight: 700;
                color: #d97706;
            }

            @keyframes slideOut {
                to {
                    opacity: 0;
                    transform: translateY(-20px);
                }
            }
        `;
            document.head.appendChild(styles);
        }

        // é–‹å§‹å€’æ•¸è¨ˆæ™‚
        startWarningCountdown();
    }

    // é—œé–‰è­¦å‘Šå°è©±æ¡†
    function closeAIWarning() {
        const dialog = document.getElementById('ai-warning-dialog');
        if (dialog) {
            dialog.style.animation = 'slideOut 0.3s ease-out';
            setTimeout(() => {
                dialog.remove();
            }, 300);
        }

        // æ¸…é™¤å€’æ•¸è¨ˆæ™‚
        if (window.aiWarningTimer) {
            clearInterval(window.aiWarningTimer);
            window.aiWarningTimer = null;
        }
    }

    // å€’æ•¸è¨ˆæ™‚åŠŸèƒ½
    function startWarningCountdown() {
        let countdown = 30;
        const countdownEl = document.getElementById('ai-warning-countdown');

        window.aiWarningTimer = setInterval(() => {
            countdown--;
            if (countdownEl) {
                countdownEl.textContent = countdown;
            }

            if (countdown <= 0) {
                clearInterval(window.aiWarningTimer);
                closeAIWarning();
            }
        }, 1000);
    }

    // æ›´æ–°æ£‹è­œé¡¯ç¤º
    function updateMoveDisplay(cycleResult = null) {
        const moveList = document.getElementById('move-list');
        if (!moveList) return;

        moveList.innerHTML = '';

        gameState.gameRecord.forEach((move, index) => {
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';

            // æ¨™è¨˜å¾ªç’°éƒ¨åˆ†
            if (cycleResult && isInCycle(index, cycleResult)) {
                if (cycleResult.type === 'draw' || cycleResult.type === 'loss') {
                    moveItem.classList.add('cycle-highlight');
                } else if (cycleResult.type === 'warning' || cycleResult.type === 'perpetual_warning') {
                    moveItem.classList.add('cycle-warning');
                }
            }

            const moveNumber = document.createElement('span');
            moveNumber.className = 'move-number';
            moveNumber.textContent = `${index + 1}.`;
            moveItem.appendChild(moveNumber);

            if (move.red) {
                const redMove = document.createElement('span');
                redMove.className = 'red-move';
                redMove.textContent = move.red;
                moveItem.appendChild(redMove);
                moveItem.appendChild(document.createTextNode(' '));
            }

            if (move.black) {
                const blackMove = document.createElement('span');
                blackMove.className = 'black-move';
                blackMove.textContent = move.black;
                moveItem.appendChild(blackMove);
            }

            moveList.appendChild(moveItem);
        });

        // æ»¾å‹•åˆ°åº•éƒ¨
        moveList.scrollTop = moveList.scrollHeight;
    }
    // ä¿®æ­£ç‰ˆæœ¬çš„è±¡æ£‹å›é¥‹ç³»çµ±



    // Google è¡¨å–®é€£çµ
    const GOOGLE_FORM_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSfkDBDErVFK1tkGesY6ZiNG7_-MknwwyiHtONGrqoYlNrbKyA/viewform?usp=header';

    // ä¸»è¦å›é¦ˆå‡½æ•°
    function showFeedbackDialog() {
        // åˆ›å»ºå›é¦ˆå¯¹è¯æ¡†
        const dialog = document.createElement('div');
        dialog.id = 'feedback-dialog';
        dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Microsoft JhengHei', sans-serif;
    `;

        const dialogContent = document.createElement('div');
        dialogContent.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        text-align: center;
    `;

        dialogContent.innerHTML = `
        <h3 style="margin-bottom: 20px; color: #333;">ğŸ› å•é¡Œå›å ±</h3>

        <div style="margin-bottom: 25px; font-size: 16px; line-height: 1.6; color: #555;">
            <p>è«‹é»æ“Šä¸‹æ–¹æŒ‰éˆ•å‰å¾€å•é¡Œå›å ±è¡¨å–®</p>
        </div>

        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
            <div style="font-size: 14px; color: #666; margin-bottom: 15px;">
                ğŸ“Œ <strong>ä½¿ç”¨èªªæ˜ï¼š</strong>
            </div>
            <ul style="text-align: left; color: #666; font-size: 14px; line-height: 1.8; margin: 0; padding-left: 20px;">
                <li>ç›´æ¥å¡«å¯«å³å¯ï¼Œå®Œå…¨å…è²»</li>
                <li>å¯ä»¥ä¸Šå‚³æˆªåœ–ã€ç›¸ç‰‡æˆ–å½±ç‰‡èªªæ˜å•é¡Œ</li>
                <li>é€™æ˜¯ Google å®˜æ–¹æœå‹™ï¼Œå®‰å…¨å¯é </li>
            </ul>
        </div>

        <div style="margin-bottom: 20px;">
            <button onclick="openGoogleForm()" style="
                background: #4285f4;
                color: white;
                padding: 15px 30px;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 2px 10px rgba(66, 133, 244, 0.3);
                transition: all 0.3s ease;
            "
            onmouseover="this.style.background='#3367d6'; this.style.transform='translateY(-2px)'"
            onmouseout="this.style.background='#4285f4'; this.style.transform='translateY(0)'">
                ğŸ“‹ é»æˆ‘å¡«å¯«å•é¡Œå›å ±è¡¨å–®
            </button>
        </div>

        <div style="text-align: center;">
            <button onclick="closeFeedbackDialog()" style="
                background: #6c757d;
                color: white;
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
            ">é—œé–‰</button>
        </div>
    `;

        dialog.appendChild(dialogContent);
        document.body.appendChild(dialog);

        // é»æ“ŠèƒŒæ™¯é—œé–‰å°è©±æ¡†
        dialog.addEventListener('click', function(e) {
            if (e.target === dialog) {
                closeFeedbackDialog();
            }
        });

        return dialog;
    }

    // é–‹å•Ÿ Google è¡¨å–®
    function openGoogleForm() {
        window.open(GOOGLE_FORM_URL, '_blank');
        // é–‹å•Ÿè¡¨å–®å¾Œé—œé–‰å°è©±æ¡†
        closeFeedbackDialog();
    }

    // é—œé–‰å›é¦ˆå°è©±æ¡†
    function closeFeedbackDialog() {
        const dialog = document.getElementById('feedback-dialog');
        if (dialog) {
            dialog.remove();
        }
    }

    // å‰µå»ºå›é¥‹æŒ‰éˆ•
    function addFeedbackButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const feedbackButton = document.createElement('button');
        feedbackButton.textContent = 'å•é¡Œå›å ±';

        if (regretButton) {
            feedbackButton.className = regretButton.className;
            feedbackButton.style.cssText = regretButton.style.cssText;
        } else {
            feedbackButton.style.cssText = `
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        `;
        }

        let feedbackInstance = null;

        feedbackButton.addEventListener('click', function() {
            if (!feedbackInstance) {
                feedbackInstance = showFeedbackDialog();
                feedbackButton.textContent = 'é—œé–‰å›å ±';
                feedbackButton.style.backgroundColor = '#dc3545';

                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node && node.id === 'feedback-dialog') {
                                    feedbackInstance = null;
                                    feedbackButton.textContent = 'å•é¡Œå›å ±';
                                    feedbackButton.style.backgroundColor = '#28a745';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                closeFeedbackDialog();
            }
        });

        buttonContainer.appendChild(feedbackButton);

        return {
            button: feedbackButton,
            getCurrentInstance: () => feedbackInstance
        };
    }

    // åˆå§‹åŒ–å›é¥‹ç³»çµ±
    function initFeedbackSystem() {
        return addFeedbackButton();
    }

    // åŸ·è¡Œåˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initFeedbackSystem);
    } else {
        initFeedbackSystem();
    }

    // éŠæˆ²èªªæ˜å°è©±æ¡†
    function showGameInstructionsDialog() {
        // å‰µå»ºå°è©±æ¡†
        const dialog = document.createElement('div');
        dialog.id = 'game-instructions-dialog';
        dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Microsoft JhengHei', sans-serif;
    `;

        const dialogContent = document.createElement('div');
        dialogContent.style.cssText = `
        background: white;
        padding: 40px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
    `;

        dialogContent.innerHTML = `
        <h2 style="text-align: center; color: #333; margin-bottom: 30px; border-bottom: 3px solid #4285f4; padding-bottom: 15px;">
            â™Ÿï¸ æ£‹å¼ˆæ±Ÿæ¹– - éŠæˆ²èªªæ˜èˆ‡åŠŸèƒ½ä»‹ç´¹
        </h2>

        <h3 style="color: #4285f4; margin-top: 25px;">ğŸ“– é—œæ–¼æœ¬éŠæˆ²</h3>
        <p style="line-height: 1.8; color: #555;">
            ã€Œæ£‹å¼ˆæ±Ÿæ¹–ã€æ˜¯ä¸€æ¬¾å°ˆæ¥­çš„è±¡æ£‹å°æˆ°å¹³å°ï¼Œæä¾›é›™äººå°æˆ°ã€AIæŒ‘æˆ°ã€æ£‹è­œåˆ†æç­‰è±å¯ŒåŠŸèƒ½ï¼Œè®“æ‚¨ç›¡äº«è±¡æ£‹æ¨‚è¶£ã€‚
            ç„¡è«–æ‚¨æ˜¯åˆå­¸è€…é‚„æ˜¯å°ˆæ¥­æ£‹æ‰‹ï¼Œéƒ½èƒ½åœ¨æ­¤å¹³å°ç²å¾—å°æ‡‰çš„é«”é©—ã€‚
        </p>

        <h3 style="color: #4285f4; margin-top: 25px;">ğŸ“œ æ£‹è¦èªªæ˜</h3>
        <p style="line-height: 1.8; color: #555;">
            æœ¬éŠæˆ²æ¡ç”¨ã€Šä¸­è¯æ°‘åœ‹è±¡æ£‹è¦å‰‡-113å¹´ä¿®è¨‚ç‰ˆã€‹ä½œç‚ºåˆ¤å®šæ¨™æº–ã€‚è©³ç´°è¦å‰‡è«‹åƒè€ƒï¼š<br>
            <a href="https://www.cccs.org.tw/Message/MessageView?itemid=3234&mid=1&GroupName=%E5%8D%94%E6%9C%83%E5%85%AC%E5%91%8A"
               target="_blank" style="color: #4285f4; text-decoration: none;">
                ä¸­è¯æ°‘åœ‹è±¡æ£‹æ–‡åŒ–å”æœƒå®˜æ–¹è¦å‰‡
            </a>
        </p>
        <p style="line-height: 1.8; color: #d32f2f; font-weight: bold;">
            âš ï¸ æ³¨æ„äº‹é …ï¼šæœ¬å¹³å°å·²ç›¡åŠ›åˆ¤å®šæ‰€æœ‰é•è¦å±€é¢ï¼Œè‹¥é‡ç„¡æ³•è‡ªå‹•åˆ¤å®šæˆ–åˆ¤å®šéŒ¯èª¤çš„æƒ…æ³ï¼Œè«‹æ£‹æ‰‹ä¾ç…§å®˜æ–¹è¦å‰‡è‡ªè¡Œè£å®šå‹è² ã€‚
        </p>

        <h3 style="color: #4285f4; margin-top: 25px;">ğŸ® åŸºæœ¬æ“ä½œ</h3>

        <h4 style="color: #333; margin-top: 15px;">å¦‚ä½•ä¸‹æ£‹</h4>
        <ol style="line-height: 1.8; color: #555;">
            <li>é»æ“Šæ‚¨æƒ³ç§»å‹•çš„æ£‹å­</li>
            <li>ç³»çµ±æœƒé«˜äº®é¡¯ç¤ºæ‰€æœ‰å¯ç§»å‹•ä½ç½®ï¼ˆåŒ…å«å¯åƒå­ä½ç½®ï¼‰</li>
            <li>é¸æ“‡ç›®æ¨™ä½ç½®å®Œæˆç§»å‹•</li>
            <li>è‹¥é¸éŒ¯æ£‹å­ï¼Œç›´æ¥é»æ“Šå…¶ä»–æ£‹å­é‡æ–°é¸æ“‡å³å¯</li>
        </ol>

        <h4 style="color: #333; margin-top: 15px;">è‡ªå‹•åˆ¤å®š</h4>
        <p style="line-height: 1.8; color: #555;">ç³»çµ±æœƒè‡ªå‹•è­˜åˆ¥ä»¥ä¸‹å±€é¢ï¼š</p>
        <ul style="line-height: 1.8; color: #555;">
            <li><strong>å°‡æ®º</strong>ï¼šéŠæˆ²çµæŸï¼Œè¢«å°‡æ®ºæ–¹æ•—åŒ—</li>
            <li><strong>å›°æ–ƒ</strong>ï¼šéŠæˆ²çµæŸï¼Œè¢«å›°æ–ƒæ–¹æ•—åŒ—</li>
            <li><strong>ç„¡éæ²³å­</strong>ï¼šè‡ªå‹•åˆ¤å®šç‚ºå’Œæ£‹</li>
            <li><strong>å¾ªç’°åˆ¤å’Œ</strong>ï¼šç³»çµ±åµæ¸¬åˆ°å±€é¢é‡è¤‡æ™‚è‡ªå‹•åˆ¤å’Œ</li>
            <li><strong>é•·æ‰/é•·å°‡åˆ¤å®š</strong>ï¼šç³»çµ±æœƒç›¡åŠ›åˆ¤æ–·æ˜¯å¦ç¬¦åˆè¦å‰‡ï¼Œè‹¥é‡è¤‡é›œå±€é¢ç„¡æ³•æº–ç¢ºåˆ¤å®šæ™‚ï¼Œå»ºè­°æ£‹æ‰‹åƒè€ƒå®˜æ–¹è¦å‰‡å”å•†è™•ç†</li>
        </ul>

        <hr style="margin: 30px 0; border: none; border-top: 2px solid #e0e0e0;">

        <h3 style="color: #4285f4; margin-top: 25px;">âš™ï¸ åŠŸèƒ½ä»‹ç´¹</h3>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ”„ æ‚”æ£‹åŠŸèƒ½</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                ä¸€éµé€€å›ä¸Šä¸€æ­¥æ£‹ï¼Œé‡æ–°æ€è€ƒèµ°æ³•ï¼Œé©åˆç·´ç¿’å’Œå­¸ç¿’ä½¿ç”¨ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ’¾ å„²å­˜å±€é¢</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                å°‡ç²¾å½©æˆ–å…·ç´€å¿µæ„ç¾©çš„å±€é¢ä¿å­˜è‡³è£ç½®ä¸­ï¼Œå¯åœ¨ä¸‹æ¬¡éŠæˆ²æ™‚é‡æ–°è¼‰å…¥ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ“‚ è¼‰å…¥å±€é¢</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                å¿«é€Ÿè¼‰å…¥ä¹‹å‰ä¿å­˜çš„æ£‹å±€ï¼Œç¹¼çºŒæœªå®Œæˆçš„å°å±€æˆ–é‡æº«ç¶“å…¸å±€é¢ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ†• é‡æ–°é–‹å§‹</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                ç„¡è«–åœ¨å°å±€ä¸­æˆ–éŠæˆ²çµæŸå¾Œï¼Œéƒ½å¯éš¨æ™‚é–‹å•Ÿå…¨æ–°ä¸€å±€ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">âš™ï¸ è‡ªè¨‚æ£‹ç›¤</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                å‰µå»ºä»»æ„åˆç†çš„æ£‹å±€ä½ˆç½®ï¼Œç”¨æ–¼ç‰¹å®šå±€é¢ç·´ç¿’æˆ–æ•™å­¸æ¼”ç¤ºã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #fff3cd; border-radius: 8px; border: 2px solid #ffc107;">
            <h4 style="color: #333; margin-top: 0;">ğŸ§  è¦†ç›¤åˆ†æ</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <em>æ™ºèƒ½æ£‹è­œåˆ†æåŠŸèƒ½</em>
            </p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <li>å°å±€çµæŸå¾Œç«‹å³åˆ†æå‰›ä¸‹å®Œçš„æ£‹è­œ</li>
                <li>æ”¯æ´æ£‹è­œæ–‡æœ¬å°å…¥ï¼Œè‡ªå‹•æ•´ç†æ ¼å¼å¾Œé€²è¡Œåˆ†æ</li>
                <li>AIæ·±åº¦åˆ†ææ¯ä¸€æ­¥æ£‹çš„å„ªåŠ£ï¼ŒæŒ‡å‡ºæ¼æ‹›å’Œæ”¹é€²å»ºè­°</li>
            </ul>
            <p style="line-height: 1.8; color: #d32f2f; font-weight: bold; margin-bottom: 5px;">
                âš ï¸ é‡è¦æé†’ï¼š
            </p>
            <ul style="line-height: 1.8; color: #d32f2f; margin-bottom: 0;">
                <li>è¦†ç›¤åˆ†æçµæœå¯èƒ½æœ‰èª¤ï¼Œè‹¥å‡ºç¾åŠ‡çƒˆæ³¢å‹•æ™‚æœ‰å¯èƒ½æ˜¯å¼•æ“å•é¡Œï¼Œé‚„ç…©è«‹å„ä½ç©å®¶è¦‹è«’</li>
                <li>AIåˆ†æéœ€è¦è¼ƒé•·æ™‚é–“ï¼Œæ‚¨å¯ä»¥åˆ‡æ›åˆ°å…¶ä»–åˆ†é è™•ç†å…¶ä»–äº‹å‹™ï¼Œä¸éœ€ç­‰å¾…</li>
                <li>AIåˆ†æä¸¦ä¸æ˜¯çµ•å°ï¼Œæœ‰å¯èƒ½å­˜åœ¨æ¯”AIè§£æ³•æ›´ä½³çš„èµ°æ³•ï¼Œaiæ¨è–¦ä¹‹èµ°æ³•åƒ…ä¾›åƒè€ƒ</li>
            </ul>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">â±ï¸ æ£‹é˜åŠŸèƒ½</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <em>å°ˆæ¥­è³½äº‹ç´šæ£‹é˜</em>
            </p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 0;">
                <li>å®Œå…¨ä»¿çœŸæ­£å¼æ¯”è³½æ£‹é˜</li>
                <li>é›™æ–¹æ“æœ‰ç›¸åŒæ™‚é–“é…ç½®å’ŒåŠ ç§’è¦å‰‡</li>
                <li>éœ€æ£‹æ‰‹ä¸»å‹•æŒ‰é˜ï¼Œæ™‚é–“è€—ç›¡è‡ªå‹•åˆ¤è² </li>
                <li>çœŸå¯¦é‚„åŸè³½å ´é«”é©—</li>
            </ul>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ¤– AIå°æˆ°</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                æŒ‘æˆ°ä¸åŒé›£åº¦ç­‰ç´šçš„AIï¼Œç›´æ¥èˆ‡é›»è…¦å°å¼ˆï¼Œå¾å…¥é–€åˆ°é«˜æ‰‹ï¼Œå¾ªåºæ¼¸é€²æå‡æ£‹è—ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ“Š AIåˆ†æ</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                å¦‚åŒå°ˆæ¥­æ•™ç·´èˆ¬å”åŠ©æ‚¨åˆ†æå±€é¢ï¼Œå³æ™‚æä¾›ç•¶å‰æœ€ä½³èµ°æ³•å»ºè­°ï¼Œæ˜¯å­¸ç¿’å’Œæé«˜çš„çµ•ä½³å·¥å…·ã€‚
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">âš™ï¸ éŠæˆ²è¨­ç½®</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <em>å€‹æ€§åŒ–æ‚¨çš„éŠæˆ²é«”é©—</em>
            </p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <li><strong>ğŸ”Š éŸ³æ•ˆè¨­å®š</strong>ï¼šæ§åˆ¶è½å­èˆ‡åƒå­éŸ³æ•ˆé–‹é—œã€èª¿æ•´éŸ³é‡å¤§å°ï¼ˆæ¡ç”¨çœŸå¯¦æ£‹ç›¤è²éŸ³éŒ„è£½ï¼Œéåˆæˆé›»å­éŸ³æ•ˆï¼‰</li>
                <li><strong>ğŸ”„ æ£‹ç›¤è¦–è§’</strong>ï¼šåˆ‡æ›ç´…æ–¹/é»‘æ–¹è¦–è§’ï¼Œç¿»è½‰å¾Œé»‘æ–¹åœ¨ä¸‹</li>
                <li><strong>ğŸ¤– AIåˆ†ææ¨¡å¼</strong>ï¼šé¸æ“‡å–®ä¸€æœ€ä½³æ­¥ã€é›™æ–¹æœ€ä½³5æ­¥è§£ã€æœ€ä½³å‰2é¸æˆ–å‰3é¸</li>
                <li><strong>ğŸ¨ æ£‹ç›¤é¢¨æ ¼</strong>ï¼šæœ¨ç´‹ã€ç°¡ç´„ç´…ç™½ã€å’–å•¡è‰²ã€çŸ³ç´‹ã€ç°¡ç´„ç™½åº•ç­‰5ç¨®é¢¨æ ¼</li>
                <li><strong>â™Ÿï¸ æ£‹å­é¢¨æ ¼</strong>ï¼šæœ¨è³ªã€æ™®é€šç™½è‰²ã€å’–å•¡è‰²ã€å…‰æšˆã€ç°¡ç´„ç™½è‰²ç­‰5ç¨®é¢¨æ ¼ (è¨­å®šæ–°çš„æ£‹å­æ¨£å¼å¾Œéœ€é‡æ–°æ•´ç†æ‰æœƒå¥—ç”¨)</li>
            </ul>
            <p style="line-height: 1.8; color: #888; font-size: 13px; margin-bottom: 0;">
                ğŸ’¡ æç¤ºï¼šæ‰€æœ‰è¨­å®šæœƒè‡ªå‹•å„²å­˜ï¼Œä¸‹æ¬¡é–‹å•ŸéŠæˆ²æ™‚è‡ªå‹•å¥—ç”¨
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ“· æ‹ç…§è­˜åˆ¥</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                è©³æƒ…è«‹è¦‹å…§å»ºä¹‹éŠæˆ²èªªæ˜ï¼ˆä½æ–¼é»é–‹æ‹ç…§è­˜åˆ¥æŒ‰éˆ•å¾Œï¼‰
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ“š é–‹å±€æ®˜å±€åº«</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                è©³æƒ…è«‹è¦‹å…§å»ºä¹‹éŠæˆ²èªªæ˜ï¼ˆä½æ–¼é»é–‹é–‹å±€æ®˜å±€åº«æŒ‰éˆ•å¾Œï¼‰
            </p>
            <p style="line-height: 1.8; color: #555; margin-bottom: 5px;">
                <strong>é¡Œåº«ä¾†æºï¼š</strong>
            </p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <li>æ±Ÿæ¹–æ®˜å±€èˆ‡ç–‘é›£é›œç—‡é¡Œç›®å‡å–æè‡ª <a href="https://www.youtube.com/@CongKuanxiangqi" target="_blank" style="color: #4285f4; text-decoration: none;">ä»å¯¬è±¡æ£‹ YouTube é »é“</a></li>
                <li>å¦‚é‡åˆ°ä¸æœƒè§£çš„å±€é¢ï¼Œæ­¡è¿å¤šå¤šåˆ©ç”¨ AI åˆ†æåŠŸèƒ½è¼”åŠ©å­¸ç¿’</li>
                <li>æˆ–ç§»æ­¥è§€çœ‹ <a href="https://www.youtube.com/@CongKuanxiangqi" target="_blank" style="color: #4285f4; text-decoration: none;">ä»å¯¬è±¡æ£‹é »é“</a> çš„è©³ç´°è¬›è§£å½±ç‰‡</li>
            </ul>
            <p style="line-height: 1.8; color: #888; font-size: 13px; margin-bottom: 0;">
                ğŸ’¡ å­¸ç¿’å»ºè­°ï¼šå»ºè­°å…ˆè‡ªè¡Œæ€è€ƒå˜—è©¦è§£é¡Œï¼Œé‡åˆ°å›°é›£æ™‚å†ä½¿ç”¨ AI åˆ†ææˆ–è§€çœ‹è¬›è§£å½±ç‰‡
            </p>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #ffebee; border-radius: 8px; border: 2px solid #e57373;">
            <h4 style="color: #c62828; margin-top: 0;">âš ï¸ AIåŠŸèƒ½ä½¿ç”¨æé†’</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                è‹¥é‡åˆ°AIç„¡æ³•æ­£ç¢ºå•Ÿå‹•çš„æƒ…æ³ï¼š
            </p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                <li><strong>ç¬¬ä¸€æ­¥ï¼š</strong>ç›´æ¥é‡æ–°å•Ÿå‹•éŠæˆ²è»Ÿé«”ï¼ˆæŒ‰F5æˆ–é‡æ–°æ•´ç†æŒ‰éˆ•ï¼‰ï¼ŒåŸºæœ¬ä¸Šå°±èƒ½å¤ æ­£å¸¸ä½¿ç”¨</li>
                <li><strong>è‹¥ç¶“éå¹¾æ¬¡é‡è©¦å¾Œä»ç„¡æ³•æ­£å¸¸ä½¿ç”¨ï¼š</strong>è«‹é€éå•é¡Œå›å ±åŠŸèƒ½å¡«å¯«å›å ±è¡¨å–®ï¼Œæˆ‘å€‘æœƒç›¡å¿«è™•ç†</li>
            </ul>
        </div>

        <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="color: #333; margin-top: 0;">ğŸ› ï¸ å•é¡Œå›å ±</h4>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;">
                é‡åˆ°ä»»ä½•å•é¡Œæˆ–å»ºè­°ï¼Œæ­¡è¿é€éå•é¡Œå›å ±åŠŸèƒ½ï¼ˆGoogleè¡¨å–®ï¼‰å‘æˆ‘å€‘åé¥‹ï¼Œæˆ‘å€‘å°‡ç©æ¥µè™•ç†ä¸¦æŒçºŒæ”¹å–„éŠæˆ²é«”é©—ã€‚
            </p>
            <p style="line-height: 1.8; color: #555; margin-bottom: 0;">
                <strong>å›å ±é€£çµï¼š</strong>
                <a href="https://docs.google.com/forms/d/e/1FAIpQLSfkDBDErVFK1tkGesY6ZiNG7_-MknwwyiHtONGrqoYlNrbKyA/viewform"
                   target="_blank" style="color: #4285f4; text-decoration: none;">
                    é»æ­¤å¡«å¯«å•é¡Œå›å ±è¡¨å–®
                </a>
            </p>
        </div>

        <hr style="margin: 30px 0; border: none; border-top: 2px solid #e0e0e0;">

        <h3 style="color: #4285f4; margin-top: 25px;">ğŸ“º å­¸ç¿’è³‡æºèˆ‡æ¨è–¦ç¶²ç«™</h3>

        <div style="margin: 20px 0; padding: 20px; background: #e8f5e9; border-radius: 8px; border-left: 5px solid #4caf50;">
            <h4 style="color: #333; margin-top: 0;">YouTube é »é“æ¨è–¦</h4>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong style="color: #d32f2f;">ğŸ¯ <a href="https://www.youtube.com/channel/UCA9JBwe5_5GdH5IrehZPPYQ" target="_blank" style="color: #d32f2f; text-decoration: none;">æ£‹å¼ˆæ±Ÿæ¹–å®˜æ–¹é »é“</a></strong><br>
                    <span style="font-size: 13px;">â­ æœ¬éŠæˆ²çš„å®˜æ–¹é »é“ï¼å®Œæ•´çš„éŠæˆ²æ“ä½œèªªæ˜å½±ç‰‡ã€é–‹ç™¼è€… Vlogã€åŠŸèƒ½æ›´æ–°ä»‹ç´¹ã€‚å¦‚é‡æ“ä½œå•é¡Œï¼Œå¯è‡³é »é“è§€çœ‹è©³ç´°æ•™å­¸å½±ç‰‡</span>
                </p>
            </div>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸº <a href="https://www.youtube.com/@CongKuanxiangqi" target="_blank" style="color: #4285f4; text-decoration: none;">ä»å¯¬è±¡æ£‹</a></strong><br>
                    <span style="font-size: 13px;">å°ˆæ³¨æ–¼æ±Ÿæ¹–æ®˜å±€èˆ‡ç–‘é›£é›œç—‡çš„è¬›è§£ï¼Œé©åˆå–œæ­¡æŒ‘æˆ°é«˜é›£åº¦æ®˜å±€çš„æ£‹å‹</span>
                </p>
            </div>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ‘‘ <a href="https://www.youtube.com/@chess_prince" target="_blank" style="color: #4285f4; text-decoration: none;">è±¡æ£‹ç‹å­</a></strong><br>
                    <span style="font-size: 13px;">ä¸­åœ‹å„å¤§è³½äº‹çš„ç›´æ’­åŒæ­¥è½‰æ’­ï¼Œè®“ä½ é«”é©—å¤§å¸«ç´šå°æˆ°çš„ç¬¬ä¸€è¦–è§’</span>
                </p>
            </div>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ¦· <a href="https://www.youtube.com/@BanYaXiangQi" target="_blank" style="color: #4285f4; text-decoration: none;">æ¿ç‰™è±¡æ£‹</a></strong><br>
                    <span style="font-size: 13px;">å°ˆæ³¨æ–¼é–‹å±€èˆ‡ä¸­å±€çš„è¬›è§£ä»¥åŠæ£‹ç†å‰–æï¼Œéå¸¸é©åˆåˆå­¸è€…å­¸ç¿’é–‹å±€æŠ€å·§</span>
                </p>
            </div>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸµ <a href="https://www.youtube.com/@WuKongxiangqi" target="_blank" style="color: #4285f4; text-decoration: none;">æ‚Ÿç©ºè±¡æ£‹</a></strong> /
                    <strong>ğŸ· <a href="https://www.youtube.com/@ErHaLuckyBaBi" target="_blank" style="color: #4285f4; text-decoration: none;">æ‚Ÿèƒ½è±¡æ£‹</a></strong> /
                    <strong>ğŸº <a href="https://www.youtube.com/@xiangqi666" target="_blank" style="color: #4285f4; text-decoration: none;">è±¡æ£‹é…’é¤¨</a></strong><br>
                    <span style="font-size: 13px;">ä¸‰å€‹é »é“å‡å°ˆæ³¨æ–¼è¬›è§£å¯¦ç”¨æŠ€å·§å‹æ®˜å±€ï¼Œå¯ä»¥å¤§å¹…æå‡æ®˜å±€æŠ€å·§ï¼Œå¶çˆ¾ä¹Ÿæœƒè¬›è§£æ±Ÿæ¹–æ®˜å±€èˆ‡ç–‘é›£é›œç—‡</span>
                </p>
            </div>

            <div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ“ <a href="https://www.youtube.com/@SiLangjiangqi" target="_blank" style="color: #4285f4; text-decoration: none;">å››éƒè®²æ£‹</a></strong><br>
                    <span style="font-size: 13px;">å°ˆæ³¨æ–¼è¬›è§£å„å¤§å¸«é–“çš„å°å±€ï¼Œåˆ†ææ¯ä¸€æ­¥çš„å¾—å¤±ï¼Œæ‹†è§£å¤§å¸«ç´šæ‹›æ³•èƒŒå¾Œçš„å¥§ç§˜</span>
                </p>
            </div>

            <div style="margin-bottom: 0; padding: 12px; background: white; border-radius: 6px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ† <a href="https://www.youtube.com/@yinchuan" target="_blank" style="color: #4285f4; text-decoration: none;">è±¡æ£‹è¨±éŠ€å·ï¼ˆä¸–ç•Œå† è»ï¼‰</a></strong><br>
                    <span style="font-size: 13px;">ä¸–ç•Œå† è»è¨±éŠ€å·é‚Šå¯¦æˆ°é‚Šè¬›è§£è±¡æ£‹ï¼Œå¾é–‹å±€è¬›è§£è‡³æ®˜å±€ï¼Œå¤§å¸«è¦ªè‡ªæˆèª²</span>
                </p>
            </div>
        </div>

        <div style="margin: 20px 0; padding: 20px; background: #e3f2fd; border-radius: 8px; border-left: 5px solid #2196f3;">
            <h4 style="color: #333; margin-top: 0;">ç·šä¸Šå°å¼ˆå¹³å°</h4>

            <div style="margin-bottom: 12px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>â™Ÿï¸ <a href="https://www.xiangqi.com/" target="_blank" style="color: #2196f3; text-decoration: none;">ç›¸å¼ˆè±¡æ£‹</a></strong><br>
                    <span style="font-size: 13px;">åŠŸèƒ½å®Œå–„çš„ç·šä¸Šè±¡æ£‹å°æˆ°å¹³å°ï¼Œå…§å»ºå¤šç¨®å®Œæ•´åŠŸèƒ½ï¼Œè©³æƒ…è«‹è‡ªè¡Œç™»å…¥å¾ŒæŸ¥çœ‹</span>
                </p>
            </div>

            <div style="margin-bottom: 0;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ® <a href="https://www.playok.com/zh/xiangqi/" target="_blank" style="color: #2196f3; text-decoration: none;">PlayOK ä¸­åœ‹è±¡æ£‹</a></strong><br>
                    <span style="font-size: 13px;">åœ‹éš›çŸ¥åçš„ç·šä¸Šæ£‹é¡éŠæˆ²å¹³å°ï¼Œæä¾›ä¸­åœ‹è±¡æ£‹å°æˆ°æœå‹™ï¼Œè©³æƒ…è«‹è‡ªè¡Œç™»å…¥å¾ŒæŸ¥çœ‹</span>
                </p>
            </div>
        </div>

        <div style="margin: 20px 0; padding: 20px; background: #fff3e0; border-radius: 8px; border-left: 5px solid #ff9800;">
            <h4 style="color: #333; margin-top: 0;">æ£‹è­œè³‡æºç¶²ç«™</h4>

            <div style="margin-bottom: 12px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ“– <a href="https://www.xqipu.com/" target="_blank" style="color: #ff9800; text-decoration: none;">è±¡æ£‹è­œ</a></strong><br>
                    <span style="font-size: 13px;">æ”¶éŒ„çœ¾å¤šå¤§å¸«é–“çš„å®Œæ•´å°å±€æ£‹è­œï¼Œé©åˆç ”ç©¶èˆ‡å­¸ç¿’</span>
                </p>
            </div>

            <div style="margin-bottom: 12px;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸ“š <a href="https://www.xiangqiqipu.com/" target="_blank" style="color: #ff9800; text-decoration: none;">æ°¸æ¨‚è±¡æ£‹ç¶²</a></strong><br>
                    <span style="font-size: 13px;">åŒæ¨£æ”¶éŒ„å¤§é‡å¤§å¸«ç´šå®Œæ•´å°å±€æ£‹è­œï¼Œè³‡æºè±å¯Œ</span>
                </p>
            </div>

            <div style="margin-bottom: 0;">
                <p style="margin: 0; line-height: 1.8; color: #555;">
                    <strong>ğŸŒ <a href="http://www.dpxq.com/" target="_blank" style="color: #ff9800; text-decoration: none;">æ±èè±¡æ£‹ç¶²</a></strong><br>
                    <span style="font-size: 13px;">è€ç‰Œè±¡æ£‹ç¶²ç«™ï¼Œæ“æœ‰æµ·é‡å¤§å¸«å°å±€æ£‹è­œè³‡æº</span>
                </p>
            </div>
        </div>

        <hr style="margin: 30px 0; border: none; border-top: 2px solid #e0e0e0;">

        <h3 style="color: #4285f4; margin-top: 25px;">ğŸŸ AIå¼•æ“ä»‹ç´¹</h3>

        <div style="margin: 20px 0; padding: 20px; background: #e3f2fd; border-radius: 8px; border-left: 5px solid #2196f3;">
            <h4 style="color: #333; margin-top: 0;">çš®å¡é­š (Pikafish)</h4>
            <p style="line-height: 1.8; color: #555;">
                æœ¬éŠæˆ²æ¡ç”¨<strong>çš®å¡é­š</strong>ä½œç‚ºAIå¼•æ“ï¼Œé€™æ˜¯ä¸€æ¬¾åŸºæ–¼Stockfishæ”¹è‰¯çš„é–‹æºä¸­åœ‹è±¡æ£‹å¼•æ“ï¼Œæ“æœ‰å¼·å¤§çš„æ£‹åŠ›å’Œç²¾æº–çš„å±€é¢è©•ä¼°èƒ½åŠ›ã€‚
            </p>
            <p style="line-height: 1.8; color: #555; margin-bottom: 10px;"><strong>é—œæ–¼çš®å¡é­šï¼š</strong></p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 15px;">
                <li>é–‹æºå…è²»çš„è±¡æ£‹å¼•æ“</li>
                <li>æŒçºŒæ›´æ–°å„ªåŒ–ï¼Œæ£‹åŠ›ä¸æ–·æå‡</li>
                <li>æ”¯æ´å¤šç·šç¨‹ä¸¦è¡Œè¨ˆç®—ï¼Œåˆ†æé€Ÿåº¦å¿«</li>
                <li>å»£æ³›æ‡‰ç”¨æ–¼è±¡æ£‹æ•™å­¸èˆ‡åˆ†æ</li>
            </ul>
            <p style="line-height: 1.8; color: #555; margin-bottom: 5px;"><strong>ç›¸é—œé€£çµï¼š</strong></p>
            <ul style="line-height: 1.8; color: #555; margin-bottom: 0;">
                <li>
                    <a href="https://xiangqiai.com/#/" target="_blank" style="color: #2196f3; text-decoration: none;">
                        çš®å¡é­šè±¡æ£‹AIåœ¨ç·šåˆ†æå¹³å°
                    </a>
                </li>
                <li>
                    <a href="https://www.pikafish.com/" target="_blank" style="color: #2196f3; text-decoration: none;">
                        çš®å¡é­šå®˜ç¶²
                    </a>
                </li>
            </ul>
        </div>

        <hr style="margin: 30px 0; border: none; border-top: 2px solid #e0e0e0;">

    <h3 style="color: #4285f4; margin-top: 25px;">ğŸ’­ é–‹ç™¼è€…çš„è©±</h3>

    <div style="margin: 20px 0; padding: 20px; background: #fff8e1; border-radius: 8px; border-left: 5px solid #ffc107;">
        <p style="line-height: 1.8; color: #555; text-indent: 2em; margin-bottom: 15px;">
            å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ä¸€åç›®å‰å°±è®€é«˜äºŒçš„å­¸ç”Ÿã€‚é–‹ç™¼ã€Œæ£‹å¼ˆæ±Ÿæ¹–ã€é€™æ¬¾è±¡æ£‹å¹³å°çš„èµ·å› ï¼Œæºè‡ªæ–¼ä¸€é …å­¸æ ¡çš„åŠŸèª²ã€‚
            ç•¶æ™‚è€å¸«è¦æ±‚æˆ‘å€‘é‹ç”¨æ‰€å­¸çš„ç¨‹å¼è¨­è¨ˆçŸ¥è­˜ï¼Œå‰µä½œä¸€å€‹èƒ½å¤ è§£æ±ºå¯¦éš›å•é¡Œæˆ–æœå‹™å¤§çœ¾çš„å°ˆé¡Œé …ç›®ã€‚
        </p>

        <p style="line-height: 1.8; color: #555; text-indent: 2em; margin-bottom: 15px;">
            èº«ç‚ºä¸€åè±¡æ£‹æ„›å¥½è€…ï¼Œæˆ‘æ·±åˆ»é«”æœƒåˆ°å­¸ç¿’è±¡æ£‹çš„éç¨‹ä¸­ï¼Œå¸¸å¸¸ç¼ºä¹ä¸€å€‹åŠŸèƒ½å®Œå–„ä¸”æ˜“æ–¼ä½¿ç”¨çš„ç·šä¸Šå¹³å°ã€‚
            å¸‚é¢ä¸Šé›–ç„¶æœ‰è¨±å¤šè±¡æ£‹è»Ÿé«”ï¼Œä½†è¦ä¸æ˜¯åŠŸèƒ½éæ–¼è¤‡é›œé›£ä»¥ä¸Šæ‰‹ï¼Œå°±æ˜¯ç¼ºå°‘ç¾ä»£åŒ–çš„ä½¿ç”¨è€…ä»‹é¢ã€‚
            å› æ­¤ï¼Œæˆ‘æ±ºå®šçµåˆè‡ªå·±å°è±¡æ£‹çš„ç†±æ„›èˆ‡ç¨‹å¼è¨­è¨ˆçš„å°ˆé•·ï¼Œæ‰“é€ ä¸€å€‹æ—¢å°ˆæ¥­åˆè¦ªåˆ‡çš„è±¡æ£‹å°å¼ˆå¹³å°ã€‚
        </p>

        <p style="line-height: 1.8; color: #555; text-indent: 2em; margin-bottom: 15px;">
            æœ¬å°ˆæ¡ˆçš„æ ¸å¿ƒç›®çš„ï¼Œæ˜¯å¸Œæœ›èƒ½å¤ æå‡å„ä½ç†±æ„›è±¡æ£‹ä¹‹æ£‹å£«çš„æ£‹åŠ›ã€‚é€éAIåˆ†æã€è¦†ç›¤åŠŸèƒ½ã€ä»¥åŠå¤šæ¨£åŒ–çš„å°æˆ°æ¨¡å¼ï¼Œ
            è®“æ¯ä¸€ä½ä½¿ç”¨è€…éƒ½èƒ½åœ¨éŠæˆ²ä¸­ä¸æ–·é€²æ­¥ï¼Œå¾åŸºç¤å…¥é–€é€æ­¥é‚å‘é«˜æ‰‹å¢ƒç•Œã€‚æˆ‘è¡·å¿ƒæœŸç›¼ï¼Œé€éé€™å€‹å¹³å°çš„æ¨å»£èˆ‡ä½¿ç”¨ï¼Œ
            èƒ½å¤ åŸ¹é¤Šå‡ºæ›´å¤šå„ªç§€çš„è±¡æ£‹äººæ‰ï¼Œè®“å¤§å®¶éƒ½æœ‰æ©Ÿæœƒæˆç‚ºè±¡æ£‹å¤§å¸«ï¼Œç”šè‡³åœ¨æœªä¾†æ¦®ç™»åœ‹éš›èˆå°ï¼Œç‚ºå°ç£è±¡æ£‹ç•Œçˆ­å…‰ï¼
        </p>

        <p style="line-height: 1.8; color: #555; text-indent: 2em; margin-bottom: 0;">
            é€™å€‹å¹³å°ä»åœ¨æŒçºŒé–‹ç™¼èˆ‡å„ªåŒ–ä¸­ï¼Œè‹¥æ‚¨åœ¨ä½¿ç”¨éç¨‹ä¸­ç™¼ç¾ä»»ä½•å•é¡Œæˆ–æœ‰ä»»ä½•å»ºè­°ï¼Œæ­¡è¿éš¨æ™‚é€éå•é¡Œå›å ±åŠŸèƒ½å‘Šè¨´æˆ‘ã€‚
            æ‚¨çš„æ¯ä¸€å‰‡å›é¥‹ï¼Œéƒ½æ˜¯æ¨å‹•æˆ‘ç¹¼çºŒæ”¹é€²çš„æœ€å¤§å‹•åŠ›ã€‚æœ€å¾Œï¼Œæ„Ÿè¬æ‰€æœ‰æ”¯æŒã€Œæ£‹å¼ˆæ±Ÿæ¹–ã€çš„ç©å®¶å€‘ï¼Œè®“æˆ‘å€‘ä¸€èµ·åœ¨æ£‹ç›¤ä¸Š
            å‰µé€ æ›´å¤šç²¾å½©çš„å°å±€ï¼Œå…±åŒè¦‹è­‰å°ç£è±¡æ£‹çš„è“¬å‹ƒç™¼å±•ï¼
        </p>
    </div>

    <hr style="margin: 30px 0; border: none; border-top: 2px solid #e0e0e0;">

    <h3 style="color: #4285f4; margin-top: 25px; text-align: center;">âœ¨ çµèª</h3>
    <p style="line-height: 1.8; color: #555; text-align: center;">
        æ„Ÿè¬æ‚¨é¸æ“‡ã€Œæ£‹å¼ˆæ±Ÿæ¹–ã€ï¼å¸Œæœ›æœ¬éŠæˆ²èƒ½æˆç‚ºæ‚¨æå‡æ£‹è—çš„æœ€ä½³å¤¥ä¼´ã€‚<br>
        æœ¬éŠæˆ²ä»æŒçºŒæ›´æ–°ä¸­ï¼Œæ‚¨çš„æ”¯æŒèˆ‡å»ºè­°æ˜¯æˆ‘å€‘æœ€å¤§çš„å‹•åŠ›ï¼
    </p>
    <p style="line-height: 1.8; color: #4285f4; text-align: center; font-weight: bold; font-size: 18px; margin-top: 20px;">
        ç¥æ‚¨æ£‹è—ç²¾é€²ï¼ŒéŠæˆ²æ„‰å¿«ï¼ğŸ¯
    </p>

    <div style="text-align: center; margin-top: 40px; margin-bottom: 20px;">
    <p style="color: #888; font-size: 14px; margin-bottom: 15px;">âœï¸ å‰µä½œè€…ç°½å</p>
    <img src="signature/signature.png" alt="å‰µä½œè€…ç°½å" style="max-width: 250px; height: auto; opacity: 0.85; border-radius: 5px;">
</div>

    <div style="text-align: center; margin-top: 30px;">
        <button onclick="closeGameInstructionsDialog()" style="
            background: #4285f4;
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(66, 133, 244, 0.3);
            transition: all 0.3s ease;
        "
        onmouseover="this.style.background='#3367d6'; this.style.transform='translateY(-2px)'"
        onmouseout="this.style.background='#4285f4'; this.style.transform='translateY(0)'">
            é—œé–‰èªªæ˜
        </button>
    </div>
`;

        dialog.appendChild(dialogContent);
        document.body.appendChild(dialog);

// é»æ“ŠèƒŒæ™¯é—œé–‰å°è©±æ¡†
        dialog.addEventListener('click', function(e) {
            if (e.target === dialog) {
                closeGameInstructionsDialog();
            }
        });

        return dialog;
    }

    // é—œé–‰éŠæˆ²èªªæ˜å°è©±æ¡†
    function closeGameInstructionsDialog() {
        const dialog = document.getElementById('game-instructions-dialog');
        if (dialog) {
            dialog.remove();
        }
    }

    // å‰µå»ºéŠæˆ²èªªæ˜æŒ‰éˆ•
    function addGameInstructionsButton() {
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const instructionsButton = document.createElement('button');
        instructionsButton.textContent = 'éŠæˆ²èªªæ˜';

        if (regretButton) {
            instructionsButton.className = regretButton.className;
            instructionsButton.style.cssText = regretButton.style.cssText;
        } else {
            instructionsButton.style.cssText = `
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
        `;
        }

        let instructionsInstance = null;

        instructionsButton.addEventListener('click', function() {
            if (!instructionsInstance) {
                instructionsInstance = showGameInstructionsDialog();
                instructionsButton.textContent = 'é—œé–‰èªªæ˜';
                instructionsButton.style.backgroundColor = '#dc3545';

                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.type === 'childList') {
                            mutation.removedNodes.forEach(function(node) {
                                if (node && node.id === 'game-instructions-dialog') {
                                    instructionsInstance = null;
                                    instructionsButton.textContent = 'éŠæˆ²èªªæ˜';
                                    instructionsButton.style.backgroundColor = '#007bff';
                                    observer.disconnect();
                                }
                            });
                        }
                    });
                });
                observer.observe(document.body, { childList: true });
            } else {
                closeGameInstructionsDialog();
            }
        });

        buttonContainer.appendChild(instructionsButton);

        return {
            button: instructionsButton,
            getCurrentInstance: () => instructionsInstance
        };
    }

    // åˆå§‹åŒ–éŠæˆ²èªªæ˜ç³»çµ±
    function initGameInstructionsSystem() {
        return addGameInstructionsButton();
    }

    // åŸ·è¡Œåˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGameInstructionsSystem);
    } else {
        initGameInstructionsSystem();
    }

    // PWA å®‰è£ç³»çµ±ï¼ˆAndroid å°ˆç”¨ï¼‰
    (function() {
        let deferredPrompt = null;
        let installDialogInstance = null;

        // æª¢æ¸¬æ˜¯å¦ç‚º iOS è£ç½®
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // ä¸»è¦å®‰è£æç¤ºå‡½æ•¸ï¼ˆAndroid/é›»è…¦ç‰ˆï¼‰
        function showInstallDialog() {
            const dialog = document.createElement('div');
            dialog.id = 'install-dialog';
            dialog.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: 'Microsoft JhengHei', sans-serif;
        `;

            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        `;

            dialogContent.innerHTML = `
            <h3 style="margin-bottom: 20px; color: #333;">ğŸ“± å®‰è£åˆ°æ¡Œé¢</h3>

            <div style="margin-bottom: 25px; font-size: 16px; line-height: 1.6; color: #555;">
                <p>å°‡è±¡æ£‹éŠæˆ²å®‰è£åˆ°æ‚¨çš„è£ç½®ï¼Œéš¨æ™‚éƒ½èƒ½å¿«é€Ÿé–‹å•Ÿï¼</p>
            </div>

            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="font-size: 14px; color: #666; margin-bottom: 15px;">
                    âœ¨ <strong>å®‰è£å„ªé»ï¼š</strong>
                </div>
                <ul style="text-align: left; color: #666; font-size: 14px; line-height: 1.8; margin: 0; padding-left: 20px;">
                    <li>åƒ APP ä¸€æ¨£ç›´æ¥é–‹å•Ÿï¼Œä¸ç”¨è¼¸å…¥ç¶²å€</li>
                    <li>å¯ä»¥é›¢ç·šéŠç©ï¼Œæ²’ç¶²è·¯ä¹Ÿèƒ½ä¸‹æ£‹</li>
                    <li><strong>AI å°å¼ˆèˆ‡æ£‹ç›¤åˆ†æåŠŸèƒ½å®Œæ•´æ”¯æ´</strong></li>
                    <li>ç¨ç«‹è¦–çª—ï¼Œæ›´å°ˆæ³¨çš„éŠæˆ²é«”é©—</li>
                    <li>ä½”ç”¨ç©ºé–“æ¥µå°ï¼Œä¸æœƒå½±éŸ¿æ‰‹æ©Ÿæ•ˆèƒ½</li>
                </ul>
            </div>

            <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-bottom: 25px;">
                <div style="font-size: 13px; color: #856404; line-height: 1.6;">
                    <strong>âš ï¸ ç³»çµ±æ”¯æ´èªªæ˜ï¼š</strong><br>
                    <span style="color: #28a745;">âœ“ Android ç³»çµ±</span>ï¼šå®Œæ•´æ”¯æ´æ‰€æœ‰åŠŸèƒ½ï¼ˆAI å°å¼ˆã€æ£‹ç›¤è­˜åˆ¥ã€åˆ†æç­‰ï¼‰<br>
                    <span style="color: #dc3545;">âœ— iOS ç³»çµ±</span>ï¼šç›®å‰å› æŠ€è¡“é™åˆ¶ï¼ŒAI ç›¸é—œåŠŸèƒ½æš«ä¸æ”¯æ´
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <button id="install-confirm-btn" style="
                    background: #4CAF50;
                    color: white;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 18px;
                    font-weight: bold;
                    box-shadow: 0 2px 10px rgba(76, 175, 80, 0.3);
                    transition: all 0.3s ease;
                "
                onmouseover="this.style.background='#45a049'; this.style.transform='translateY(-2px)'"
                onmouseout="this.style.background='#4CAF50'; this.style.transform='translateY(0)'">
                    ğŸ“¥ ç«‹å³å®‰è£ï¼ˆAndroid é©ç”¨ï¼‰
                </button>
            </div>

            <div style="text-align: center;">
                <button id="install-cancel-btn" style="
                    background: #6c757d;
                    color: white;
                    padding: 10px 20px;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                ">æš«æ™‚ä¸è¦</button>
            </div>
        `;

            dialog.appendChild(dialogContent);
            document.body.appendChild(dialog);

            document.getElementById('install-confirm-btn').addEventListener('click', triggerInstall);
            document.getElementById('install-cancel-btn').addEventListener('click', closeInstallDialog);

            dialog.addEventListener('click', function(e) {
                if (e.target === dialog) {
                    closeInstallDialog();
                }
            });

            return dialog;
        }

        // iOS å°ˆç”¨èªªæ˜å°è©±æ¡†
        function showIOSInstructionDialog() {
            const dialog = document.createElement('div');
            dialog.id = 'install-dialog';
            dialog.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-family: 'Microsoft JhengHei', sans-serif;
        `;

            const dialogContent = document.createElement('div');
            dialogContent.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        `;

            dialogContent.innerHTML = `
            <h3 style="margin-bottom: 20px; color: #333;">ğŸ iOS ç³»çµ±èªªæ˜</h3>

            <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
                <div style="font-size: 15px; color: #856404; line-height: 1.8;">
                    <strong>âš ï¸ é‡è¦æé†’</strong><br><br>
                    ç›®å‰å®Œæ•´ç‰ˆï¼ˆå« AI å°å¼ˆã€æ£‹ç›¤è­˜åˆ¥ã€å±€é¢åˆ†æï¼‰<strong>åƒ…æ”¯æ´ Android ç³»çµ±</strong><br><br>
                    <span style="color: #dc3545;">iOS ç³»çµ±å› ç€è¦½å™¨æŠ€è¡“é™åˆ¶ï¼ŒAI ç›¸é—œåŠŸèƒ½æš«æ™‚ç„¡æ³•ä½¿ç”¨</span>
                </div>
            </div>

            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 25px;">
                <div style="font-size: 14px; color: #666; margin-bottom: 15px;">
                    ğŸ“± <strong>iOS æ‰‹å‹•å®‰è£æ–¹å¼ï¼š</strong>
                </div>
                <ol style="text-align: left; color: #666; font-size: 14px; line-height: 2; margin: 0; padding-left: 20px;">
                    <li>é»æ“Š Safari åº•éƒ¨çš„ <strong>ã€Œåˆ†äº«ã€</strong> æŒ‰éˆ• ğŸ“¤</li>
                    <li>å¾€ä¸‹æ»‘æ‰¾åˆ° <strong>ã€ŒåŠ å…¥ä¸»ç•«é¢ã€</strong></li>
                    <li>é»æ“Š <strong>ã€Œæ–°å¢ã€</strong> å®Œæˆå®‰è£</li>
                </ol>
                <div style="margin-top: 15px; padding: 10px; background: #fff; border-radius: 5px; font-size: 13px; color: #999;">
                    â€» æ³¨æ„ï¼šiOS ç‰ˆæœ¬å°‡ä¸åŒ…å« AI åŠŸèƒ½
                </div>
            </div>

            <div style="text-align: center;">
                <button id="ios-close-btn" style="
                    background: #6c757d;
                    color: white;
                    padding: 12px 25px;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 14px;
                ">æˆ‘çŸ¥é“äº†</button>
            </div>
        `;

            dialog.appendChild(dialogContent);
            document.body.appendChild(dialog);

            document.getElementById('ios-close-btn').addEventListener('click', closeInstallDialog);

            dialog.addEventListener('click', function(e) {
                if (e.target === dialog) {
                    closeInstallDialog();
                }
            });

            return dialog;
        }

        // è§¸ç™¼å®‰è£æç¤º
        async function triggerInstall() {
            if (!deferredPrompt) {
                alert('æŠ±æ­‰ï¼Œæ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´å®‰è£åŠŸèƒ½ï¼Œæˆ–è€…å·²ç¶“å®‰è£éäº†ï¼');
                closeInstallDialog();
                return;
            }

            deferredPrompt.prompt();

            const { outcome } = await deferredPrompt.userChoice;
            console.log(`å®‰è£çµæœ: ${outcome}`);

            if (outcome === 'accepted') {
                console.log('ç”¨æˆ¶æ¥å—å®‰è£');
            } else {
                console.log('ç”¨æˆ¶æ‹’çµ•å®‰è£');
            }

            deferredPrompt = null;
            closeInstallDialog();
        }

        // é—œé–‰å®‰è£å°è©±æ¡†
        function closeInstallDialog() {
            const dialog = document.getElementById('install-dialog');
            if (dialog) {
                dialog.remove();
                installDialogInstance = null;
            }
        }

        // å‰µå»ºå®‰è£æŒ‰éˆ•
        function addInstallButton() {
            const feedbackButton = Array.from(document.querySelectorAll('button')).find(btn =>
                btn.textContent.includes('å•é¡Œå›å ±')
            );

            const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
                btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
            );

            let buttonContainer = feedbackButton ? feedbackButton.parentElement :
                (regretButton ? regretButton.parentElement : document.body);

            const installButton = document.createElement('button');
            installButton.id = 'pwa-install-button';

            // iOS é¡¯ç¤ºä¸åŒæ–‡å­—
            if (isIOS()) {
                installButton.textContent = 'ğŸ“± iOS å®‰è£èªªæ˜';
            } else {
                installButton.textContent = 'ğŸ“± å®‰è£æ‡‰ç”¨';
            }

            installButton.style.display = 'inline-block'; // iOS ä¹Ÿé¡¯ç¤ºæŒ‰éˆ•

            if (feedbackButton || regretButton) {
                const referenceButton = feedbackButton || regretButton;
                installButton.className = referenceButton.className;
                installButton.style.cssText = referenceButton.style.cssText;
                installButton.style.backgroundColor = '#2196F3';
            } else {
                installButton.style.cssText = `
                padding: 12px 20px;
                background-color: #2196F3;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                margin: 5px;
            `;
            }

            installButton.addEventListener('click', function() {
                if (!installDialogInstance) {
                    // iOS é¡¯ç¤ºèªªæ˜å°è©±æ¡†
                    if (isIOS()) {
                        installDialogInstance = showIOSInstructionDialog();
                    } else {
                        installDialogInstance = showInstallDialog();
                    }
                }
            });

            buttonContainer.appendChild(installButton);

            return installButton;
        }

        // ç›£è½å®‰è£æç¤ºäº‹ä»¶ï¼ˆåƒ… Android/é›»è…¦ï¼‰
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('åµæ¸¬åˆ°å¯å®‰è£ PWA');
            e.preventDefault();
            deferredPrompt = e;

            const installButton = document.getElementById('pwa-install-button');
            if (installButton && !isIOS()) {
                installButton.style.display = 'inline-block';
            }
        });

        // ç›£è½å®‰è£æˆåŠŸäº‹ä»¶
        window.addEventListener('appinstalled', () => {
            console.log('PWA å®‰è£æˆåŠŸï¼');
            deferredPrompt = null;

            const installButton = document.getElementById('pwa-install-button');
            if (installButton) {
                installButton.style.display = 'none';
            }

            closeInstallDialog();

            alert('å®‰è£æˆåŠŸï¼æ‚¨ç¾åœ¨å¯ä»¥å¾æ¡Œé¢æˆ–æ‡‰ç”¨ç¨‹å¼åˆ—è¡¨ä¸­é–‹å•Ÿè±¡æ£‹éŠæˆ²äº†ï¼');
        });

        // åˆå§‹åŒ–å®‰è£ç³»çµ±
        function initInstallSystem() {
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('æ‡‰ç”¨å·²åœ¨ç¨ç«‹æ¨¡å¼ä¸‹é‹è¡Œï¼ˆå·²å®‰è£ï¼‰');
                return;
            }

            addInstallButton();
            console.log('PWA å®‰è£ç³»çµ±å·²åˆå§‹åŒ–');
        }

        // åŸ·è¡Œåˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initInstallSystem);
        } else {
            initInstallSystem();
        }
    })();


    // ==================== éŠæˆ²è¨­ç½®ç³»çµ± ====================

    // è¨­ç½®é…ç½®
    const SETTINGS_CONFIG = {
        // æ£‹ç›¤é¸é …
        chessboards: [
            { id: 'wooden', name: 'æœ¨ç´‹æ£‹ç›¤', file: 'Wood-grain Chessboard.png' },
            { id: 'white', name: 'ç°¡ç´„ç´…ç™½æ£‹ç›¤', file: 'Simple Bicolor Red  White Chessboard.png' },
            { id: 'brown', name: 'æ™®é€šå’–å•¡è‰²æ£‹ç›¤', file: 'Simple Brown Cardboard Chessboard.png' },
            { id: 'shadowed', name: 'çŸ³ç´‹æ£‹ç›¤', file: 'Stone-textured Chessboard.png' },
            { id: 'minimalist', name: 'ç°¡ç´„ç™½åº•æ£‹ç›¤', file: 'Minimalist White Chessboard.png' }
        ],

        // æ£‹å­é¢¨æ ¼é¸é …
        pieceStyles: [
            { id: 'wooden', name: 'æœ¨è³ªè±¡æ£‹', prefix: 'Wooden' },
            { id: 'white', name: 'æ™®é€šç™½è‰²è±¡æ£‹', prefix: 'White' },
            { id: 'brown', name: 'æ™®é€šå’–å•¡è‰²è±¡æ£‹', prefix: 'Brown' },
            { id: 'shadowed', name: 'å…‰æšˆè±¡æ£‹', prefix: 'Shadowed' },
            { id: 'minimalist White', name: 'ç°¡ç´„ç™½è‰²è±¡æ£‹', prefix: 'Minimalist White' }
        ],



        // ğŸ”¥ æ–°å¢: AI åˆ†ææ·±åº¦é¸é …
        aiAnalysisModes: [
            {
                id: 'single',
                name: 'å–®ä¸€æœ€ä½³æ­¥',
                description: 'åªé¡¯ç¤º1å€‹èµ°æ£‹æ–¹çš„æœ€ä½³èµ°æ³•',
                multipv: 1,
                sequence: false,
                icon: 'â‘ '
            },
            {
                id: 'sequence',
                name: 'é›™æ–¹æœ€ä½³5æ­¥è§£',
                description: 'é¡¯ç¤ºç´…é»‘ç´…é»‘ç´…çš„é€£çºŒæœ€ä½³èµ°æ³•',
                multipv: 1,
                sequence: true,
                icon: 'ğŸ”„'
            },
            {
                id: 'top2',
                name: 'æœ€ä½³å‰2é¸',
                description: 'é¡¯ç¤ºå‰2å€‹èµ°æ£‹æ–¹çš„æ¨è–¦èµ°æ³•',
                multipv: 2,
                sequence: false,
                icon: 'â‘¡'
            },
            {
                id: 'top3',
                name: 'æœ€ä½³å‰3é¸',
                description: 'é¡¯ç¤ºå‰3å€‹èµ°æ£‹æ–¹çš„æ¨è–¦èµ°æ³•',
                multipv: 3,
                sequence: false,
                icon: 'â‘¢'
            }
        ],

        // é è¨­è¨­ç½®

        defaults: {
            chessboard: 'minimalist',
            pieceStyle: 'minimalist White',
            soundMove: true,
            soundCapture: true,
            volume: 70,
            boardFlipped: false,  // ğŸ”¥ æ–°å¢ï¼šé è¨­ä¸ç¿»è½‰
            aiAnalysisMode: 'single'  // ğŸ”¥ æ–°å¢é è¨­å€¼
        }

    };

    // å„²å­˜éµå
    const STORAGE_KEY = 'chessGameSettings';

    // ==================== ä¿®æ­£ loadSettings() å‡½æ•¸ ====================
    // åŠ å…¥ aiAnalysisMode çš„è¼‰å…¥æ”¯æ´

    function loadSettings() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const settings = JSON.parse(saved);
                return {
                    chessboard: settings.chessboard || SETTINGS_CONFIG.defaults.chessboard,
                    pieceStyle: settings.pieceStyle || SETTINGS_CONFIG.defaults.pieceStyle,
                    soundMove: settings.soundMove !== undefined ? settings.soundMove : SETTINGS_CONFIG.defaults.soundMove,
                    soundCapture: settings.soundCapture !== undefined ? settings.soundCapture : SETTINGS_CONFIG.defaults.soundCapture,
                    volume: settings.volume !== undefined ? settings.volume : SETTINGS_CONFIG.defaults.volume,
                    boardFlipped: settings.boardFlipped !== undefined ? settings.boardFlipped : SETTINGS_CONFIG.defaults.boardFlipped,
                    // ğŸ”¥ æ–°å¢: è¼‰å…¥ AI åˆ†ææ¨¡å¼
                    aiAnalysisMode: settings.aiAnalysisMode || SETTINGS_CONFIG.defaults.aiAnalysisMode
                };
            }
        } catch (e) {
            console.warn('ç„¡æ³•è¼‰å…¥è¨­ç½®ï¼Œä½¿ç”¨é è¨­å€¼', e);
        }
        return { ...SETTINGS_CONFIG.defaults };
    }

    // å„²å­˜è¨­ç½®
    function saveSettings(settings) {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
            return true;
        } catch (e) {
            console.error('ç„¡æ³•å„²å­˜è¨­ç½®', e);
            return false;
        }
    }

    // ç•¶å‰è¨­ç½®
    let currentSettings = loadSettings();

    // ==================== å¥—ç”¨è¨­ç½®åˆ°éŠæˆ² ====================

    // å¥—ç”¨æ£‹ç›¤
    function applyChessboard(chessboardId) {
        const chessboard = SETTINGS_CONFIG.chessboards.find(cb => cb.id === chessboardId);
        if (!chessboard) return false;

        const chessBoardElement = document.getElementById('chess-board');
        if (!chessBoardElement) return false;

        chessBoardElement.style.backgroundImage = `url('chessboard/${chessboard.file}')`;
        return true;
    }

    // å¥—ç”¨æ£‹å­é¢¨æ ¼ (éœ€è¦é‡æ–°æ¸²æŸ“æ£‹ç›¤)
    function applyPieceStyle(styleId) {
        const style = SETTINGS_CONFIG.pieceStyles.find(s => s.id === styleId);
        if (!style) return false;

        // æ›´æ–°å…¨å±€æ£‹å­å‰ç¶´
        window.currentPiecePrefix = style.prefix;

        // å¦‚æœ renderBoard å‡½æ•¸å­˜åœ¨ï¼Œé‡æ–°æ¸²æŸ“
        if (typeof renderBoard === 'function') {
            renderBoard();
        }

        return true;
    }

    function applyBoardFlip(isFlipped) {
        console.log(`ğŸ”„ å¥—ç”¨æ£‹ç›¤ç¿»è½‰: ${isFlipped ? 'é»‘æ–¹åœ¨ä¸‹' : 'ç´…æ–¹åœ¨ä¸‹'}`);

        gameState.isFlipped = isFlipped;

        // é‡æ–°æ¸²æŸ“æ£‹ç›¤
        if (typeof renderBoard === 'function') {
            renderBoard();
        }

        // âœ… é‡æ–°æ¸²æŸ“è¢«åƒæ£‹å­ï¼ˆæœƒè‡ªå‹•è™•ç†ç¿»è½‰ï¼‰
        if (typeof renderCapturedPieces === 'function') {
            renderCapturedPieces();
        }

        // é¡¯ç¤ºç¿»è½‰æŒ‡ç¤ºå™¨
        updateFlipIndicator(isFlipped);

        return true;
    }

    /**
     * é¡¯ç¤º/éš±è—ç¿»è½‰æŒ‡ç¤ºå™¨
     */
    function updateFlipIndicator(isFlipped) {
        // ç§»é™¤èˆŠçš„æŒ‡ç¤ºå™¨
        const oldIndicator = document.getElementById('flip-indicator');
        if (oldIndicator) {
            oldIndicator.remove();
        }

        // å¦‚æœç¿»è½‰ï¼Œé¡¯ç¤ºæŒ‡ç¤ºå™¨
        if (isFlipped) {
            const indicator = document.createElement('div');
            indicator.id = 'flip-indicator';
            indicator.style.cssText = `
            position: absolute;
            top: -30px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        `;
            indicator.textContent = 'ğŸ”„ é»‘æ–¹è¦–è§’';

            const chessBoard = document.getElementById('chess-board');
            if (chessBoard) {
                chessBoard.style.position = 'relative';
                chessBoard.appendChild(indicator);
            }
        }
    }

    // ==================== 8. æ›´æ–° applyAllSettings() å‡½æ•¸ ====================

    // ğŸ”¥ ä¿®æ”¹ç¾æœ‰çš„ applyAllSettings() å‡½æ•¸
    function applyAllSettings(settings) {
        applyChessboard(settings.chessboard);
        applyPieceStyle(settings.pieceStyle);
        applyBoardFlip(settings.boardFlipped);  // ğŸ”¥ æ–°å¢
        currentSettings = { ...settings };
        saveSettings(settings);
    }

    // é¡¯ç¤ºè¨­ç½®å°è©±æ¡†
    function showSettingsDialog() {
        // å¦‚æœå·²ç¶“å­˜åœ¨ï¼Œå…ˆç§»é™¤
        closeSettingsDialog();

        // å‰µå»ºå°è©±æ¡†
        const dialog = document.createElement('div');
        dialog.id = 'settings-dialog';
        dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: 'Microsoft JhengHei', sans-serif;
        overflow-y: auto;
    `;

        const dialogContent = document.createElement('div');
        dialogContent.style.cssText = `
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 800px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
    `;

        // è‡¨æ™‚è¨­ç½®
        const tempSettings = { ...currentSettings };

        dialogContent.innerHTML = `
        <h3 style="margin-bottom: 20px; color: #333; text-align: center;">âš™ï¸ éŠæˆ²è¨­ç½®</h3>

        <div style="margin-bottom: 30px;">
            <h4 style="color: #555; margin-bottom: 15px;">ğŸ”Š éŸ³æ•ˆè¨­å®š</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                    <label style="font-size: 14px; color: #333;">è½å­éŸ³æ•ˆ</label>
                    <label class="switch" style="position: relative; display: inline-block; width: 50px; height: 24px;">
                        <input type="checkbox" id="sound-move-toggle" ${tempSettings.soundMove ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;"></span>
                    </label>
                </div>
                <div style="margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between;">
                    <label style="font-size: 14px; color: #333;">åƒå­éŸ³æ•ˆ</label>
                    <label class="switch" style="position: relative; display: inline-block; width: 50px; height: 24px;">
                        <input type="checkbox" id="sound-capture-toggle" ${tempSettings.soundCapture ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
                        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;"></span>
                    </label>
                </div>
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 14px; color: #333; display: block; margin-bottom: 8px;">éŸ³é‡å¤§å°: <span id="volume-value">${tempSettings.volume}%</span></label>
                    <input type="range" id="volume-slider" min="0" max="100" value="${tempSettings.volume}" style="width: 100%; cursor: pointer;">
                </div>
                <button id="test-sound-btn" style="width: 100%; padding: 8px; background: #17a2b8; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 13px; margin-top: 10px;">ğŸ”Š æ¸¬è©¦éŸ³æ•ˆ</button>
            </div>
        </div>



    <div style="margin-bottom: 30px;">
        <h4 style="color: #555; margin-bottom: 15px;">ğŸ”„ æ£‹ç›¤è¦–è§’</h4>
        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
        <div style="display: flex; align-items: center; justify-content: space-between;">
        <div>
        <label style="font-size: 14px; color: #333; display: block; margin-bottom: 5px;">ç¿»è½‰æ£‹ç›¤ï¼ˆé»‘æ–¹åœ¨ä¸‹ï¼‰</label>
        <p style="font-size: 12px; color: #888; margin: 0;">ç¿»è½‰å¾Œé»‘æ–¹æ£‹å­åœ¨ä¸‹æ–¹,ç´…æ–¹æ£‹å­åœ¨ä¸Šæ–¹</p>
        </div>
        <label class="switch" style="position: relative; display: inline-block; width: 50px; height: 24px;">
        <input type="checkbox" id="board-flip-toggle" ${tempSettings.boardFlipped ? 'checked' : ''} style="opacity: 0; width: 0; height: 0;">
        <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;"></span>
        </label>
        </div>
        </div>
        </div>

        <div style="margin-bottom: 30px;">
            <h4 style="color: #555; margin-bottom: 15px;">ğŸ¤– AI åˆ†ææ¨¡å¼</h4>
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                <div id="ai-analysis-modes" style="display: flex; flex-direction: column; gap: 12px;">
                    ${SETTINGS_CONFIG.aiAnalysisModes.map(mode => `
                        <label style="
                            display: flex;
                            align-items: center;
                            padding: 12px;
                            border: 2px solid ${tempSettings.aiAnalysisMode === mode.id ? '#007bff' : '#ddd'};
                            border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.3s;
                            background: ${tempSettings.aiAnalysisMode === mode.id ? 'rgba(0, 123, 255, 0.1)' : 'white'};
                        " data-mode-id="${mode.id}">
                            <input type="radio" name="ai-analysis-mode" value="${mode.id}"
                                    ${tempSettings.aiAnalysisMode === mode.id ? 'checked' : ''}
                                   style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: #333; margin-bottom: 4px;">
                                    ${mode.icon} ${mode.name}
                                </div>
                                <div style="font-size: 12px; color: #666;">
                                    ${mode.description}
                                </div>
                            </div>
                        </label>
                    `).join('')}
                </div>
            </div>
        </div>

        <div style="margin-bottom: 30px;">
            <h4 style="color: #555; margin-bottom: 15px;">ğŸ¨ é¸æ“‡æ£‹ç›¤</h4>
            <div id="chessboard-options" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px;"></div>
        </div>

        <div style="margin-bottom: 30px;">
            <h4 style="color: #555; margin-bottom: 15px;">â™Ÿï¸ é¸æ“‡æ£‹å­é¢¨æ ¼</h4>
            <p style="font-size: 12px; color: #888; margin-bottom: 10px;">é è¦½ï¼šé»‘å°‡</p>
            <div id="piece-options" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px;"></div>
        </div>

        <div style="text-align: center; display: flex; gap: 10px; justify-content: center;">
            <button id="apply-settings-btn" style="background: #28a745; color: white; padding: 12px 30px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">âœ“ å¥—ç”¨è¨­ç½®</button>
            <button id="cancel-settings-btn" style="background: #6c757d; color: white; padding: 12px 30px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; transition: all 0.3s ease;">âœ— å–æ¶ˆ</button>
        </div>
    `;

        dialog.appendChild(dialogContent);
        document.body.appendChild(dialog);

        // æ·»åŠ é–‹é—œæ¨£å¼
        const style = document.createElement('style');
        style.textContent = `
            .switch input:checked + span {
                background-color: #007bff !important;
            }
            .switch input:checked + span:before {
                transform: translateX(26px);
            }
            .switch input:not(:checked) + span {
                background-color: #6c757d !important;
            }
            .switch span {
                transition: background-color 0.3s ease;
            }
            .switch span:before {
                position: absolute;
                content: "";
                height: 18px;
                width: 18px;
                left: 3px;
                bottom: 3px;
                background-color: white;
                transition: .4s;
                border-radius: 50%;
            }
        `;
        document.head.appendChild(style);

        // éŸ³æ•ˆé–‹é—œäº‹ä»¶
        const soundMoveToggle = dialog.querySelector('#sound-move-toggle');
        const soundCaptureToggle = dialog.querySelector('#sound-capture-toggle');
        const volumeSlider = dialog.querySelector('#volume-slider');
        const volumeValue = dialog.querySelector('#volume-value');
        const testSoundBtn = dialog.querySelector('#test-sound-btn');

        soundMoveToggle.addEventListener('change', (e) => {
            tempSettings.soundMove = e.target.checked;
        });

        soundCaptureToggle.addEventListener('change', (e) => {
            tempSettings.soundCapture = e.target.checked;
        });

        volumeSlider.addEventListener('input', (e) => {
            tempSettings.volume = parseInt(e.target.value);
            volumeValue.textContent = tempSettings.volume + '%';
        });

        testSoundBtn.addEventListener('click', () => {
            if (window.playSound && typeof window.playSound === 'function') {
                // å…ˆæ¸¬è©¦è½å­éŸ³æ•ˆï¼Œ1ç§’å¾Œæ¸¬è©¦åƒå­éŸ³æ•ˆ
                if (tempSettings.soundMove) {
                    window.playSound('move', tempSettings.volume);
                }
                setTimeout(() => {
                    if (tempSettings.soundCapture) {
                        window.playSound('capture', tempSettings.volume);
                    }
                }, 1000);
            } else {
                alert('éŸ³æ•ˆç³»çµ±å°šæœªè¼‰å…¥');
            }
        });

        // ğŸ”¥ æ–°å¢ï¼šç¿»è½‰é–‹é—œäº‹ä»¶
        const boardFlipToggle = dialog.querySelector('#board-flip-toggle');
        boardFlipToggle.addEventListener('change', (e) => {
            tempSettings.boardFlipped = e.target.checked;
            console.log(`ç¿»è½‰è¨­å®šè®Šæ›´: ${e.target.checked}`);
        });

        // æ¸²æŸ“æ£‹ç›¤é¸é …
        const chessboardOptions = dialog.querySelector('#chessboard-options');
        SETTINGS_CONFIG.chessboards.forEach(board => {
            const option = createChessboardOption(board, tempSettings);
            chessboardOptions.appendChild(option);
        });

        // æ¸²æŸ“æ£‹å­é¸é …
        const pieceOptions = dialog.querySelector('#piece-options');
        SETTINGS_CONFIG.pieceStyles.forEach(style => {
            const option = createPieceOption(style, tempSettings);
            pieceOptions.appendChild(option);
        });

        // å¥—ç”¨æŒ‰éˆ•
        dialog.querySelector('#apply-settings-btn').addEventListener('click', () => {
            applyAllSettings(tempSettings);
            closeSettingsDialog();
        });

        // å–æ¶ˆæŒ‰éˆ•
        dialog.querySelector('#cancel-settings-btn').addEventListener('click', closeSettingsDialog);

        // ç›£è½ AI åˆ†ææ¨¡å¼é¸æ“‡
        dialog.querySelectorAll('input[name="ai-analysis-mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                tempSettings.aiAnalysisMode = e.target.value;

                // æ›´æ–°æ‰€æœ‰é¸é …çš„æ¨£å¼
                dialog.querySelectorAll('[data-mode-id]').forEach(label => {
                    const isSelected = label.dataset.modeId === e.target.value;
                    label.style.border = `2px solid ${isSelected ? '#007bff' : '#ddd'}`;
                    label.style.background = isSelected ? 'rgba(0, 123, 255, 0.1)' : 'white';
                });
            });
        });

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        dialog.addEventListener('click', (e) => {
            if (e.target === dialog) {
                closeSettingsDialog();
            }
        });

        return dialog;
    }

    // å‰µå»ºæ£‹ç›¤é¸é …å…ƒç´ 
    function createChessboardOption(board, tempSettings) {
        const option = document.createElement('div');
        option.style.cssText = `
        border: 3px solid ${tempSettings.chessboard === board.id ? '#28a745' : '#ddd'};
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    `;

        option.innerHTML = `
        <div style="width: 100%; height: 100px; background-image: url('chessboard/${board.file}'); background-size: cover; background-position: center; border-radius: 5px; margin-bottom: 8px;"></div>
        <div style="font-size: 14px; color: #333; font-weight: ${tempSettings.chessboard === board.id ? 'bold' : 'normal'};">${board.name}</div>
    `;

        option.addEventListener('click', () => {
            tempSettings.chessboard = board.id;
            // æ›´æ–°æ‰€æœ‰é¸é …çš„é‚Šæ¡†
            option.parentElement.querySelectorAll('div').forEach(opt => {
                opt.style.border = '3px solid #ddd';
                const name = opt.querySelector('div:last-child');
                if (name) name.style.fontWeight = 'normal';
            });
            option.style.border = '3px solid #28a745';
            const name = option.querySelector('div:last-child');
            if (name) name.style.fontWeight = 'bold';
        });

        option.addEventListener('mouseenter', () => {
            if (tempSettings.chessboard !== board.id) {
                option.style.border = '3px solid #28a745';
                option.style.opacity = '0.7';
            }
        });

        option.addEventListener('mouseleave', () => {
            if (tempSettings.chessboard !== board.id) {
                option.style.border = '3px solid #ddd';
                option.style.opacity = '1';
            }
        });

        return option;
    }

    function createPieceOption(style, tempSettings) {
        const option = document.createElement('div');
        option.style.cssText = `
        border: 3px solid ${tempSettings.pieceStyle === style.id ? '#28a745' : '#ddd'};
        border-radius: 8px;
        padding: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
    `;

        const previewImage = `chess pieces/${style.prefix} Black Jiang.png`;

        option.innerHTML = `
        <div style="width: 100%; height: 100px; display: flex; justify-content: center; align-items: center; margin-bottom: 8px;">
            <img src="${previewImage}" alt="${style.name}" style="max-width: 80px; max-height: 80px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div style="display: none; font-size: 40px;">å°‡</div>
        </div>
        <div style="font-size: 14px; color: #333; font-weight: ${tempSettings.pieceStyle === style.id ? 'bold' : 'normal'};">${style.name}</div>
    `;

        option.addEventListener('click', () => {
            tempSettings.pieceStyle = style.id;
            // æ›´æ–°æ‰€æœ‰é¸é …çš„é‚Šæ¡†
            option.parentElement.querySelectorAll('div').forEach(opt => {
                opt.style.border = '3px solid #ddd';
                const name = opt.querySelector('div:last-child');
                if (name) name.style.fontWeight = 'normal';
            });
            option.style.border = '3px solid #28a745';
            const name = option.querySelector('div:last-child');
            if (name) name.style.fontWeight = 'bold';
        });

        option.addEventListener('mouseenter', () => {
            if (tempSettings.pieceStyle !== style.id) {
                option.style.border = '3px solid #28a745';
                option.style.opacity = '0.7';
            }
        });

        option.addEventListener('mouseleave', () => {
            if (tempSettings.pieceStyle !== style.id) {
                option.style.border = '3px solid #ddd';
                option.style.opacity = '1';
            }
        });

        return option;
    }

    // é—œé–‰è¨­ç½®å°è©±æ¡†
    function closeSettingsDialog() {
        const dialog = document.getElementById('settings-dialog');
        if (dialog) {
            dialog.remove();
        }
    }

    // ==================== å‰µå»ºè¨­ç½®æŒ‰éˆ• ====================

    function addSettingsButton() {
        // å°‹æ‰¾æ‚”æ£‹æŒ‰éˆ•ä½œç‚ºåƒè€ƒ
        const regretButton = Array.from(document.querySelectorAll('button')).find(btn =>
            btn.textContent.includes('æ‚”æ£‹') || btn.textContent.includes('undo')
        );

        let buttonContainer = regretButton ? regretButton.parentElement : document.body;

        const settingsButton = document.createElement('button');
        settingsButton.id = 'settings-button'; // æ·»åŠ  ID ä»¥ä¾¿å¾ŒçºŒæ§åˆ¶
        settingsButton.textContent = 'âš™ï¸ éŠæˆ²è¨­ç½®';

        if (regretButton) {
            settingsButton.className = regretButton.className;
            settingsButton.style.cssText = regretButton.style.cssText;
        } else {
            settingsButton.style.cssText = `
            padding: 12px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s ease;
        `;
        }

        // ğŸ”¥ ä¿®æ”¹é»æ“Šäº‹ä»¶ï¼šæ·»åŠ åˆ†æç‹€æ…‹æª¢æŸ¥
        settingsButton.addEventListener('click', () => {
            // æª¢æŸ¥æ˜¯å¦æ­£åœ¨é€²è¡Œå¾©ç›¤åˆ†æ
            if (gameState && gameState.isAnalyzing) {
                showAnalysisBlockMessage();
                return;
            }

            showSettingsDialog();
        });

        buttonContainer.appendChild(settingsButton);

        return settingsButton;
    }

    // ğŸ”¥ æ–°å¢ï¼šé¡¯ç¤ºåˆ†æé˜»æ­¢æç¤ºè¨Šæ¯
    function showAnalysisBlockMessage() {
        // ç§»é™¤å·²å­˜åœ¨çš„æç¤º
        const existingMessage = document.getElementById('analysis-block-message');
        if (existingMessage) {
            existingMessage.remove();
        }

        // å‰µå»ºæç¤ºè¨Šæ¯
        const message = document.createElement('div');
        message.id = 'analysis-block-message';
        message.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff5722, #ff7043);
        color: white;
        padding: 25px 35px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: bold;
        z-index: 10003;
        box-shadow: 0 8px 24px rgba(255, 87, 34, 0.4);
        text-align: center;
        max-width: 400px;
        animation: slideIn 0.3s ease-out;
    `;

        message.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 10px;">ğŸ”’</div>
        <div style="font-size: 18px; margin-bottom: 8px;">å¾©ç›¤åˆ†æé€²è¡Œä¸­</div>
        <div style="font-size: 14px; font-weight: normal; opacity: 0.9;">
            ç‚ºé¿å…åˆ†æéŒ¯èª¤ï¼Œè«‹ç­‰å¾…åˆ†æå®Œæˆå¾Œå†èª¿æ•´è¨­ç½®
        </div>
    `;

        document.body.appendChild(message);

        // æ·»åŠ å‹•ç•«æ¨£å¼
        if (!document.getElementById('analysis-block-animation')) {
            const style = document.createElement('style');
            style.id = 'analysis-block-animation';
            style.textContent = `
            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translate(-50%, -60%);
                }
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%);
                }
            }

            @keyframes slideOut {
                from {
                    opacity: 1;
                    transform: translate(-50%, -50%);
                }
                to {
                    opacity: 0;
                    transform: translate(-50%, -40%);
                }
            }
        `;
            document.head.appendChild(style);
        }

        // 2.5ç§’å¾Œè‡ªå‹•ç§»é™¤ï¼ˆå¸¶å‹•ç•«ï¼‰
        setTimeout(() => {
            message.style.animation = 'slideOut 0.3s ease-out';
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 300);
        }, 2500);
    }

    // ==================== åˆå§‹åŒ–ç³»çµ± ====================

    function initSettingsSystem() {
        // å¥—ç”¨å·²å„²å­˜çš„è¨­ç½®
        applyAllSettings(currentSettings);

        // å‰µå»ºè¨­ç½®æŒ‰éˆ•
        addSettingsButton();

        console.log('éŠæˆ²è¨­ç½®ç³»çµ±å·²åˆå§‹åŒ–', currentSettings);
    }

    // åŸ·è¡Œåˆå§‹åŒ–
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initSettingsSystem);
    } else {
        initSettingsSystem();
    }

    // ==================== åŒ¯å‡ºåŠŸèƒ½ (ä¾›å¤–éƒ¨ä½¿ç”¨) ====================
    window.chessSettings = {
        show: showSettingsDialog,
        close: closeSettingsDialog,
        get: () => ({ ...currentSettings }),
        apply: applyAllSettings,
        getCurrentPrefix: () => {
            const style = SETTINGS_CONFIG.pieceStyles.find(s => s.id === currentSettings.pieceStyle);
            return style ? style.prefix : SETTINGS_CONFIG.pieceStyles[0].prefix;
        }
    };


    // åˆ¤æ–·æŸå€‹ç§»å‹•æ˜¯å¦åœ¨å¾ªç’°ä¸­
    function isInCycle(moveIndex, cycleResult) {
        const sequence = cycleDetector.convertToMoveSequence(gameState.gameRecord);

        let sequenceIndex = 0;
        for (let i = 0; i < moveIndex; i++) {
            if (gameState.gameRecord[i].red) sequenceIndex++;
            if (gameState.gameRecord[i].black) sequenceIndex++;
        }

        return sequenceIndex >= cycleResult.startIndex && sequenceIndex < cycleResult.endIndex;
    }

    function resetGameAfterDraw() {
        // é‡ç½®éŠæˆ²ç‹€æ…‹
        gameState.board = initializePieces();
        gameState.currentTurn = 'red';
        gameState.selectedPiece = null;
        gameState.possibleMoves = [];
        gameState.history = [];
        gameState.historyIndex = -1;
        gameState.gameRecord = [];
        gameState.gameOver = false;
        gameState.winner = null;
        gameState.gameResult = null;
        gameState.checkStatus = null;
        gameState.noCaptureCount = 0;
        gameState.totalMoves = 0;

        // âœ… æ–°å¢ï¼šæ¸…ç©ºè¢«åƒæ£‹å­
        gameState.capturedPieces = {
            red: [],
            black: []
        };

        // é‡ç½®å¾ªç’°æª¢æ¸¬å™¨
        cycleDetector.resetWarning();

        // é—œé–‰é€šçŸ¥
        closeCycleNotification();

        // é‡æ–°æ¸²æŸ“æ£‹ç›¤
        renderBoard();
        renderCapturedPieces(); // âœ… æ–°å¢

        // æ›´æ–°é¡¯ç¤º
        updateMoveDisplay();

        // ä¿å­˜åˆ°æ­·å²è¨˜éŒ„
        saveToHistory();

        // é‡æ–°é–‹å§‹è¨ˆæ™‚å™¨
        if (typeof startTimer === 'function') {
            startTimer();
        }

        console.log('ğŸ® éŠæˆ²å·²é‡ç½®ï¼Œé‡æ–°é–‹å§‹ï¼');
    }


    // ç§»é™¤åŸä¾†çš„ resetBoard() å‡½æ•¸ï¼Œå› ç‚ºä¸å†éœ€è¦äº†

    // é‡ç½®æ£‹ç›¤å‡½æ•¸
    function resetBoard() {
        // é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›æ£‹ç›¤å¯¦ç¾ä¾†é‡ç½®
        console.log('ğŸ”„ æ£‹ç›¤å·²é‡ç½®åˆ°åˆå§‹ç‹€æ…‹');
    }

    // ğŸ¨ ç²¾ç¾çš„ç¢ºèªå°è©±æ¡†
    function showCustomDialog(message, onConfirm) {
        // å‰µå»ºé®ç½©å±¤
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

        // å‰µå»ºå°è©±æ¡†
        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 350px;
    `;

        // è¨Šæ¯æ–‡å­—
        const messageElement = document.createElement('p');
        messageElement.textContent = message;
        messageElement.style.cssText = `
        margin: 0 0 25px 0;
        font-size: 18px;
        color: white;
        line-height: 1.5;
    `;

        // æŒ‰éˆ•å®¹å™¨
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
        display: flex;
        gap: 15px;
        justify-content: center;
    `;

        // å–æ¶ˆæŒ‰éˆ•
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'å–æ¶ˆ';
        cancelButton.style.cssText = `
        padding: 10px 25px;
        border: 2px solid white;
        background: transparent;
        color: white;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    `;
        cancelButton.onmouseover = () => cancelButton.style.background = 'rgba(255,255,255,0.2)';
        cancelButton.onmouseout = () => cancelButton.style.background = 'transparent';
        cancelButton.onclick = () => document.body.removeChild(overlay);

        // ç¢ºå®šæŒ‰éˆ•
        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'ç¢ºå®š';
        confirmButton.style.cssText = `
        padding: 10px 25px;
        border: none;
        background: white;
        color: #667eea;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    `;
        confirmButton.onmouseover = () => confirmButton.style.transform = 'scale(1.05)';
        confirmButton.onmouseout = () => confirmButton.style.transform = 'scale(1)';
        confirmButton.onclick = () => {
            document.body.removeChild(overlay);
            onConfirm();
        };

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(confirmButton);
        dialog.appendChild(messageElement);
        dialog.appendChild(buttonContainer);
        overlay.appendChild(dialog);

        // é»æ“Šé®ç½©é—œé–‰
        overlay.onclick = (e) => {
            if (e.target === overlay) document.body.removeChild(overlay);
        };

        document.body.appendChild(overlay);
    }


    // æ–°éŠæˆ²æ™‚é‡ç½®å¾ªç’°æª¢æ¸¬
    function resetGame() {
        cycleDetector.resetWarning();
        closeCycleNotification();
    }

    // æ·»åŠ CSSæ¨£å¼ï¼ˆæ›´æ–°ç‰ˆï¼‰
    function addGameStyles() {
        const style = document.createElement('style');
        style.textContent = `
/* å¾ªç’°æª¢æ¸¬ç›¸é—œæ¨£å¼ */
.cycle-highlight {
    background-color: #ffe6e6;
    border-left: 4px solid #ff4444;
    padding-left: 8px;
    margin: 2px 0;
    border-radius: 0 4px 4px 0;
}

.cycle-warning {
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
    padding-left: 8px;
    margin: 2px 0;
    border-radius: 0 4px 4px 0;
}

/* é•·å°‡æª¢æ¸¬ç›¸é—œæ¨£å¼ */
.perpetual-highlight {
    background-color: #e3f2fd;
    border-left: 4px solid #2196f3;
    padding-left: 8px;
    margin: 2px 0;
    border-radius: 0 4px 4px 0;
}

.perpetual-warning {
    background-color: #fff8e1;
    border-left: 4px solid #ff9800;
    padding-left: 8px;
    margin: 2px 0;
    border-radius: 0 4px 4px 0;
}

.cycle-highlight .red-move,
.cycle-highlight .black-move,
.cycle-warning .red-move,
.cycle-warning .black-move,
.perpetual-highlight .red-move,
.perpetual-highlight .black-move,
.perpetual-warning .red-move,
.perpetual-warning .black-move {
    font-weight: bold;
}

/* é€šç”¨éŠæˆ²é€šçŸ¥æ¨£å¼ */
.game-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 450px;
    min-width: 350px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 15px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3), 0 5px 15px rgba(0, 0, 0, 0.2);
    z-index: 10000;
    animation: slideInCenter 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
}

.game-notification.warning {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

.game-notification.perpetual_warning {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
}

.game-notification.draw {
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
}

.game-notification.loss {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
}

.notification-content {
    display: flex;
    align-items: flex-start;
    padding: 24px;
    position: relative;
    color: white;
}

.notification-icon {
    font-size: 36px;
    margin-right: 16px;
    flex-shrink: 0;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    animation: pulse 2s infinite;
}

.notification-text {
    flex: 1;
}

.notification-title {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 8px;
    color: white;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    line-height: 1.4;
}

.notification-pattern {
    font-size: 14px;
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    padding: 12px;
    border-radius: 8px;
    margin-top: 12px;
    font-family: 'Courier New', monospace;
    color: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.notification-close {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: white;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.notification-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

@keyframes slideInCenter {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.7);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.1);
    }
}

.game-notification.fade-out {
    animation: fadeOutCenter 0.4s ease-out;
}

@keyframes fadeOutCenter {
    from {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    to {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.7);
    }
}

/* å‘å¾Œå…¼å®¹çš„èˆŠæ¨£å¼é¡å */
.cycle-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 450px;
    min-width: 350px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 15px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    z-index: 10000;
    animation: slideInCenter 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* æ£‹è­œé¡¯ç¤ºæ¨£å¼ */
.move-item {
    padding: 4px 8px;
    margin: 2px 0;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.move-item:hover {
    background-color: #f5f5f5;
}

.move-number {
    color: #666;
    margin-right: 8px;
    font-weight: bold;
}

.red-move {
    color: #d32f2f;
    font-weight: 500;
}

.black-move {
    color: #1976d2;
    font-weight: 500;
}

/* é•·å°‡æª¢æ¸¬ç‰¹æ®Šæ¨£å¼ */
.perpetual-check-highlight {
    animation: perpetualGlow 1.5s ease-in-out infinite alternate;
}

@keyframes perpetualGlow {
    from {
        box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
    }
    to {
        box-shadow: 0 0 20px rgba(33, 150, 243, 0.8);
    }
}

/* éŸ¿æ‡‰å¼è¨­è¨ˆ */
@media (max-width: 768px) {
    .game-notification {
        max-width: 90vw;
        min-width: 280px;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
    }

    .notification-content {
        padding: 20px;
    }

    .notification-icon {
        font-size: 28px;
        margin-right: 12px;
    }

    .notification-title {
        font-size: 16px;
    }
}
`;
        document.head.appendChild(style);
    }

    // å‘å¾Œå…¼å®¹çš„åˆ¥å
    function addCycleStyles() {
        addGameStyles();
    }

    // åˆå§‹åŒ–æ™‚æ·»åŠ æ¨£å¼
    addGameStyles();
    // === æª¢æ¸¬çœŸæ­£çš„æ£‹ç›¤æ•¸æ“šè®Šæ•¸ ===




    // æ‰‹å‹•æ¸¬è©¦
    function manualTest() {
        console.log('\n=== æ‰‹å‹•æ¸¬è©¦é–‹å§‹ ===');
        cycleDetector.resetWarning();

        const mockGameState = {
            gameRecord: [],
            gameOver: false,
            winner: null,
            currentTurn: 'red'
        };

        const moves = [
            { desc: 'ç¬¬1æ­¥ ç´…æ–¹', notation: 'è»ŠäºŒé€²ä¸‰' },
            { desc: 'ç¬¬1æ­¥ é»‘æ–¹', notation: 'è»Š2é€€3' },
            { desc: 'ç¬¬2æ­¥ ç´…æ–¹', notation: 'è»ŠäºŒé€€ä¸‰' },
            { desc: 'ç¬¬2æ­¥ é»‘æ–¹', notation: 'è»Š2é€²3' },
            { desc: 'ç¬¬3æ­¥ ç´…æ–¹ï¼ˆæ‡‰è©²è­¦å‘Šï¼‰', notation: 'è»ŠäºŒé€²ä¸‰' },
            { desc: 'ç¬¬3æ­¥ é»‘æ–¹', notation: 'è»Š2é€€3' },
            { desc: 'ç¬¬4æ­¥ ç´…æ–¹ï¼ˆæ‡‰è©²åˆ¤å’Œï¼‰', notation: 'è»ŠäºŒé€€ä¸‰' },
            { desc: 'ç¬¬4æ­¥ é»‘æ–¹', notation: 'è»Š2é€²3' }
        ];

        moves.forEach((move, index) => {
            console.log(`\n${move.desc}: ${move.notation}`);

            if (index % 2 === 0) {
                mockGameState.gameRecord.push({ red: move.notation, black: null });
            } else {
                const lastMove = mockGameState.gameRecord[mockGameState.gameRecord.length - 1];
                lastMove.black = move.notation;
            }

            const result = cycleDetector.detectCycle(mockGameState.gameRecord);
            if (result) {
                console.log(`ğŸ” æª¢æ¸¬çµæœ: ${result.type}, æ¬¡æ•¸: ${result.cycleCount}`);
                if (result.type === 'warning') {
                    cycleDetector.markWarningShown(result);
                } else if (result.type === 'draw') {
                    return;
                }
            } else {
                console.log('âŒ æœªæª¢æ¸¬åˆ°å¾ªç’°');
            }
        });

        console.log('\n=== æ‰‹å‹•æ¸¬è©¦å®Œæˆ ===');
    }


    manualTest();


    // é€šç”¨é€šçŸ¥ç³»çµ±
    function showNotification(message, type = 'info', duration = 3000) {
        // ç§»é™¤ç¾æœ‰é€šçŸ¥
        const existingNotif = document.getElementById('game-notification');
        const existingBackdrop = document.getElementById('game-notification-backdrop');
        const existingStyle = document.getElementById('game-notification-style');

        if (existingNotif) document.body.removeChild(existingNotif);
        if (existingBackdrop) document.body.removeChild(existingBackdrop);
        if (existingStyle) document.head.removeChild(existingStyle);

        // æ ¹æ“šé¡å‹è¨­å®šæ¨£å¼
        const typeConfig = {
            success: {
                gradient: 'linear-gradient(135deg, #10b981 0%, #059669 100%)',
                icon: 'âœ“',
                title: 'æ“ä½œæˆåŠŸ'
            },
            error: {
                gradient: 'linear-gradient(135deg, #dc2626 0%, #991b1b 100%)',
                icon: 'âœ•',
                title: 'æ“ä½œå¤±æ•—'
            },
            info: {
                gradient: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
                icon: 'â„¹',
                title: 'æç¤º'
            },
            warning: {
                gradient: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                icon: 'âš ',
                title: 'è­¦å‘Š'
            }
        };

        const config = typeConfig[type] || typeConfig.info;

        // å‰µå»ºæ¨£å¼
        const style = document.createElement('style');
        style.id = 'game-notification-style';
        style.textContent = `
        .game-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: ${config.gradient};
            color: white;
            padding: 30px 40px;
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 10000;
            min-width: 320px;
            max-width: 500px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .game-notification-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 9999;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-notification-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .game-notification-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .game-notification-content {
            position: relative;
            width: 100%;
            text-align: center;
        }

        .game-notification-icon {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 0 auto;
        }

        .game-notification-title {
            font-size: 22px;
            font-weight: bold;
            margin: 8px 0 0 0;
        }

        .game-notification-message {
            font-size: 15px;
            opacity: 0.95;
            text-align: center;
            margin: 0;
            line-height: 1.6;
            word-break: break-word;
        }
    `;
        document.head.appendChild(style);

        const closeNotification = () => {
            const notif = document.getElementById('game-notification');
            const back = document.getElementById('game-notification-backdrop');
            const sty = document.getElementById('game-notification-style');

            if (notif) document.body.removeChild(notif);
            if (back) document.body.removeChild(back);
            if (sty) document.head.removeChild(sty);
        };

        // å‰µå»ºèƒŒæ™¯é®ç½©
        const backdrop = document.createElement('div');
        backdrop.className = 'game-notification-backdrop';
        backdrop.id = 'game-notification-backdrop';
        backdrop.addEventListener('click', closeNotification);

        // å‰µå»ºé€šçŸ¥å…ƒç´ 
        const notification = document.createElement('div');
        notification.className = 'game-notification';
        notification.id = 'game-notification';
        notification.innerHTML = `
        <div class="game-notification-content">
            <button class="game-notification-close" aria-label="é—œé–‰">âœ•</button>
            <div class="game-notification-icon">${config.icon}</div>
            <h3 class="game-notification-title">${config.title}</h3>
            <p class="game-notification-message">${message}</p>
        </div>
    `;

        document.body.appendChild(backdrop);
        document.body.appendChild(notification);

        const closeBtn = notification.querySelector('.game-notification-close');
        closeBtn.addEventListener('click', closeNotification);

        // è‡ªå‹•é—œé–‰
        if (duration > 0) {
            setTimeout(closeNotification, duration);
        }
    }

    // é¡¯ç¤ºå„²å­˜UI
    function showSaveUI() {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    `;

        const modal = document.createElement('div');
        modal.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        min-width: 300px;
    `;

        modal.innerHTML = `
        <h3 style="margin: 0 0 25px 0; text-align: center; color: #333; font-size: 22px;">å„²å­˜å±€é¢</h3>
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <button class="save-load-btn copy-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">ğŸ“‹ è¤‡è£½ç•¶å‰å±€é¢</button>
            <button class="save-load-btn save-file-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%); color: #333;">ğŸ’¾ å„²å­˜åˆ°æª”æ¡ˆ</button>
            <button class="save-load-btn cancel-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: #e0e0e0; color: #666;">âœ– å–æ¶ˆ</button>
        </div>
    `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // è¤‡è£½å±€é¢
        modal.querySelector('.copy-btn').onclick = async () => {
            await copyGameState();
            document.body.removeChild(overlay);
        };

        // å„²å­˜åˆ°æª”æ¡ˆ
        modal.querySelector('.save-file-btn').onclick = async () => {
            await saveGameStateToFile();
            document.body.removeChild(overlay);
        };

        // å–æ¶ˆ
        modal.querySelector('.cancel-btn').onclick = () => {
            document.body.removeChild(overlay);
        };

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
            }
        };
    }

    // é¡¯ç¤ºè¼‰å…¥UI
    function showLoadUI() {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    `;

        const modal = document.createElement('div');
        modal.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        min-width: 300px;
    `;

        modal.innerHTML = `
        <h3 style="margin: 0 0 25px 0; text-align: center; color: #333; font-size: 22px;">è¼‰å…¥å±€é¢</h3>
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <button class="save-load-btn paste-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">ğŸ“¥ è²¼ä¸Šå±€é¢</button>
            <button class="save-load-btn load-file-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333;">ğŸ“‚ å¾æª”æ¡ˆè¼‰å…¥</button>
            <input type="file" id="modalFileInput" accept=".json" style="display: none;">
            <button class="save-load-btn cancel-btn" style="width: 100%; padding: 15px; border: none; border-radius: 10px; font-size: 16px; cursor: pointer; font-weight: 600; background: #e0e0e0; color: #666;">âœ– å–æ¶ˆ</button>
        </div>
    `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // è²¼ä¸Šå±€é¢
        modal.querySelector('.paste-btn').onclick = async () => {
            await pasteGameState();
            document.body.removeChild(overlay);
        };

        // å¾æª”æ¡ˆè¼‰å…¥
        const fileInput = modal.querySelector('#modalFileInput');
        modal.querySelector('.load-file-btn').onclick = () => {
            fileInput.click();
        };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                loadGameState(file);
                document.body.removeChild(overlay);
            }
        };

        // å–æ¶ˆ
        modal.querySelector('.cancel-btn').onclick = () => {
            document.body.removeChild(overlay);
        };

        // é»æ“ŠèƒŒæ™¯é—œé–‰
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
            }
        };
    }



    // è¤‡è£½ç•¶å‰å±€é¢åˆ°å‰ªè²¼ç°¿
    async function copyGameState() {
        try {
            const gameData = {
                board: gameState.board,
                currentTurn: gameState.currentTurn,
                gameRecord: gameState.gameRecord,
                saveTime: new Date().toISOString()
            };

            const jsonString = JSON.stringify(gameData);
            await navigator.clipboard.writeText(jsonString);
            showNotification('âœ… å±€é¢å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', 'success');
        } catch (err) {
            console.error('è¤‡è£½å¤±æ•—:', err);
            showNotification('âŒ è¤‡è£½å¤±æ•—: ' + err.message, 'error', 5000);
        }
    }

    // å¾å‰ªè²¼ç°¿è²¼ä¸Šå±€é¢
    async function pasteGameState() {
        try {
            const text = await navigator.clipboard.readText();

            if (!text || text.trim() === '') {
                throw new Error('å‰ªè²¼ç°¿æ˜¯ç©ºçš„');
            }

            let gameData;
            try {
                gameData = JSON.parse(text);
            } catch (parseError) {
                throw new Error('å‰ªè²¼ç°¿å…§å®¹ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
            }

            if (!gameData.board || !Array.isArray(gameData.board)) {
                throw new Error('æ£‹ç›¤æ•¸æ“šç¼ºå¤±æˆ–æ ¼å¼ä¸æ­£ç¢º');
            }

            if (!gameData.currentTurn || !['red', 'black'].includes(gameData.currentTurn)) {
                throw new Error('ç•¶å‰å›åˆä¿¡æ¯ç¼ºå¤±æˆ–æ ¼å¼ä¸æ­£ç¢º');
            }

            if (gameData.board.length !== 10 || gameData.board[0].length !== 9) {
                throw new Error('æ£‹ç›¤å°ºå¯¸ä¸æ­£ç¢º');
            }

            // âœ… é—œéµä¿®æ”¹ï¼šä¿å­˜åˆå§‹å±€é¢
            gameState.initialBoard = JSON.parse(JSON.stringify(gameData.board));
            gameState.initialTurn = gameData.currentTurn;

            // æ›´æ–°éŠæˆ²ç‹€æ…‹
            gameState.board = JSON.parse(JSON.stringify(gameData.board));
            gameState.currentTurn = gameData.currentTurn;
            gameState.gameRecord = gameData.gameRecord || [];
            gameState.selectedPiece = null;
            gameState.possibleMoves = [];
            gameState.history = [];
            gameState.historyIndex = -1;
            gameState.gameOver = false;
            gameState.checkStatus = null;

            // æ¸…ç©º HistoryManager
            if (historyManager) {
                historyManager.clear();
            }

            // é‡æ–°æ¸²æŸ“æ£‹ç›¤
            renderBoard();
            updateMoveDisplay();

            // âœ… ä¿å­˜åˆå§‹ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„ï¼ˆé€™æ¨£ç¬¬ä¸€æ­¥å°±èƒ½æ‚”æ£‹ï¼‰
            saveToHistory();

            showNotification('âœ… å±€é¢è¼‰å…¥æˆåŠŸï¼åˆå§‹å±€é¢å·²ä¿å­˜ã€‚', 'success');
            console.log('âœ… åˆå§‹å±€é¢å·²ä¿å­˜:', gameState.initialBoard);
        } catch (error) {
            console.error('è²¼ä¸Šå¤±æ•—:', error);
            showNotification('âŒ ' + error.message, 'error', 5000);
        }
    }

    // åŸæœ¬çš„å¾æª”æ¡ˆè¼‰å…¥å±€é¢å‡½æ•¸ï¼ˆä¿ç•™çµ¦é›»è…¦ç‰ˆä½¿ç”¨ï¼‰
    function loadGameState(file) {
        const reader = new FileReader();

        reader.onload = function(e) {
            try {
                if (!e.target.result) {
                    throw new Error('æª”æ¡ˆå…§å®¹ç‚ºç©º');
                }

                let gameData;
                try {
                    gameData = JSON.parse(e.target.result);
                } catch (parseError) {
                    throw new Error('æª”æ¡ˆä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼');
                }

                if (!gameData.board || !Array.isArray(gameData.board)) {
                    throw new Error('æ£‹ç›¤æ•¸æ“šç¼ºå¤±æˆ–æ ¼å¼ä¸æ­£ç¢º');
                }

                if (!gameData.currentTurn || !['red', 'black'].includes(gameData.currentTurn)) {
                    throw new Error('ç•¶å‰å›åˆä¿¡æ¯ç¼ºå¤±æˆ–æ ¼å¼ä¸æ­£ç¢º');
                }

                if (gameData.board.length !== 10 || gameData.board[0].length !== 9) {
                    throw new Error('æ£‹ç›¤å°ºå¯¸ä¸æ­£ç¢º');
                }

                // âœ… é—œéµä¿®æ”¹ï¼šä¿å­˜åˆå§‹å±€é¢
                gameState.initialBoard = JSON.parse(JSON.stringify(gameData.board));
                gameState.initialTurn = gameData.currentTurn;

                // æ›´æ–°éŠæˆ²ç‹€æ…‹
                gameState.board = JSON.parse(JSON.stringify(gameData.board));
                gameState.currentTurn = gameData.currentTurn;
                gameState.gameRecord = gameData.gameRecord || [];
                gameState.selectedPiece = null;
                gameState.possibleMoves = [];
                gameState.history = [];
                gameState.historyIndex = -1;
                gameState.gameOver = false;
                gameState.checkStatus = null;

                // æ¸…ç©º HistoryManager
                if (historyManager) {
                    historyManager.clear();
                }

                // é‡æ–°æ¸²æŸ“æ£‹ç›¤
                renderBoard();
                updateMoveDisplay();

                // âœ… ä¿å­˜åˆå§‹ç‹€æ…‹åˆ°æ­·å²è¨˜éŒ„ï¼ˆé€™æ¨£ç¬¬ä¸€æ­¥å°±èƒ½æ‚”æ£‹ï¼‰
                saveToHistory();

                showNotification('å±€é¢è¼‰å…¥æˆåŠŸï¼åˆå§‹å±€é¢å·²ä¿å­˜ã€‚', 'success');
                console.log('âœ… åˆå§‹å±€é¢å·²ä¿å­˜:', gameState.initialBoard);
            } catch (error) {
                console.error('è¼‰å…¥å¤±æ•—:', error);
                showNotification(error.message, 'error', 5000);
            }
        };

        reader.readAsText(file);
    }

    // ğŸ¨ ç°¡æ½”çš„ç¢ºèªå°è©±æ¡†
    function showConfirmDialog(message, onConfirm) {
        // å‰µå»ºé®ç½©å±¤
        const overlay = document.createElement('div');
        overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

        // å‰µå»ºå°è©±æ¡†
        const dialog = document.createElement('div');
        dialog.style.cssText = `
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        text-align: center;
        max-width: 350px;
    `;

        // è¨Šæ¯æ–‡å­—
        const messageElement = document.createElement('p');
        messageElement.textContent = message;
        messageElement.style.cssText = `
        margin: 0 0 25px 0;
        font-size: 18px;
        color: white;
        line-height: 1.5;
    `;

        // æŒ‰éˆ•å®¹å™¨
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
        display: flex;
        gap: 15px;
        justify-content: center;
    `;

        // å–æ¶ˆæŒ‰éˆ•
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'å–æ¶ˆ';
        cancelButton.style.cssText = `
        padding: 10px 25px;
        border: 2px solid white;
        background: transparent;
        color: white;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    `;
        cancelButton.onmouseover = () => cancelButton.style.background = 'rgba(255,255,255,0.2)';
        cancelButton.onmouseout = () => cancelButton.style.background = 'transparent';
        cancelButton.onclick = () => document.body.removeChild(overlay);

        // ç¢ºå®šæŒ‰éˆ•
        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'ç¢ºå®š';
        confirmButton.style.cssText = `
        padding: 10px 25px;
        border: none;
        background: white;
        color: #667eea;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    `;
        confirmButton.onmouseover = () => confirmButton.style.transform = 'scale(1.05)';
        confirmButton.onmouseout = () => confirmButton.style.transform = 'scale(1)';
        confirmButton.onclick = () => {
            document.body.removeChild(overlay);
            onConfirm();
        };

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(confirmButton);
        dialog.appendChild(messageElement);
        dialog.appendChild(buttonContainer);
        overlay.appendChild(dialog);

        // é»æ“Šé®ç½©é—œé–‰
        overlay.onclick = (e) => {
            if (e.target === overlay) document.body.removeChild(overlay);
        };

        document.body.appendChild(overlay);
    }

    function newGame() {
        showConfirmDialog('ç¢ºå®šè¦é–‹å§‹æ–°éŠæˆ²å—ï¼Ÿ\nç•¶å‰é€²åº¦å°‡æœƒä¸Ÿå¤±ã€‚', () => {
            gameState.board = initializePieces();
            gameState.currentTurn = 'red';
            gameState.selectedPiece = null;
            gameState.possibleMoves = [];
            gameState.history = [];
            gameState.historyIndex = -1;
            gameState.gameRecord = [];
            gameState.gameOver = false;
            gameState.checkStatus = null;
            gameState.noCaptureCount = 0;
            gameState.totalMoves = 0;

            // âœ… æ–°å¢ï¼šæ¸…ç©ºè¢«åƒæ£‹å­
            gameState.capturedPieces = {
                red: [],
                black: []
            };

            renderBoard();
            renderCapturedPieces(); // âœ… æ–°å¢
            updateMoveDisplay();
            saveToHistory();
        });
    }

    // ğŸ”¥ æ–°å¢ï¼šå…¨åŸŸ AI è®Šæ•¸
    let gameAI = null;

    // åˆå§‹åŒ–éŠæˆ²
    function initializeGame() {
        initializeBoard();
        gameState.board = initializePieces();
        renderBoard();
        // ä¿å­˜åˆå§‹ç‹€æ…‹
        saveToHistory();
        console.log("ğŸ’¡ this æ˜¯ï¼š", this);
        addCustomBoardButton()
        let historyManager = new BoardHistoryManager();
        console.log("âœ… historyManager å·²åˆå§‹åŒ–:", historyManager);

        try {
            const history = historyManager.getHistory();
            console.log("âœ… getHistory èª¿ç”¨æˆåŠŸ:", history);
        } catch (error) {
            console.error("âŒ getHistory èª¿ç”¨å¤±æ•—:", error);
        }
        timerControl = addTimerButton();
        // ç¶å®šåŸæœ‰æŒ‰éˆ•äº‹ä»¶
        document.getElementById('saveBtn').addEventListener('click', showSaveUI);
        document.getElementById('loadBtn').addEventListener('click', showLoadUI);
        document.getElementById('undoBtn').addEventListener('click', undoMove);
        document.getElementById('newGameBtn').addEventListener('click', newGame);

        // ğŸ”¥ æ–°å¢ï¼šåˆå§‹åŒ– AI å¼•æ“ï¼ˆæª¢æŸ¥ WASM æ˜¯å¦å°±ç·’ï¼‰
        if (window.pikafishReady && typeof Module !== 'undefined') {
            console.log('âœ… WASM å·²å°±ç·’ï¼Œç«‹å³åˆå§‹åŒ– AI');
            initializeAI();
        } else {
            console.log('â³ WASM å°šæœªå°±ç·’ï¼Œç­‰å¾…åˆå§‹åŒ–...');

            // ç›£è½ WASM å°±ç·’äº‹ä»¶
            window.addEventListener('pikafish-ready', () => {
                console.log('âœ… æ”¶åˆ° pikafish-ready äº‹ä»¶ï¼Œé–‹å§‹åˆå§‹åŒ– AI');
                initializeAI();
            }, { once: true }); // once: true è¡¨ç¤ºåªåŸ·è¡Œä¸€æ¬¡

            // å‚™ç”¨æ–¹æ¡ˆï¼šå¦‚æœ 10 ç§’å¾Œé‚„æ²’å°±ç·’ï¼Œä»¥é›™äººæ¨¡å¼å•Ÿå‹•
            setTimeout(() => {
                if (!window.pikafishReady) {
                    console.log('âš ï¸ WASM è¼‰å…¥è¶…æ™‚ï¼Œä»¥é›™äººå°æˆ°æ¨¡å¼å•Ÿå‹•');
                    // ä¸èª¿ç”¨ initializeAI()ï¼ŒéŠæˆ²ä»å¯é›™äººå°æˆ°
                }
            }, 10000);
        }
    }

    // ğŸ”¥ ä¿®æ­£ï¼šAI åˆå§‹åŒ–å‡½æ•¸
    async function initializeAI() {
        aiAnalysisManager = new AIAnalysisManager();

        // å‰µå»º AI åˆ†ææŒ‰éˆ•
        createAIAnalysisButton();

        // åŠ å…¥ CSS æ¨£å¼
        addAIAnalysisStyles();

        try {
            console.log('ğŸ¤– æ­£åœ¨åˆå§‹åŒ– AI å¼•æ“...');

            // å‰µå»º AI å¯¦ä¾‹ï¼ˆä½¿ç”¨ä½ çš„ gameState.boardï¼‰
            gameAI = new XiangqiGameAI(gameState.board);
            window.xiangqiGameAI = gameAI;

            // **æ–°å¢ï¼šæ ¹æ“šç•¶å‰æ¨¡å¼è¨­å®šåˆå§‹å€¼**
            if (typeof currentMode !== 'undefined' && currentMode) {
                if (currentMode.depth <= 5) {
                    gameAI.setDifficulty('easy');
                } else if (currentMode.depth <= 10) {
                    gameAI.setDifficulty('medium');
                } else {
                    gameAI.setDifficulty('hard');
                }
                console.log(`ğŸ”§ æ ¹æ“š currentMode.depth(${currentMode.depth}) è¨­å®šé›£åº¦: ${gameAI.difficulty}`);
            }

            // åˆå§‹åŒ– AI å¼•æ“
            const success = await gameAI.initializeAI();

            if (success) {
                console.log('ğŸ‰ AI å¼•æ“åˆå§‹åŒ–æˆåŠŸï¼');
                console.log(`ğŸ“Š ç•¶å‰è¨­å®š - æ¨¡å¼: ${gameAI.analysisMode}, é›£åº¦: ${gameAI.difficulty}`);

                // é¡¯ç¤º AI æ§åˆ¶æŒ‰éˆ•
                const aiControls = document.getElementById('ai-controls');
                if (aiControls) {
                    aiControls.style.display = 'block';
                }

                // ç¶å®š AI æŒ‰éˆ•äº‹ä»¶
                bindAIButtons();

            } else {
                console.warn('âš ï¸ AI å¼•æ“åˆå§‹åŒ–å¤±æ•—ï¼Œå°‡ä»¥é›™äººæ¨¡å¼é‹è¡Œ');
            }

        } catch (error) {
            console.error('âŒ AI åˆå§‹åŒ–å‡ºç¾éŒ¯èª¤:', error);
            console.warn('âš ï¸ å°‡ä»¥é›™äººæ¨¡å¼é‹è¡Œ');
        }
    }

    // ğŸ”¥ æ–°å¢ï¼šç¶å®š AI æŒ‰éˆ•äº‹ä»¶
    function bindAIButtons() {
        // AI å»ºè­°æŒ‰éˆ•
        const aiSuggestionBtn = document.getElementById('aiSuggestionBtn');
        if (aiSuggestionBtn) {
            aiSuggestionBtn.addEventListener('click', showAISuggestion);
        }

        // AI ä¸‹æ£‹æŒ‰éˆ•
        const aiMoveBtn = document.getElementById('aiMoveBtn');
        if (aiMoveBtn) {
            aiMoveBtn.addEventListener('click', makeAIMove);
        }

        // åˆ‡æ› AI æ¨¡å¼æŒ‰éˆ•
        const toggleAIBtn = document.getElementById('toggleAIBtn');
        if (toggleAIBtn) {
            toggleAIBtn.addEventListener('click', toggleAIMode);
        }

        // AI é›£åº¦æŒ‰éˆ•
        const difficultyBtn = document.getElementById('difficultyBtn');
        if (difficultyBtn) {
            difficultyBtn.addEventListener('click', changeDifficulty);
        }
    }

    // ğŸ”¥ æ–°å¢ï¼šAI åŠŸèƒ½å‡½æ•¸å€‘

    // AI å»ºè­°åŠŸèƒ½
    async function showAISuggestion() {
        if (!gameAI || !gameAI.ai.isAIReady()) {
            alert('AI å¼•æ“å°šæœªæº–å‚™å°±ç·’');
            return;
        }

        try {
            console.log('ğŸ¤– æ­£åœ¨ç²å– AI å»ºè­°...');
            const suggestion = await gameAI.getAISuggestion();

            if (suggestion) {
                console.log('âœ… AI å»ºè­°:', suggestion);

                // åœ¨æ£‹ç›¤ä¸Šé«˜äº®é¡¯ç¤ºå»ºè­°çš„ç§»å‹•
                highlightAIMove(suggestion.from, suggestion.to);

                // é¡¯ç¤ºå»ºè­°æè¿°
                alert(`ğŸ¤– AI å»ºè­°ï¼š${suggestion.description}`);

            } else {
                alert('AI ç„¡æ³•æä¾›å»ºè­°');
            }

        } catch (error) {
            console.error('âŒ ç²å– AI å»ºè­°å¤±æ•—:', error);
            alert('ç²å– AI å»ºè­°æ™‚ç™¼ç”ŸéŒ¯èª¤');
        }
    }

    // AI è‡ªå‹•ä¸‹æ£‹
    async function makeAIMove() {
        if (!gameAI || !gameAI.ai.isAIReady()) {
            alert('AI å¼•æ“å°šæœªæº–å‚™å°±ç·’');
            return;
        }

        try {
            console.log('ğŸ¯ AI æ­£åœ¨æ€è€ƒ...');
            const move = await gameAI.makeAIMove();

            if (move) {
                console.log('âœ… AI å·²ä¸‹æ£‹:', move);

                // é‡æ–°æ¸²æŸ“æ£‹ç›¤
                renderBoard();

                // ä¿å­˜åˆ°æ­·å²
                saveToHistory();

                // æª¢æŸ¥éŠæˆ²ç‹€æ…‹
                // checkWinCondition(); // å¦‚æœä½ æœ‰é€™å€‹å‡½æ•¸çš„è©±

                // åˆ‡æ›å›åˆ
                gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'black' : 'red';

            } else {
                alert('AI ç„¡æ³•ä¸‹æ£‹');
            }

        } catch (error) {
            console.error('âŒ AI ä¸‹æ£‹å¤±æ•—:', error);
            alert('AI ä¸‹æ£‹æ™‚ç™¼ç”ŸéŒ¯èª¤');
        }
    }

    // åˆ‡æ› AI å°æˆ°æ¨¡å¼
    function toggleAIMode() {
        if (!gameAI) {
            alert('AI å¼•æ“å°šæœªåˆå§‹åŒ–');
            return;
        }

        const isAIMode = gameAI.toggleAIMode();
        const toggleBtn = document.getElementById('toggleAIBtn');

        if (toggleBtn) {
            toggleBtn.textContent = isAIMode ? 'ğŸ¯ é—œé–‰ AI å°æˆ°' : 'ğŸ¯ é–‹å•Ÿ AI å°æˆ°';
            toggleBtn.style.backgroundColor = isAIMode ? '#dc3545' : '#28a745';
        }

        console.log('ğŸ® AI å°æˆ°æ¨¡å¼:', isAIMode ? 'å·²é–‹å•Ÿ' : 'å·²é—œé–‰');
    }

    // èª¿æ•´ AI é›£åº¦
    function changeDifficulty() {
        if (!gameAI) {
            alert('AI å¼•æ“å°šæœªåˆå§‹åŒ–');
            return;
        }

        const difficulties = ['easy', 'medium', 'hard', 'expert'];
        const currentDifficulty = gameAI.ai.difficulty;
        const currentIndex = difficulties.indexOf(currentDifficulty);
        const nextIndex = (currentIndex + 1) % difficulties.length;
        const newDifficulty = difficulties[nextIndex];

        gameAI.setDifficulty(newDifficulty);

        const difficultyBtn = document.getElementById('difficultyBtn');
        if (difficultyBtn) {
            const difficultyNames = {
                'easy': 'ç°¡å–®',
                'medium': 'ä¸­ç­‰',
                'hard': 'å›°é›£',
                'expert': 'å°ˆå®¶'
            };
            difficultyBtn.textContent = `âš™ï¸ é›£åº¦: ${difficultyNames[newDifficulty]}`;
        }

        console.log('ğŸ¯ AI é›£åº¦å·²èª¿æ•´ç‚º:', newDifficulty);
    }

    // ğŸ”¥ æ–°å¢ï¼šé«˜äº® AI å»ºè­°ç§»å‹•çš„å‡½æ•¸
    function highlightAIMove(from, to) {
        // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
        clearHighlights();

        // é«˜äº®èµ·å§‹ä½ç½®ï¼ˆç¶ è‰²ï¼‰
        const fromCell = document.querySelector(`[data-row="${from.row}"][data-col="${from.col}"]`);
        if (fromCell) {
            fromCell.style.backgroundColor = '#90EE90';
            fromCell.style.border = '3px solid #32CD32';
        }

        // é«˜äº®ç›®æ¨™ä½ç½®ï¼ˆè—è‰²ï¼‰
        const toCell = document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);
        if (toCell) {
            toCell.style.backgroundColor = '#87CEEB';
            toCell.style.border = '3px solid #4169E1';
        }

        // 3ç§’å¾Œæ¸…é™¤é«˜äº®
        setTimeout(clearHighlights, 3000);
    }

    // æ¸…é™¤é«˜äº®
    function clearHighlights() {
        const allCells = document.querySelectorAll('.board-cell');
        allCells.forEach(cell => {
            cell.style.backgroundColor = '';
            cell.style.border = '';
        });
    }

    // å•Ÿå‹•éŠæˆ²
    initializeGame();

    // ========== ğŸ‘‡ åœ¨é€™è£¡åŠ å…¥æ–°çš„ç¨‹å¼ç¢¼ ==========
    // æ£‹è­œè¨˜éŒ„å½ˆçª—æ§åˆ¶
    document.getElementById('showHistoryBtn').addEventListener('click', function() {
        document.getElementById('move-history').classList.add('show');
        document.getElementById('history-overlay').classList.add('show');
    });

    document.getElementById('close-history').addEventListener('click', function() {
        document.getElementById('move-history').classList.remove('show');
        document.getElementById('history-overlay').classList.remove('show');
    });

    document.getElementById('history-overlay').addEventListener('click', function() {
        document.getElementById('move-history').classList.remove('show');
        document.getElementById('history-overlay').classList.remove('show');
    });
    // ========== æ–°ç¨‹å¼ç¢¼çµæŸ ==========

</script>
</body>
</html>